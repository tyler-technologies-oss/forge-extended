/**
 * @license
 * Copyright Tyler Technologies, Inc. 
 * License: Apache-2.0
 */
import { __decorate } from "tslib";
import { customElement, attachShadowTemplate, coreProperty, coerceBoolean, coerceNumber, ensureChild } from '@tylertech/forge-core';
import { tylIconClockOutline } from '@tylertech/tyler-icons/extended';
import { tylIconClose } from '@tylertech/tyler-icons/standard';
import { TimePickerAdapter } from './time-picker-adapter';
import { TimePickerCore } from './time-picker-core';
import { TIME_PICKER_CONSTANTS } from './time-picker-constants';
import { IconRegistry, IconComponent } from '../icon';
import { IconButtonComponent } from '../icon-button';
import { DialogComponent } from '../dialog';
import { ListComponent, ListItemComponent } from '../list';
import { BaseComponent } from '../core/base/base-component';
import { PopoverComponent } from '../popover/popover';
const template = '<template><slot></slot></template>';
const styles = ':host{display:block}:host([hidden]){display:none}';
/**
 * @tag forge-time-picker
 */
let TimePickerComponent = class TimePickerComponent extends BaseComponent {
    static get observedAttributes() {
        return [
            TIME_PICKER_CONSTANTS.attributes.VALUE,
            TIME_PICKER_CONSTANTS.attributes.OPEN,
            TIME_PICKER_CONSTANTS.attributes.ALLOW_SECONDS,
            TIME_PICKER_CONSTANTS.attributes.MASKED,
            TIME_PICKER_CONSTANTS.attributes.SHOW_MASK_FORMAT,
            TIME_PICKER_CONSTANTS.attributes.USE_24_HOUR_TIME,
            TIME_PICKER_CONSTANTS.attributes.ALLOW_INVALID_TIME,
            TIME_PICKER_CONSTANTS.attributes.MIN,
            TIME_PICKER_CONSTANTS.attributes.MAX,
            TIME_PICKER_CONSTANTS.attributes.START_TIME,
            TIME_PICKER_CONSTANTS.attributes.STEP,
            TIME_PICKER_CONSTANTS.attributes.ALLOW_INPUT,
            TIME_PICKER_CONSTANTS.attributes.SHOW_NOW,
            TIME_PICKER_CONSTANTS.attributes.SHOW_HOUR_OPTIONS,
            TIME_PICKER_CONSTANTS.attributes.DISABLED,
            TIME_PICKER_CONSTANTS.attributes.POPUP_CLASSES,
            TIME_PICKER_CONSTANTS.attributes.ALLOW_DROPDOWN
        ];
    }
    constructor() {
        super();
        IconRegistry.define([tylIconClockOutline, tylIconClose]);
        attachShadowTemplate(this, template, styles);
        this._core = new TimePickerCore(new TimePickerAdapter(this));
    }
    connectedCallback() {
        if (this.querySelector(TIME_PICKER_CONSTANTS.selectors.INPUT)) {
            this._core.initialize();
        }
        else {
            ensureChild(this, TIME_PICKER_CONSTANTS.selectors.INPUT).then(() => this._core.initialize());
        }
    }
    disconnectedCallback() {
        this._core.destroy();
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case TIME_PICKER_CONSTANTS.attributes.VALUE:
                this.value = newValue;
                break;
            case TIME_PICKER_CONSTANTS.attributes.OPEN:
                this.open = coerceBoolean(newValue);
                break;
            case TIME_PICKER_CONSTANTS.attributes.ALLOW_SECONDS:
                this.allowSeconds = coerceBoolean(newValue);
                break;
            case TIME_PICKER_CONSTANTS.attributes.MASKED:
                this.masked = coerceBoolean(newValue);
                break;
            case TIME_PICKER_CONSTANTS.attributes.SHOW_MASK_FORMAT:
                this.showMaskFormat = coerceBoolean(newValue);
                break;
            case TIME_PICKER_CONSTANTS.attributes.USE_24_HOUR_TIME:
                this.use24HourTime = coerceBoolean(newValue);
                break;
            case TIME_PICKER_CONSTANTS.attributes.ALLOW_INVALID_TIME:
                this.allowInvalidTime = coerceBoolean(newValue);
                break;
            case TIME_PICKER_CONSTANTS.attributes.SHOW_NOW:
                this.showNow = coerceBoolean(newValue);
                break;
            case TIME_PICKER_CONSTANTS.attributes.SHOW_HOUR_OPTIONS:
                this.showHourOptions = coerceBoolean(newValue);
                break;
            case TIME_PICKER_CONSTANTS.attributes.MIN:
                this.min = newValue;
                break;
            case TIME_PICKER_CONSTANTS.attributes.MAX:
                this.max = newValue;
                break;
            case TIME_PICKER_CONSTANTS.attributes.START_TIME:
                this.startTime = newValue;
                break;
            case TIME_PICKER_CONSTANTS.attributes.STEP:
                this.step = coerceNumber(newValue);
                break;
            case TIME_PICKER_CONSTANTS.attributes.ALLOW_INPUT:
                this.allowInput = coerceBoolean(newValue);
                break;
            case TIME_PICKER_CONSTANTS.attributes.DISABLED:
                this.disabled = coerceBoolean(newValue);
                break;
            case TIME_PICKER_CONSTANTS.attributes.POPUP_CLASSES:
                this.popupClasses = newValue;
                break;
            case TIME_PICKER_CONSTANTS.attributes.ALLOW_DROPDOWN:
                this.allowDropdown = coerceBoolean(newValue);
                break;
        }
    }
};
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "value", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "open", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "allowSeconds", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "masked", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "showMaskFormat", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "use24HourTime", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "allowInvalidTime", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "min", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "max", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "restrictedTimes", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "startTime", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "step", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "allowInput", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "showNow", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "showHourOptions", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "customOptions", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "validationCallback", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "parseCallback", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "formatCallback", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "coercionCallback", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "prepareMaskCallback", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "disabled", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "popupClasses", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "allowDropdown", void 0);
__decorate([
    coreProperty()
], TimePickerComponent.prototype, "popupTarget", void 0);
TimePickerComponent = __decorate([
    customElement({
        name: TIME_PICKER_CONSTANTS.elementName,
        dependencies: [ListComponent, ListItemComponent, IconButtonComponent, IconComponent, PopoverComponent, IconComponent, DialogComponent]
    })
], TimePickerComponent);
export { TimePickerComponent };
