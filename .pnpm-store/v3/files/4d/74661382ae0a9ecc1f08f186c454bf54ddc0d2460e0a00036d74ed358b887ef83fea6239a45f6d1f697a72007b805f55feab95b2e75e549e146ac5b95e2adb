import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, Input, booleanAttribute, NgModule, Directive, numberAttribute, forwardRef, HostListener, ElementRef, createEnvironmentInjector, createComponent, Injectable, ViewContainerRef, InjectionToken, inject, DestroyRef, TemplateRef } from '@angular/core';
import { defineAccordionComponent, defineOpenIconComponent, defineExpansionPanelComponent, defineAppBarComponent, defineAppBarHelpButtonComponent, defineAppBarMenuButtonComponent, defineAppBarNotificationButtonComponent, defineAppBarProfileButtonComponent, defineAppBarSearchComponent, defineAutocompleteComponent, AUTOCOMPLETE_CONSTANTS, defineAvatarComponent, defineBackdropComponent, defineBadgeComponent, defineBannerComponent, defineBottomSheetComponent, defineButtonComponent, defineButtonAreaComponent, defineButtonToggleComponent, defineButtonToggleGroupComponent, defineCalendarComponent, defineCardComponent, defineCheckboxComponent, defineChipComponent, defineChipFieldComponent, defineChipSetComponent, defineCircularProgressComponent, defineColorPickerComponent, defineDatePickerComponent, defineDateRangePickerComponent, defineDeprecatedButtonComponent, defineDeprecatedIconButtonComponent, defineDialogComponent, defineDividerComponent, defineDrawerComponent, defineFloatingActionButtonComponent, defineFieldComponent, defineFilePickerComponent, defineFocusIndicatorComponent, defineIconComponent, defineIconButtonComponent, defineInlineMessageComponent, defineKeyboardShortcutComponent, defineLabelComponent, defineLabelValueComponent, defineLinearProgressComponent, defineListComponent, defineListItemComponent, defineMenuComponent, defineMiniDrawerComponent, defineModalDrawerComponent, defineOptionComponent, defineOptionGroupComponent, defineOverlayComponent, definePageStateComponent, definePaginatorComponent, definePopoverComponent, POPOVER_CONSTANTS, PopoverComponent as PopoverComponent$1, defineProfileCardComponent, defineRadioGroupComponent, defineRadioComponent, defineScaffoldComponent, defineSelectComponent, defineSelectDropdownComponent, defineSkeletonComponent, defineSkipLinkComponent, defineSliderComponent, defineSplitButtonComponent, defineSplitViewComponent, defineSplitViewPanelComponent, defineStackComponent, defineStateLayerComponent, defineStepComponent, defineStepperComponent, defineSwitchComponent, defineTabComponent, defineTabBarComponent, defineTableComponent, defineTextFieldComponent, defineTimePickerComponent, defineToastComponent, ToastComponent as ToastComponent$1, TOAST_CONSTANTS, defineToolbarComponent, defineTooltipComponent, defineViewComponent, defineViewSwitcherComponent } from '@tylertech/forge';
import { CommonModule } from '@angular/common';
import * as i1 from '@angular/router';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { AsyncSubject, Subject, take } from 'rxjs';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class AccordionComponent {
    /**
     * Gets/sets the selector to use for finding the child expansion panels. Defaults to searching the direct children for `<forge-expansion-panel>` elements.
     * Use this if you need to scope this accordion to a specific set of expansion panels, or your expansion panels are not direct children of the accordion.
     */
    set panelSelector(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.panelSelector = value;
        });
    }
    get panelSelector() {
        return this.nativeElement.panelSelector;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-accordion element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineAccordionComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AccordionComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.7", type: AccordionComponent, selector: "forge-accordion", inputs: { panelSelector: "panelSelector" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AccordionComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-accordion',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { panelSelector: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class OpenIconComponent {
    /** Whether the icon is open or closed. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** The orientation of the rotation. */
    set orientation(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.orientation = value;
        });
    }
    get orientation() {
        return this.nativeElement.orientation;
    }
    /** The rotation amount. */
    set rotation(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.rotation = value;
        });
    }
    get rotation() {
        return this.nativeElement.rotation;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-open-icon element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineOpenIconComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: OpenIconComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: OpenIconComponent, selector: "forge-open-icon", inputs: { open: ["open", "open", booleanAttribute], orientation: "orientation", rotation: "rotation" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: OpenIconComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-open-icon',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], orientation: [{
                type: Input
            }], rotation: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeOpenIconModule {
    constructor() {
        defineOpenIconComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeOpenIconModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeOpenIconModule, declarations: [OpenIconComponent], imports: [CommonModule], exports: [OpenIconComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeOpenIconModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeOpenIconModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [OpenIconComponent],
                    exports: [OpenIconComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ExpansionPanelComponent {
    /** Whether the panel is open or closed. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** The orientation of the panel. */
    set orientation(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.orientation = value;
        });
    }
    get orientation() {
        return this.nativeElement.orientation;
    }
    /** The type of animation to use when opening/closing the panel. */
    set animationType(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.animationType = value;
        });
    }
    get animationType() {
        return this.nativeElement.animationType;
    }
    /** Toggles the open state of the panel. */
    toggle(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.toggle(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-expansion-panel element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineExpansionPanelComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ExpansionPanelComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ExpansionPanelComponent, selector: "forge-expansion-panel", inputs: { open: ["open", "open", booleanAttribute], orientation: "orientation", animationType: "animationType" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ExpansionPanelComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-expansion-panel',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], orientation: [{
                type: Input
            }], animationType: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeExpansionPanelModule {
    constructor() {
        defineExpansionPanelComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeExpansionPanelModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeExpansionPanelModule, declarations: [ExpansionPanelComponent], imports: [CommonModule, ForgeOpenIconModule], exports: [ExpansionPanelComponent, ForgeOpenIconModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeExpansionPanelModule, imports: [CommonModule, ForgeOpenIconModule, ForgeOpenIconModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeExpansionPanelModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ForgeOpenIconModule],
                    declarations: [ExpansionPanelComponent],
                    exports: [ExpansionPanelComponent, ForgeOpenIconModule]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeAccordionModule {
    constructor() {
        defineAccordionComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAccordionModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeAccordionModule, declarations: [AccordionComponent], imports: [CommonModule, ForgeExpansionPanelModule], exports: [AccordionComponent, ForgeExpansionPanelModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAccordionModule, imports: [CommonModule, ForgeExpansionPanelModule, ForgeExpansionPanelModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAccordionModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ForgeExpansionPanelModule],
                    declarations: [AccordionComponent],
                    exports: [AccordionComponent, ForgeExpansionPanelModule]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class AppBarComponent {
    /** The text to display in the title. */
    set titleText(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.titleText = value;
        });
    }
    get titleText() {
        return this.nativeElement.titleText;
    }
    /** The elevation of the app bar. */
    set elevation(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.elevation = value;
        });
    }
    get elevation() {
        return this.nativeElement.elevation;
    }
    /** The theme of the app bar. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    /** The href that will be used to make the logo and title area a clickable link. */
    set href(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.href = value;
        });
    }
    get href() {
        return this.nativeElement.href;
    }
    /** The `<a>` target of the logo + title area link when `href` is set. */
    set target(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.target = value;
        });
    }
    get target() {
        return this.nativeElement.target;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-app-bar element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineAppBarComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AppBarComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.7", type: AppBarComponent, selector: "forge-app-bar", inputs: { titleText: "titleText", elevation: "elevation", theme: "theme", href: "href", target: "target" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AppBarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-app-bar',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { titleText: [{
                type: Input
            }], elevation: [{
                type: Input
            }], theme: [{
                type: Input
            }], href: [{
                type: Input
            }], target: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeAppBarProxyModule {
    constructor() {
        defineAppBarComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarProxyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarProxyModule, declarations: [AppBarComponent], imports: [CommonModule], exports: [AppBarComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarProxyModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarProxyModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [AppBarComponent],
                    exports: [AppBarComponent]
                }]
        }], ctorParameters: () => [] });

class AppBarRouterNavigateDirective {
    constructor(_elementRef, _router) {
        this._elementRef = _elementRef;
        this._router = _router;
        this._listener = this._onNavigate.bind(this);
    }
    ngOnInit() {
        this._elementRef.nativeElement.addEventListener('forge-app-bar-navigate', this._listener);
    }
    _onNavigate(event) {
        const target = event.target;
        if (!target.href) {
            return;
        }
        event.preventDefault();
        this._router.navigate([target.href]);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AppBarRouterNavigateDirective, deps: [{ token: i0.ElementRef }, { token: i1.Router }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.7", type: AppBarRouterNavigateDirective, selector: "forge-app-bar[href]", ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AppBarRouterNavigateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'forge-app-bar[href]'
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1.Router }] });

class ForgeAppBarModule {
    constructor() {
        defineAppBarComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarModule, declarations: [AppBarRouterNavigateDirective], imports: [CommonModule], exports: [AppBarRouterNavigateDirective,
            ForgeAppBarProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarModule, imports: [CommonModule, ForgeAppBarProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        AppBarRouterNavigateDirective
                    ],
                    exports: [
                        AppBarRouterNavigateDirective,
                        ForgeAppBarProxyModule
                    ]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class AppBarHelpButtonComponent {
    /** The menu options to display when the button is clicked */
    set options(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.options = value;
        });
    }
    get options() {
        return this.nativeElement.options;
    }
    /** The name of an alternative icon to display. */
    set icon(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.icon = value;
        });
    }
    get icon() {
        return this.nativeElement.icon;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-app-bar-help-button element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineAppBarHelpButtonComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AppBarHelpButtonComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.7", type: AppBarHelpButtonComponent, selector: "forge-app-bar-help-button", inputs: { options: "options", icon: "icon" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AppBarHelpButtonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-app-bar-help-button',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { options: [{
                type: Input
            }], icon: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeAppBarHelpButtonModule {
    constructor() {
        defineAppBarHelpButtonComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarHelpButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarHelpButtonModule, declarations: [AppBarHelpButtonComponent], imports: [CommonModule], exports: [AppBarHelpButtonComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarHelpButtonModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarHelpButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [AppBarHelpButtonComponent],
                    exports: [AppBarHelpButtonComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class AppBarMenuButtonComponent {
    /** The name of an alternative icon to display. */
    set icon(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.icon = value;
        });
    }
    get icon() {
        return this.nativeElement.icon;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-app-bar-menu-button element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineAppBarMenuButtonComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AppBarMenuButtonComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.7", type: AppBarMenuButtonComponent, selector: "forge-app-bar-menu-button", inputs: { icon: "icon" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AppBarMenuButtonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-app-bar-menu-button',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { icon: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeAppBarMenuButtonModule {
    constructor() {
        defineAppBarMenuButtonComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarMenuButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarMenuButtonModule, declarations: [AppBarMenuButtonComponent], imports: [CommonModule], exports: [AppBarMenuButtonComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarMenuButtonModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarMenuButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [AppBarMenuButtonComponent],
                    exports: [AppBarMenuButtonComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class AppBarNotificationButtonComponent {
    /** The number to display in the badge. */
    set count(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.count = value;
        });
    }
    get count() {
        return this.nativeElement.count;
    }
    /** Whether to display the dot variant of the badge or not. */
    set dot(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dot = value;
        });
    }
    get dot() {
        return this.nativeElement.dot;
    }
    /** The theme to apply to the badge. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    /** The name of an alternative icon to display. */
    set icon(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.icon = value;
        });
    }
    get icon() {
        return this.nativeElement.icon;
    }
    /** Whether to display the badge or not. */
    set showBadge(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.showBadge = value;
        });
    }
    get showBadge() {
        return this.nativeElement.showBadge;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-app-bar-notification-button element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineAppBarNotificationButtonComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AppBarNotificationButtonComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: AppBarNotificationButtonComponent, selector: "forge-app-bar-notification-button", inputs: { count: "count", dot: ["dot", "dot", booleanAttribute], theme: "theme", icon: "icon", showBadge: ["showBadge", "showBadge", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AppBarNotificationButtonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-app-bar-notification-button',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { count: [{
                type: Input
            }], dot: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], theme: [{
                type: Input
            }], icon: [{
                type: Input
            }], showBadge: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeAppBarNotificationButtonModule {
    constructor() {
        defineAppBarNotificationButtonComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarNotificationButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarNotificationButtonModule, declarations: [AppBarNotificationButtonComponent], imports: [CommonModule], exports: [AppBarNotificationButtonComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarNotificationButtonModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarNotificationButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [AppBarNotificationButtonComponent],
                    exports: [AppBarNotificationButtonComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class AppBarProfileButtonComponent {
    /** The full name. */
    set fullName(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.fullName = value;
        });
    }
    get fullName() {
        return this.nativeElement.fullName;
    }
    /** The email address. */
    set email(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.email = value;
        });
    }
    get email() {
        return this.nativeElement.email;
    }
    /** The url of the avatar image to display. */
    set avatarImageUrl(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.avatarImageUrl = value;
        });
    }
    get avatarImageUrl() {
        return this.nativeElement.avatarImageUrl;
    }
    /** The number of letters to display in the avatar. */
    set avatarLetterCount(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.avatarLetterCount = value;
        });
    }
    get avatarLetterCount() {
        return this.nativeElement.avatarLetterCount;
    }
    /** The text to display in the avatar. */
    set avatarText(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.avatarText = value;
        });
    }
    get avatarText() {
        return this.nativeElement.avatarText;
    }
    /** The name of an alternative icon to display in the avatar. */
    set avatarIcon(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.avatarIcon = value;
        });
    }
    get avatarIcon() {
        return this.nativeElement.avatarIcon;
    }
    /** Whether to display the sign out button or not. Defaults to `true`. */
    set signOutButton(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.signOutButton = value;
        });
    }
    get signOutButton() {
        return this.nativeElement.signOutButton;
    }
    /** Whether to display the profile button or not. */
    set profileButton(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.profileButton = value;
        });
    }
    get profileButton() {
        return this.nativeElement.profileButton;
    }
    /** The text to display in the sign out button. */
    set signOutButtonText(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.signOutButtonText = value;
        });
    }
    get signOutButtonText() {
        return this.nativeElement.signOutButtonText;
    }
    /** The text to display in the profile button. */
    set profileButtonText(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.profileButtonText = value;
        });
    }
    get profileButtonText() {
        return this.nativeElement.profileButtonText;
    }
    /** Whether the profile card is open or not. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** The popup element when open. */
    get popupElement() {
        return this.nativeElement.popupElement;
    }
    /** Sets the profile card builder callback that will be used to add extra content to the profile card. */
    set profileCardBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.profileCardBuilder = value;
        });
    }
    get profileCardBuilder() {
        return this.nativeElement.profileCardBuilder;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-app-bar-profile-button element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineAppBarProfileButtonComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AppBarProfileButtonComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: AppBarProfileButtonComponent, selector: "forge-app-bar-profile-button", inputs: { fullName: "fullName", email: "email", avatarImageUrl: "avatarImageUrl", avatarLetterCount: ["avatarLetterCount", "avatarLetterCount", numberAttribute], avatarText: "avatarText", avatarIcon: "avatarIcon", signOutButton: ["signOutButton", "signOutButton", booleanAttribute], profileButton: ["profileButton", "profileButton", booleanAttribute], signOutButtonText: "signOutButtonText", profileButtonText: "profileButtonText", open: ["open", "open", booleanAttribute], profileCardBuilder: "profileCardBuilder" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AppBarProfileButtonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-app-bar-profile-button',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { fullName: [{
                type: Input
            }], email: [{
                type: Input
            }], avatarImageUrl: [{
                type: Input
            }], avatarLetterCount: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], avatarText: [{
                type: Input
            }], avatarIcon: [{
                type: Input
            }], signOutButton: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], profileButton: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], signOutButtonText: [{
                type: Input
            }], profileButtonText: [{
                type: Input
            }], open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], profileCardBuilder: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeAppBarProfileButtonModule {
    constructor() {
        defineAppBarProfileButtonComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarProfileButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarProfileButtonModule, declarations: [AppBarProfileButtonComponent], imports: [CommonModule], exports: [AppBarProfileButtonComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarProfileButtonModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarProfileButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [AppBarProfileButtonComponent],
                    exports: [AppBarProfileButtonComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class AppBarSearchComponent {
    /** The value of the input. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** A boolean property that, if true, indicates that the input should be disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** The placeholder text of the input. */
    set placeholder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.placeholder = value;
        });
    }
    get placeholder() {
        return this.nativeElement.placeholder;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-app-bar-search element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineAppBarSearchComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AppBarSearchComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: AppBarSearchComponent, selector: "forge-app-bar-search", inputs: { value: "value", disabled: ["disabled", "disabled", booleanAttribute], placeholder: "placeholder" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AppBarSearchComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-app-bar-search',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { value: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], placeholder: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeAppBarSearchModule {
    constructor() {
        defineAppBarSearchComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarSearchModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarSearchModule, declarations: [AppBarSearchComponent], imports: [CommonModule], exports: [AppBarSearchComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarSearchModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAppBarSearchModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [AppBarSearchComponent],
                    exports: [AppBarSearchComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class AutocompleteComponent {
    /** Gets/sets the interaction mode. */
    set mode(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.mode = value;
        });
    }
    get mode() {
        return this.nativeElement.mode;
    }
    /** Gets/sets the multi-select state. */
    set multiple(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.multiple = value;
        });
    }
    get multiple() {
        return this.nativeElement.multiple;
    }
    /** Gets/sets the value. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Gets/sets the debounce delay (milliseconds) for keyboard events. */
    set debounce(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.debounce = value;
        });
    }
    get debounce() {
        return this.nativeElement.debounce;
    }
    /** Gets/sets filter on focus settings which controls whether the dropdown displays automatically when focused. */
    set filterOnFocus(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.filterOnFocus = value;
        });
    }
    get filterOnFocus() {
        return this.nativeElement.filterOnFocus;
    }
    /** Gets/sets whether the first option in the dropdown will be focused automatically when opened or not. */
    set filterFocusFirst(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.filterFocusFirst = value;
        });
    }
    get filterFocusFirst() {
        return this.nativeElement.filterFocusFirst;
    }
    /** Controls whether unmatched text entered by the user will stay visible an option in the dropdown is not found. */
    set allowUnmatched(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.allowUnmatched = value;
        });
    }
    get allowUnmatched() {
        return this.nativeElement.allowUnmatched;
    }
    /** Gets/sets the selector that will be used to find an element to attach the popup to. Defaults to the input element. */
    set popupTarget(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popupTarget = value;
        });
    }
    get popupTarget() {
        return this.nativeElement.popupTarget;
    }
    /**
     * Gets/sets the filter text.
     *
     * Setting the filter text only applies when allowUnmatched is enabled.
     */
    set filterText(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.filterText = value;
        });
    }
    get filterText() {
        return this.nativeElement.filterText;
    }
    /** Sets the option builder callback that will be executed when building the option list in the dropdown. */
    set optionBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.optionBuilder = value;
        });
    }
    get optionBuilder() {
        return this.nativeElement.optionBuilder;
    }
    /** Sets the filter callback that will be executed when fetching options for the autocomplete dropdown. */
    set filter(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.filter = value;
        });
    }
    get filter() {
        return this.nativeElement.filter;
    }
    /** Sets the selected text builder callback that will be executed when getting the selected text. */
    set selectedTextBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selectedTextBuilder = value;
        });
    }
    get selectedTextBuilder() {
        return this.nativeElement.selectedTextBuilder;
    }
    /** Controls the open state of the dropdown. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** Gets/sets the property key to match the value to an option. */
    set matchKey(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.matchKey = value;
        });
    }
    get matchKey() {
        return this.nativeElement.matchKey;
    }
    /** Returns whether the component has been initialized or not yet. */
    get isInitialized() {
        return this.nativeElement.isInitialized;
    }
    /** Gets the currently active popup element when the dropdown is open. */
    get popupElement() {
        return this.nativeElement.popupElement;
    }
    /** Sets the callback to be executed when the user selects an option, before the UI is updated to allow for validation. */
    set beforeValueChange(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.beforeValueChange = value;
        });
    }
    get beforeValueChange() {
        return this.nativeElement.beforeValueChange;
    }
    /** Gets/sets the list of classes to apply to the popup element. */
    set popupClasses(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popupClasses = value;
        });
    }
    get popupClasses() {
        return this.nativeElement.popupClasses;
    }
    /** Gets/sets the callback function for generating header content within the popup. */
    set popupHeaderBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popupHeaderBuilder = value;
        });
    }
    get popupHeaderBuilder() {
        return this.nativeElement.popupHeaderBuilder;
    }
    /** Gets/sets the callback function for generating header content within the popup. */
    set popupFooterBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popupFooterBuilder = value;
        });
    }
    get popupFooterBuilder() {
        return this.nativeElement.popupFooterBuilder;
    }
    /** Gets/sets whether the popup width is synchronized with the popup target width. */
    set syncPopupWidth(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.syncPopupWidth = value;
        });
    }
    get syncPopupWidth() {
        return this.nativeElement.syncPopupWidth;
    }
    /** Gets/sets the maximum number of options to display in the dropdown. */
    set optionLimit(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.optionLimit = value;
        });
    }
    get optionLimit() {
        return this.nativeElement.optionLimit;
    }
    /** Controls the observation of scroll events on the dropdown. */
    set observeScroll(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.observeScroll = value;
        });
    }
    get observeScroll() {
        return this.nativeElement.observeScroll;
    }
    /** The number of pixels from the bottom to trigger the scroll bottom event. Only applicable if `observeScroll` is true. */
    set observeScrollThreshold(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.observeScrollThreshold = value;
        });
    }
    get observeScrollThreshold() {
        return this.nativeElement.observeScrollThreshold;
    }
    /** Gets/sets whether the popup width will be constrained to a max width of the viewport width (default: `100vw`). */
    set constrainPopupWidth(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.constrainPopupWidth = value;
        });
    }
    get constrainPopupWidth() {
        return this.nativeElement.constrainPopupWidth;
    }
    /**
     * Gets/sets whether the options will wrap their text or not.
     * This only applies if `constrainPopupWidth` is `true`, if there is an explicit width set via CSS.
     */
    set wrapOptionText(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.wrapOptionText = value;
        });
    }
    get wrapOptionText() {
        return this.nativeElement.wrapOptionText;
    }
    /** Adds options to the dropdown while it is open. Has no effect if the dropdown is closed. */
    appendOptions(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.appendOptions(...args));
    }
    /** Opens the dropdown. */
    openDropdown(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.openDropdown(...args));
    }
    /** Closes the dropdown. */
    closeDropdown(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.closeDropdown(...args));
    }
    /** Forces the filter callback to be executed to update the current selection state with new options. */
    forceFilter(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.forceFilter(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-autocomplete element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineAutocompleteComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AutocompleteComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: AutocompleteComponent, selector: "forge-autocomplete", inputs: { mode: "mode", multiple: ["multiple", "multiple", booleanAttribute], value: "value", debounce: ["debounce", "debounce", numberAttribute], filterOnFocus: ["filterOnFocus", "filterOnFocus", booleanAttribute], filterFocusFirst: ["filterFocusFirst", "filterFocusFirst", booleanAttribute], allowUnmatched: ["allowUnmatched", "allowUnmatched", booleanAttribute], popupTarget: "popupTarget", filterText: "filterText", optionBuilder: "optionBuilder", filter: "filter", selectedTextBuilder: "selectedTextBuilder", open: ["open", "open", booleanAttribute], matchKey: "matchKey", beforeValueChange: "beforeValueChange", popupClasses: "popupClasses", popupHeaderBuilder: "popupHeaderBuilder", popupFooterBuilder: "popupFooterBuilder", syncPopupWidth: ["syncPopupWidth", "syncPopupWidth", booleanAttribute], optionLimit: ["optionLimit", "optionLimit", numberAttribute], observeScroll: ["observeScroll", "observeScroll", booleanAttribute], observeScrollThreshold: ["observeScrollThreshold", "observeScrollThreshold", numberAttribute], constrainPopupWidth: ["constrainPopupWidth", "constrainPopupWidth", booleanAttribute], wrapOptionText: ["wrapOptionText", "wrapOptionText", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AutocompleteComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-autocomplete',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { mode: [{
                type: Input
            }], multiple: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], value: [{
                type: Input
            }], debounce: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], filterOnFocus: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], filterFocusFirst: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], allowUnmatched: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], popupTarget: [{
                type: Input
            }], filterText: [{
                type: Input
            }], optionBuilder: [{
                type: Input
            }], filter: [{
                type: Input
            }], selectedTextBuilder: [{
                type: Input
            }], open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], matchKey: [{
                type: Input
            }], beforeValueChange: [{
                type: Input
            }], popupClasses: [{
                type: Input
            }], popupHeaderBuilder: [{
                type: Input
            }], popupFooterBuilder: [{
                type: Input
            }], syncPopupWidth: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], optionLimit: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], observeScroll: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], observeScrollThreshold: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], constrainPopupWidth: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], wrapOptionText: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeAutocompleteProxyModule {
    constructor() {
        defineAutocompleteComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAutocompleteProxyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeAutocompleteProxyModule, declarations: [AutocompleteComponent], imports: [CommonModule], exports: [AutocompleteComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAutocompleteProxyModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAutocompleteProxyModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [AutocompleteComponent],
                    exports: [AutocompleteComponent]
                }]
        }], ctorParameters: () => [] });

const AUTOCOMPLETE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => AutocompleteValueAccessor),
    multi: true
};
class AutocompleteValueAccessor {
    autocompleteChange(event) {
        this.change(event.detail);
    }
    blur() {
        this.onTouched();
    }
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    writeValue(value) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        const inputEl = this._elementRef.nativeElement.querySelector('input');
        if (inputEl) {
            this._renderer.setProperty(inputEl, 'disabled', isDisabled);
        }
        const clearButtonEl = this._elementRef.nativeElement.querySelector(AUTOCOMPLETE_CONSTANTS.selectors.CLEAR_BUTTON);
        if (clearButtonEl) {
            this._renderer.setProperty(clearButtonEl, 'disabled', isDisabled);
        }
    }
    change(value) {
        this.onChange(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AutocompleteValueAccessor, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.7", type: AutocompleteValueAccessor, selector: "forge-autocomplete[formControlName],forge-autocomplete[formControl],forge-autocomplete[ngModel]", host: { listeners: { "forge-autocomplete-change": "autocompleteChange($event)", "focusout": "blur()" } }, providers: [AUTOCOMPLETE_VALUE_ACCESSOR], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AutocompleteValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'forge-autocomplete[formControlName],forge-autocomplete[formControl],forge-autocomplete[ngModel]',
                    providers: [AUTOCOMPLETE_VALUE_ACCESSOR]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { autocompleteChange: [{
                type: HostListener,
                args: ['forge-autocomplete-change', ['$event']]
            }], blur: [{
                type: HostListener,
                args: ['focusout']
            }] } });

class ForgeAutocompleteModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAutocompleteModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeAutocompleteModule, declarations: [AutocompleteValueAccessor], exports: [AutocompleteValueAccessor,
            ForgeAutocompleteProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAutocompleteModule, imports: [ForgeAutocompleteProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAutocompleteModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        AutocompleteValueAccessor
                    ],
                    exports: [
                        AutocompleteValueAccessor,
                        ForgeAutocompleteProxyModule
                    ]
                }]
        }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class AvatarComponent {
    /** The text to display in the avatar. */
    set text(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.text = value;
        });
    }
    get text() {
        return this.nativeElement.text;
    }
    /** Controls the number of letters to display from the text. By default the text is split on spaces and the first character of each word is used. */
    set letterCount(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.letterCount = value;
        });
    }
    get letterCount() {
        return this.nativeElement.letterCount;
    }
    /** The background image URL to use. */
    set imageUrl(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.imageUrl = value;
        });
    }
    get imageUrl() {
        return this.nativeElement.imageUrl;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-avatar element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineAvatarComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AvatarComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: AvatarComponent, selector: "forge-avatar", inputs: { text: "text", letterCount: ["letterCount", "letterCount", numberAttribute], imageUrl: "imageUrl" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: AvatarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-avatar',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { text: [{
                type: Input
            }], letterCount: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], imageUrl: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeAvatarModule {
    constructor() {
        defineAvatarComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAvatarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeAvatarModule, declarations: [AvatarComponent], imports: [CommonModule], exports: [AvatarComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAvatarModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeAvatarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [AvatarComponent],
                    exports: [AvatarComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class BackdropComponent {
    /** Whether the backdrop is visible. */
    set visible(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.visible = value;
        });
    }
    get visible() {
        return this.nativeElement.visible;
    }
    /** Whether the backdrop uses "fixed" or "relative" positioning. */
    set fixed(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.fixed = value;
        });
    }
    get fixed() {
        return this.nativeElement.fixed;
    }
    /** Immediately shows the backdrop by setting the `visibility` to `true` without animations. */
    show(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.show(...args));
    }
    /** Immediately hides the backdrop by setting the `visibility` to `false` without animations. */
    hide(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.hide(...args));
    }
    /** Sets the `visibility` to `true` and animates in. */
    fadeIn(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.fadeIn(...args));
    }
    /** Sets the `visibility` to `false` and animates out. */
    fadeOut(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.fadeOut(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-backdrop element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineBackdropComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: BackdropComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: BackdropComponent, selector: "forge-backdrop", inputs: { visible: ["visible", "visible", booleanAttribute], fixed: ["fixed", "fixed", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: BackdropComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-backdrop',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { visible: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], fixed: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeBackdropModule {
    constructor() {
        defineBackdropComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeBackdropModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeBackdropModule, declarations: [BackdropComponent], imports: [CommonModule], exports: [BackdropComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeBackdropModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeBackdropModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [BackdropComponent],
                    exports: [BackdropComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class BadgeComponent {
    /** Controls whether the badge will be a small dot without any content visible. */
    set dot(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dot = value;
        });
    }
    get dot() {
        return this.nativeElement.dot;
    }
    /** The theme of the badge. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    /** Controls whether the badge will have a stronger visual appearance. */
    set strong(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.strong = value;
        });
    }
    get strong() {
        return this.nativeElement.strong;
    }
    /** Controls whether the badge is visible. */
    set hide(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.hide = value;
        });
    }
    get hide() {
        return this.nativeElement.hide;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-badge element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineBadgeComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: BadgeComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: BadgeComponent, selector: "forge-badge", inputs: { dot: ["dot", "dot", booleanAttribute], theme: "theme", strong: ["strong", "strong", booleanAttribute], hide: ["hide", "hide", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: BadgeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-badge',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { dot: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], theme: [{
                type: Input
            }], strong: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], hide: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeBadgeModule {
    constructor() {
        defineBadgeComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeBadgeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeBadgeModule, declarations: [BadgeComponent], imports: [CommonModule], exports: [BadgeComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeBadgeModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeBadgeModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [BadgeComponent],
                    exports: [BadgeComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class BannerComponent {
    /** Controls the visibility of the banner. */
    set dismissed(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dismissed = value;
        });
    }
    get dismissed() {
        return this.nativeElement.dismissed;
    }
    /** Controls the visibility of the built-in dismiss button. */
    set persistent(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.persistent = value;
        });
    }
    get persistent() {
        return this.nativeElement.persistent;
    }
    /** The theme of the banner. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    set canDismiss(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.canDismiss = value;
        });
    }
    get canDismiss() {
        return this.nativeElement.canDismiss;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-banner element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineBannerComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: BannerComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: BannerComponent, selector: "forge-banner", inputs: { dismissed: ["dismissed", "dismissed", booleanAttribute], persistent: ["persistent", "persistent", booleanAttribute], theme: "theme", canDismiss: ["canDismiss", "canDismiss", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: BannerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-banner',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { dismissed: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], persistent: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], theme: [{
                type: Input
            }], canDismiss: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeBannerModule {
    constructor() {
        defineBannerComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeBannerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeBannerModule, declarations: [BannerComponent], imports: [CommonModule], exports: [BannerComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeBannerModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeBannerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [BannerComponent],
                    exports: [BannerComponent]
                }]
        }], ctorParameters: () => [] });

class BottomSheetConfig {
}

class BaseInjector {
    constructor(_parentInjector, _additionalTokens) {
        this._parentInjector = _parentInjector;
        this._additionalTokens = _additionalTokens;
    }
    get(token, notFoundValue) {
        const value = this._additionalTokens.get(token);
        if (value) {
            return value;
        }
        return this._parentInjector.get(token, notFoundValue);
    }
}

class BottomSheetInjector extends BaseInjector {
}

class BottomSheetRef {
    constructor(instance) {
        this._afterClosed = new AsyncSubject();
        this.afterClosed = this._afterClosed.asObservable();
        this._beforeClose = new Subject();
        this.beforeClose = this._beforeClose.asObservable();
        this._elementRef = new ElementRef(instance);
        instance.addEventListener('forge-bottom-sheet-before-close', evt => this._beforeClose.next(evt));
    }
    close(result) {
        this.nativeElement.open = false;
        this._afterClosed.next(result);
        this._afterClosed.complete();
        this._beforeClose.complete();
    }
    get nativeElement() {
        return this._elementRef.nativeElement;
    }
}

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class BottomSheetComponent {
    /** Whether the bottom sheet is open. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** The mode of the bottom sheet. */
    set mode(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.mode = value;
        });
    }
    get mode() {
        return this.nativeElement.mode;
    }
    /** Whether the bottom sheet is persistent. */
    set persistent(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.persistent = value;
        });
    }
    get persistent() {
        return this.nativeElement.persistent;
    }
    /** Whether the bottom sheet is fullscreen. */
    set fullscreen(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.fullscreen = value;
        });
    }
    get fullscreen() {
        return this.nativeElement.fullscreen;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-bottom-sheet element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineBottomSheetComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: BottomSheetComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: BottomSheetComponent, selector: "forge-bottom-sheet", inputs: { open: ["open", "open", booleanAttribute], mode: "mode", persistent: ["persistent", "persistent", booleanAttribute], fullscreen: ["fullscreen", "fullscreen", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: BottomSheetComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-bottom-sheet',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], mode: [{
                type: Input
            }], persistent: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], fullscreen: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeBottomSheetModule {
    constructor() {
        defineBottomSheetComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeBottomSheetModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeBottomSheetModule, declarations: [BottomSheetComponent], imports: [CommonModule], exports: [BottomSheetComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeBottomSheetModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeBottomSheetModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [BottomSheetComponent],
                    exports: [BottomSheetComponent]
                }]
        }], ctorParameters: () => [] });

class BottomSheetService {
    constructor(_appRef, _injector, _ngZone) {
        this._appRef = _appRef;
        this._injector = _injector;
        this._ngZone = _ngZone;
        defineBottomSheetComponent();
    }
    /**
     * Displays a components within a Forge bottom sheet instance.
     * @param component The component reference.
     * @param options The component reference.
     * @param config The configuration to provide to the dynamic component as an injectable token.
     * @param moduleRef An NgModuleRef to create the component factory from. (should the injector also inherit from this?)
     * @param envInjector An environment injector to provide to the component.
     * @returns A reference for interacting with the created bottom sheet.
     */
    show(component, options, config, moduleRef, envInjector) {
        // Contains tokens that will be provided to components through our custom bottom sheet injector
        const providers = [];
        // If we got a config, we should provide it as an injection token
        if (config) {
            providers.push({ provide: BottomSheetConfig, useValue: config });
        }
        // Create the Forge bottom sheet element
        const bottomSheetElement = document.createElement('forge-bottom-sheet');
        // Configure the bottom sheet with the provided options
        if (options) {
            const { bottomSheetClass, attributes, ...restOptions } = options;
            if (bottomSheetClass) {
                bottomSheetElement.classList.add(bottomSheetClass);
            }
            if (attributes) {
                attributes.forEach((value, key) => bottomSheetElement.setAttribute(key, value));
            }
            Object.assign(bottomSheetElement, restOptions);
        }
        // Create the ref that will allow the consumer to control the bottom sheet
        const bottomSheetRef = new BottomSheetRef(bottomSheetElement);
        // Always provide the bottom sheet ref as an injection token
        providers.push({ provide: BottomSheetRef, useValue: bottomSheetRef });
        // Create and attach the dynamic component to the bottom sheet element
        this._ngZone.run(() => {
            const parentInjector = envInjector ?? moduleRef?.injector ?? this._injector;
            const environmentInjector = createEnvironmentInjector(providers, parentInjector);
            const componentRef = createComponent(component, { environmentInjector });
            this._appRef.attachView(componentRef.hostView);
            const element = componentRef.hostView.rootNodes[0];
            bottomSheetElement.appendChild(element);
            bottomSheetElement.addEventListener('forge-bottom-sheet-close', () => {
                if (bottomSheetRef.nativeElement.open) {
                    bottomSheetRef.close();
                    return;
                }
                componentRef.destroy();
                bottomSheetElement.remove();
            });
        });
        bottomSheetElement.open = true;
        document.body.appendChild(bottomSheetElement);
        return bottomSheetRef;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: BottomSheetService, deps: [{ token: i0.ApplicationRef }, { token: i0.EnvironmentInjector }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: BottomSheetService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: BottomSheetService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: i0.ApplicationRef }, { type: i0.EnvironmentInjector }, { type: i0.NgZone }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ButtonComponent {
    /** The variant of the button. */
    set variant(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.variant = value;
        });
    }
    get variant() {
        return this.nativeElement.variant;
    }
    /** Whether or not the button is pill-shaped. */
    set pill(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.pill = value;
        });
    }
    get pill() {
        return this.nativeElement.pill;
    }
    /** The theme of the button. Defaults to `primary`. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    /** Whether or not the button is full-width. */
    set fullWidth(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.fullWidth = value;
        });
    }
    get fullWidth() {
        return this.nativeElement.fullWidth;
    }
    /** The type of button. Valid values are `button`, `submit`, and `reset`. */
    set type(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.type = value;
        });
    }
    get type() {
        return this.nativeElement.type;
    }
    /** Whether or not the button is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Whether or not the button shows a built-in popover icon. */
    set popoverIcon(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popoverIcon = value;
        });
    }
    get popoverIcon() {
        return this.nativeElement.popoverIcon;
    }
    /** The name of the button. */
    set name(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.name = value;
        });
    }
    get name() {
        return this.nativeElement.name;
    }
    /** The form value of the button. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Whether or not the button is dense. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** The form reference of the button if within a `<form>` element. */
    get form() {
        return this.nativeElement.form;
    }
    /** Clicks the button. */
    click(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.click(...args));
    }
    /** Focuses the button. */
    focus(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.focus(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-button element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineButtonComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ButtonComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ButtonComponent, selector: "forge-button", inputs: { variant: "variant", pill: ["pill", "pill", booleanAttribute], theme: "theme", fullWidth: ["fullWidth", "fullWidth", booleanAttribute], type: "type", disabled: ["disabled", "disabled", booleanAttribute], popoverIcon: ["popoverIcon", "popoverIcon", booleanAttribute], name: "name", value: "value", dense: ["dense", "dense", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ButtonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-button',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { variant: [{
                type: Input
            }], pill: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], theme: [{
                type: Input
            }], fullWidth: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], type: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], popoverIcon: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], name: [{
                type: Input
            }], value: [{
                type: Input
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeButtonModule {
    constructor() {
        defineButtonComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonModule, declarations: [ButtonComponent], imports: [CommonModule], exports: [ButtonComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [ButtonComponent],
                    exports: [ButtonComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ButtonAreaComponent {
    /** Sets whether the button area and slotted button are disabled. Setting this on one will also set it on the other. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-button-area element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineButtonAreaComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ButtonAreaComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ButtonAreaComponent, selector: "forge-button-area", inputs: { disabled: ["disabled", "disabled", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ButtonAreaComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-button-area',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeButtonAreaModule {
    constructor() {
        defineButtonAreaComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonAreaModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonAreaModule, declarations: [ButtonAreaComponent], imports: [CommonModule], exports: [ButtonAreaComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonAreaModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonAreaModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [ButtonAreaComponent],
                    exports: [ButtonAreaComponent]
                }]
        }], ctorParameters: () => [] });

const BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => ButtonToggleGroupValueAccessor),
    multi: true
};
class ButtonToggleGroupValueAccessor {
    buttonToggleGroupChange(event) {
        this.change(event.detail);
    }
    blur() {
        this.onTouched();
    }
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    writeValue(value) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);
    }
    registerOnChange(fn) {
        this.onChange = value => fn(value === '' ? null : value);
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    change(value) {
        this.onChange(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ButtonToggleGroupValueAccessor, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.7", type: ButtonToggleGroupValueAccessor, selector: "forge-button-toggle-group[formControlName],forge-button-toggle-group[formControl],forge-button-toggle-group[ngModel]", host: { listeners: { "forge-button-toggle-group-change": "buttonToggleGroupChange($event)", "focusout": "blur()" } }, providers: [BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ButtonToggleGroupValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'forge-button-toggle-group[formControlName],forge-button-toggle-group[formControl],forge-button-toggle-group[ngModel]',
                    providers: [BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { buttonToggleGroupChange: [{
                type: HostListener,
                args: ['forge-button-toggle-group-change', ['$event']]
            }], blur: [{
                type: HostListener,
                args: ['focusout']
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ButtonToggleComponent {
    /** The value of the button toggle. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Whether or not the button is selected. */
    set selected(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selected = value;
        });
    }
    get selected() {
        return this.nativeElement.selected;
    }
    /** Whether or not the button is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Whether or not the button is readonly. */
    set readonly(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.readonly = value;
        });
    }
    get readonly() {
        return this.nativeElement.readonly;
    }
    focus(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.focus(...args));
    }
    click(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.click(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-button-toggle element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineButtonToggleComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ButtonToggleComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ButtonToggleComponent, selector: "forge-button-toggle", inputs: { value: "value", selected: ["selected", "selected", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], readonly: ["readonly", "readonly", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ButtonToggleComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-button-toggle',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { value: [{
                type: Input
            }], selected: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], readonly: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeButtonToggleProxyModule {
    constructor() {
        defineButtonToggleComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonToggleProxyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonToggleProxyModule, declarations: [ButtonToggleComponent], imports: [CommonModule], exports: [ButtonToggleComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonToggleProxyModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonToggleProxyModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [ButtonToggleComponent],
                    exports: [ButtonToggleComponent]
                }]
        }], ctorParameters: () => [] });

class ForgeButtonToggleModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonToggleModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonToggleModule, declarations: [ButtonToggleGroupValueAccessor], exports: [ButtonToggleGroupValueAccessor,
            ForgeButtonToggleProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonToggleModule, imports: [ForgeButtonToggleProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonToggleModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        ButtonToggleGroupValueAccessor
                    ],
                    exports: [
                        ButtonToggleGroupValueAccessor,
                        ForgeButtonToggleProxyModule
                    ]
                }]
        }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ButtonToggleGroupComponent {
    /** The value of the selected button toggle(s). */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Whether or not the group should be outlined. */
    set outlined(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.outlined = value;
        });
    }
    get outlined() {
        return this.nativeElement.outlined;
    }
    /** Whether or not the group should allow multiple selections. */
    set multiple(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.multiple = value;
        });
    }
    get multiple() {
        return this.nativeElement.multiple;
    }
    /** Whether or not the group should require a selection once a button has been toggled on. */
    set mandatory(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.mandatory = value;
        });
    }
    get mandatory() {
        return this.nativeElement.mandatory;
    }
    /** Whether or not the group should be displayed vertically. */
    set vertical(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.vertical = value;
        });
    }
    get vertical() {
        return this.nativeElement.vertical;
    }
    /** Whether or not the group should stretch to fill the available width. */
    set stretch(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.stretch = value;
        });
    }
    get stretch() {
        return this.nativeElement.stretch;
    }
    /** Whether or not the group should be dense. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** Whether or not the group should be disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    set required(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.required = value;
        });
    }
    get required() {
        return this.nativeElement.required;
    }
    /** Whether or not the group should be readonly. */
    set readonly(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.readonly = value;
        });
    }
    get readonly() {
        return this.nativeElement.readonly;
    }
    /** The theme to use for the group. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    get validity() {
        return this.nativeElement.validity;
    }
    get validationMessage() {
        return this.nativeElement.validationMessage;
    }
    get willValidate() {
        return this.nativeElement.willValidate;
    }
    checkValidity(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.checkValidity(...args));
    }
    reportValidity(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.reportValidity(...args));
    }
    setCustomValidity(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.setCustomValidity(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-button-toggle-group element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineButtonToggleGroupComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ButtonToggleGroupComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ButtonToggleGroupComponent, selector: "forge-button-toggle-group", inputs: { value: "value", outlined: ["outlined", "outlined", booleanAttribute], multiple: ["multiple", "multiple", booleanAttribute], mandatory: ["mandatory", "mandatory", booleanAttribute], vertical: ["vertical", "vertical", booleanAttribute], stretch: ["stretch", "stretch", booleanAttribute], dense: ["dense", "dense", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], required: ["required", "required", booleanAttribute], readonly: ["readonly", "readonly", booleanAttribute], theme: "theme" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ButtonToggleGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-button-toggle-group',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { value: [{
                type: Input
            }], outlined: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], multiple: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], mandatory: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], vertical: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], stretch: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], required: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], readonly: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], theme: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeButtonToggleGroupModule {
    constructor() {
        defineButtonToggleGroupComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonToggleGroupModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonToggleGroupModule, declarations: [ButtonToggleGroupComponent], imports: [CommonModule, ForgeButtonToggleProxyModule], exports: [ButtonToggleGroupComponent, ForgeButtonToggleProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonToggleGroupModule, imports: [CommonModule, ForgeButtonToggleProxyModule, ForgeButtonToggleProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeButtonToggleGroupModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ForgeButtonToggleProxyModule],
                    declarations: [ButtonToggleGroupComponent],
                    exports: [ButtonToggleGroupComponent, ForgeButtonToggleProxyModule]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class CalendarComponent {
    /** The currently active date in the calendar. */
    get activeDate() {
        return this.nativeElement.activeDate;
    }
    /** Whether to allow a single date range to be selected. */
    set allowSingleDateRange(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.allowSingleDateRange = value;
        });
    }
    get allowSingleDateRange() {
        return this.nativeElement.allowSingleDateRange;
    }
    /** Whether to show a button to clear the selected date(s). */
    set clearButton(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.clearButton = value;
        });
    }
    get clearButton() {
        return this.nativeElement.clearButton;
    }
    /** Callback function to call when the clear button is clicked. */
    set clearCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.clearCallback = value;
        });
    }
    get clearCallback() {
        return this.nativeElement.clearCallback;
    }
    /** Whether to constrain the selected date(s) to the enabled dates. */
    set constrainToEnabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.constrainToEnabled = value;
        });
    }
    get constrainToEnabled() {
        return this.nativeElement.constrainToEnabled;
    }
    /** Function to build the date content. */
    set dateBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dateBuilder = value;
        });
    }
    get dateBuilder() {
        return this.nativeElement.dateBuilder;
    }
    /** Callback function to call when a date is selected. */
    set dateSelectCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dateSelectCallback = value;
        });
    }
    get dateSelectCallback() {
        return this.nativeElement.dateSelectCallback;
    }
    /** Function to build the day content. */
    set dayBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dayBuilder = value;
        });
    }
    get dayBuilder() {
        return this.nativeElement.dayBuilder;
    }
    /** Function to determine if a date is disabled. */
    set disabledDateBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabledDateBuilder = value;
        });
    }
    get disabledDateBuilder() {
        return this.nativeElement.disabledDateBuilder;
    }
    /** Dates that are disabled from being selected. */
    set disabledDates(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabledDates = value;
        });
    }
    get disabledDates() {
        return this.nativeElement.disabledDates;
    }
    /** Days of the week that are disabled from being selected. */
    set disabledDaysOfWeek(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabledDaysOfWeek = value;
        });
    }
    get disabledDaysOfWeek() {
        return this.nativeElement.disabledDaysOfWeek;
    }
    /** Function to build the event content. */
    set eventBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.eventBuilder = value;
        });
    }
    get eventBuilder() {
        return this.nativeElement.eventBuilder;
    }
    /** Events to display on the calendar. */
    set events(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.events = value;
        });
    }
    get events() {
        return this.nativeElement.events;
    }
    /** The first day of the week. */
    set firstDayOfWeek(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.firstDayOfWeek = value;
        });
    }
    get firstDayOfWeek() {
        return this.nativeElement.firstDayOfWeek;
    }
    /** Whether to fix the height of the calendar. */
    set fixedHeight(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.fixedHeight = value;
        });
    }
    get fixedHeight() {
        return this.nativeElement.fixedHeight;
    }
    /** Whether to list the years in the year view. */
    set listYears(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.listYears = value;
        });
    }
    get listYears() {
        return this.nativeElement.listYears;
    }
    /** The locale to use for formatting dates. */
    set locale(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.locale = value;
        });
    }
    get locale() {
        return this.nativeElement.locale;
    }
    /** The maximum date that can be selected. */
    set max(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.max = value;
        });
    }
    get max() {
        return this.nativeElement.max;
    }
    /** The animation to use for the menu. */
    set menuAnimation(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.menuAnimation = value;
        });
    }
    get menuAnimation() {
        return this.nativeElement.menuAnimation;
    }
    /** The minimum date that can be selected. */
    set min(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.min = value;
        });
    }
    get min() {
        return this.nativeElement.min;
    }
    /** The mode of the calendar. */
    set mode(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.mode = value;
        });
    }
    get mode() {
        return this.nativeElement.mode;
    }
    /** The month to display. */
    set month(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.month = value;
        });
    }
    get month() {
        return this.nativeElement.month;
    }
    /** Whether to prevent the calendar from taking focus. */
    set preventFocus(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.preventFocus = value;
        });
    }
    get preventFocus() {
        return this.nativeElement.preventFocus;
    }
    /** Whether the calendar is readonly. */
    set readonly(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.readonly = value;
        });
    }
    get readonly() {
        return this.nativeElement.readonly;
    }
    /** Whether the selection follows the month. */
    set selectionFollowsMonth(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selectionFollowsMonth = value;
        });
    }
    get selectionFollowsMonth() {
        return this.nativeElement.selectionFollowsMonth;
    }
    /** Whether to show the header. */
    set showHeader(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.showHeader = value;
        });
    }
    get showHeader() {
        return this.nativeElement.showHeader;
    }
    /** Whether to show days from other months. */
    set showOtherMonths(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.showOtherMonths = value;
        });
    }
    get showOtherMonths() {
        return this.nativeElement.showOtherMonths;
    }
    /** Whether to show the today button. */
    set showToday(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.showToday = value;
        });
    }
    get showToday() {
        return this.nativeElement.showToday;
    }
    /** Whether to show a button to select today. */
    set todayButton(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.todayButton = value;
        });
    }
    get todayButton() {
        return this.nativeElement.todayButton;
    }
    /** Callback function to call when the today button is clicked. */
    set todayCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.todayCallback = value;
        });
    }
    get todayCallback() {
        return this.nativeElement.todayCallback;
    }
    /** Function to build the tooltip content. */
    set tooltipBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.tooltipBuilder = value;
        });
    }
    get tooltipBuilder() {
        return this.nativeElement.tooltipBuilder;
    }
    /** The selected date(s). */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** The view of the calendar. */
    set view(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.view = value;
        });
    }
    get view() {
        return this.nativeElement.view;
    }
    /** The days of the week that are considered weekends. */
    set weekendDays(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.weekendDays = value;
        });
    }
    get weekendDays() {
        return this.nativeElement.weekendDays;
    }
    /** The year to display. */
    set year(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.year = value;
        });
    }
    get year() {
        return this.nativeElement.year;
    }
    /** The range of years to display. */
    set yearRange(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.yearRange = value;
        });
    }
    get yearRange() {
        return this.nativeElement.yearRange;
    }
    /** Clears the selected date(s). */
    clear(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.clear(...args));
    }
    /** Deselects a date. */
    deselectDate(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.deselectDate(...args));
    }
    /** Navigates to a specific date. */
    goToDate(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.goToDate(...args));
    }
    /** Handles a keyboard event. */
    handleKey(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.handleKey(...args));
    }
    /** Lays out the calendar. */
    layout(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.layout(...args));
    }
    /** Selects a date. */
    selectDate(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.selectDate(...args));
    }
    /** Sets the active date. */
    setActiveDate(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.setActiveDate(...args));
    }
    /** Sets the calendar to today. */
    today(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.today(...args));
    }
    /** Toggles a date selection. */
    toggleDate(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.toggleDate(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-calendar element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineCalendarComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: CalendarComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: CalendarComponent, selector: "forge-calendar", inputs: { allowSingleDateRange: ["allowSingleDateRange", "allowSingleDateRange", booleanAttribute], clearButton: ["clearButton", "clearButton", booleanAttribute], clearCallback: "clearCallback", constrainToEnabled: ["constrainToEnabled", "constrainToEnabled", booleanAttribute], dateBuilder: "dateBuilder", dateSelectCallback: "dateSelectCallback", dayBuilder: "dayBuilder", disabledDateBuilder: "disabledDateBuilder", disabledDates: "disabledDates", disabledDaysOfWeek: "disabledDaysOfWeek", eventBuilder: "eventBuilder", events: "events", firstDayOfWeek: "firstDayOfWeek", fixedHeight: ["fixedHeight", "fixedHeight", booleanAttribute], listYears: ["listYears", "listYears", booleanAttribute], locale: "locale", max: "max", menuAnimation: "menuAnimation", min: "min", mode: "mode", month: ["month", "month", numberAttribute], preventFocus: ["preventFocus", "preventFocus", booleanAttribute], readonly: ["readonly", "readonly", booleanAttribute], selectionFollowsMonth: ["selectionFollowsMonth", "selectionFollowsMonth", booleanAttribute], showHeader: ["showHeader", "showHeader", booleanAttribute], showOtherMonths: ["showOtherMonths", "showOtherMonths", booleanAttribute], showToday: ["showToday", "showToday", booleanAttribute], todayButton: ["todayButton", "todayButton", booleanAttribute], todayCallback: "todayCallback", tooltipBuilder: "tooltipBuilder", value: "value", view: "view", weekendDays: "weekendDays", year: ["year", "year", numberAttribute], yearRange: "yearRange" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: CalendarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-calendar',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { allowSingleDateRange: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], clearButton: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], clearCallback: [{
                type: Input
            }], constrainToEnabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], dateBuilder: [{
                type: Input
            }], dateSelectCallback: [{
                type: Input
            }], dayBuilder: [{
                type: Input
            }], disabledDateBuilder: [{
                type: Input
            }], disabledDates: [{
                type: Input
            }], disabledDaysOfWeek: [{
                type: Input
            }], eventBuilder: [{
                type: Input
            }], events: [{
                type: Input
            }], firstDayOfWeek: [{
                type: Input
            }], fixedHeight: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], listYears: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], locale: [{
                type: Input
            }], max: [{
                type: Input
            }], menuAnimation: [{
                type: Input
            }], min: [{
                type: Input
            }], mode: [{
                type: Input
            }], month: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], preventFocus: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], readonly: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], selectionFollowsMonth: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], showHeader: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], showOtherMonths: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], showToday: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], todayButton: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], todayCallback: [{
                type: Input
            }], tooltipBuilder: [{
                type: Input
            }], value: [{
                type: Input
            }], view: [{
                type: Input
            }], weekendDays: [{
                type: Input
            }], year: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], yearRange: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeCalendarModule {
    constructor() {
        defineCalendarComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeCalendarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeCalendarModule, declarations: [CalendarComponent], imports: [CommonModule], exports: [CalendarComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeCalendarModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeCalendarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [CalendarComponent],
                    exports: [CalendarComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class CardComponent {
    /** Whether the card has elevation or not. */
    set raised(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.raised = value;
        });
    }
    get raised() {
        return this.nativeElement.raised;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-card element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineCardComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: CardComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: CardComponent, selector: "forge-card", inputs: { raised: ["raised", "raised", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: CardComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-card',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { raised: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeCardModule {
    constructor() {
        defineCardComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeCardModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeCardModule, declarations: [CardComponent], imports: [CommonModule], exports: [CardComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeCardModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeCardModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [CardComponent],
                    exports: [CardComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class CheckboxComponent {
    /** Gets/sets whether the checkbox is checked. */
    set checked(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.checked = value;
        });
    }
    get checked() {
        return this.nativeElement.checked;
    }
    /** Gets/sets whether the checkbox is checked by default. */
    set defaultChecked(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.defaultChecked = value;
        });
    }
    get defaultChecked() {
        return this.nativeElement.defaultChecked;
    }
    /** Gets/sets the indeterminate state. */
    set indeterminate(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.indeterminate = value;
        });
    }
    get indeterminate() {
        return this.nativeElement.indeterminate;
    }
    /** Controls the value submitted with a form when checked. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Controls whether the checkbox is dense. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** Controls whether the checkbox is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Controls whether the checkbox is required. */
    set required(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.required = value;
        });
    }
    get required() {
        return this.nativeElement.required;
    }
    /** Controls whether the checkbox is readonly. */
    set readonly(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.readonly = value;
        });
    }
    get readonly() {
        return this.nativeElement.readonly;
    }
    /** Controls whether the label appears before or after the checkbox. */
    set labelPosition(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.labelPosition = value;
        });
    }
    get labelPosition() {
        return this.nativeElement.labelPosition;
    }
    /** Toggles the checkbox checked or unchecked. */
    toggle(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.toggle(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-checkbox element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineCheckboxComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: CheckboxComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: CheckboxComponent, selector: "forge-checkbox", inputs: { checked: ["checked", "checked", booleanAttribute], defaultChecked: ["defaultChecked", "defaultChecked", booleanAttribute], indeterminate: ["indeterminate", "indeterminate", booleanAttribute], value: "value", dense: ["dense", "dense", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], required: ["required", "required", booleanAttribute], readonly: ["readonly", "readonly", booleanAttribute], labelPosition: "labelPosition" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: CheckboxComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-checkbox',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { checked: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], defaultChecked: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], indeterminate: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], value: [{
                type: Input
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], required: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], readonly: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], labelPosition: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeCheckboxProxyModule {
    constructor() {
        defineCheckboxComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeCheckboxProxyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeCheckboxProxyModule, declarations: [CheckboxComponent], imports: [CommonModule], exports: [CheckboxComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeCheckboxProxyModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeCheckboxProxyModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [CheckboxComponent],
                    exports: [CheckboxComponent]
                }]
        }], ctorParameters: () => [] });

const CHECKBOX_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => CheckboxValueAccessor),
    multi: true
};
class CheckboxValueAccessor {
    switchChange(evt) {
        this.change(evt.target.checked);
    }
    blur() {
        this.onTouched();
    }
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    writeValue(value) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'checked', !!value);
    }
    registerOnChange(fn) {
        this.onChange = value => fn(value);
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(value) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', value);
    }
    change(value) {
        this.onChange(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: CheckboxValueAccessor, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.7", type: CheckboxValueAccessor, selector: "forge-checkbox[formControlName],forge-checkbox[formControl],forge-checkbox[ngModel]", host: { listeners: { "change": "switchChange($event)", "blur": "blur()" } }, providers: [CHECKBOX_VALUE_ACCESSOR], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: CheckboxValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'forge-checkbox[formControlName],forge-checkbox[formControl],forge-checkbox[ngModel]',
                    providers: [CHECKBOX_VALUE_ACCESSOR]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { switchChange: [{
                type: HostListener,
                args: ['change', ['$event']]
            }], blur: [{
                type: HostListener,
                args: ['blur']
            }] } });

class ForgeCheckboxModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeCheckboxModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeCheckboxModule, declarations: [CheckboxValueAccessor], exports: [CheckboxValueAccessor,
            ForgeCheckboxProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeCheckboxModule, imports: [ForgeCheckboxProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeCheckboxModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        CheckboxValueAccessor
                    ],
                    exports: [
                        CheckboxValueAccessor,
                        ForgeCheckboxProxyModule
                    ]
                }]
        }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ChipComponent {
    /** The type of chip. */
    set type(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.type = value;
        });
    }
    get type() {
        return this.nativeElement.type;
    }
    /** The value of the chip. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Whether the chip is selected. */
    set selected(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selected = value;
        });
    }
    get selected() {
        return this.nativeElement.selected;
    }
    /** Whether the chip is invalid. */
    set invalid(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.invalid = value;
        });
    }
    get invalid() {
        return this.nativeElement.invalid;
    }
    /** Whether the chip is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Whether the chip is dense. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** The theme of the chip. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    /** The href of the chip. */
    set href(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.href = value;
        });
    }
    get href() {
        return this.nativeElement.href;
    }
    /** The target of the chip. */
    set target(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.target = value;
        });
    }
    get target() {
        return this.nativeElement.target;
    }
    /** The download of the chip. */
    set download(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.download = value;
        });
    }
    get download() {
        return this.nativeElement.download;
    }
    /** The rel of the chip. */
    set rel(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.rel = value;
        });
    }
    get rel() {
        return this.nativeElement.rel;
    }
    focus(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.focus(...args));
    }
    focusRemoveButton(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.focusRemoveButton(...args));
    }
    click(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.click(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-chip element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineChipComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ChipComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ChipComponent, selector: "forge-chip", inputs: { type: "type", value: "value", selected: ["selected", "selected", booleanAttribute], invalid: ["invalid", "invalid", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], dense: ["dense", "dense", booleanAttribute], theme: "theme", href: "href", target: "target", download: "download", rel: "rel" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ChipComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-chip',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { type: [{
                type: Input
            }], value: [{
                type: Input
            }], selected: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], invalid: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], theme: [{
                type: Input
            }], href: [{
                type: Input
            }], target: [{
                type: Input
            }], download: [{
                type: Input
            }], rel: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeChipProxyModule {
    constructor() {
        defineChipComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeChipProxyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeChipProxyModule, declarations: [ChipComponent], imports: [CommonModule], exports: [ChipComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeChipProxyModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeChipProxyModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [ChipComponent],
                    exports: [ChipComponent]
                }]
        }], ctorParameters: () => [] });

const CHIP_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => ChipValueAccessor),
    multi: true
};
class ChipValueAccessor {
    chipSelect(event) {
        this.change(event.detail.value);
    }
    blur() {
        this.onTouched();
    }
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    writeValue(value) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'selected', this._elementRef.nativeElement.value === value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    change(value) {
        this.onChange(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ChipValueAccessor, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.7", type: ChipValueAccessor, selector: "forge-chip[value][formControlName],forge-chip[value][formControl],forge-chip[value][ngModel]", host: { listeners: { "forge-chip-select": "chipSelect($event)", "blur": "blur()" } }, providers: [CHIP_VALUE_ACCESSOR], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ChipValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'forge-chip[value][formControlName],forge-chip[value][formControl],forge-chip[value][ngModel]',
                    providers: [CHIP_VALUE_ACCESSOR]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { chipSelect: [{
                type: HostListener,
                args: ['forge-chip-select', ['$event']]
            }], blur: [{
                type: HostListener,
                args: ['blur']
            }] } });

class ForgeChipModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeChipModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeChipModule, declarations: [ChipValueAccessor], exports: [ChipValueAccessor,
            ForgeChipProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeChipModule, imports: [ForgeChipProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeChipModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        ChipValueAccessor
                    ],
                    exports: [
                        ChipValueAccessor,
                        ForgeChipProxyModule
                    ]
                }]
        }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ChipFieldComponent {
    /** Whether or not to add chip when blur event */
    set addOnBlur(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.addOnBlur = value;
        });
    }
    get addOnBlur() {
        return this.nativeElement.addOnBlur;
    }
    /** The target element for the popover. */
    get popoverTargetElement() {
        return this.nativeElement.popoverTargetElement;
    }
    /** The position of the label relative to the field. */
    set labelPosition(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.labelPosition = value;
        });
    }
    get labelPosition() {
        return this.nativeElement.labelPosition;
    }
    /** The alignment of the label relative to the field. */
    set labelAlignment(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.labelAlignment = value;
        });
    }
    get labelAlignment() {
        return this.nativeElement.labelAlignment;
    }
    /** Whether the field is in an invalid state. */
    set invalid(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.invalid = value;
        });
    }
    get invalid() {
        return this.nativeElement.invalid;
    }
    /** Whether the field is required. */
    set required(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.required = value;
        });
    }
    get required() {
        return this.nativeElement.required;
    }
    /** Whether the field is optional. */
    set optional(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.optional = value;
        });
    }
    get optional() {
        return this.nativeElement.optional;
    }
    /** Whether the field is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Whether the label should float above the field. Only applies when the label is inset. */
    set floatLabel(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.floatLabel = value;
        });
    }
    get floatLabel() {
        return this.nativeElement.floatLabel;
    }
    /** The variant of the field. */
    set variant(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.variant = value;
        });
    }
    get variant() {
        return this.nativeElement.variant;
    }
    /** The theme of the field. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    /** The shape of the field. */
    set shape(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.shape = value;
        });
    }
    get shape() {
        return this.nativeElement.shape;
    }
    /** The density of the field. */
    set density(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.density = value;
        });
    }
    get density() {
        return this.nativeElement.density;
    }
    /** Whether the field is dense. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** Whether the field has a popover icon. */
    set popoverIcon(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popoverIcon = value;
        });
    }
    get popoverIcon() {
        return this.nativeElement.popoverIcon;
    }
    /** Whether the field's popover is expanded. */
    set popoverExpanded(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popoverExpanded = value;
        });
    }
    get popoverExpanded() {
        return this.nativeElement.popoverExpanded;
    }
    /** The inset of the support text. */
    set supportTextInset(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.supportTextInset = value;
        });
    }
    get supportTextInset() {
        return this.nativeElement.supportTextInset;
    }
    click(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.click(...args));
    }
    /** Floats the label immediately. Only applies when the label is inset. */
    floatLabelWithoutAnimation(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.floatLabelWithoutAnimation(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-chip-field element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineChipFieldComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ChipFieldComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ChipFieldComponent, selector: "forge-chip-field", inputs: { addOnBlur: ["addOnBlur", "addOnBlur", booleanAttribute], labelPosition: "labelPosition", labelAlignment: "labelAlignment", invalid: ["invalid", "invalid", booleanAttribute], required: ["required", "required", booleanAttribute], optional: ["optional", "optional", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], floatLabel: ["floatLabel", "floatLabel", booleanAttribute], variant: "variant", theme: "theme", shape: "shape", density: "density", dense: ["dense", "dense", booleanAttribute], popoverIcon: ["popoverIcon", "popoverIcon", booleanAttribute], popoverExpanded: ["popoverExpanded", "popoverExpanded", booleanAttribute], supportTextInset: "supportTextInset" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ChipFieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-chip-field',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { addOnBlur: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], labelPosition: [{
                type: Input
            }], labelAlignment: [{
                type: Input
            }], invalid: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], required: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], optional: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], floatLabel: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], variant: [{
                type: Input
            }], theme: [{
                type: Input
            }], shape: [{
                type: Input
            }], density: [{
                type: Input
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], popoverIcon: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], popoverExpanded: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], supportTextInset: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeChipFieldModule {
    constructor() {
        defineChipFieldComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeChipFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeChipFieldModule, declarations: [ChipFieldComponent], imports: [CommonModule, ForgeChipProxyModule], exports: [ChipFieldComponent, ForgeChipProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeChipFieldModule, imports: [CommonModule, ForgeChipProxyModule, ForgeChipProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeChipFieldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ForgeChipProxyModule],
                    declarations: [ChipFieldComponent],
                    exports: [ChipFieldComponent, ForgeChipProxyModule]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ChipSetComponent {
    /** Whether the chip set is vertical. */
    set vertical(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.vertical = value;
        });
    }
    get vertical() {
        return this.nativeElement.vertical;
    }
    /** The type of chip. */
    set type(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.type = value;
        });
    }
    get type() {
        return this.nativeElement.type;
    }
    /** Whether the chip set is dense. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** Whether the chip set is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Whether the chip set is invalid. */
    set invalid(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.invalid = value;
        });
    }
    get invalid() {
        return this.nativeElement.invalid;
    }
    /** The theme of the chip set. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-chip-set element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineChipSetComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ChipSetComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ChipSetComponent, selector: "forge-chip-set", inputs: { vertical: ["vertical", "vertical", booleanAttribute], type: "type", dense: ["dense", "dense", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], invalid: ["invalid", "invalid", booleanAttribute], theme: "theme" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ChipSetComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-chip-set',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { vertical: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], type: [{
                type: Input
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], invalid: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], theme: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeChipSetModule {
    constructor() {
        defineChipSetComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeChipSetModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeChipSetModule, declarations: [ChipSetComponent], imports: [CommonModule, ForgeChipProxyModule], exports: [ChipSetComponent, ForgeChipProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeChipSetModule, imports: [CommonModule, ForgeChipProxyModule, ForgeChipProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeChipSetModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ForgeChipProxyModule],
                    declarations: [ChipSetComponent],
                    exports: [ChipSetComponent, ForgeChipProxyModule]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class CircularProgressComponent {
    /** Controls the determinate state. */
    set determinate(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.determinate = value;
        });
    }
    get determinate() {
        return this.nativeElement.determinate;
    }
    /** Controls the progress while in a determinate state. Accepts values from `0` to `1`. */
    set progress(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.progress = value;
        });
    }
    get progress() {
        return this.nativeElement.progress;
    }
    /** Controls the theme of the progress indicator. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    /** Controls the visibility of the track background. */
    set track(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.track = value;
        });
    }
    get track() {
        return this.nativeElement.track;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-circular-progress element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineCircularProgressComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: CircularProgressComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: CircularProgressComponent, selector: "forge-circular-progress", inputs: { determinate: ["determinate", "determinate", booleanAttribute], progress: ["progress", "progress", numberAttribute], theme: "theme", track: ["track", "track", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: CircularProgressComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-circular-progress',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { determinate: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], progress: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], theme: [{
                type: Input
            }], track: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeCircularProgressModule {
    constructor() {
        defineCircularProgressComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeCircularProgressModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeCircularProgressModule, declarations: [CircularProgressComponent], imports: [CommonModule], exports: [CircularProgressComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeCircularProgressModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeCircularProgressModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [CircularProgressComponent],
                    exports: [CircularProgressComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ColorPickerComponent {
    /** Gets/sets the value using hex format only. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Gets/sets the value using rgba format. */
    set rgba(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.rgba = value;
        });
    }
    get rgba() {
        return this.nativeElement.rgba;
    }
    /** Gets/sets the value using hsva format. */
    set hsva(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.hsva = value;
        });
    }
    get hsva() {
        return this.nativeElement.hsva;
    }
    /** Gets/sets the opacity value, if `allowOpacity` is true. */
    set opacity(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.opacity = value;
        });
    }
    get opacity() {
        return this.nativeElement.opacity;
    }
    /** Gets/sets whether opacity is displayed and allowed be to changed. */
    set allowOpacity(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.allowOpacity = value;
        });
    }
    get allowOpacity() {
        return this.nativeElement.allowOpacity;
    }
    /** Gets/sets whether change event has a debounce applied to avoid successive updates. */
    set debounceChangeEvent(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.debounceChangeEvent = value;
        });
    }
    get debounceChangeEvent() {
        return this.nativeElement.debounceChangeEvent;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-color-picker element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineColorPickerComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ColorPickerComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ColorPickerComponent, selector: "forge-color-picker", inputs: { value: "value", rgba: "rgba", hsva: "hsva", opacity: "opacity", allowOpacity: ["allowOpacity", "allowOpacity", booleanAttribute], debounceChangeEvent: ["debounceChangeEvent", "debounceChangeEvent", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ColorPickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-color-picker',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { value: [{
                type: Input
            }], rgba: [{
                type: Input
            }], hsva: [{
                type: Input
            }], opacity: [{
                type: Input
            }], allowOpacity: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], debounceChangeEvent: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeColorPickerModule {
    constructor() {
        defineColorPickerComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeColorPickerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeColorPickerModule, declarations: [ColorPickerComponent], imports: [CommonModule], exports: [ColorPickerComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeColorPickerModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeColorPickerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [ColorPickerComponent],
                    exports: [ColorPickerComponent]
                }]
        }], ctorParameters: () => [] });

class DynamicComponentService {
    constructor(_cfr, _injector, _appRef) {
        this._cfr = _cfr;
        this._injector = _injector;
        this._appRef = _appRef;
    }
    /**
     * Creates an Angular component dynamically, and optionally attaches the component instance to a given element.
     * @param component The component to create.
     * @param target Optional target element to attach the component element to.
     * @param moduleRef Optional module to create the component factory from.
     */
    create(component, target, injector, moduleRef) {
        const cfr = moduleRef ? moduleRef.componentFactoryResolver : this._cfr;
        const componentFactory = this._isComponentFactory(component) ? component : cfr.resolveComponentFactory(component);
        injector = injector || this._injector;
        if (target instanceof ViewContainerRef) {
            const ref = target.createComponent(componentFactory, undefined, injector);
            return {
                instance: ref.instance,
                componentRef: ref,
                destroy: () => {
                    target.detach();
                    componentRef.destroy();
                }
            };
        }
        const componentRef = componentFactory.create(injector);
        this._appRef.attachView(componentRef.hostView);
        const componentElement = componentRef.hostView.rootNodes[0];
        if (target) {
            target.appendChild(componentElement);
        }
        return {
            instance: componentRef.instance,
            componentRef,
            componentElement,
            destroy: () => {
                this._appRef.detachView(componentRef.hostView);
                componentRef.destroy();
            }
        };
    }
    _isComponentFactory(component) {
        return component.create !== undefined;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DynamicComponentService, deps: [{ token: i0.ComponentFactoryResolver }, { token: i0.Injector }, { token: i0.ApplicationRef }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DynamicComponentService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DynamicComponentService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: i0.ComponentFactoryResolver }, { type: i0.Injector }, { type: i0.ApplicationRef }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class DatePickerComponent {
    /** The value of the date picker. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** The minimum date the calendar will allow. */
    set min(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.min = value;
        });
    }
    get min() {
        return this.nativeElement.min;
    }
    /** The maximum date the calendar will allow. */
    set max(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.max = value;
        });
    }
    get max() {
        return this.nativeElement.max;
    }
    /** The dates that are restricted from being selected. */
    set disabledDates(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabledDates = value;
        });
    }
    get disabledDates() {
        return this.nativeElement.disabledDates;
    }
    /** Whether the calendar dropdown is open. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** The CSS classes that are applied to the popup element. */
    set popupClasses(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popupClasses = value;
        });
    }
    get popupClasses() {
        return this.nativeElement.popupClasses;
    }
    /** Whether the date picker is disabled or not. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Whether the input mask is applied or not. */
    set masked(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.masked = value;
        });
    }
    get masked() {
        return this.nativeElement.masked;
    }
    /** The mask format that displayed in the input. Default is `MM/DD/YYYY`. */
    set maskFormat(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.maskFormat = value;
        });
    }
    get maskFormat() {
        return this.nativeElement.maskFormat;
    }
    /** Whether the mask format is displayed in the input or not. Only applies if `masked` is `true`. */
    set showMaskFormat(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.showMaskFormat = value;
        });
    }
    get showMaskFormat() {
        return this.nativeElement.showMaskFormat;
    }
    /** The type for the `value` property and `forge-date-picker-change` event. */
    set valueMode(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.valueMode = value;
        });
    }
    get valueMode() {
        return this.nativeElement.valueMode;
    }
    /** Whether the native input will be notified of value changes via the `input` and `change` events. */
    set notifyInputValueChanges(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.notifyInputValueChanges = value;
        });
    }
    get notifyInputValueChanges() {
        return this.nativeElement.notifyInputValueChanges;
    }
    /** Whether to allow an invalid date to be input. When true, the date picker will not clear out the value of the input if the date was invalid (i.e. could not be parsed). */
    set allowInvalidDate(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.allowInvalidDate = value;
        });
    }
    get allowInvalidDate() {
        return this.nativeElement.allowInvalidDate;
    }
    /** Whether the today button is visible in the popup. */
    set showToday(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.showToday = value;
        });
    }
    get showToday() {
        return this.nativeElement.showToday;
    }
    /** Whether the clear button is visible in the popup. */
    set showClear(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.showClear = value;
        });
    }
    get showClear() {
        return this.nativeElement.showClear;
    }
    /** The callback to use for parsing a date value string to a `Date` object. */
    set parseCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.parseCallback = value;
        });
    }
    get parseCallback() {
        return this.nativeElement.parseCallback;
    }
    /** The callback to use for formatting `Date` value to a custom string format. */
    set formatCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.formatCallback = value;
        });
    }
    get formatCallback() {
        return this.nativeElement.formatCallback;
    }
    /** The callback to use when altering default mask entry. */
    set prepareMaskCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.prepareMaskCallback = value;
        });
    }
    get prepareMaskCallback() {
        return this.nativeElement.prepareMaskCallback;
    }
    /** The days of the week to disable from selection. */
    set disabledDaysOfWeek(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabledDaysOfWeek = value;
        });
    }
    get disabledDaysOfWeek() {
        return this.nativeElement.disabledDaysOfWeek;
    }
    /** The callback to use for testing whether a specific date should be disabled or not. */
    set disableDayCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disableDayCallback = value;
        });
    }
    get disableDayCallback() {
        return this.nativeElement.disableDayCallback;
    }
    /** The year range. */
    set yearRange(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.yearRange = value;
        });
    }
    get yearRange() {
        return this.nativeElement.yearRange;
    }
    /** The locale to use. */
    set locale(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.locale = value;
        });
    }
    get locale() {
        return this.nativeElement.locale;
    }
    /** Customized strings to display in the calendar dropdown UI. */
    set calendarText(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.calendarText = value;
        });
    }
    get calendarText() {
        return this.nativeElement.calendarText;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-date-picker element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineDatePickerComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DatePickerComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: DatePickerComponent, selector: "forge-date-picker", inputs: { value: "value", min: "min", max: "max", disabledDates: "disabledDates", open: ["open", "open", booleanAttribute], popupClasses: "popupClasses", disabled: ["disabled", "disabled", booleanAttribute], masked: ["masked", "masked", booleanAttribute], maskFormat: "maskFormat", showMaskFormat: ["showMaskFormat", "showMaskFormat", booleanAttribute], valueMode: "valueMode", notifyInputValueChanges: ["notifyInputValueChanges", "notifyInputValueChanges", booleanAttribute], allowInvalidDate: ["allowInvalidDate", "allowInvalidDate", booleanAttribute], showToday: ["showToday", "showToday", booleanAttribute], showClear: ["showClear", "showClear", booleanAttribute], parseCallback: "parseCallback", formatCallback: "formatCallback", prepareMaskCallback: "prepareMaskCallback", disabledDaysOfWeek: "disabledDaysOfWeek", disableDayCallback: "disableDayCallback", yearRange: "yearRange", locale: "locale", calendarText: "calendarText" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DatePickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-date-picker',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { value: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], disabledDates: [{
                type: Input
            }], open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], popupClasses: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], masked: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], maskFormat: [{
                type: Input
            }], showMaskFormat: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], valueMode: [{
                type: Input
            }], notifyInputValueChanges: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], allowInvalidDate: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], showToday: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], showClear: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], parseCallback: [{
                type: Input
            }], formatCallback: [{
                type: Input
            }], prepareMaskCallback: [{
                type: Input
            }], disabledDaysOfWeek: [{
                type: Input
            }], disableDayCallback: [{
                type: Input
            }], yearRange: [{
                type: Input
            }], locale: [{
                type: Input
            }], calendarText: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeDatePickerProxyModule {
    constructor() {
        defineDatePickerComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDatePickerProxyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeDatePickerProxyModule, declarations: [DatePickerComponent], imports: [CommonModule], exports: [DatePickerComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDatePickerProxyModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDatePickerProxyModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [DatePickerComponent],
                    exports: [DatePickerComponent]
                }]
        }], ctorParameters: () => [] });

const DATEPICKER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => DatePickerValueAccessor),
    multi: true
};
class DatePickerValueAccessor {
    datePickerChange(event) {
        this.change(event.detail);
    }
    blur() {
        this.onTouched();
    }
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    writeValue(value) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    change(value) {
        this.onChange(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DatePickerValueAccessor, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.7", type: DatePickerValueAccessor, selector: "forge-date-picker[formControlName],forge-date-picker[formControl],forge-date-picker[ngModel]", host: { listeners: { "forge-date-picker-change": "datePickerChange($event)", "focusout": "blur()" } }, providers: [DATEPICKER_VALUE_ACCESSOR], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DatePickerValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'forge-date-picker[formControlName],forge-date-picker[formControl],forge-date-picker[ngModel]',
                    providers: [DATEPICKER_VALUE_ACCESSOR]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { datePickerChange: [{
                type: HostListener,
                args: ['forge-date-picker-change', ['$event']]
            }], blur: [{
                type: HostListener,
                args: ['focusout']
            }] } });

class ForgeDatePickerModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDatePickerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeDatePickerModule, declarations: [DatePickerValueAccessor], exports: [DatePickerValueAccessor,
            ForgeDatePickerProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDatePickerModule, imports: [ForgeDatePickerProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDatePickerModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        DatePickerValueAccessor
                    ],
                    exports: [
                        DatePickerValueAccessor,
                        ForgeDatePickerProxyModule
                    ]
                }]
        }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class DateRangePickerComponent {
    /** Gets/sets the "from" date range value. */
    set from(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.from = value;
        });
    }
    get from() {
        return this.nativeElement.from;
    }
    /** Gets/sets the "to" date range value. */
    set to(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.to = value;
        });
    }
    get to() {
        return this.nativeElement.to;
    }
    /** Gets/sets the date range value. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Gets/sets the minimum date range value. */
    set min(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.min = value;
        });
    }
    get min() {
        return this.nativeElement.min;
    }
    /** Gets/sets the maximum date range value. */
    set max(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.max = value;
        });
    }
    get max() {
        return this.nativeElement.max;
    }
    /** Gets/sets the disabled date range values. */
    set disabledDates(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabledDates = value;
        });
    }
    get disabledDates() {
        return this.nativeElement.disabledDates;
    }
    /** Gets/sets the open state of the date range picker. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** Gets/sets the callback used to parse date strings. */
    set parseCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.parseCallback = value;
        });
    }
    get parseCallback() {
        return this.nativeElement.parseCallback;
    }
    /** Gets/sets the callback used to format date strings. */
    set formatCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.formatCallback = value;
        });
    }
    get formatCallback() {
        return this.nativeElement.formatCallback;
    }
    /** Gets/sets the callback used to prepare the mask for the date input. */
    set prepareMaskCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.prepareMaskCallback = value;
        });
    }
    get prepareMaskCallback() {
        return this.nativeElement.prepareMaskCallback;
    }
    /** Gets/sets the callback used to disable days in the calendar. */
    set disableDayCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disableDayCallback = value;
        });
    }
    get disableDayCallback() {
        return this.nativeElement.disableDayCallback;
    }
    /** Gets/sets the classes to apply to the date range picker popup. */
    set popupClasses(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popupClasses = value;
        });
    }
    get popupClasses() {
        return this.nativeElement.popupClasses;
    }
    /** Gets/sets the disabled state of the date range picker. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Gets/sets the masked state of the date range picker. */
    set masked(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.masked = value;
        });
    }
    get masked() {
        return this.nativeElement.masked;
    }
    /** Gets/sets the mask format for the date input. */
    set maskFormat(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.maskFormat = value;
        });
    }
    get maskFormat() {
        return this.nativeElement.maskFormat;
    }
    /** Gets/sets the state of whether to show the mask format in the date input. */
    set showMaskFormat(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.showMaskFormat = value;
        });
    }
    get showMaskFormat() {
        return this.nativeElement.showMaskFormat;
    }
    /** Gets/sets the value mode of the date range picker. */
    set valueMode(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.valueMode = value;
        });
    }
    get valueMode() {
        return this.nativeElement.valueMode;
    }
    /** Gets/sets the state of whether to notify input value changes. */
    set notifyInputValueChanges(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.notifyInputValueChanges = value;
        });
    }
    get notifyInputValueChanges() {
        return this.nativeElement.notifyInputValueChanges;
    }
    /** Gets/sets the state of whether to allow invalid dates. */
    set allowInvalidDate(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.allowInvalidDate = value;
        });
    }
    get allowInvalidDate() {
        return this.nativeElement.allowInvalidDate;
    }
    /** Gets/sets the state of whether to show the "Today" button. */
    set showToday(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.showToday = value;
        });
    }
    get showToday() {
        return this.nativeElement.showToday;
    }
    /** Gets/sets the state of whether to show the "Clear" button. */
    set showClear(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.showClear = value;
        });
    }
    get showClear() {
        return this.nativeElement.showClear;
    }
    /** Gets/sets the disabled days of the week. */
    set disabledDaysOfWeek(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabledDaysOfWeek = value;
        });
    }
    get disabledDaysOfWeek() {
        return this.nativeElement.disabledDaysOfWeek;
    }
    /** Gets/sets the year range for the date range picker. */
    set yearRange(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.yearRange = value;
        });
    }
    get yearRange() {
        return this.nativeElement.yearRange;
    }
    /** Gets/sets the locale for the date range picker. */
    set locale(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.locale = value;
        });
    }
    get locale() {
        return this.nativeElement.locale;
    }
    /** Customized strings to display in the calendar dropdown UI. */
    set calendarText(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.calendarText = value;
        });
    }
    get calendarText() {
        return this.nativeElement.calendarText;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-date-range-picker element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineDateRangePickerComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DateRangePickerComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: DateRangePickerComponent, selector: "forge-date-range-picker", inputs: { from: "from", to: "to", value: "value", min: "min", max: "max", disabledDates: "disabledDates", open: ["open", "open", booleanAttribute], parseCallback: "parseCallback", formatCallback: "formatCallback", prepareMaskCallback: "prepareMaskCallback", disableDayCallback: "disableDayCallback", popupClasses: "popupClasses", disabled: ["disabled", "disabled", booleanAttribute], masked: ["masked", "masked", booleanAttribute], maskFormat: "maskFormat", showMaskFormat: ["showMaskFormat", "showMaskFormat", booleanAttribute], valueMode: "valueMode", notifyInputValueChanges: ["notifyInputValueChanges", "notifyInputValueChanges", booleanAttribute], allowInvalidDate: ["allowInvalidDate", "allowInvalidDate", booleanAttribute], showToday: ["showToday", "showToday", booleanAttribute], showClear: ["showClear", "showClear", booleanAttribute], disabledDaysOfWeek: "disabledDaysOfWeek", yearRange: "yearRange", locale: "locale", calendarText: "calendarText" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DateRangePickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-date-range-picker',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { from: [{
                type: Input
            }], to: [{
                type: Input
            }], value: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], disabledDates: [{
                type: Input
            }], open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], parseCallback: [{
                type: Input
            }], formatCallback: [{
                type: Input
            }], prepareMaskCallback: [{
                type: Input
            }], disableDayCallback: [{
                type: Input
            }], popupClasses: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], masked: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], maskFormat: [{
                type: Input
            }], showMaskFormat: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], valueMode: [{
                type: Input
            }], notifyInputValueChanges: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], allowInvalidDate: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], showToday: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], showClear: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabledDaysOfWeek: [{
                type: Input
            }], yearRange: [{
                type: Input
            }], locale: [{
                type: Input
            }], calendarText: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeDateRangePickerProxyModule {
    constructor() {
        defineDateRangePickerComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDateRangePickerProxyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeDateRangePickerProxyModule, declarations: [DateRangePickerComponent], imports: [CommonModule], exports: [DateRangePickerComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDateRangePickerProxyModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDateRangePickerProxyModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [DateRangePickerComponent],
                    exports: [DateRangePickerComponent]
                }]
        }], ctorParameters: () => [] });

const DATE_RANGE_PICKER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => DateRangePickerValueAccessor),
    multi: true
};
class DateRangePickerValueAccessor {
    dateRangePickerChange(event) {
        this.change(event.detail);
    }
    blur() {
        this.onTouched();
    }
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    writeValue(value) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    change(value) {
        this.onChange(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DateRangePickerValueAccessor, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.7", type: DateRangePickerValueAccessor, selector: "forge-date-range-picker[formControlName],forge-date-range-picker[formControl],forge-date-range-picker[ngModel]", host: { listeners: { "forge-date-range-picker-change": "dateRangePickerChange($event)", "focusout": "blur()" } }, providers: [DATE_RANGE_PICKER_VALUE_ACCESSOR], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DateRangePickerValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'forge-date-range-picker[formControlName],forge-date-range-picker[formControl],forge-date-range-picker[ngModel]',
                    providers: [DATE_RANGE_PICKER_VALUE_ACCESSOR]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { dateRangePickerChange: [{
                type: HostListener,
                args: ['forge-date-range-picker-change', ['$event']]
            }], blur: [{
                type: HostListener,
                args: ['focusout']
            }] } });

class ForgeDateRangePickerModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDateRangePickerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeDateRangePickerModule, declarations: [DateRangePickerValueAccessor], exports: [DateRangePickerValueAccessor,
            ForgeDateRangePickerProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDateRangePickerModule, imports: [ForgeDateRangePickerProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDateRangePickerModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        DateRangePickerValueAccessor
                    ],
                    exports: [
                        DateRangePickerValueAccessor,
                        ForgeDateRangePickerProxyModule
                    ]
                }]
        }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class DeprecatedButtonComponent {
    set type(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.type = value;
        });
    }
    get type() {
        return this.nativeElement.type;
    }
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    set fullWidth(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.fullWidth = value;
        });
    }
    get fullWidth() {
        return this.nativeElement.fullWidth;
    }
    focus(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.focus(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-deprecated-button element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineDeprecatedButtonComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DeprecatedButtonComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: DeprecatedButtonComponent, selector: "forge-deprecated-button", inputs: { type: "type", disabled: ["disabled", "disabled", booleanAttribute], fullWidth: ["fullWidth", "fullWidth", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DeprecatedButtonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-deprecated-button',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { type: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], fullWidth: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeDeprecatedButtonModule {
    constructor() {
        defineDeprecatedButtonComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDeprecatedButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeDeprecatedButtonModule, declarations: [DeprecatedButtonComponent], imports: [CommonModule], exports: [DeprecatedButtonComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDeprecatedButtonModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDeprecatedButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [DeprecatedButtonComponent],
                    exports: [DeprecatedButtonComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class DeprecatedIconButtonComponent {
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    set toggle(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.toggle = value;
        });
    }
    get toggle() {
        return this.nativeElement.toggle;
    }
    set isOn(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.isOn = value;
        });
    }
    get isOn() {
        return this.nativeElement.isOn;
    }
    set densityLevel(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.densityLevel = value;
        });
    }
    get densityLevel() {
        return this.nativeElement.densityLevel;
    }
    focus(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.focus(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-deprecated-icon-button element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineDeprecatedIconButtonComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DeprecatedIconButtonComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: DeprecatedIconButtonComponent, selector: "forge-deprecated-icon-button", inputs: { disabled: ["disabled", "disabled", booleanAttribute], toggle: ["toggle", "toggle", booleanAttribute], isOn: ["isOn", "isOn", booleanAttribute], densityLevel: ["densityLevel", "densityLevel", numberAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DeprecatedIconButtonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-deprecated-icon-button',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], toggle: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], isOn: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], densityLevel: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeDeprecatedIconButtonModule {
    constructor() {
        defineDeprecatedIconButtonComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDeprecatedIconButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeDeprecatedIconButtonModule, declarations: [DeprecatedIconButtonComponent], imports: [CommonModule], exports: [DeprecatedIconButtonComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDeprecatedIconButtonModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDeprecatedIconButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [DeprecatedIconButtonComponent],
                    exports: [DeprecatedIconButtonComponent]
                }]
        }], ctorParameters: () => [] });

class DialogConfig {
}
const DIALOG_DATA = new InjectionToken('DIALOG_DATA');

class DialogInjector extends BaseInjector {
}

class DialogRef {
    constructor(instance) {
        this._afterClosed = new Subject();
        this.afterClosed = this._afterClosed.asObservable();
        this._beforeClose = new Subject();
        this.beforeClose = this._beforeClose.asObservable();
        this._elementRef = new ElementRef(instance);
        instance.addEventListener('forge-dialog-before-close', evt => this._beforeClose.next(evt));
    }
    close(result) {
        this.nativeElement.open = false;
        this._afterClosed.next(result);
        this._afterClosed.complete();
        this._beforeClose.complete();
    }
    get nativeElement() {
        return this._elementRef.nativeElement;
    }
    get isClosed() {
        return this._afterClosed.closed;
    }
}

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class DialogComponent {
    /** Indicates whether the dialog is open. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** The mode of the dialog. */
    set mode(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.mode = value;
        });
    }
    get mode() {
        return this.nativeElement.mode;
    }
    /** The type of the dialog. */
    set type(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.type = value;
        });
    }
    get type() {
        return this.nativeElement.type;
    }
    /** The animation type of the dialog. */
    set animationType(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.animationType = value;
        });
    }
    get animationType() {
        return this.nativeElement.animationType;
    }
    /** The preset design that the dialog will apply. */
    set preset(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.preset = value;
        });
    }
    get preset() {
        return this.nativeElement.preset;
    }
    /** Indicates whether the dialog is dismissible via escape and backdrop click or not. */
    set persistent(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.persistent = value;
        });
    }
    get persistent() {
        return this.nativeElement.persistent;
    }
    /** Indicates whether the dialog is fullscreen or not. */
    set fullscreen(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.fullscreen = value;
        });
    }
    get fullscreen() {
        return this.nativeElement.fullscreen;
    }
    /** The screen width at which the dialog will switch to fullscreen. */
    set fullscreenThreshold(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.fullscreenThreshold = value;
        });
    }
    get fullscreenThreshold() {
        return this.nativeElement.fullscreenThreshold;
    }
    /** The selector of the element that triggers the dialog. */
    set trigger(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.trigger = value;
        });
    }
    get trigger() {
        return this.nativeElement.trigger;
    }
    /** The element that triggers the dialog. */
    set triggerElement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.triggerElement = value;
        });
    }
    get triggerElement() {
        return this.nativeElement.triggerElement;
    }
    /** Indicates whether the dialog is moveable or not. */
    set moveable(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.moveable = value;
        });
    }
    get moveable() {
        return this.nativeElement.moveable;
    }
    /** Controls whether the dialog is rendered relative to the viewport or its nearest containing block. */
    set positionStrategy(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.positionStrategy = value;
        });
    }
    get positionStrategy() {
        return this.nativeElement.positionStrategy;
    }
    /** Controls the block and/or inline size of the dialog. Defaults to the size of the content it contains. */
    set sizeStrategy(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.sizeStrategy = value;
        });
    }
    get sizeStrategy() {
        return this.nativeElement.sizeStrategy;
    }
    /** The placement of the dialog. */
    set placement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.placement = value;
        });
    }
    get placement() {
        return this.nativeElement.placement;
    }
    /** Shows the dialog. */
    show(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.show(...args));
    }
    /** Hides the dialog. */
    hide(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.hide(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-dialog element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineDialogComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DialogComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: DialogComponent, selector: "forge-dialog", inputs: { open: ["open", "open", booleanAttribute], mode: "mode", type: "type", animationType: "animationType", preset: "preset", persistent: ["persistent", "persistent", booleanAttribute], fullscreen: ["fullscreen", "fullscreen", booleanAttribute], fullscreenThreshold: ["fullscreenThreshold", "fullscreenThreshold", numberAttribute], trigger: "trigger", triggerElement: "triggerElement", moveable: ["moveable", "moveable", booleanAttribute], positionStrategy: "positionStrategy", sizeStrategy: "sizeStrategy", placement: "placement" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DialogComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-dialog',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], mode: [{
                type: Input
            }], type: [{
                type: Input
            }], animationType: [{
                type: Input
            }], preset: [{
                type: Input
            }], persistent: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], fullscreen: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], fullscreenThreshold: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], trigger: [{
                type: Input
            }], triggerElement: [{
                type: Input
            }], moveable: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], positionStrategy: [{
                type: Input
            }], sizeStrategy: [{
                type: Input
            }], placement: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeDialogModule {
    constructor() {
        defineDialogComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDialogModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeDialogModule, declarations: [DialogComponent], imports: [CommonModule], exports: [DialogComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDialogModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDialogModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [DialogComponent],
                    exports: [DialogComponent]
                }]
        }], ctorParameters: () => [] });

const MAX_NESTED_DIALOGS = 2;
/**
 * Provides facilities for working with a Forge dialog and placing dynamic components within it.
 */
class DialogService {
    constructor(_appRef, _injector, _ngZone) {
        this._appRef = _appRef;
        this._injector = _injector;
        this._ngZone = _ngZone;
        this._openDialogRefs = [];
        this._destroyRef = inject(DestroyRef);
        defineDialogComponent();
    }
    /**
     * Displays a component within a Forge dialog instance.
     * @deprecated Use `open()` instead.
     * @param component The component reference.
     * @param config The configuration to provide to the dynamic component as an injectable token.
     * @param moduleRef Optional NgModule ref if need by the component.
     * @param envInjector Optional environment injector to provide to the component.
     * @returns A reference for interacting with the created dialog.
     */
    show(component, options, config, moduleRef, envInjector) {
        return this.open(component, { options, config, module: moduleRef, injector: envInjector });
    }
    /**
     * Opens a Forge dialog with the provided component.
     * @param component The component reference.
     * @param configuration The configuration for the dialog.
     * @returns A reference for interacting with the created dialog.
     */
    open(component, configuration = {}) {
        const dialogRef = this._showDialog(component, configuration);
        this._openDialogRefs.push(dialogRef);
        dialogRef.afterClosed.pipe(take(1), takeUntilDestroyed(this._destroyRef)).subscribe(() => this._removeDialogRef(dialogRef));
        return dialogRef;
    }
    _showDialog(component, { config, data, injector, elementInjector, module, options }) {
        // Contains tokens that will be provided to components through our custom dialog injector
        const providers = [];
        // Since config and data can be provided separately, we should create a config with data if only data was provided
        if (!config && data != null) {
            config = { data };
        }
        // If we got a config, we should provide it as an injection token
        if (config) {
            providers.push({ provide: DialogConfig, useValue: config });
        }
        // If we got data, we should also provide it as a injection token on its own
        if (data != null) {
            providers.push({ provide: DIALOG_DATA, useValue: data });
        }
        // Create the Forge dialog element
        const dialogElement = document.createElement('forge-dialog');
        // Configure the dialog with the provided options
        if (options) {
            const { dialogClass, attributes, ...restOptions } = options;
            if (dialogClass) {
                dialogElement.classList.add(dialogClass);
            }
            if (attributes) {
                attributes.forEach((value, key) => dialogElement.setAttribute(key, value));
            }
            Object.assign(dialogElement, restOptions);
        }
        // Create the ref that will allow the consumer to control the dialog
        const dialogRef = new DialogRef(dialogElement);
        // Always provide the dialog ref as an injection token
        providers.push({ provide: DialogRef, useValue: dialogRef });
        // Create and attach the dynamic component to the dialog element
        this._ngZone.run(() => {
            const parentInjector = injector ?? module?.injector ?? this._injector;
            const environmentInjector = createEnvironmentInjector(providers, parentInjector);
            const componentRef = createComponent(component, { environmentInjector, elementInjector });
            dialogRef.componentInstance = componentRef.instance;
            this._appRef.attachView(componentRef.hostView);
            const element = componentRef.hostView.rootNodes[0];
            dialogElement.appendChild(element);
            dialogElement.addEventListener('forge-dialog-close', () => {
                if (!dialogRef.isClosed) {
                    dialogRef.close();
                }
                componentRef.destroy();
                dialogElement.remove();
            });
        });
        dialogElement.open = true;
        document.body.appendChild(dialogElement);
        return dialogRef;
    }
    /**
     * Closes all dialogs.
     * @param result The result of closing the dialogs. Default is false.
     */
    closeAllDialogs(result = false) {
        this._closeAllDialogs(result);
    }
    // While multiple dialogs is an anti-UX pattern, this is a minimal safeguard to protect against dirty dialogs
    _closeAllDialogs(result, recursiveExecutionCount = 0) {
        if (recursiveExecutionCount > MAX_NESTED_DIALOGS) {
            throw new Error('Could not close all dialogs. Reason: Too many nested dialogs.');
        }
        this._openDialogRefs.forEach(ref => ref.close(result));
        // This is here to close any dialogs that open as a result of other dialogs closing
        // e.g. A dirty dialog opening when a dirty form dialog closes.
        if (this._openDialogRefs.length > 0) {
            this._closeAllDialogs(result, ++recursiveExecutionCount);
        }
    }
    _removeDialogRef(ref) {
        const index = this._openDialogRefs.findIndex(dlgRef => ref === dlgRef);
        if (index < 0) {
            return;
        }
        this._openDialogRefs.splice(index, 1);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DialogService, deps: [{ token: i0.ApplicationRef }, { token: i0.EnvironmentInjector }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DialogService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DialogService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: i0.ApplicationRef }, { type: i0.EnvironmentInjector }, { type: i0.NgZone }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class DividerComponent {
    /** Controls if the divider is displayed vertically or horizontally. */
    set vertical(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.vertical = value;
        });
    }
    get vertical() {
        return this.nativeElement.vertical;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-divider element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineDividerComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DividerComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: DividerComponent, selector: "forge-divider", inputs: { vertical: ["vertical", "vertical", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DividerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-divider',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { vertical: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeDividerModule {
    constructor() {
        defineDividerComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDividerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeDividerModule, declarations: [DividerComponent], imports: [CommonModule], exports: [DividerComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDividerModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDividerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [DividerComponent],
                    exports: [DividerComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class DrawerComponent {
    /** Toggles whether the drawer is visible or not. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** Controls the layout and animation direction of the drawer for positioning on the left vs. right side of the screen when toggling the `open` attribute. */
    set direction(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.direction = value;
        });
    }
    get direction() {
        return this.nativeElement.direction;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-drawer element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineDrawerComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DrawerComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: DrawerComponent, selector: "forge-drawer", inputs: { open: ["open", "open", booleanAttribute], direction: "direction" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: DrawerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-drawer',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], direction: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeDrawerModule {
    constructor() {
        defineDrawerComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDrawerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeDrawerModule, declarations: [DrawerComponent], imports: [CommonModule], exports: [DrawerComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDrawerModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeDrawerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [DrawerComponent],
                    exports: [DrawerComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class FloatingActionButtonComponent {
    /** Sets the theme of the button. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    /** Sets the density of the button. */
    set density(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.density = value;
        });
    }
    get density() {
        return this.nativeElement.density;
    }
    /** Sets the elevation of the button. */
    set elevation(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.elevation = value;
        });
    }
    get elevation() {
        return this.nativeElement.elevation;
    }
    get form() {
        return this.nativeElement.form;
    }
    /** The name of the button. */
    set name(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.name = value;
        });
    }
    get name() {
        return this.nativeElement.name;
    }
    /** The value of the button. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Sets the type of the button. Possible values are `button`, `submit`, and `reset`. */
    set type(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.type = value;
        });
    }
    get type() {
        return this.nativeElement.type;
    }
    /** Disables the button. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Shows a popover icon on the button. */
    set popoverIcon(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popoverIcon = value;
        });
    }
    get popoverIcon() {
        return this.nativeElement.popoverIcon;
    }
    /** Sets the density of the button. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** Clicks the button. */
    click(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.click(...args));
    }
    /** Focuses the button. */
    focus(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.focus(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-fab element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineFloatingActionButtonComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: FloatingActionButtonComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: FloatingActionButtonComponent, selector: "forge-fab", inputs: { theme: "theme", density: "density", elevation: "elevation", name: "name", value: "value", type: "type", disabled: ["disabled", "disabled", booleanAttribute], popoverIcon: ["popoverIcon", "popoverIcon", booleanAttribute], dense: ["dense", "dense", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: FloatingActionButtonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-fab',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { theme: [{
                type: Input
            }], density: [{
                type: Input
            }], elevation: [{
                type: Input
            }], name: [{
                type: Input
            }], value: [{
                type: Input
            }], type: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], popoverIcon: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeFloatingActionButtonModule {
    constructor() {
        defineFloatingActionButtonComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeFloatingActionButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeFloatingActionButtonModule, declarations: [FloatingActionButtonComponent], imports: [CommonModule], exports: [FloatingActionButtonComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeFloatingActionButtonModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeFloatingActionButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [FloatingActionButtonComponent],
                    exports: [FloatingActionButtonComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class FieldComponent {
    /** The position of the label relative to the input area. */
    set labelPosition(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.labelPosition = value;
        });
    }
    get labelPosition() {
        return this.nativeElement.labelPosition;
    }
    /** The alignment of the label relative to the input area. */
    set labelAlignment(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.labelAlignment = value;
        });
    }
    get labelAlignment() {
        return this.nativeElement.labelAlignment;
    }
    /** Whether an inset positioned label is floated to the top of the container. */
    set floatLabel(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.floatLabel = value;
        });
    }
    get floatLabel() {
        return this.nativeElement.floatLabel;
    }
    /** Whether the field is in an invalid state. */
    set invalid(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.invalid = value;
        });
    }
    get invalid() {
        return this.nativeElement.invalid;
    }
    /** Whether the field is required. */
    set required(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.required = value;
        });
    }
    get required() {
        return this.nativeElement.required;
    }
    /** Whether the field is optional. */
    set optional(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.optional = value;
        });
    }
    get optional() {
        return this.nativeElement.optional;
    }
    /** Whether the field is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** The variant of the field. */
    set variant(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.variant = value;
        });
    }
    get variant() {
        return this.nativeElement.variant;
    }
    /** The theme of the field. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    /** The border radius of the field's corners. */
    set shape(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.shape = value;
        });
    }
    get shape() {
        return this.nativeElement.shape;
    }
    /** The density of the field. */
    set density(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.density = value;
        });
    }
    get density() {
        return this.nativeElement.density;
    }
    /** Whether the field is at the "extra-small" density level. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** Whether the field has a popover icon. */
    set popoverIcon(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popoverIcon = value;
        });
    }
    get popoverIcon() {
        return this.nativeElement.popoverIcon;
    }
    /** Whether the field's popover icon is in the expanded orientation. */
    set popoverExpanded(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popoverExpanded = value;
        });
    }
    get popoverExpanded() {
        return this.nativeElement.popoverExpanded;
    }
    /** Whether the field contains a multiline input. */
    set multiline(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.multiline = value;
        });
    }
    get multiline() {
        return this.nativeElement.multiline;
    }
    /** Whether the field's support text is inset from either side. */
    set supportTextInset(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.supportTextInset = value;
        });
    }
    get supportTextInset() {
        return this.nativeElement.supportTextInset;
    }
    /** The element to attach the focus indicator to. */
    set focusIndicatorTargetElement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.focusIndicatorTargetElement = value;
        });
    }
    get focusIndicatorTargetElement() {
        return this.nativeElement.focusIndicatorTargetElement;
    }
    /** The focus mode to use on the focus indicator. */
    set focusIndicatorFocusMode(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.focusIndicatorFocusMode = value;
        });
    }
    get focusIndicatorFocusMode() {
        return this.nativeElement.focusIndicatorFocusMode;
    }
    /** Whether the focus indicator should render when the target element matches `:focus` instead of `:focus-visible`. */
    set focusIndicatorAllowFocus(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.focusIndicatorAllowFocus = value;
        });
    }
    get focusIndicatorAllowFocus() {
        return this.nativeElement.focusIndicatorAllowFocus;
    }
    /** Sets the floating label without animating the transition. */
    floatLabelWithoutAnimation(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.floatLabelWithoutAnimation(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-field element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineFieldComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: FieldComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: FieldComponent, selector: "forge-field", inputs: { labelPosition: "labelPosition", labelAlignment: "labelAlignment", floatLabel: ["floatLabel", "floatLabel", booleanAttribute], invalid: ["invalid", "invalid", booleanAttribute], required: ["required", "required", booleanAttribute], optional: ["optional", "optional", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], variant: "variant", theme: "theme", shape: "shape", density: "density", dense: ["dense", "dense", booleanAttribute], popoverIcon: ["popoverIcon", "popoverIcon", booleanAttribute], popoverExpanded: ["popoverExpanded", "popoverExpanded", booleanAttribute], multiline: ["multiline", "multiline", booleanAttribute], supportTextInset: "supportTextInset", focusIndicatorTargetElement: "focusIndicatorTargetElement", focusIndicatorFocusMode: "focusIndicatorFocusMode", focusIndicatorAllowFocus: ["focusIndicatorAllowFocus", "focusIndicatorAllowFocus", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: FieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-field',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { labelPosition: [{
                type: Input
            }], labelAlignment: [{
                type: Input
            }], floatLabel: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], invalid: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], required: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], optional: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], variant: [{
                type: Input
            }], theme: [{
                type: Input
            }], shape: [{
                type: Input
            }], density: [{
                type: Input
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], popoverIcon: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], popoverExpanded: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], multiline: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], supportTextInset: [{
                type: Input
            }], focusIndicatorTargetElement: [{
                type: Input
            }], focusIndicatorFocusMode: [{
                type: Input
            }], focusIndicatorAllowFocus: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeFieldModule {
    constructor() {
        defineFieldComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeFieldModule, declarations: [FieldComponent], imports: [CommonModule], exports: [FieldComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeFieldModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeFieldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [FieldComponent],
                    exports: [FieldComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class FilePickerComponent {
    /** Gets/sets the allowed file types. */
    set accept(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.accept = value;
        });
    }
    get accept() {
        return this.nativeElement.accept;
    }
    /** Gets/sets the maximum allowed file size. */
    set maxSize(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.maxSize = value;
        });
    }
    get maxSize() {
        return this.nativeElement.maxSize;
    }
    /** Gets/sets the camera to use when capturing video or images. */
    set capture(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.capture = value;
        });
    }
    get capture() {
        return this.nativeElement.capture;
    }
    /** Gets/sets whether multiple files are allowed. */
    set multiple(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.multiple = value;
        });
    }
    get multiple() {
        return this.nativeElement.multiple;
    }
    /** Gets/sets whether the file picker is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Gets/sets whether the file picker uses the compact variant. */
    set compact(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.compact = value;
        });
    }
    get compact() {
        return this.nativeElement.compact;
    }
    /** Gets and sets whether the file picker is borderless. */
    set borderless(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.borderless = value;
        });
    }
    get borderless() {
        return this.nativeElement.borderless;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-file-picker element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineFilePickerComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: FilePickerComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: FilePickerComponent, selector: "forge-file-picker", inputs: { accept: "accept", maxSize: "maxSize", capture: "capture", multiple: ["multiple", "multiple", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], compact: ["compact", "compact", booleanAttribute], borderless: ["borderless", "borderless", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: FilePickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-file-picker',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { accept: [{
                type: Input
            }], maxSize: [{
                type: Input
            }], capture: [{
                type: Input
            }], multiple: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], compact: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], borderless: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeFilePickerModule {
    constructor() {
        defineFilePickerComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeFilePickerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeFilePickerModule, declarations: [FilePickerComponent], imports: [CommonModule], exports: [FilePickerComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeFilePickerModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeFilePickerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [FilePickerComponent],
                    exports: [FilePickerComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class FocusIndicatorComponent {
    /** The element to attach the focus indicator to. */
    set targetElement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.targetElement = value;
        });
    }
    get targetElement() {
        return this.nativeElement.targetElement;
    }
    /** The id of the element to attach the focus indicator to. */
    set target(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.target = value;
        });
    }
    get target() {
        return this.nativeElement.target;
    }
    /** Controls whether the indicator is active. */
    set active(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.active = value;
        });
    }
    get active() {
        return this.nativeElement.active;
    }
    /** Controls whether the indicator renders inward. */
    set inward(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.inward = value;
        });
    }
    get inward() {
        return this.nativeElement.inward;
    }
    /** Controls whether the indicator renders circular. */
    set circular(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.circular = value;
        });
    }
    get circular() {
        return this.nativeElement.circular;
    }
    /** Controls whether the indicator renders when the target element matches `:focus` instead of `:focus-visible`. */
    set allowFocus(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.allowFocus = value;
        });
    }
    get allowFocus() {
        return this.nativeElement.allowFocus;
    }
    /** The focus mode to use. */
    set focusMode(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.focusMode = value;
        });
    }
    get focusMode() {
        return this.nativeElement.focusMode;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-focus-indicator element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineFocusIndicatorComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: FocusIndicatorComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: FocusIndicatorComponent, selector: "forge-focus-indicator", inputs: { targetElement: "targetElement", target: "target", active: ["active", "active", booleanAttribute], inward: ["inward", "inward", booleanAttribute], circular: ["circular", "circular", booleanAttribute], allowFocus: ["allowFocus", "allowFocus", booleanAttribute], focusMode: "focusMode" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: FocusIndicatorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-focus-indicator',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { targetElement: [{
                type: Input
            }], target: [{
                type: Input
            }], active: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], inward: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], circular: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], allowFocus: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], focusMode: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeFocusIndicatorModule {
    constructor() {
        defineFocusIndicatorComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeFocusIndicatorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeFocusIndicatorModule, declarations: [FocusIndicatorComponent], imports: [CommonModule], exports: [FocusIndicatorComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeFocusIndicatorModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeFocusIndicatorModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [FocusIndicatorComponent],
                    exports: [FocusIndicatorComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class IconComponent {
    /** The name of the icon to render. */
    set name(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.name = value;
        });
    }
    get name() {
        return this.nativeElement.name;
    }
    /** Provides the ability to set the SVG string content directly. */
    set src(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.src = value;
        });
    }
    get src() {
        return this.nativeElement.src;
    }
    /** Controls whether the icon will be loaded dynamically when it comes into view. False by default. */
    set lazy(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.lazy = value;
        });
    }
    get lazy() {
        return this.nativeElement.lazy;
    }
    /** Controls whether external network requests are allowed for this icon. Only pertains for icons that aren't already defined in the registry. */
    set external(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.external = value;
        });
    }
    get external() {
        return this.nativeElement.external;
    }
    /** The type of icon to load externally. Possible values: "standard" (default), "extended", "custom". */
    set externalType(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.externalType = value;
        });
    }
    get externalType() {
        return this.nativeElement.externalType;
    }
    /** A callback that can be provided to generate a URL that will be used to fetch an SVG icon. */
    set externalUrlBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.externalUrlBuilder = value;
        });
    }
    get externalUrlBuilder() {
        return this.nativeElement.externalUrlBuilder;
    }
    /** A custom value to apply to the `viewBox` attribute on the internal `<svg>` element. */
    set viewbox(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.viewbox = value;
        });
    }
    get viewbox() {
        return this.nativeElement.viewbox;
    }
    /** The theme to apply to the icon. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    /** Forces a reload of the icon. */
    layout(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.layout(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-icon element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineIconComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: IconComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: IconComponent, selector: "forge-icon", inputs: { name: "name", src: "src", lazy: ["lazy", "lazy", booleanAttribute], external: ["external", "external", booleanAttribute], externalType: "externalType", externalUrlBuilder: "externalUrlBuilder", viewbox: "viewbox", theme: "theme" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: IconComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-icon',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { name: [{
                type: Input
            }], src: [{
                type: Input
            }], lazy: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], external: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], externalType: [{
                type: Input
            }], externalUrlBuilder: [{
                type: Input
            }], viewbox: [{
                type: Input
            }], theme: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeIconModule {
    constructor() {
        defineIconComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeIconModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeIconModule, declarations: [IconComponent], imports: [CommonModule], exports: [IconComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeIconModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeIconModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [IconComponent],
                    exports: [IconComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class IconButtonComponent {
    /** Whether or not the icon button can be toggled. */
    set toggle(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.toggle = value;
        });
    }
    get toggle() {
        return this.nativeElement.toggle;
    }
    /** Whether or not the button is on. Only applies when `toggle` is `true`. */
    set on(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.on = value;
        });
    }
    get on() {
        return this.nativeElement.on;
    }
    /** The theme of the button. Valid values are `default`, `primary`, `secondary`, `tertiary`, `success`, `error`, `warning`, `info`. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    /** The variant of the button. Valid values are `text`, `outlined`, `filled`, and `raised`. */
    set variant(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.variant = value;
        });
    }
    get variant() {
        return this.nativeElement.variant;
    }
    /** The shape of the button. Valid values are `circular` and `squared`. */
    set shape(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.shape = value;
        });
    }
    get shape() {
        return this.nativeElement.shape;
    }
    /** The density of the button. Valid values are `small`, `medium`, and `large`. */
    set density(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.density = value;
        });
    }
    get density() {
        return this.nativeElement.density;
    }
    /** The type of button. Defaults to `button`. Valid values are `button`, `submit`, and `reset`. */
    set type(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.type = value;
        });
    }
    get type() {
        return this.nativeElement.type;
    }
    /** Whether or not the button is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Whether or not the button shows a built-in popover icon. */
    set popoverIcon(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popoverIcon = value;
        });
    }
    get popoverIcon() {
        return this.nativeElement.popoverIcon;
    }
    /** Whether or not the button is dense. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** The name of the button. */
    set name(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.name = value;
        });
    }
    get name() {
        return this.nativeElement.name;
    }
    /** The form value of the button. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** The form reference of the button if within a `<form>` element. */
    get form() {
        return this.nativeElement.form;
    }
    /** Clicks the button. */
    click(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.click(...args));
    }
    /** Focuses the button. */
    focus(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.focus(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-icon-button element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineIconButtonComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: IconButtonComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: IconButtonComponent, selector: "forge-icon-button", inputs: { toggle: ["toggle", "toggle", booleanAttribute], on: ["on", "on", booleanAttribute], theme: "theme", variant: "variant", shape: "shape", density: "density", type: "type", disabled: ["disabled", "disabled", booleanAttribute], popoverIcon: ["popoverIcon", "popoverIcon", booleanAttribute], dense: ["dense", "dense", booleanAttribute], name: "name", value: "value" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: IconButtonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-icon-button',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { toggle: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], on: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], theme: [{
                type: Input
            }], variant: [{
                type: Input
            }], shape: [{
                type: Input
            }], density: [{
                type: Input
            }], type: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], popoverIcon: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], name: [{
                type: Input
            }], value: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeIconButtonModule {
    constructor() {
        defineIconButtonComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeIconButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeIconButtonModule, declarations: [IconButtonComponent], imports: [CommonModule, ForgeIconModule], exports: [IconButtonComponent, ForgeIconModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeIconButtonModule, imports: [CommonModule, ForgeIconModule, ForgeIconModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeIconButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ForgeIconModule],
                    declarations: [IconButtonComponent],
                    exports: [IconButtonComponent, ForgeIconModule]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class InlineMessageComponent {
    /** The theme to apply. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-inline-message element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineInlineMessageComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: InlineMessageComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.7", type: InlineMessageComponent, selector: "forge-inline-message", inputs: { theme: "theme" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: InlineMessageComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-inline-message',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { theme: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeInlineMessageModule {
    constructor() {
        defineInlineMessageComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeInlineMessageModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeInlineMessageModule, declarations: [InlineMessageComponent], imports: [CommonModule], exports: [InlineMessageComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeInlineMessageModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeInlineMessageModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [InlineMessageComponent],
                    exports: [InlineMessageComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class KeyboardShortcutComponent {
    /** Gets/sets the key binding. */
    set key(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.key = value;
        });
    }
    get key() {
        return this.nativeElement.key;
    }
    /** Alias for key. */
    set keyBinding(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.keyBinding = value;
        });
    }
    get keyBinding() {
        return this.nativeElement.keyBinding;
    }
    /** Gets/sets the target element selector. */
    set target(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.target = value;
        });
    }
    get target() {
        return this.nativeElement.target;
    }
    /** Gets/sets the global listener state. */
    set global(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.global = value;
        });
    }
    get global() {
        return this.nativeElement.global;
    }
    /** Gets/sets whether the callback will be called while in a text entry field. */
    set allowWhileTyping(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.allowWhileTyping = value;
        });
    }
    get allowWhileTyping() {
        return this.nativeElement.allowWhileTyping;
    }
    /** Gets/sets whether to prevent default on keyboard events */
    set preventDefault(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.preventDefault = value;
        });
    }
    get preventDefault() {
        return this.nativeElement.preventDefault;
    }
    /** Gets/sets whether to use capturing on keyboard events */
    set capture(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.capture = value;
        });
    }
    get capture() {
        return this.nativeElement.capture;
    }
    /** Gets/sets whether to match codes instead of keys on keyboard events. */
    set useCode(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.useCode = value;
        });
    }
    get useCode() {
        return this.nativeElement.useCode;
    }
    /** Gets/sets whether the callback will be called. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Gets/sets whether the activation callback. */
    set activateCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.activateCallback = value;
        });
    }
    get activateCallback() {
        return this.nativeElement.activateCallback;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-keyboard-shortcut element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineKeyboardShortcutComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: KeyboardShortcutComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: KeyboardShortcutComponent, selector: "forge-keyboard-shortcut", inputs: { key: "key", keyBinding: "keyBinding", target: "target", global: ["global", "global", booleanAttribute], allowWhileTyping: ["allowWhileTyping", "allowWhileTyping", booleanAttribute], preventDefault: ["preventDefault", "preventDefault", booleanAttribute], capture: ["capture", "capture", booleanAttribute], useCode: ["useCode", "useCode", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], activateCallback: "activateCallback" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: KeyboardShortcutComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-keyboard-shortcut',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { key: [{
                type: Input
            }], keyBinding: [{
                type: Input
            }], target: [{
                type: Input
            }], global: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], allowWhileTyping: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], preventDefault: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], capture: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], useCode: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], activateCallback: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeKeyboardShortcutModule {
    constructor() {
        defineKeyboardShortcutComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeKeyboardShortcutModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeKeyboardShortcutModule, declarations: [KeyboardShortcutComponent], imports: [CommonModule], exports: [KeyboardShortcutComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeKeyboardShortcutModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeKeyboardShortcutModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [KeyboardShortcutComponent],
                    exports: [KeyboardShortcutComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class LabelComponent {
    /** The id of the associated element. */
    set for(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.for = value;
        });
    }
    get for() {
        return this.nativeElement.for;
    }
    /** The associated element. */
    set forElement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.forElement = value;
        });
    }
    get forElement() {
        return this.nativeElement.forElement;
    }
    /** The element that a click should be simulated on. If not defined clicks act on the associated element. */
    set clickTarget(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.clickTarget = value;
        });
    }
    get clickTarget() {
        return this.nativeElement.clickTarget;
    }
    /** Propagates changes in the label's text content to the associated element. */
    set dynamic(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dynamic = value;
        });
    }
    get dynamic() {
        return this.nativeElement.dynamic;
    }
    /** Removes click handling from the label. */
    set nonInteractive(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.nonInteractive = value;
        });
    }
    get nonInteractive() {
        return this.nativeElement.nonInteractive;
    }
    /** Whether or not the label should be associated with an ancestor element. */
    set legend(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.legend = value;
        });
    }
    get legend() {
        return this.nativeElement.legend;
    }
    /** Updates the targeted element with the label's current text content. */
    update(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.update(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-label element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineLabelComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: LabelComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: LabelComponent, selector: "forge-label", inputs: { for: "for", forElement: "forElement", clickTarget: "clickTarget", dynamic: ["dynamic", "dynamic", booleanAttribute], nonInteractive: ["nonInteractive", "nonInteractive", booleanAttribute], legend: ["legend", "legend", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: LabelComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-label',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { for: [{
                type: Input
            }], forElement: [{
                type: Input
            }], clickTarget: [{
                type: Input
            }], dynamic: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], nonInteractive: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], legend: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeLabelModule {
    constructor() {
        defineLabelComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeLabelModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeLabelModule, declarations: [LabelComponent], imports: [CommonModule], exports: [LabelComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeLabelModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeLabelModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [LabelComponent],
                    exports: [LabelComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class LabelValueComponent {
    /** If true, the value will be displayed in an alternative emphasized style. */
    set empty(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.empty = value;
        });
    }
    get empty() {
        return this.nativeElement.empty;
    }
    /** If true, the value will be truncated with an ellipsis if it overflows its container. */
    set ellipsis(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.ellipsis = value;
        });
    }
    get ellipsis() {
        return this.nativeElement.ellipsis;
    }
    /** If true, the label and value will be displayed on the same line. */
    set inline(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.inline = value;
        });
    }
    get inline() {
        return this.nativeElement.inline;
    }
    /** Deprecated. Use `inline` instead. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-label-value element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineLabelValueComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: LabelValueComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: LabelValueComponent, selector: "forge-label-value", inputs: { empty: ["empty", "empty", booleanAttribute], ellipsis: ["ellipsis", "ellipsis", booleanAttribute], inline: ["inline", "inline", booleanAttribute], dense: ["dense", "dense", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: LabelValueComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-label-value',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { empty: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], ellipsis: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], inline: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeLabelValueModule {
    constructor() {
        defineLabelValueComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeLabelValueModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeLabelValueModule, declarations: [LabelValueComponent], imports: [CommonModule], exports: [LabelValueComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeLabelValueModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeLabelValueModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [LabelValueComponent],
                    exports: [LabelValueComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class LinearProgressComponent {
    /** Controls the determinate state. */
    set determinate(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.determinate = value;
        });
    }
    get determinate() {
        return this.nativeElement.determinate;
    }
    /** Controls the progress while in a determinate state. Accepts values from `0` to `1`. */
    set progress(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.progress = value;
        });
    }
    get progress() {
        return this.nativeElement.progress;
    }
    /** Controls the buffer progress while in a determinate state. Accepts values from `0` to `1`. */
    set buffer(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.buffer = value;
        });
    }
    get buffer() {
        return this.nativeElement.buffer;
    }
    /** Sets the theme. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-linear-progress element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineLinearProgressComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: LinearProgressComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: LinearProgressComponent, selector: "forge-linear-progress", inputs: { determinate: ["determinate", "determinate", booleanAttribute], progress: ["progress", "progress", numberAttribute], buffer: ["buffer", "buffer", numberAttribute], theme: "theme" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: LinearProgressComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-linear-progress',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { determinate: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], progress: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], buffer: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], theme: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeLinearProgressModule {
    constructor() {
        defineLinearProgressComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeLinearProgressModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeLinearProgressModule, declarations: [LinearProgressComponent], imports: [CommonModule], exports: [LinearProgressComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeLinearProgressModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeLinearProgressModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [LinearProgressComponent],
                    exports: [LinearProgressComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ListComponent {
    /** Whether the list has all dense items or not. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** Whether the list items within this list are indented. Default is false. */
    set indented(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.indented = value;
        });
    }
    get indented() {
        return this.nativeElement.indented;
    }
    /** The selected list item value(s). */
    set selectedValue(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selectedValue = value;
        });
    }
    get selectedValue() {
        return this.nativeElement.selectedValue;
    }
    /** Whether the list has all two-line items or not. */
    set twoLine(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.twoLine = value;
        });
    }
    get twoLine() {
        return this.nativeElement.twoLine;
    }
    /** Whether the list has all three-line items or not. */
    set threeLine(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.threeLine = value;
        });
    }
    get threeLine() {
        return this.nativeElement.threeLine;
    }
    /** Whether the list has all items that wrap their text or not. */
    set wrap(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.wrap = value;
        });
    }
    get wrap() {
        return this.nativeElement.wrap;
    }
    /** Controls whether the list items will automatically attach themselves to interactive slotted elements or not. */
    set noninteractive(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.noninteractive = value;
        });
    }
    get noninteractive() {
        return this.nativeElement.noninteractive;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-list element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineListComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ListComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ListComponent, selector: "forge-list", inputs: { dense: ["dense", "dense", booleanAttribute], indented: ["indented", "indented", booleanAttribute], selectedValue: "selectedValue", twoLine: ["twoLine", "twoLine", booleanAttribute], threeLine: ["threeLine", "threeLine", booleanAttribute], wrap: ["wrap", "wrap", booleanAttribute], noninteractive: ["noninteractive", "noninteractive", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-list',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], indented: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], selectedValue: [{
                type: Input
            }], twoLine: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], threeLine: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], wrap: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], noninteractive: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ListItemComponent {
    /** Applies the selected state to the list item. */
    set selected(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selected = value;
        });
    }
    get selected() {
        return this.nativeElement.selected;
    }
    /** Applies the active state to the list item by emulating its focused state. */
    set active(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.active = value;
        });
    }
    get active() {
        return this.nativeElement.active;
    }
    /** The unique value of the list item. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Applies the dense state to the list item. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** Applies the indented state by adding margin to the start of the list item. */
    set indented(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.indented = value;
        });
    }
    get indented() {
        return this.nativeElement.indented;
    }
    /** Sets the list item height to support at least two lines of text. */
    set twoLine(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.twoLine = value;
        });
    }
    get twoLine() {
        return this.nativeElement.twoLine;
    }
    /** Sets the list item height to support at least three lines of text. */
    set threeLine(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.threeLine = value;
        });
    }
    get threeLine() {
        return this.nativeElement.threeLine;
    }
    /** Sets the list item to wrap its text content. */
    set wrap(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.wrap = value;
        });
    }
    get wrap() {
        return this.nativeElement.wrap;
    }
    /** Controls whether the list item will automatically attach itself to interactive slotted elements or not. */
    set noninteractive(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.noninteractive = value;
        });
    }
    get noninteractive() {
        return this.nativeElement.noninteractive;
    }
    /** Controls whether the interactive element will receive focus if a non-interactive element is clicked within the list item. */
    set focusPropagation(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.focusPropagation = value;
        });
    }
    get focusPropagation() {
        return this.nativeElement.focusPropagation;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-list-item element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineListItemComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ListItemComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ListItemComponent, selector: "forge-list-item", inputs: { selected: ["selected", "selected", booleanAttribute], active: ["active", "active", booleanAttribute], value: "value", dense: ["dense", "dense", booleanAttribute], indented: ["indented", "indented", booleanAttribute], twoLine: ["twoLine", "twoLine", booleanAttribute], threeLine: ["threeLine", "threeLine", booleanAttribute], wrap: ["wrap", "wrap", booleanAttribute], noninteractive: ["noninteractive", "noninteractive", booleanAttribute], focusPropagation: ["focusPropagation", "focusPropagation", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ListItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-list-item',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { selected: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], active: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], value: [{
                type: Input
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], indented: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], twoLine: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], threeLine: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], wrap: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], noninteractive: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], focusPropagation: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeListItemModule {
    constructor() {
        defineListItemComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeListItemModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeListItemModule, declarations: [ListItemComponent], imports: [CommonModule], exports: [ListItemComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeListItemModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeListItemModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [ListItemComponent],
                    exports: [ListItemComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeListModule {
    constructor() {
        defineListComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeListModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeListModule, declarations: [ListComponent], imports: [CommonModule, ForgeListItemModule], exports: [ListComponent, ForgeListItemModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeListModule, imports: [CommonModule, ForgeListItemModule, ForgeListItemModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeListModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ForgeListItemModule],
                    declarations: [ListComponent],
                    exports: [ListComponent, ForgeListItemModule]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class MenuComponent {
    /** Gets/sets the open state. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** Gets/sets the array of options to display in the menu. */
    set options(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.options = value;
        });
    }
    get options() {
        return this.nativeElement.options;
    }
    /** Gets/sets the selected option to the index. Does not support cascading menus. */
    set selectedIndex(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selectedIndex = value;
        });
    }
    get selectedIndex() {
        return this.nativeElement.selectedIndex;
    }
    /** Gets/sets the value of the option to select. */
    set selectedValue(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selectedValue = value;
        });
    }
    get selectedValue() {
        return this.nativeElement.selectedValue;
    }
    /** Gets/sets the menu placement (default is bottom-left). */
    set placement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.placement = value;
        });
    }
    get placement() {
        return this.nativeElement.placement;
    }
    /** Gets/sets the fallback menu placement for overriding the default of any side. */
    set fallbackPlacements(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.fallbackPlacements = value;
        });
    }
    get fallbackPlacements() {
        return this.nativeElement.fallbackPlacements;
    }
    /** Gets/sets dense state of the list options used in the menu popup. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** Gets/sets the class name to use for option icons. */
    set iconClass(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.iconClass = value;
        });
    }
    get iconClass() {
        return this.nativeElement.iconClass;
    }
    /** Gets/sets whether selection of menu items is persisted. */
    set persistSelection(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.persistSelection = value;
        });
    }
    get persistSelection() {
        return this.nativeElement.persistSelection;
    }
    /** Gets/sets the mode that this menu is using. */
    set mode(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.mode = value;
        });
    }
    get mode() {
        return this.nativeElement.mode;
    }
    /** Sets the position adjustment on the internal popup element. */
    set popupOffset(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popupOffset = value;
        });
    }
    get popupOffset() {
        return this.nativeElement.popupOffset;
    }
    /** Sets the callback that will be executed for each option in the dropdown for producing custom option templates. */
    set optionBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.optionBuilder = value;
        });
    }
    get optionBuilder() {
        return this.nativeElement.optionBuilder;
    }
    /** Gets the currently active popup element when the dropdown is open. */
    get popupElement() {
        return this.nativeElement.popupElement;
    }
    /** Gets/sets the list of classes to apply to the popup element. */
    set popupClasses(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popupClasses = value;
        });
    }
    get popupClasses() {
        return this.nativeElement.popupClasses;
    }
    /** Gets/sets the callback function for generating header content within the popup. */
    set popupHeaderBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popupHeaderBuilder = value;
        });
    }
    get popupHeaderBuilder() {
        return this.nativeElement.popupHeaderBuilder;
    }
    /** Gets/sets the callback function for generating header content within the popup. */
    set popupFooterBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popupFooterBuilder = value;
        });
    }
    get popupFooterBuilder() {
        return this.nativeElement.popupFooterBuilder;
    }
    /** Gets/sets whether the popup width is synchronized with the popup target width. */
    set syncPopupWidth(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.syncPopupWidth = value;
        });
    }
    get syncPopupWidth() {
        return this.nativeElement.syncPopupWidth;
    }
    /** Gets/sets the maximum number of options to display in the dropdown. */
    set optionLimit(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.optionLimit = value;
        });
    }
    get optionLimit() {
        return this.nativeElement.optionLimit;
    }
    /** Controls the observation of scroll events on the dropdown. */
    set observeScroll(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.observeScroll = value;
        });
    }
    get observeScroll() {
        return this.nativeElement.observeScroll;
    }
    /** The number of pixels from the bottom to trigger the scroll bottom event. Only applicable if `observeScroll` is true. */
    set observeScrollThreshold(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.observeScrollThreshold = value;
        });
    }
    get observeScrollThreshold() {
        return this.nativeElement.observeScrollThreshold;
    }
    /** Gets/sets whether the popup width will be constrained to a max width of the viewport width (default: `100vw`). */
    set constrainPopupWidth(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.constrainPopupWidth = value;
        });
    }
    get constrainPopupWidth() {
        return this.nativeElement.constrainPopupWidth;
    }
    /**
     * Gets/sets whether the options will wrap their text or not.
     * This only applies if `constrainPopupWidth` is `true`, if there is an explicit width set via CSS.
     */
    set wrapOptionText(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.wrapOptionText = value;
        });
    }
    get wrapOptionText() {
        return this.nativeElement.wrapOptionText;
    }
    /** Force propagates the key event from another element to this component. */
    propagateKeyEvent(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.propagateKeyEvent(...args));
    }
    /** Activates the first option in the menu when open. */
    activateFirstOption(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.activateFirstOption(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-menu element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineMenuComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: MenuComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: MenuComponent, selector: "forge-menu", inputs: { open: ["open", "open", booleanAttribute], options: "options", selectedIndex: ["selectedIndex", "selectedIndex", numberAttribute], selectedValue: "selectedValue", placement: "placement", fallbackPlacements: "fallbackPlacements", dense: ["dense", "dense", booleanAttribute], iconClass: "iconClass", persistSelection: ["persistSelection", "persistSelection", booleanAttribute], mode: "mode", popupOffset: "popupOffset", optionBuilder: "optionBuilder", popupClasses: "popupClasses", popupHeaderBuilder: "popupHeaderBuilder", popupFooterBuilder: "popupFooterBuilder", syncPopupWidth: ["syncPopupWidth", "syncPopupWidth", booleanAttribute], optionLimit: ["optionLimit", "optionLimit", numberAttribute], observeScroll: ["observeScroll", "observeScroll", booleanAttribute], observeScrollThreshold: ["observeScrollThreshold", "observeScrollThreshold", numberAttribute], constrainPopupWidth: ["constrainPopupWidth", "constrainPopupWidth", booleanAttribute], wrapOptionText: ["wrapOptionText", "wrapOptionText", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: MenuComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-menu',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], options: [{
                type: Input
            }], selectedIndex: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], selectedValue: [{
                type: Input
            }], placement: [{
                type: Input
            }], fallbackPlacements: [{
                type: Input
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], iconClass: [{
                type: Input
            }], persistSelection: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], mode: [{
                type: Input
            }], popupOffset: [{
                type: Input
            }], optionBuilder: [{
                type: Input
            }], popupClasses: [{
                type: Input
            }], popupHeaderBuilder: [{
                type: Input
            }], popupFooterBuilder: [{
                type: Input
            }], syncPopupWidth: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], optionLimit: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], observeScroll: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], observeScrollThreshold: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], constrainPopupWidth: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], wrapOptionText: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeMenuModule {
    constructor() {
        defineMenuComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeMenuModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeMenuModule, declarations: [MenuComponent], imports: [CommonModule], exports: [MenuComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeMenuModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeMenuModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [MenuComponent],
                    exports: [MenuComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class MiniDrawerComponent {
    /** The drawer will expand open when hovered. */
    set hover(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.hover = value;
        });
    }
    get hover() {
        return this.nativeElement.hover;
    }
    /** Toggles whether the drawer is visible or not. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** Controls the layout and animation direction of the drawer for positioning on the left vs. right side of the screen when toggling the `open` attribute. */
    set direction(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.direction = value;
        });
    }
    get direction() {
        return this.nativeElement.direction;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-mini-drawer element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineMiniDrawerComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: MiniDrawerComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: MiniDrawerComponent, selector: "forge-mini-drawer", inputs: { hover: ["hover", "hover", booleanAttribute], open: ["open", "open", booleanAttribute], direction: "direction" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: MiniDrawerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-mini-drawer',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { hover: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], direction: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeMiniDrawerModule {
    constructor() {
        defineMiniDrawerComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeMiniDrawerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeMiniDrawerModule, declarations: [MiniDrawerComponent], imports: [CommonModule], exports: [MiniDrawerComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeMiniDrawerModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeMiniDrawerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [MiniDrawerComponent],
                    exports: [MiniDrawerComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ModalDrawerComponent {
    /** Toggles whether the drawer is visible or not. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** Controls the layout and animation direction of the drawer for positioning on the left vs. right side of the screen when toggling the `open` attribute. */
    set direction(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.direction = value;
        });
    }
    get direction() {
        return this.nativeElement.direction;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-modal-drawer element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineModalDrawerComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ModalDrawerComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ModalDrawerComponent, selector: "forge-modal-drawer", inputs: { open: ["open", "open", booleanAttribute], direction: "direction" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ModalDrawerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-modal-drawer',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], direction: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeModalDrawerModule {
    constructor() {
        defineModalDrawerComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeModalDrawerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeModalDrawerModule, declarations: [ModalDrawerComponent], imports: [CommonModule], exports: [ModalDrawerComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeModalDrawerModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeModalDrawerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [ModalDrawerComponent],
                    exports: [ModalDrawerComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class OptionComponent {
    /** Gets/sets the value of this option. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Gets/sets the label of this option. */
    set label(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.label = value;
        });
    }
    get label() {
        return this.nativeElement.label;
    }
    /** Gets/sets the secondary label of this option. */
    set secondaryLabel(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.secondaryLabel = value;
        });
    }
    get secondaryLabel() {
        return this.nativeElement.secondaryLabel;
    }
    /** Gets/sets the disabled status of this option. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Gets/sets the whether this option is a divider. */
    set divider(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.divider = value;
        });
    }
    get divider() {
        return this.nativeElement.divider;
    }
    /** Gets/sets the classes of this option. */
    set optionClass(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.optionClass = value;
        });
    }
    get optionClass() {
        return this.nativeElement.optionClass;
    }
    /** Gets/sets the leading icon of this option. */
    set leadingIcon(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.leadingIcon = value;
        });
    }
    get leadingIcon() {
        return this.nativeElement.leadingIcon;
    }
    /** Gets/sets the leading icon class of this option. */
    set leadingIconClass(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.leadingIconClass = value;
        });
    }
    get leadingIconClass() {
        return this.nativeElement.leadingIconClass;
    }
    /** Gets/sets the leading icon type of this option. */
    set leadingIconType(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.leadingIconType = value;
        });
    }
    get leadingIconType() {
        return this.nativeElement.leadingIconType;
    }
    /** Gets/sets properties on leading icon component. */
    set leadingIconComponentProps(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.leadingIconComponentProps = value;
        });
    }
    get leadingIconComponentProps() {
        return this.nativeElement.leadingIconComponentProps;
    }
    /** Gets/sets the trailing icon of this option. */
    set trailingIcon(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.trailingIcon = value;
        });
    }
    get trailingIcon() {
        return this.nativeElement.trailingIcon;
    }
    /** Gets/sets the trailing icon class of this option. */
    set trailingIconClass(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.trailingIconClass = value;
        });
    }
    get trailingIconClass() {
        return this.nativeElement.trailingIconClass;
    }
    /** Gets/sets the trailing icon type of this option. */
    set trailingIconType(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.trailingIconType = value;
        });
    }
    get trailingIconType() {
        return this.nativeElement.trailingIconType;
    }
    /** Gets/sets properties on trailing icon component. */
    set trailingIconComponentProps(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.trailingIconComponentProps = value;
        });
    }
    get trailingIconComponentProps() {
        return this.nativeElement.trailingIconComponentProps;
    }
    /** Gets/sets the leading builder of this option. */
    set leadingBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.leadingBuilder = value;
        });
    }
    get leadingBuilder() {
        return this.nativeElement.leadingBuilder;
    }
    /** Gets/sets the trailing builder of this option. */
    set trailingBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.trailingBuilder = value;
        });
    }
    get trailingBuilder() {
        return this.nativeElement.trailingBuilder;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-option element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineOptionComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: OptionComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: OptionComponent, selector: "forge-option", inputs: { value: "value", label: "label", secondaryLabel: "secondaryLabel", disabled: ["disabled", "disabled", booleanAttribute], divider: ["divider", "divider", booleanAttribute], optionClass: "optionClass", leadingIcon: "leadingIcon", leadingIconClass: "leadingIconClass", leadingIconType: "leadingIconType", leadingIconComponentProps: "leadingIconComponentProps", trailingIcon: "trailingIcon", trailingIconClass: "trailingIconClass", trailingIconType: "trailingIconType", trailingIconComponentProps: "trailingIconComponentProps", leadingBuilder: "leadingBuilder", trailingBuilder: "trailingBuilder" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: OptionComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-option',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { value: [{
                type: Input
            }], label: [{
                type: Input
            }], secondaryLabel: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], divider: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], optionClass: [{
                type: Input
            }], leadingIcon: [{
                type: Input
            }], leadingIconClass: [{
                type: Input
            }], leadingIconType: [{
                type: Input
            }], leadingIconComponentProps: [{
                type: Input
            }], trailingIcon: [{
                type: Input
            }], trailingIconClass: [{
                type: Input
            }], trailingIconType: [{
                type: Input
            }], trailingIconComponentProps: [{
                type: Input
            }], leadingBuilder: [{
                type: Input
            }], trailingBuilder: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeOptionModule {
    constructor() {
        defineOptionComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeOptionModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeOptionModule, declarations: [OptionComponent], imports: [CommonModule], exports: [OptionComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeOptionModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeOptionModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [OptionComponent],
                    exports: [OptionComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class OptionGroupComponent {
    /** Gets/sets the label of this option group. */
    set label(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.label = value;
        });
    }
    get label() {
        return this.nativeElement.label;
    }
    /** The child options of this group. */
    set options(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.options = value;
        });
    }
    get options() {
        return this.nativeElement.options;
    }
    /** The builder function for the group content. */
    set builder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.builder = value;
        });
    }
    get builder() {
        return this.nativeElement.builder;
    }
    /** Gets/sets the optional group value. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** The text content for the group. */
    set text(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.text = value;
        });
    }
    get text() {
        return this.nativeElement.text;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-option-group element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineOptionGroupComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: OptionGroupComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.7", type: OptionGroupComponent, selector: "forge-option-group", inputs: { label: "label", options: "options", builder: "builder", value: "value", text: "text" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: OptionGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-option-group',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { label: [{
                type: Input
            }], options: [{
                type: Input
            }], builder: [{
                type: Input
            }], value: [{
                type: Input
            }], text: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeOptionGroupModule {
    constructor() {
        defineOptionGroupComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeOptionGroupModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeOptionGroupModule, declarations: [OptionGroupComponent], imports: [CommonModule], exports: [OptionGroupComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeOptionGroupModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeOptionGroupModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [OptionGroupComponent],
                    exports: [OptionGroupComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class OverlayComponent {
    /** The element to use as the arrow for the overlay. */
    set arrowElement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.arrowElement = value;
        });
    }
    get arrowElement() {
        return this.nativeElement.arrowElement;
    }
    /** The offset to apply to the arrow element. */
    set arrowElementOffset(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.arrowElementOffset = value;
        });
    }
    get arrowElementOffset() {
        return this.nativeElement.arrowElementOffset;
    }
    /** Whether or not the overlay is open. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** Whether or not the overlay should be rendered inline (not in the :top-layer). */
    set inline(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.inline = value;
        });
    }
    get inline() {
        return this.nativeElement.inline;
    }
    /** The element to anchor the overlay to. */
    set anchorElement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.anchorElement = value;
        });
    }
    get anchorElement() {
        return this.nativeElement.anchorElement;
    }
    /** The id of the element to anchor the overlay to. */
    set anchor(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.anchor = value;
        });
    }
    get anchor() {
        return this.nativeElement.anchor;
    }
    /** Whether or not the overlay should be rendered without an anchor (centered on page by default). */
    set noAnchor(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.noAnchor = value;
        });
    }
    get noAnchor() {
        return this.nativeElement.noAnchor;
    }
    /** The placement of the overlay relative to the anchor element. */
    set placement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.placement = value;
        });
    }
    get placement() {
        return this.nativeElement.placement;
    }
    /** The positioning strategy to use for the overlay. Valid values are `'fixed'` and `'absolute'`. */
    set positionStrategy(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.positionStrategy = value;
        });
    }
    get positionStrategy() {
        return this.nativeElement.positionStrategy;
    }
    /** The offset to apply to the overlay position relative to the anchor element. */
    set offset(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.offset = value;
        });
    }
    get offset() {
        return this.nativeElement.offset;
    }
    /** Whether or not the anchor element should shift along the side of the overlay when scrolling. */
    set shift(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.shift = value;
        });
    }
    get shift() {
        return this.nativeElement.shift;
    }
    /** Whether or not the overlay should hide itself when the anchor element is out of view. */
    set hide(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.hide = value;
        });
    }
    get hide() {
        return this.nativeElement.hide;
    }
    /** Whether or not the overlay handles light dismiss itself or not. */
    set persistent(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.persistent = value;
        });
    }
    get persistent() {
        return this.nativeElement.persistent;
    }
    /** Whether or not the overlay should flip to the opposite placement when not enough room. */
    set flip(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.flip = value;
        });
    }
    get flip() {
        return this.nativeElement.flip;
    }
    /** The id of the element to use as the boundary for the overlay. */
    set boundary(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.boundary = value;
        });
    }
    get boundary() {
        return this.nativeElement.boundary;
    }
    /** The element to use as the boundary for the overlay. */
    set boundaryElement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.boundaryElement = value;
        });
    }
    get boundaryElement() {
        return this.nativeElement.boundaryElement;
    }
    /** The fallback placements to use when the overlay cannot be placed in the desired placement. */
    set fallbackPlacements(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.fallbackPlacements = value;
        });
    }
    get fallbackPlacements() {
        return this.nativeElement.fallbackPlacements;
    }
    position(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.position(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-overlay element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineOverlayComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: OverlayComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: OverlayComponent, selector: "forge-overlay", inputs: { arrowElement: "arrowElement", arrowElementOffset: ["arrowElementOffset", "arrowElementOffset", numberAttribute], open: ["open", "open", booleanAttribute], inline: ["inline", "inline", booleanAttribute], anchorElement: "anchorElement", anchor: "anchor", noAnchor: ["noAnchor", "noAnchor", booleanAttribute], placement: "placement", positionStrategy: "positionStrategy", offset: "offset", shift: ["shift", "shift", booleanAttribute], hide: "hide", persistent: ["persistent", "persistent", booleanAttribute], flip: "flip", boundary: "boundary", boundaryElement: "boundaryElement", fallbackPlacements: "fallbackPlacements" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: OverlayComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-overlay',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { arrowElement: [{
                type: Input
            }], arrowElementOffset: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], inline: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], anchorElement: [{
                type: Input
            }], anchor: [{
                type: Input
            }], noAnchor: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], placement: [{
                type: Input
            }], positionStrategy: [{
                type: Input
            }], offset: [{
                type: Input
            }], shift: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], hide: [{
                type: Input
            }], persistent: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], flip: [{
                type: Input
            }], boundary: [{
                type: Input
            }], boundaryElement: [{
                type: Input
            }], fallbackPlacements: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeOverlayModule {
    constructor() {
        defineOverlayComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeOverlayModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeOverlayModule, declarations: [OverlayComponent], imports: [CommonModule], exports: [OverlayComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeOverlayModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeOverlayModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [OverlayComponent],
                    exports: [OverlayComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class PageStateComponent {
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-page-state element. */
        this.nativeElement = this.elementRef.nativeElement;
        definePageStateComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: PageStateComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.7", type: PageStateComponent, selector: "forge-page-state", ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: PageStateComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-page-state',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgePageStateModule {
    constructor() {
        definePageStateComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgePageStateModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgePageStateModule, declarations: [PageStateComponent], imports: [CommonModule], exports: [PageStateComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgePageStateModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgePageStateModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [PageStateComponent],
                    exports: [PageStateComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class PaginatorComponent {
    /** The zero-based page index. */
    set pageIndex(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.pageIndex = value;
        });
    }
    get pageIndex() {
        return this.nativeElement.pageIndex;
    }
    /** Number of items to display on a page. */
    set pageSize(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.pageSize = value;
        });
    }
    get pageSize() {
        return this.nativeElement.pageSize;
    }
    /** Sets page index by providing the number of items to skip. The getter for this property returns the number of items to skip. */
    set offset(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.offset = value;
        });
    }
    get offset() {
        return this.nativeElement.offset;
    }
    /** The total number of items to be paginated. */
    set total(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.total = value;
        });
    }
    get total() {
        return this.nativeElement.total;
    }
    /** The set of provided page size options to display to the user. */
    set pageSizeOptions(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.pageSizeOptions = value;
        });
    }
    get pageSizeOptions() {
        return this.nativeElement.pageSizeOptions;
    }
    /** A label for the paginator. */
    set label(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.label = value;
        });
    }
    get label() {
        return this.nativeElement.label;
    }
    /** Whether to show the first page and last page buttons. */
    set firstLast(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.firstLast = value;
        });
    }
    get firstLast() {
        return this.nativeElement.firstLast;
    }
    /** Whether to show the first page button. Default is false. */
    set first(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.first = value;
        });
    }
    get first() {
        return this.nativeElement.first;
    }
    /** Whether the paginator is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Whether to use the alternative range label slot. */
    set alternative(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.alternative = value;
        });
    }
    get alternative() {
        return this.nativeElement.alternative;
    }
    /** A callback function to build the range label dynamically. */
    set rangeLabelCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.rangeLabelCallback = value;
        });
    }
    get rangeLabelCallback() {
        return this.nativeElement.rangeLabelCallback;
    }
    /** Sets focus to the first focusable element within the paginator. */
    focus(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.focus(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-paginator element. */
        this.nativeElement = this.elementRef.nativeElement;
        definePaginatorComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: PaginatorComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: PaginatorComponent, selector: "forge-paginator", inputs: { pageIndex: ["pageIndex", "pageIndex", numberAttribute], pageSize: ["pageSize", "pageSize", numberAttribute], offset: ["offset", "offset", numberAttribute], total: ["total", "total", numberAttribute], pageSizeOptions: "pageSizeOptions", label: "label", firstLast: ["firstLast", "firstLast", booleanAttribute], first: ["first", "first", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], alternative: ["alternative", "alternative", booleanAttribute], rangeLabelCallback: "rangeLabelCallback" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: PaginatorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-paginator',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { pageIndex: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], pageSize: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], offset: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], total: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], pageSizeOptions: [{
                type: Input
            }], label: [{
                type: Input
            }], firstLast: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], first: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], alternative: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], rangeLabelCallback: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgePaginatorModule {
    constructor() {
        definePaginatorComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgePaginatorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgePaginatorModule, declarations: [PaginatorComponent], imports: [CommonModule], exports: [PaginatorComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgePaginatorModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgePaginatorModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [PaginatorComponent],
                    exports: [PaginatorComponent]
                }]
        }], ctorParameters: () => [] });

class PopoverConfig {
}

class PopoverInjector extends BaseInjector {
}

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class PopoverComponent {
    /** Whether or not the popover should render an arrow. */
    set arrow(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.arrow = value;
        });
    }
    get arrow() {
        return this.nativeElement.arrow;
    }
    /** The animation type to use for the popover. Valid values are `'none'`, `'fade'`, `'slide'`, and `'zoom'` (default). */
    set animationType(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.animationType = value;
        });
    }
    get animationType() {
        return this.nativeElement.animationType;
    }
    /** The trigger type(s) to use for the popover. Valid values are `'click'` (default), `'hover'`, `'focus'`, and `'longpress'`. Multiple can be specified. */
    set triggerType(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.triggerType = value;
        });
    }
    get triggerType() {
        return this.nativeElement.triggerType;
    }
    /** The delay in milliseconds before a longpress event is detected. */
    set longpressDelay(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.longpressDelay = value;
        });
    }
    get longpressDelay() {
        return this.nativeElement.longpressDelay;
    }
    /** Whether or not the popover should remain open when the user hovers outside the popover. */
    set persistentHover(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.persistentHover = value;
        });
    }
    get persistentHover() {
        return this.nativeElement.persistentHover;
    }
    /** The delay in milliseconds before the popover is shown. */
    set hoverDelay(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.hoverDelay = value;
        });
    }
    get hoverDelay() {
        return this.nativeElement.hoverDelay;
    }
    /** The delay in milliseconds before the popover is dismissed when the user hovers outside of the popover. */
    set hoverDismissDelay(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.hoverDismissDelay = value;
        });
    }
    get hoverDismissDelay() {
        return this.nativeElement.hoverDismissDelay;
    }
    /** The preset to use for the popover. */
    set preset(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.preset = value;
        });
    }
    get preset() {
        return this.nativeElement.preset;
    }
    /** A readonly reference to the internal `<forge-overlay>` element instance. */
    get overlay() {
        return this.nativeElement.overlay;
    }
    /** The anchor element to position the overlay relative to. */
    set anchorElement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.anchorElement = value;
        });
    }
    get anchorElement() {
        return this.nativeElement.anchorElement;
    }
    /** The IDREF of the anchor element to position the overlay relative to. */
    set anchor(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.anchor = value;
        });
    }
    get anchor() {
        return this.nativeElement.anchor;
    }
    /** Whether the overlay should not be anchored to an element. This allows for custom positioning. */
    set noAnchor(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.noAnchor = value;
        });
    }
    get noAnchor() {
        return this.nativeElement.noAnchor;
    }
    /** Whether the overlay is open. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** Whether the overlay is inline (not in the top-layer). */
    set inline(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.inline = value;
        });
    }
    get inline() {
        return this.nativeElement.inline;
    }
    /** The placement of the overlay. */
    set placement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.placement = value;
        });
    }
    get placement() {
        return this.nativeElement.placement;
    }
    /** The position strategy of the overlay. */
    set positionStrategy(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.positionStrategy = value;
        });
    }
    get positionStrategy() {
        return this.nativeElement.positionStrategy;
    }
    /** The offset of the overlay. */
    set offset(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.offset = value;
        });
    }
    get offset() {
        return this.nativeElement.offset;
    }
    /** Whether the overlay should shift to fit within the viewport. */
    set shift(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.shift = value;
        });
    }
    get shift() {
        return this.nativeElement.shift;
    }
    /** The hide state of the overlay. */
    set hide(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.hide = value;
        });
    }
    get hide() {
        return this.nativeElement.hide;
    }
    /** Whether the overlay should persist when the anchor is removed. */
    set persistent(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.persistent = value;
        });
    }
    get persistent() {
        return this.nativeElement.persistent;
    }
    /** Whether the overlay should flip placements to another side fit within the viewport. */
    set flip(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.flip = value;
        });
    }
    get flip() {
        return this.nativeElement.flip;
    }
    /** An IDREF to boundary element to constrain the overlay within. */
    set boundary(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.boundary = value;
        });
    }
    get boundary() {
        return this.nativeElement.boundary;
    }
    /** The boundary element instance to constrain the overlay within. */
    set boundaryElement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.boundaryElement = value;
        });
    }
    get boundaryElement() {
        return this.nativeElement.boundaryElement;
    }
    /** The fallback placements of the overlay. */
    set fallbackPlacements(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.fallbackPlacements = value;
        });
    }
    get fallbackPlacements() {
        return this.nativeElement.fallbackPlacements;
    }
    /** Hides the popover, and returns a `Promise` that resolves when the hide animation is complete. */
    hideAsync(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.hideAsync(...args));
    }
    /** Forces the overlay to reposition itself. */
    position(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.position(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-popover element. */
        this.nativeElement = this.elementRef.nativeElement;
        definePopoverComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: PopoverComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: PopoverComponent, selector: "forge-popover", inputs: { arrow: ["arrow", "arrow", booleanAttribute], animationType: "animationType", triggerType: "triggerType", longpressDelay: ["longpressDelay", "longpressDelay", numberAttribute], persistentHover: ["persistentHover", "persistentHover", booleanAttribute], hoverDelay: ["hoverDelay", "hoverDelay", numberAttribute], hoverDismissDelay: ["hoverDismissDelay", "hoverDismissDelay", numberAttribute], preset: "preset", anchorElement: "anchorElement", anchor: "anchor", noAnchor: ["noAnchor", "noAnchor", booleanAttribute], open: ["open", "open", booleanAttribute], inline: ["inline", "inline", booleanAttribute], placement: "placement", positionStrategy: "positionStrategy", offset: "offset", shift: ["shift", "shift", booleanAttribute], hide: "hide", persistent: ["persistent", "persistent", booleanAttribute], flip: "flip", boundary: "boundary", boundaryElement: "boundaryElement", fallbackPlacements: "fallbackPlacements" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: PopoverComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-popover',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { arrow: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], animationType: [{
                type: Input
            }], triggerType: [{
                type: Input
            }], longpressDelay: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], persistentHover: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], hoverDelay: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], hoverDismissDelay: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], preset: [{
                type: Input
            }], anchorElement: [{
                type: Input
            }], anchor: [{
                type: Input
            }], noAnchor: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], inline: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], placement: [{
                type: Input
            }], positionStrategy: [{
                type: Input
            }], offset: [{
                type: Input
            }], shift: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], hide: [{
                type: Input
            }], persistent: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], flip: [{
                type: Input
            }], boundary: [{
                type: Input
            }], boundaryElement: [{
                type: Input
            }], fallbackPlacements: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgePopoverProxyModule {
    constructor() {
        definePopoverComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgePopoverProxyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgePopoverProxyModule, declarations: [PopoverComponent], imports: [CommonModule], exports: [PopoverComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgePopoverProxyModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgePopoverProxyModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [PopoverComponent],
                    exports: [PopoverComponent]
                }]
        }], ctorParameters: () => [] });

class PopoverRef {
    constructor(instance) {
        this._afterClosed = new AsyncSubject();
        this.afterClosed = this._afterClosed.asObservable();
        this._elementRef = new ElementRef(instance);
    }
    close(result) {
        this.nativeElement.open = false;
        this._afterClosed.next(result);
        this._afterClosed.complete();
    }
    get nativeElement() {
        return this._elementRef.nativeElement;
    }
}

/**
 * Allows for declaratively specifying an element that should display a Forge popover
 * from the provided `TemplateRef`.
 */
class PopoverDirective {
    /**
     * @deprecated Use static property instead.
     */
    set forgePopoverCloseOnBlur(value) {
        this.persistent = !value;
    }
    get popoverElement() {
        return this._popoverElement;
    }
    constructor(_elementRef, _viewContainerRef) {
        this._elementRef = _elementRef;
        this._viewContainerRef = _viewContainerRef;
        /** The popover placement around the `ElementRef`. */
        this.forgePopoverPlacement = 'bottom';
        /** Controls whether the popover closes when it loses focus. */
        this.persistent = false;
        this._elementRef.nativeElement.addEventListener(POPOVER_CONSTANTS.events.TOGGLE, () => {
            window.requestAnimationFrame(() => this.close());
        });
    }
    /** Creates and renders a TemplateRef inside of a Forge popover. */
    open() {
        if (this._popoverElement) {
            return;
        }
        // Ensure that we have a popover template
        if (this.forgePopover instanceof TemplateRef === false) {
            throw new Error('Popover template is not defined.');
        }
        // Create the embedded view from the template
        this._contentRef = this._viewContainerRef.createEmbeddedView(this.forgePopover);
        if (this._contentRef.rootNodes[0] instanceof PopoverComponent$1) {
            // <forge-popover> element is supplied in the template
            this._popoverElement = this._contentRef.rootNodes[0];
            this._popoverElement.remove();
        }
        else {
            // Create the Forge popover element
            this._popoverElement = document.createElement('forge-popover');
            // Because createEmbeddedView will place the template within the element defined by ViewContainerRef, we
            // need to then move the elements to children of the Forge popover element so they render within the popover
            this._contentRef.rootNodes.forEach(node => this._popoverElement?.appendChild(node));
            this._popoverElement.placement = this.forgePopoverPlacement;
            // Add the custom class (if provided)
            if (this.forgePopoverClass) {
                this._popoverElement.classList.add(this.forgePopoverClass);
            }
            this._popoverElement.persistent = this.persistent;
        }
        let hostElement = this._elementRef.nativeElement.closest(POPOVER_CONSTANTS.selectors.HOST);
        if (!hostElement) {
            const rootNode = this._elementRef.nativeElement.getRootNode();
            const hostRootNode = rootNode instanceof ShadowRoot ? rootNode : (this._elementRef.nativeElement.ownerDocument ?? document).body;
            hostElement = hostRootNode;
        }
        hostElement.appendChild(this._popoverElement);
        this._popoverElement.anchorElement = this._elementRef.nativeElement;
        this._popoverElement.open = true;
    }
    /** Closes the Forge popover and destroys the embedded view. */
    close() {
        if (this._popoverElement) {
            this._popoverElement.open = false;
            this._popoverElement = undefined;
        }
        if (this._contentRef) {
            this._contentRef.destroy();
            this._contentRef = undefined;
        }
    }
    ngOnDestroy() {
        this.close();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: PopoverDirective, deps: [{ token: i0.ElementRef }, { token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.7", type: PopoverDirective, selector: "[forgePopover]", inputs: { forgePopover: "forgePopover", forgePopoverPlacement: "forgePopoverPlacement", forgePopoverCloseOnBlur: "forgePopoverCloseOnBlur", persistent: "persistent", forgePopoverClass: "forgePopoverClass" }, exportAs: ["forgePopover"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: PopoverDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[forgePopover]',
                    exportAs: 'forgePopover'
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.ViewContainerRef }], propDecorators: { forgePopover: [{
                type: Input
            }], forgePopoverPlacement: [{
                type: Input
            }], forgePopoverCloseOnBlur: [{
                type: Input
            }], persistent: [{
                type: Input
            }], forgePopoverClass: [{
                type: Input
            }] } });

class ForgePopoverModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgePopoverModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgePopoverModule, declarations: [PopoverDirective], exports: [PopoverDirective,
            ForgePopoverProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgePopoverModule, imports: [ForgePopoverProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgePopoverModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        PopoverDirective
                    ],
                    exports: [
                        PopoverDirective,
                        ForgePopoverProxyModule
                    ]
                }]
        }] });

class PopoverService {
    constructor(_appRef, _injector, _ngZone) {
        this._appRef = _appRef;
        this._injector = _injector;
        this._ngZone = _ngZone;
        definePopoverComponent();
    }
    /**
     * Displays a components within a Forge popover instance.
     * @param component The component reference.
     * @param options Sets attributes and properties on the `forge-popover` element. `targetElement` is required.
     * @param config The configuration to provide to the dynamic component as an injectable token.
     * @param moduleRef Optional NgModule ref if need by the component.
     * @returns A PopoverRef to the forge-popover and dynamically created component, and related close handling.
     */
    show(component, options, config, moduleRef, envInjector) {
        // Contains tokens that will be provided to components through our custom popover injector
        const providers = [];
        // If we got a config, we should provide it as an injection token
        if (config) {
            providers.push({ provide: PopoverConfig, useValue: config });
        }
        // Create the Forge popover element
        const popoverElement = document.createElement('forge-popover');
        // Configure the popover with the provided options
        const { className, attributes, ...restOptions } = options;
        if (className) {
            popoverElement.classList.add(className);
        }
        if (attributes) {
            attributes.forEach((value, key) => popoverElement.setAttribute(key, value));
        }
        Object.assign(popoverElement, restOptions);
        // Create the ref that will allow the consumer to control the popover
        const popoverRef = new PopoverRef(popoverElement);
        // Always provide the popover ref as an injection token
        providers.push({ provide: PopoverRef, useValue: popoverRef });
        // Create and attach the dynamic component to the popover element
        this._ngZone.run(() => {
            const parentInjector = envInjector ?? moduleRef?.injector ?? this._injector;
            const environmentInjector = createEnvironmentInjector(providers, parentInjector);
            const componentRef = createComponent(component, { environmentInjector });
            this._appRef.attachView(componentRef.hostView);
            const element = componentRef.hostView.rootNodes[0];
            popoverElement.appendChild(element);
            // Always destroy when the popover is closed
            const sub = popoverRef.afterClosed.subscribe(() => {
                componentRef.destroy();
                sub.unsubscribe();
            });
            popoverElement.addEventListener('forge-popover-toggle', () => {
                popoverRef.close();
                componentRef.destroy();
                sub.unsubscribe();
                popoverElement.remove();
            });
            // Force initial change detection so component size can affect initial positioning.
            componentRef.changeDetectorRef.detectChanges();
        });
        popoverElement.open = true;
        document.body.appendChild(popoverElement);
        return popoverRef;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: PopoverService, deps: [{ token: i0.ApplicationRef }, { token: i0.EnvironmentInjector }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: PopoverService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: PopoverService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: i0.ApplicationRef }, { type: i0.EnvironmentInjector }, { type: i0.NgZone }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ProfileCardComponent {
    set fullName(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.fullName = value;
        });
    }
    get fullName() {
        return this.nativeElement.fullName;
    }
    set email(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.email = value;
        });
    }
    get email() {
        return this.nativeElement.email;
    }
    set signOut(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.signOut = value;
        });
    }
    get signOut() {
        return this.nativeElement.signOut;
    }
    set profile(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.profile = value;
        });
    }
    get profile() {
        return this.nativeElement.profile;
    }
    set signOutText(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.signOutText = value;
        });
    }
    get signOutText() {
        return this.nativeElement.signOutText;
    }
    set profileText(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.profileText = value;
        });
    }
    get profileText() {
        return this.nativeElement.profileText;
    }
    set avatarText(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.avatarText = value;
        });
    }
    get avatarText() {
        return this.nativeElement.avatarText;
    }
    set avatarIcon(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.avatarIcon = value;
        });
    }
    get avatarIcon() {
        return this.nativeElement.avatarIcon;
    }
    set avatarImageUrl(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.avatarImageUrl = value;
        });
    }
    get avatarImageUrl() {
        return this.nativeElement.avatarImageUrl;
    }
    set avatarLetterCount(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.avatarLetterCount = value;
        });
    }
    get avatarLetterCount() {
        return this.nativeElement.avatarLetterCount;
    }
    focus(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.focus(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-profile-card element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineProfileCardComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ProfileCardComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ProfileCardComponent, selector: "forge-profile-card", inputs: { fullName: "fullName", email: "email", signOut: ["signOut", "signOut", booleanAttribute], profile: ["profile", "profile", booleanAttribute], signOutText: "signOutText", profileText: "profileText", avatarText: "avatarText", avatarIcon: "avatarIcon", avatarImageUrl: "avatarImageUrl", avatarLetterCount: ["avatarLetterCount", "avatarLetterCount", numberAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ProfileCardComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-profile-card',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { fullName: [{
                type: Input
            }], email: [{
                type: Input
            }], signOut: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], profile: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], signOutText: [{
                type: Input
            }], profileText: [{
                type: Input
            }], avatarText: [{
                type: Input
            }], avatarIcon: [{
                type: Input
            }], avatarImageUrl: [{
                type: Input
            }], avatarLetterCount: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeProfileCardModule {
    constructor() {
        defineProfileCardComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeProfileCardModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeProfileCardModule, declarations: [ProfileCardComponent], imports: [CommonModule], exports: [ProfileCardComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeProfileCardModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeProfileCardModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [ProfileCardComponent],
                    exports: [ProfileCardComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class RadioGroupComponent {
    /** Controls whether the radio group is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-radio-group element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineRadioGroupComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: RadioGroupComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: RadioGroupComponent, selector: "forge-radio-group", inputs: { disabled: ["disabled", "disabled", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: RadioGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-radio-group',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class RadioComponent {
    /** Gets/sets whether the radio is checked. */
    set checked(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.checked = value;
        });
    }
    get checked() {
        return this.nativeElement.checked;
    }
    /** Gets/sets whether the radio is checked by default. */
    set defaultChecked(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.defaultChecked = value;
        });
    }
    get defaultChecked() {
        return this.nativeElement.defaultChecked;
    }
    /** Gets/sets the value of the radio when submitted as part of a form. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Controls whether the radio is dense. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** Controls whether the radio is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Controls whether the radio is required. */
    set required(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.required = value;
        });
    }
    get required() {
        return this.nativeElement.required;
    }
    /** Controls whether the radio is read-only. */
    set readonly(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.readonly = value;
        });
    }
    get readonly() {
        return this.nativeElement.readonly;
    }
    /** Controls whether the label appears before or after the radio. */
    set labelPosition(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.labelPosition = value;
        });
    }
    get labelPosition() {
        return this.nativeElement.labelPosition;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-radio element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineRadioComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: RadioComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: RadioComponent, selector: "forge-radio", inputs: { checked: ["checked", "checked", booleanAttribute], defaultChecked: ["defaultChecked", "defaultChecked", booleanAttribute], value: "value", dense: ["dense", "dense", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], required: ["required", "required", booleanAttribute], readonly: ["readonly", "readonly", booleanAttribute], labelPosition: "labelPosition" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: RadioComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-radio',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { checked: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], defaultChecked: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], value: [{
                type: Input
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], required: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], readonly: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], labelPosition: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeRadioProxyModule {
    constructor() {
        defineRadioComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeRadioProxyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeRadioProxyModule, declarations: [RadioComponent], imports: [CommonModule], exports: [RadioComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeRadioProxyModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeRadioProxyModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [RadioComponent],
                    exports: [RadioComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeRadioGroupModule {
    constructor() {
        defineRadioGroupComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeRadioGroupModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeRadioGroupModule, declarations: [RadioGroupComponent], imports: [CommonModule, ForgeRadioProxyModule], exports: [RadioGroupComponent, ForgeRadioProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeRadioGroupModule, imports: [CommonModule, ForgeRadioProxyModule, ForgeRadioProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeRadioGroupModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ForgeRadioProxyModule],
                    declarations: [RadioGroupComponent],
                    exports: [RadioGroupComponent, ForgeRadioProxyModule]
                }]
        }], ctorParameters: () => [] });

const RADIO_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => RadioValueAccessor),
    multi: true
};
class RadioValueAccessor {
    switchChange(evt) {
        const target = evt.target;
        this.change(target.value);
    }
    blur() {
        this.onTouched();
    }
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    writeValue(value) {
        const checked = value === this._elementRef.nativeElement.value;
        this._renderer.setProperty(this._elementRef.nativeElement, 'checked', checked);
    }
    registerOnChange(fn) {
        this.onChange = value => fn(value);
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(value) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', value);
    }
    change(value) {
        this.onChange(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: RadioValueAccessor, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.7", type: RadioValueAccessor, selector: "forge-radio[formControlName],forge-radio[formControl],forge-radio[ngModel]", host: { listeners: { "change": "switchChange($event)", "blur": "blur()" } }, providers: [RADIO_VALUE_ACCESSOR], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: RadioValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'forge-radio[formControlName],forge-radio[formControl],forge-radio[ngModel]',
                    providers: [RADIO_VALUE_ACCESSOR]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { switchChange: [{
                type: HostListener,
                args: ['change', ['$event']]
            }], blur: [{
                type: HostListener,
                args: ['blur']
            }] } });

class ForgeRadioModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeRadioModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeRadioModule, declarations: [RadioValueAccessor], exports: [RadioValueAccessor,
            ForgeRadioProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeRadioModule, imports: [ForgeRadioProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeRadioModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        RadioValueAccessor
                    ],
                    exports: [
                        RadioValueAccessor,
                        ForgeRadioProxyModule
                    ]
                }]
        }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ScaffoldComponent {
    /** Whether the scaffold should be full viewport height. */
    set viewport(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.viewport = value;
        });
    }
    get viewport() {
        return this.nativeElement.viewport;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-scaffold element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineScaffoldComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ScaffoldComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ScaffoldComponent, selector: "forge-scaffold", inputs: { viewport: ["viewport", "viewport", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ScaffoldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-scaffold',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { viewport: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeScaffoldModule {
    constructor() {
        defineScaffoldComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeScaffoldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeScaffoldModule, declarations: [ScaffoldComponent], imports: [CommonModule], exports: [ScaffoldComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeScaffoldModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeScaffoldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [ScaffoldComponent],
                    exports: [ScaffoldComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class SelectComponent {
    /** Controls the label text. */
    set label(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.label = value;
        });
    }
    get label() {
        return this.nativeElement.label;
    }
    /** Controls the placeholder text. */
    set placeholder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.placeholder = value;
        });
    }
    get placeholder() {
        return this.nativeElement.placeholder;
    }
    set readonly(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.readonly = value;
        });
    }
    get readonly() {
        return this.nativeElement.readonly;
    }
    /** Whether the label floats above the field. */
    set floatLabel(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.floatLabel = value;
        });
    }
    get floatLabel() {
        return this.nativeElement.floatLabel;
    }
    /** The density of the field. */
    set density(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.density = value;
        });
    }
    get density() {
        return this.nativeElement.density;
    }
    /** Whether the field is dense. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** Whether the field is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Whether the field is required. */
    set required(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.required = value;
        });
    }
    get required() {
        return this.nativeElement.required;
    }
    /** The position of the label. */
    set labelPosition(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.labelPosition = value;
        });
    }
    get labelPosition() {
        return this.nativeElement.labelPosition;
    }
    /** Gets/sets the value. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Gets/sets the selected index. */
    set selectedIndex(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selectedIndex = value;
        });
    }
    get selectedIndex() {
        return this.nativeElement.selectedIndex;
    }
    /** Gets/sets the available options. */
    set options(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.options = value;
        });
    }
    get options() {
        return this.nativeElement.options;
    }
    /** Gets/sets the multiple select state. */
    set multiple(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.multiple = value;
        });
    }
    get multiple() {
        return this.nativeElement.multiple;
    }
    /** Gets/sets the open state. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** Gets/sets the option builder function. */
    set optionBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.optionBuilder = value;
        });
    }
    get optionBuilder() {
        return this.nativeElement.optionBuilder;
    }
    /** Gets/sets the selected text builder function. */
    set selectedTextBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selectedTextBuilder = value;
        });
    }
    get selectedTextBuilder() {
        return this.nativeElement.selectedTextBuilder;
    }
    /** Gets/sets the before value change callback. */
    set beforeValueChange(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.beforeValueChange = value;
        });
    }
    get beforeValueChange() {
        return this.nativeElement.beforeValueChange;
    }
    /** The alignment of the label. */
    set labelAlignment(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.labelAlignment = value;
        });
    }
    get labelAlignment() {
        return this.nativeElement.labelAlignment;
    }
    /** Whether the field is invalid. */
    set invalid(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.invalid = value;
        });
    }
    get invalid() {
        return this.nativeElement.invalid;
    }
    /** Whether the field is optional. */
    set optional(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.optional = value;
        });
    }
    get optional() {
        return this.nativeElement.optional;
    }
    /** The variant of the field. */
    set variant(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.variant = value;
        });
    }
    get variant() {
        return this.nativeElement.variant;
    }
    /** The theme of the field. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    /** The shape of the field. */
    set shape(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.shape = value;
        });
    }
    get shape() {
        return this.nativeElement.shape;
    }
    /** Whether the popover icon is displayed. */
    set popoverIcon(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popoverIcon = value;
        });
    }
    get popoverIcon() {
        return this.nativeElement.popoverIcon;
    }
    /** The inset of the support text. */
    set supportTextInset(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.supportTextInset = value;
        });
    }
    get supportTextInset() {
        return this.nativeElement.supportTextInset;
    }
    setFormValue(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.setFormValue(...args));
    }
    /** Floats the label without an animation. Only applies when the label is inset. */
    floatLabelWithoutAnimation(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.floatLabelWithoutAnimation(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-select element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineSelectComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SelectComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: SelectComponent, selector: "forge-select", inputs: { label: "label", placeholder: "placeholder", readonly: ["readonly", "readonly", booleanAttribute], floatLabel: ["floatLabel", "floatLabel", booleanAttribute], density: "density", dense: ["dense", "dense", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], required: ["required", "required", booleanAttribute], labelPosition: "labelPosition", value: "value", selectedIndex: "selectedIndex", options: "options", multiple: ["multiple", "multiple", booleanAttribute], open: ["open", "open", booleanAttribute], optionBuilder: "optionBuilder", selectedTextBuilder: "selectedTextBuilder", beforeValueChange: "beforeValueChange", labelAlignment: "labelAlignment", invalid: ["invalid", "invalid", booleanAttribute], optional: ["optional", "optional", booleanAttribute], variant: "variant", theme: "theme", shape: "shape", popoverIcon: ["popoverIcon", "popoverIcon", booleanAttribute], supportTextInset: "supportTextInset" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SelectComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-select',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { label: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], readonly: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], floatLabel: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], density: [{
                type: Input
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], required: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], labelPosition: [{
                type: Input
            }], value: [{
                type: Input
            }], selectedIndex: [{
                type: Input
            }], options: [{
                type: Input
            }], multiple: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], optionBuilder: [{
                type: Input
            }], selectedTextBuilder: [{
                type: Input
            }], beforeValueChange: [{
                type: Input
            }], labelAlignment: [{
                type: Input
            }], invalid: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], optional: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], variant: [{
                type: Input
            }], theme: [{
                type: Input
            }], shape: [{
                type: Input
            }], popoverIcon: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], supportTextInset: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeSelectProxyModule {
    constructor() {
        defineSelectComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSelectProxyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeSelectProxyModule, declarations: [SelectComponent], imports: [CommonModule, ForgeOptionModule], exports: [SelectComponent, ForgeOptionModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSelectProxyModule, imports: [CommonModule, ForgeOptionModule, ForgeOptionModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSelectProxyModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ForgeOptionModule],
                    declarations: [SelectComponent],
                    exports: [SelectComponent, ForgeOptionModule]
                }]
        }], ctorParameters: () => [] });

const SELECT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => SelectValueAccessor),
    multi: true
};
class SelectValueAccessor {
    selectChange(event) {
        this.change(event.target.value);
    }
    blur() {
        this.onTouched();
    }
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    writeValue(value) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    change(value) {
        this.onChange(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SelectValueAccessor, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.7", type: SelectValueAccessor, selector: "forge-select[formControlName],forge-select[formControl],forge-select[ngModel]", host: { listeners: { "change": "selectChange($event)", "blur": "blur()" } }, providers: [SELECT_VALUE_ACCESSOR], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SelectValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'forge-select[formControlName],forge-select[formControl],forge-select[ngModel]',
                    providers: [SELECT_VALUE_ACCESSOR]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { selectChange: [{
                type: HostListener,
                args: ['change', ['$event']]
            }], blur: [{
                type: HostListener,
                args: ['blur']
            }] } });

class ForgeSelectModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSelectModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeSelectModule, declarations: [SelectValueAccessor], exports: [SelectValueAccessor,
            ForgeSelectProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSelectModule, imports: [ForgeSelectProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSelectModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        SelectValueAccessor
                    ],
                    exports: [
                        SelectValueAccessor,
                        ForgeSelectProxyModule
                    ]
                }]
        }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class SelectDropdownComponent {
    /** Sets the target element CSS selector */
    set target(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.target = value;
        });
    }
    get target() {
        return this.nativeElement.target;
    }
    /** Sets the selected text element CSS selector */
    set selectedTextTarget(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selectedTextTarget = value;
        });
    }
    get selectedTextTarget() {
        return this.nativeElement.selectedTextTarget;
    }
    /** Controls whether the selected text is synchronized to the target elements' text content. Default is false. */
    set syncSelectedText(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.syncSelectedText = value;
        });
    }
    get syncSelectedText() {
        return this.nativeElement.syncSelectedText;
    }
    /** Gets/sets the value. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Gets/sets the selected index. */
    set selectedIndex(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selectedIndex = value;
        });
    }
    get selectedIndex() {
        return this.nativeElement.selectedIndex;
    }
    /** Gets/sets the available options. */
    set options(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.options = value;
        });
    }
    get options() {
        return this.nativeElement.options;
    }
    /** Gets/sets the multiple select state. */
    set multiple(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.multiple = value;
        });
    }
    get multiple() {
        return this.nativeElement.multiple;
    }
    /** Gets the open state of the dropdown. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** Sets the option builder callback that will be executed when building the option list in the dropdown. */
    set optionBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.optionBuilder = value;
        });
    }
    get optionBuilder() {
        return this.nativeElement.optionBuilder;
    }
    /** Sets the selected text builder callback that will be executed when getting the selected text to display in the field. */
    set selectedTextBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selectedTextBuilder = value;
        });
    }
    get selectedTextBuilder() {
        return this.nativeElement.selectedTextBuilder;
    }
    /** Sets the callback to be executed when the user selects a value. */
    set beforeValueChange(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.beforeValueChange = value;
        });
    }
    get beforeValueChange() {
        return this.nativeElement.beforeValueChange;
    }
    /** Gets the popup element (when the dropdown is open). */
    get popupElement() {
        return this.nativeElement.popupElement;
    }
    /** Gets/sets the list of classes to apply to the popup element. */
    set popupClasses(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popupClasses = value;
        });
    }
    get popupClasses() {
        return this.nativeElement.popupClasses;
    }
    /** Gets/sets the callback function for generating header content within the popup. */
    set popupHeaderBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popupHeaderBuilder = value;
        });
    }
    get popupHeaderBuilder() {
        return this.nativeElement.popupHeaderBuilder;
    }
    /** Gets/sets the callback function for generating header content within the popup. */
    set popupFooterBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popupFooterBuilder = value;
        });
    }
    get popupFooterBuilder() {
        return this.nativeElement.popupFooterBuilder;
    }
    /** Gets/sets whether the popup width is synchronized with the popup target width. */
    set syncPopupWidth(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.syncPopupWidth = value;
        });
    }
    get syncPopupWidth() {
        return this.nativeElement.syncPopupWidth;
    }
    /** Gets/sets the maximum number of options to display in the dropdown. */
    set optionLimit(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.optionLimit = value;
        });
    }
    get optionLimit() {
        return this.nativeElement.optionLimit;
    }
    /** Controls the observation of scroll events on the dropdown. */
    set observeScroll(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.observeScroll = value;
        });
    }
    get observeScroll() {
        return this.nativeElement.observeScroll;
    }
    /** The number of pixels from the bottom to trigger the scroll bottom event. Only applicable if `observeScroll` is true. */
    set observeScrollThreshold(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.observeScrollThreshold = value;
        });
    }
    get observeScrollThreshold() {
        return this.nativeElement.observeScrollThreshold;
    }
    /** Gets/sets whether the popup width will be constrained to a max width of the viewport width (default: `100vw`). */
    set constrainPopupWidth(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.constrainPopupWidth = value;
        });
    }
    get constrainPopupWidth() {
        return this.nativeElement.constrainPopupWidth;
    }
    /**
     * Gets/sets whether the options will wrap their text or not.
     * This only applies if `constrainPopupWidth` is `true`, if there is an explicit width set via CSS.
     */
    set wrapOptionText(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.wrapOptionText = value;
        });
    }
    get wrapOptionText() {
        return this.nativeElement.wrapOptionText;
    }
    /** Dynamically appends options to the dropdown while it's open. */
    appendOptions(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.appendOptions(...args));
    }
    /** Selects all options. */
    selectAll(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.selectAll(...args));
    }
    /** Deselects all options. */
    deselectAll(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.deselectAll(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-select-dropdown element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineSelectDropdownComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SelectDropdownComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: SelectDropdownComponent, selector: "forge-select-dropdown", inputs: { target: "target", selectedTextTarget: "selectedTextTarget", syncSelectedText: ["syncSelectedText", "syncSelectedText", booleanAttribute], value: "value", selectedIndex: "selectedIndex", options: "options", multiple: ["multiple", "multiple", booleanAttribute], open: ["open", "open", booleanAttribute], optionBuilder: "optionBuilder", selectedTextBuilder: "selectedTextBuilder", beforeValueChange: "beforeValueChange", popupClasses: "popupClasses", popupHeaderBuilder: "popupHeaderBuilder", popupFooterBuilder: "popupFooterBuilder", syncPopupWidth: ["syncPopupWidth", "syncPopupWidth", booleanAttribute], optionLimit: ["optionLimit", "optionLimit", numberAttribute], observeScroll: ["observeScroll", "observeScroll", booleanAttribute], observeScrollThreshold: ["observeScrollThreshold", "observeScrollThreshold", numberAttribute], constrainPopupWidth: ["constrainPopupWidth", "constrainPopupWidth", booleanAttribute], wrapOptionText: ["wrapOptionText", "wrapOptionText", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SelectDropdownComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-select-dropdown',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { target: [{
                type: Input
            }], selectedTextTarget: [{
                type: Input
            }], syncSelectedText: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], value: [{
                type: Input
            }], selectedIndex: [{
                type: Input
            }], options: [{
                type: Input
            }], multiple: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], optionBuilder: [{
                type: Input
            }], selectedTextBuilder: [{
                type: Input
            }], beforeValueChange: [{
                type: Input
            }], popupClasses: [{
                type: Input
            }], popupHeaderBuilder: [{
                type: Input
            }], popupFooterBuilder: [{
                type: Input
            }], syncPopupWidth: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], optionLimit: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], observeScroll: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], observeScrollThreshold: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], constrainPopupWidth: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], wrapOptionText: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeSelectDropdownModule {
    constructor() {
        defineSelectDropdownComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSelectDropdownModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeSelectDropdownModule, declarations: [SelectDropdownComponent], imports: [CommonModule], exports: [SelectDropdownComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSelectDropdownModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSelectDropdownModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [SelectDropdownComponent],
                    exports: [SelectDropdownComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class SkeletonComponent {
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-skeleton element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineSkeletonComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SkeletonComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.7", type: SkeletonComponent, selector: "forge-skeleton", ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SkeletonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-skeleton',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeSkeletonModule {
    constructor() {
        defineSkeletonComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSkeletonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeSkeletonModule, declarations: [SkeletonComponent], imports: [CommonModule], exports: [SkeletonComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSkeletonModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSkeletonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [SkeletonComponent],
                    exports: [SkeletonComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class SkipLinkComponent {
    /** The IDREF of the element to which the skip link should navigate. */
    set target(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.target = value;
        });
    }
    get target() {
        return this.nativeElement.target;
    }
    /** The theme applied to the skip link. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    /** Whether or not the skip link uses a muted color scheme. */
    set muted(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.muted = value;
        });
    }
    get muted() {
        return this.nativeElement.muted;
    }
    /** Whether or not the skip link should remain visible when not focused. */
    set persistent(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.persistent = value;
        });
    }
    get persistent() {
        return this.nativeElement.persistent;
    }
    /** Whether or not the skip link renders within its container. */
    set inline(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.inline = value;
        });
    }
    get inline() {
        return this.nativeElement.inline;
    }
    /** Sets the skip link to skip browser navigation and scroll to the target element. */
    set skipUrlChange(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.skipUrlChange = value;
        });
    }
    get skipUrlChange() {
        return this.nativeElement.skipUrlChange;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-skip-link element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineSkipLinkComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SkipLinkComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: SkipLinkComponent, selector: "forge-skip-link", inputs: { target: "target", theme: "theme", muted: ["muted", "muted", booleanAttribute], persistent: ["persistent", "persistent", booleanAttribute], inline: ["inline", "inline", booleanAttribute], skipUrlChange: ["skipUrlChange", "skipUrlChange", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SkipLinkComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-skip-link',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { target: [{
                type: Input
            }], theme: [{
                type: Input
            }], muted: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], persistent: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], inline: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], skipUrlChange: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeSkipLinkModule {
    constructor() {
        defineSkipLinkComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSkipLinkModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeSkipLinkModule, declarations: [SkipLinkComponent], imports: [CommonModule], exports: [SkipLinkComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSkipLinkModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSkipLinkModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [SkipLinkComponent],
                    exports: [SkipLinkComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class SliderComponent {
    get form() {
        return this.nativeElement.form;
    }
    get labels() {
        return this.nativeElement.labels;
    }
    /** The form control name. */
    set name(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.name = value;
        });
    }
    get name() {
        return this.nativeElement.name;
    }
    /** The form control name for the start handle in range mode. */
    set nameStart(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.nameStart = value;
        });
    }
    get nameStart() {
        return this.nativeElement.nameStart;
    }
    /** The form control name for the end handle in range mode. */
    set nameEnd(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.nameEnd = value;
        });
    }
    get nameEnd() {
        return this.nativeElement.nameEnd;
    }
    /** The current value of the slider. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** The current start value of the slider. */
    set valueStart(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.valueStart = value;
        });
    }
    get valueStart() {
        return this.nativeElement.valueStart;
    }
    /** The current end value of the slider. */
    set valueEnd(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.valueEnd = value;
        });
    }
    get valueEnd() {
        return this.nativeElement.valueEnd;
    }
    /** The label text for the slider handle. */
    set label(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.label = value;
        });
    }
    get label() {
        return this.nativeElement.label;
    }
    /** The label text for the start slider handle. */
    set labelStart(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.labelStart = value;
        });
    }
    get labelStart() {
        return this.nativeElement.labelStart;
    }
    /** The label text for the end slider handle. */
    set labelEnd(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.labelEnd = value;
        });
    }
    get labelEnd() {
        return this.nativeElement.labelEnd;
    }
    /** A function that returns a label for the slider handle. */
    set labelBuilder(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.labelBuilder = value;
        });
    }
    get labelBuilder() {
        return this.nativeElement.labelBuilder;
    }
    /** The minimum value of the slider. */
    set min(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.min = value;
        });
    }
    get min() {
        return this.nativeElement.min;
    }
    /** The maximum value of the slider. */
    set max(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.max = value;
        });
    }
    get max() {
        return this.nativeElement.max;
    }
    /** The step value of the slider. */
    set step(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.step = value;
        });
    }
    get step() {
        return this.nativeElement.step;
    }
    /** Controls if tickmarks are visible. */
    set tickmarks(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.tickmarks = value;
        });
    }
    get tickmarks() {
        return this.nativeElement.tickmarks;
    }
    /** Controls if labels are visible. */
    set labeled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.labeled = value;
        });
    }
    get labeled() {
        return this.nativeElement.labeled;
    }
    /** Controls range mode. */
    set range(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.range = value;
        });
    }
    get range() {
        return this.nativeElement.range;
    }
    /** Controls if the slider is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Controls if the slider is readonly. */
    set readonly(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.readonly = value;
        });
    }
    get readonly() {
        return this.nativeElement.readonly;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-slider element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineSliderComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SliderComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: SliderComponent, selector: "forge-slider", inputs: { name: "name", nameStart: "nameStart", nameEnd: "nameEnd", value: ["value", "value", numberAttribute], valueStart: ["valueStart", "valueStart", numberAttribute], valueEnd: ["valueEnd", "valueEnd", numberAttribute], label: "label", labelStart: "labelStart", labelEnd: "labelEnd", labelBuilder: "labelBuilder", min: ["min", "min", numberAttribute], max: ["max", "max", numberAttribute], step: ["step", "step", numberAttribute], tickmarks: ["tickmarks", "tickmarks", booleanAttribute], labeled: ["labeled", "labeled", booleanAttribute], range: ["range", "range", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], readonly: ["readonly", "readonly", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SliderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-slider',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { name: [{
                type: Input
            }], nameStart: [{
                type: Input
            }], nameEnd: [{
                type: Input
            }], value: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], valueStart: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], valueEnd: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], label: [{
                type: Input
            }], labelStart: [{
                type: Input
            }], labelEnd: [{
                type: Input
            }], labelBuilder: [{
                type: Input
            }], min: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], max: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], step: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], tickmarks: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], labeled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], range: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], readonly: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeSliderProxyModule {
    constructor() {
        defineSliderComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSliderProxyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeSliderProxyModule, declarations: [SliderComponent], imports: [CommonModule], exports: [SliderComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSliderProxyModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSliderProxyModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [SliderComponent],
                    exports: [SliderComponent]
                }]
        }], ctorParameters: () => [] });

const SLIDER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => SliderValueAccessor),
    multi: true
};
class SliderValueAccessor {
    sliderChange(event) {
        this.change(event.detail.value);
    }
    sliderInput(event) {
        this.change(event.detail.value);
    }
    sliderRangeChange(event) {
        this.change(event.detail);
    }
    sliderRangeInput(event) {
        this.change(event.detail);
    }
    blur() {
        this.onTouched();
    }
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    writeValue(value) {
        if (this._elementRef.nativeElement.range) {
            if (value === null || value === undefined || typeof value !== 'object') {
                this._renderer.setProperty(this._elementRef.nativeElement, 'valueStart', 0);
                this._renderer.setProperty(this._elementRef.nativeElement, 'valueEnd', 0);
                return;
            }
            if ('valueStart' in value) {
                this._renderer.setProperty(this._elementRef.nativeElement, 'valueStart', this._toFloat(value.valueStart));
            }
            if ('valueStart' in value) {
                this._renderer.setProperty(this._elementRef.nativeElement, 'valueEnd', this._toFloat(value.valueEnd));
            }
        }
        else {
            this._renderer.setProperty(this._elementRef.nativeElement, 'value', this._toFloat(value));
        }
    }
    registerOnChange(fn) {
        this.onChange = value => fn(value);
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    change(value) {
        this.onChange(value);
    }
    _toFloat(value) {
        if (value === null || value === undefined) {
            return 0;
        }
        const parsedValue = parseFloat(value);
        if (isNaN(parsedValue) || typeof parsedValue !== 'number') {
            return 0;
        }
        return parsedValue;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SliderValueAccessor, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.7", type: SliderValueAccessor, selector: "forge-slider[formControlName],forge-slider[formControl],forge-slider[ngModel]", host: { listeners: { "forge-slider-change": "sliderChange($event)", "forge-slider-input": "sliderInput($event)", "forge-slider-range-change": "sliderRangeChange($event)", "forge-slider-range-input": "sliderRangeInput($event)", "blur": "blur()" } }, providers: [SLIDER_VALUE_ACCESSOR], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SliderValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'forge-slider[formControlName],forge-slider[formControl],forge-slider[ngModel]',
                    providers: [SLIDER_VALUE_ACCESSOR]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { sliderChange: [{
                type: HostListener,
                args: ['forge-slider-change', ['$event']]
            }], sliderInput: [{
                type: HostListener,
                args: ['forge-slider-input', ['$event']]
            }], sliderRangeChange: [{
                type: HostListener,
                args: ['forge-slider-range-change', ['$event']]
            }], sliderRangeInput: [{
                type: HostListener,
                args: ['forge-slider-range-input', ['$event']]
            }], blur: [{
                type: HostListener,
                args: ['blur']
            }] } });

class ForgeSliderModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSliderModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeSliderModule, declarations: [SliderValueAccessor], exports: [SliderValueAccessor,
            ForgeSliderProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSliderModule, imports: [ForgeSliderProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSliderModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        SliderValueAccessor
                    ],
                    exports: [
                        SliderValueAccessor,
                        ForgeSliderProxyModule
                    ]
                }]
        }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class SplitButtonComponent {
    /** The variant of the buttons. Valid values are `text`, `outlined`, `tonal`, `filled`, and `raised`. */
    set variant(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.variant = value;
        });
    }
    get variant() {
        return this.nativeElement.variant;
    }
    /** The theme of the buttons. Valid values are `primary`, `secondary`, `tertiary`, `success`, `error`, `warning`, `info`. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    /** Whether or not the buttons are disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Whether or not the buttons are dense. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** Whether or not the buttons are pill-shaped. */
    set pill(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.pill = value;
        });
    }
    get pill() {
        return this.nativeElement.pill;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-split-button element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineSplitButtonComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SplitButtonComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: SplitButtonComponent, selector: "forge-split-button", inputs: { variant: "variant", theme: "theme", disabled: ["disabled", "disabled", booleanAttribute], dense: ["dense", "dense", booleanAttribute], pill: ["pill", "pill", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SplitButtonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-split-button',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { variant: [{
                type: Input
            }], theme: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], pill: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeSplitButtonModule {
    constructor() {
        defineSplitButtonComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSplitButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeSplitButtonModule, declarations: [SplitButtonComponent], imports: [CommonModule], exports: [SplitButtonComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSplitButtonModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSplitButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [SplitButtonComponent],
                    exports: [SplitButtonComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class SplitViewComponent {
    /** Whether child split view panels are laid out and resize horizontally or vertically. */
    set orientation(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.orientation = value;
        });
    }
    get orientation() {
        return this.nativeElement.orientation;
    }
    /** Whether child split view panels have resize interactions disabled or enabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Whether child split view panels can be closed via keyboard interaction. */
    set allowClose(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.allowClose = value;
        });
    }
    get allowClose() {
        return this.nativeElement.allowClose;
    }
    /** Whether child split view panels automatically close when they reach a size of 0. */
    set autoClose(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.autoClose = value;
        });
    }
    get autoClose() {
        return this.nativeElement.autoClose;
    }
    /** The size at which panels auto close. */
    set autoCloseThreshold(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.autoCloseThreshold = value;
        });
    }
    get autoCloseThreshold() {
        return this.nativeElement.autoCloseThreshold;
    }
    /** Arranges split view panels to avoid overlapping during animations. */
    layerSlottedPanels(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.layerSlottedPanels(...args));
    }
    /** Removes presentation data set during an animation. */
    unlayerSlottedPanels(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.unlayerSlottedPanels(...args));
    }
    /** Updates the provided characteristics of each slotted panel. */
    update(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.update(...args));
    }
    /** Resizes panels within the split view to avoid overflow. */
    refit(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.refit(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-split-view element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineSplitViewComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SplitViewComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: SplitViewComponent, selector: "forge-split-view", inputs: { orientation: "orientation", disabled: ["disabled", "disabled", booleanAttribute], allowClose: ["allowClose", "allowClose", booleanAttribute], autoClose: ["autoClose", "autoClose", booleanAttribute], autoCloseThreshold: ["autoCloseThreshold", "autoCloseThreshold", numberAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SplitViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-split-view',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { orientation: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], allowClose: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], autoClose: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], autoCloseThreshold: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class SplitViewPanelComponent {
    /** Controls which side of the panel the resize handle appears on. */
    set resizable(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.resizable = value;
        });
    }
    get resizable() {
        return this.nativeElement.resizable;
    }
    /** The initial size along the axis of orientation. */
    set size(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.size = value;
        });
    }
    get size() {
        return this.nativeElement.size;
    }
    /** The smallest size the panel can take along its axis of orientation. */
    set min(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.min = value;
        });
    }
    get min() {
        return this.nativeElement.min;
    }
    /** The largest size the panel can take along its axis of orientation. */
    set max(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.max = value;
        });
    }
    get max() {
        return this.nativeElement.max;
    }
    /** The ARIA label given to the resize handle. */
    set accessibleLabel(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.accessibleLabel = value;
        });
    }
    get accessibleLabel() {
        return this.nativeElement.accessibleLabel;
    }
    /** Controls the open state of the panel. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** Whether resize interactions are disabled or enabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Whether the panel can be closed via keyboard interaction. */
    set allowClose(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.allowClose = value;
        });
    }
    get allowClose() {
        return this.nativeElement.allowClose;
    }
    /** Whether the panel automatically closes when it reaches a size of 0. */
    set autoClose(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.autoClose = value;
        });
    }
    get autoClose() {
        return this.nativeElement.autoClose;
    }
    /** The size at which the panel auto closes. */
    set autoCloseThreshold(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.autoCloseThreshold = value;
        });
    }
    get autoCloseThreshold() {
        return this.nativeElement.autoCloseThreshold;
    }
    /** Gets the size of content along the axis of orientation. */
    getContentSize(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.getContentSize(...args));
    }
    /**
     * Gets the amount that the content can shrink along the axis of orientation before reaching its
     * min size.
     */
    getCollapsibleSize(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.getCollapsibleSize(...args));
    }
    /** Sets the size of content along the axis of orientation. */
    setContentSize(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.setContentSize(...args));
    }
    /** Updates the provided characteristics. */
    update(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.update(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-split-view-panel element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineSplitViewPanelComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SplitViewPanelComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: SplitViewPanelComponent, selector: "forge-split-view-panel", inputs: { resizable: "resizable", size: "size", min: "min", max: "max", accessibleLabel: "accessibleLabel", open: ["open", "open", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], allowClose: ["allowClose", "allowClose", booleanAttribute], autoClose: ["autoClose", "autoClose", booleanAttribute], autoCloseThreshold: ["autoCloseThreshold", "autoCloseThreshold", numberAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SplitViewPanelComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-split-view-panel',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { resizable: [{
                type: Input
            }], size: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], accessibleLabel: [{
                type: Input
            }], open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], allowClose: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], autoClose: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], autoCloseThreshold: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeSplitViewPanelModule {
    constructor() {
        defineSplitViewPanelComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSplitViewPanelModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeSplitViewPanelModule, declarations: [SplitViewPanelComponent], imports: [CommonModule], exports: [SplitViewPanelComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSplitViewPanelModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSplitViewPanelModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [SplitViewPanelComponent],
                    exports: [SplitViewPanelComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeSplitViewModule {
    constructor() {
        defineSplitViewComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSplitViewModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeSplitViewModule, declarations: [SplitViewComponent], imports: [CommonModule, ForgeSplitViewPanelModule], exports: [SplitViewComponent, ForgeSplitViewPanelModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSplitViewModule, imports: [CommonModule, ForgeSplitViewPanelModule, ForgeSplitViewPanelModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSplitViewModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ForgeSplitViewPanelModule],
                    declarations: [SplitViewComponent],
                    exports: [SplitViewComponent, ForgeSplitViewPanelModule]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class StackComponent {
    /** Controls the direction of the stack. */
    set inline(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.inline = value;
        });
    }
    get inline() {
        return this.nativeElement.inline;
    }
    /** Controls if items wrap to a new line in inline mode */
    set wrap(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.wrap = value;
        });
    }
    get wrap() {
        return this.nativeElement.wrap;
    }
    /** Controls if items stretch and take up the maximum amount of space */
    set stretch(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.stretch = value;
        });
    }
    get stretch() {
        return this.nativeElement.stretch;
    }
    /** Controls the gap between the children within the stack */
    set gap(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.gap = value;
        });
    }
    get gap() {
        return this.nativeElement.gap;
    }
    /** Controls the align-items property of a row or column */
    set alignment(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.alignment = value;
        });
    }
    get alignment() {
        return this.nativeElement.alignment;
    }
    /** Controls the justify-content property of a row or column */
    set justify(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.justify = value;
        });
    }
    get justify() {
        return this.nativeElement.justify;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-stack element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineStackComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: StackComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: StackComponent, selector: "forge-stack", inputs: { inline: ["inline", "inline", booleanAttribute], wrap: ["wrap", "wrap", booleanAttribute], stretch: ["stretch", "stretch", booleanAttribute], gap: "gap", alignment: "alignment", justify: "justify" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: StackComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-stack',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { inline: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], wrap: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], stretch: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], gap: [{
                type: Input
            }], alignment: [{
                type: Input
            }], justify: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeStackModule {
    constructor() {
        defineStackComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeStackModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeStackModule, declarations: [StackComponent], imports: [CommonModule], exports: [StackComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeStackModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeStackModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [StackComponent],
                    exports: [StackComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class StateLayerComponent {
    /** The element to attach the state layer to. */
    set targetElement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.targetElement = value;
        });
    }
    get targetElement() {
        return this.nativeElement.targetElement;
    }
    /** The id of the element to attach the state layer to. */
    set target(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.target = value;
        });
    }
    get target() {
        return this.nativeElement.target;
    }
    /** Controls whether the state layer is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /**
     * Triggers the animation to run.
     *
     * Note: If coordinates are not provided, the transition will originate from the center of the target element.
     */
    playAnimation(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.playAnimation(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-state-layer element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineStateLayerComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: StateLayerComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: StateLayerComponent, selector: "forge-state-layer", inputs: { targetElement: "targetElement", target: "target", disabled: ["disabled", "disabled", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: StateLayerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-state-layer',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { targetElement: [{
                type: Input
            }], target: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeStateLayerModule {
    constructor() {
        defineStateLayerComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeStateLayerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeStateLayerModule, declarations: [StateLayerComponent], imports: [CommonModule], exports: [StateLayerComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeStateLayerModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeStateLayerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [StateLayerComponent],
                    exports: [StateLayerComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class StepComponent {
    /** Whether the step is in the alternative style. */
    set alternative(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.alternative = value;
        });
    }
    get alternative() {
        return this.nativeElement.alternative;
    }
    /** The index of the step. */
    set index(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.index = value;
        });
    }
    get index() {
        return this.nativeElement.index;
    }
    /** Whether the step is editable. */
    set editable(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.editable = value;
        });
    }
    get editable() {
        return this.nativeElement.editable;
    }
    /** Whether the step is completed. */
    set completed(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.completed = value;
        });
    }
    get completed() {
        return this.nativeElement.completed;
    }
    /** Whether the step has an error. */
    set error(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.error = value;
        });
    }
    get error() {
        return this.nativeElement.error;
    }
    /** Whether the step is selected. */
    set selected(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selected = value;
        });
    }
    get selected() {
        return this.nativeElement.selected;
    }
    /** Whether the step is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Whether the step is in vertical mode. */
    set vertical(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.vertical = value;
        });
    }
    get vertical() {
        return this.nativeElement.vertical;
    }
    /** Whether the step is expanded. */
    set expanded(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.expanded = value;
        });
    }
    get expanded() {
        return this.nativeElement.expanded;
    }
    /** Whether the step should ignore user expansion. */
    set ignoreUserExpansion(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.ignoreUserExpansion = value;
        });
    }
    get ignoreUserExpansion() {
        return this.nativeElement.ignoreUserExpansion;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-step element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineStepComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: StepComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: StepComponent, selector: "forge-step", inputs: { alternative: ["alternative", "alternative", booleanAttribute], index: ["index", "index", numberAttribute], editable: ["editable", "editable", booleanAttribute], completed: ["completed", "completed", booleanAttribute], error: ["error", "error", booleanAttribute], selected: ["selected", "selected", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], vertical: ["vertical", "vertical", booleanAttribute], expanded: ["expanded", "expanded", booleanAttribute], ignoreUserExpansion: ["ignoreUserExpansion", "ignoreUserExpansion", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: StepComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-step',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { alternative: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], index: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], editable: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], completed: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], error: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], selected: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], vertical: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], expanded: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], ignoreUserExpansion: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeStepModule {
    constructor() {
        defineStepComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeStepModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeStepModule, declarations: [StepComponent], imports: [CommonModule], exports: [StepComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeStepModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeStepModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [StepComponent],
                    exports: [StepComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class StepperComponent {
    /** The step configurations. */
    set steps(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.steps = value;
        });
    }
    get steps() {
        return this.nativeElement.steps;
    }
    /** The active step index. */
    set selectedIndex(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selectedIndex = value;
        });
    }
    get selectedIndex() {
        return this.nativeElement.selectedIndex;
    }
    /** Whether the stepper is linear or non-linear. */
    set linear(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.linear = value;
        });
    }
    get linear() {
        return this.nativeElement.linear;
    }
    /** Whether the stepper uses the default or alternative label layout mode. */
    set alternative(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.alternative = value;
        });
    }
    get alternative() {
        return this.nativeElement.alternative;
    }
    /** The layout mode of the stepper. */
    set layoutMode(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.layoutMode = value;
        });
    }
    get layoutMode() {
        return this.nativeElement.layoutMode;
    }
    /** The layout alignment of the stepper. */
    set layoutAlign(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.layoutAlign = value;
        });
    }
    get layoutAlign() {
        return this.nativeElement.layoutAlign;
    }
    /** Whether the stepper is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Whether the stepper is vertical. */
    set vertical(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.vertical = value;
        });
    }
    get vertical() {
        return this.nativeElement.vertical;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-stepper element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineStepperComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: StepperComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: StepperComponent, selector: "forge-stepper", inputs: { steps: "steps", selectedIndex: ["selectedIndex", "selectedIndex", numberAttribute], linear: ["linear", "linear", booleanAttribute], alternative: ["alternative", "alternative", booleanAttribute], layoutMode: "layoutMode", layoutAlign: "layoutAlign", disabled: ["disabled", "disabled", booleanAttribute], vertical: ["vertical", "vertical", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: StepperComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-stepper',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { steps: [{
                type: Input
            }], selectedIndex: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], linear: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], alternative: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], layoutMode: [{
                type: Input
            }], layoutAlign: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], vertical: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeStepperModule {
    constructor() {
        defineStepperComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeStepperModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeStepperModule, declarations: [StepperComponent], imports: [CommonModule, ForgeStepModule], exports: [StepperComponent, ForgeStepModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeStepperModule, imports: [CommonModule, ForgeStepModule, ForgeStepModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeStepperModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ForgeStepModule],
                    declarations: [StepperComponent],
                    exports: [StepperComponent, ForgeStepModule]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class SwitchComponent {
    /** Gets/sets whether the switch is on or off. */
    set on(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.on = value;
        });
    }
    get on() {
        return this.nativeElement.on;
    }
    /** Alias for `on` _(deprecated)_. */
    set selected(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selected = value;
        });
    }
    get selected() {
        return this.nativeElement.selected;
    }
    /** Gets/sets whether the switch is on or off by default. */
    set defaultOn(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.defaultOn = value;
        });
    }
    get defaultOn() {
        return this.nativeElement.defaultOn;
    }
    /** Gets/sets the value of the switch. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Controls whether the switch is dense. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** Controls whether the switch is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Controls whether the switch is required. */
    set required(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.required = value;
        });
    }
    get required() {
        return this.nativeElement.required;
    }
    /** Controls whether the switch is readonly. */
    set readonly(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.readonly = value;
        });
    }
    get readonly() {
        return this.nativeElement.readonly;
    }
    /** Controls the presence of the off and on icons. */
    set icon(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.icon = value;
        });
    }
    get icon() {
        return this.nativeElement.icon;
    }
    /** Controls whether the label appears before or after the switch. */
    set labelPosition(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.labelPosition = value;
        });
    }
    get labelPosition() {
        return this.nativeElement.labelPosition;
    }
    /** Toggles the switch on or off. */
    toggle(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.toggle(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-switch element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineSwitchComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SwitchComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: SwitchComponent, selector: "forge-switch", inputs: { on: ["on", "on", booleanAttribute], selected: ["selected", "selected", booleanAttribute], defaultOn: ["defaultOn", "defaultOn", booleanAttribute], value: "value", dense: ["dense", "dense", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], required: ["required", "required", booleanAttribute], readonly: ["readonly", "readonly", booleanAttribute], icon: "icon", labelPosition: "labelPosition" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SwitchComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-switch',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { on: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], selected: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], defaultOn: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], value: [{
                type: Input
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], required: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], readonly: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], icon: [{
                type: Input
            }], labelPosition: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeSwitchProxyModule {
    constructor() {
        defineSwitchComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSwitchProxyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeSwitchProxyModule, declarations: [SwitchComponent], imports: [CommonModule], exports: [SwitchComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSwitchProxyModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSwitchProxyModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [SwitchComponent],
                    exports: [SwitchComponent]
                }]
        }], ctorParameters: () => [] });

const SWITCH_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => SwitchValueAccessor),
    multi: true
};
class SwitchValueAccessor {
    switchChange(evt) {
        this.change(evt.detail);
    }
    blur() {
        this.onTouched();
    }
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    writeValue(value) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'on', Boolean(value));
    }
    registerOnChange(fn) {
        this.onChange = value => fn(value);
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(value) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', Boolean(value));
    }
    change(value) {
        this.onChange(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SwitchValueAccessor, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.7", type: SwitchValueAccessor, selector: "forge-switch[formControlName],forge-switch[formControl],forge-switch[ngModel]", host: { listeners: { "forge-switch-change": "switchChange($event)", "blur": "blur()" } }, providers: [SWITCH_VALUE_ACCESSOR], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: SwitchValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'forge-switch[formControlName],forge-switch[formControl],forge-switch[ngModel]',
                    providers: [SWITCH_VALUE_ACCESSOR]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { switchChange: [{
                type: HostListener,
                args: ['forge-switch-change', ['$event']]
            }], blur: [{
                type: HostListener,
                args: ['blur']
            }] } });

class ForgeSwitchModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSwitchModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeSwitchModule, declarations: [SwitchValueAccessor], exports: [SwitchValueAccessor,
            ForgeSwitchProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSwitchModule, imports: [ForgeSwitchProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeSwitchModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        SwitchValueAccessor
                    ],
                    exports: [
                        SwitchValueAccessor,
                        ForgeSwitchProxyModule
                    ]
                }]
        }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class TabComponent {
    /** The disabled state of the tab. Should not be set if using the disabled property on `forge-tab-bar`. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** The selected state of the tab. */
    set selected(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selected = value;
        });
    }
    get selected() {
        return this.nativeElement.selected;
    }
    /** Controls whether the tab is vertical or horizontal. */
    set vertical(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.vertical = value;
        });
    }
    get vertical() {
        return this.nativeElement.vertical;
    }
    /** Controls whether the tab is taller to allow for slotted leading/trailing elements. */
    set stacked(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.stacked = value;
        });
    }
    get stacked() {
        return this.nativeElement.stacked;
    }
    /** Controls whether the tab is styled as secondary tab navigation. */
    set secondary(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.secondary = value;
        });
    }
    get secondary() {
        return this.nativeElement.secondary;
    }
    /** Controls whether the tab indicator is rendered on the opposite side of the tab. */
    set inverted(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.inverted = value;
        });
    }
    get inverted() {
        return this.nativeElement.inverted;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-tab element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineTabComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: TabComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: TabComponent, selector: "forge-tab", inputs: { disabled: ["disabled", "disabled", booleanAttribute], selected: ["selected", "selected", booleanAttribute], vertical: ["vertical", "vertical", booleanAttribute], stacked: ["stacked", "stacked", booleanAttribute], secondary: ["secondary", "secondary", booleanAttribute], inverted: ["inverted", "inverted", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: TabComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-tab',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], selected: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], vertical: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], stacked: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], secondary: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], inverted: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeTabModule {
    constructor() {
        defineTabComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTabModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeTabModule, declarations: [TabComponent], imports: [CommonModule], exports: [TabComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTabModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTabModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [TabComponent],
                    exports: [TabComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class TabBarComponent {
    /** Sets the disabled state of all child tabs.  If true, any new tabs added to the DOM will be disabled by default. This can be used instead of setting individual tab disabled properties, mixing the two methods of disabling is not supported. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** The index of the active tab. */
    set activeTab(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.activeTab = value;
        });
    }
    get activeTab() {
        return this.nativeElement.activeTab;
    }
    /** Controls whether the tab bar is vertical or horizontal. */
    set vertical(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.vertical = value;
        });
    }
    get vertical() {
        return this.nativeElement.vertical;
    }
    /** Controls whether the tabs stretch the full width of their container or cluster together at their minimum width. */
    set clustered(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.clustered = value;
        });
    }
    get clustered() {
        return this.nativeElement.clustered;
    }
    /** Controls whether the tabs are taller to allow for slotted leading/trailing elements. */
    set stacked(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.stacked = value;
        });
    }
    get stacked() {
        return this.nativeElement.stacked;
    }
    /** Controls whether the tabs are styled as secondary tab navigation. */
    set secondary(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.secondary = value;
        });
    }
    get secondary() {
        return this.nativeElement.secondary;
    }
    /** Controls whether the tabs are rendered inverted (tab indicator at top instead of bottom). */
    set inverted(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.inverted = value;
        });
    }
    get inverted() {
        return this.nativeElement.inverted;
    }
    /** Controls whether the tabs are automatically activated when receiving focus. */
    set autoActivate(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.autoActivate = value;
        });
    }
    get autoActivate() {
        return this.nativeElement.autoActivate;
    }
    /** Controls whether scroll buttons are displayed when the tabs overflow their container. */
    set scrollButtons(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.scrollButtons = value;
        });
    }
    get scrollButtons() {
        return this.nativeElement.scrollButtons;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-tab-bar element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineTabBarComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: TabBarComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: TabBarComponent, selector: "forge-tab-bar", inputs: { disabled: ["disabled", "disabled", booleanAttribute], activeTab: ["activeTab", "activeTab", numberAttribute], vertical: ["vertical", "vertical", booleanAttribute], clustered: ["clustered", "clustered", booleanAttribute], stacked: ["stacked", "stacked", booleanAttribute], secondary: ["secondary", "secondary", booleanAttribute], inverted: ["inverted", "inverted", booleanAttribute], autoActivate: ["autoActivate", "autoActivate", booleanAttribute], scrollButtons: ["scrollButtons", "scrollButtons", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: TabBarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-tab-bar',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], activeTab: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], vertical: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], clustered: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], stacked: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], secondary: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], inverted: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], autoActivate: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], scrollButtons: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeTabBarModule {
    constructor() {
        defineTabBarComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTabBarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeTabBarModule, declarations: [TabBarComponent], imports: [CommonModule, ForgeTabModule], exports: [TabBarComponent, ForgeTabModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTabBarModule, imports: [CommonModule, ForgeTabModule, ForgeTabModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTabBarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ForgeTabModule],
                    declarations: [TabBarComponent],
                    exports: [TabBarComponent, ForgeTabModule]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class TableComponent {
    /** The data to be display in the table body. */
    set data(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.data = value;
        });
    }
    get data() {
        return this.nativeElement.data;
    }
    /** The column configuration options. */
    set columnConfigurations(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.columnConfigurations = value;
        });
    }
    get columnConfigurations() {
        return this.nativeElement.columnConfigurations;
    }
    /** Controls the visibility of the select column. */
    set select(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.select = value;
        });
    }
    get select() {
        return this.nativeElement.select;
    }
    /** Controls the visibility of the select all checkbox (only applied when `select` is `true`). */
    set multiselect(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.multiselect = value;
        });
    }
    get multiselect() {
        return this.nativeElement.multiselect;
    }
    /** The row key for matching data to selections. */
    set selectKey(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selectKey = value;
        });
    }
    get selectKey() {
        return this.nativeElement.selectKey;
    }
    /** The tooltip to display when hovering over the select column. */
    set tooltipSelect(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.tooltipSelect = value;
        });
    }
    get tooltipSelect() {
        return this.nativeElement.tooltipSelect;
    }
    /** The tooltip to display when hovering over the select all checkbox. */
    set tooltipSelectAll(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.tooltipSelectAll = value;
        });
    }
    get tooltipSelectAll() {
        return this.nativeElement.tooltipSelectAll;
    }
    /** Controls whether the table is dense or not. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** Controls whether the table is roomy or not. */
    set roomy(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.roomy = value;
        });
    }
    get roomy() {
        return this.nativeElement.roomy;
    }
    /** Controls whether the table shows its column filter row. */
    set filter(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.filter = value;
        });
    }
    get filter() {
        return this.nativeElement.filter;
    }
    /** Controls whether the table applies fixed headers when in scroll containers. */
    set fixedHeaders(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.fixedHeaders = value;
        });
    }
    get fixedHeaders() {
        return this.nativeElement.fixedHeaders;
    }
    /** Controls the table layout algorithm. */
    set layoutType(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.layoutType = value;
        });
    }
    get layoutType() {
        return this.nativeElement.layoutType;
    }
    /** Controls whether the content in each cell wraps or not (true by default). */
    set wrapContent(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.wrapContent = value;
        });
    }
    get wrapContent() {
        return this.nativeElement.wrapContent;
    }
    /** Controls whether the columns are resizable or not. */
    set resizable(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.resizable = value;
        });
    }
    get resizable() {
        return this.nativeElement.resizable;
    }
    /** Gets/sets the minimum width that a column can be resized to by the user dragging the resize handle. */
    set minResizeWidth(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.minResizeWidth = value;
        });
    }
    get minResizeWidth() {
        return this.nativeElement.minResizeWidth;
    }
    /** Gets/sets whether the rows respond to (and emit) row click events. */
    set allowRowClick(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.allowRowClick = value;
        });
    }
    get allowRowClick() {
        return this.nativeElement.allowRowClick;
    }
    /** Gets/sets whether the table supports multi-column sorting. */
    set multiColumnSort(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.multiColumnSort = value;
        });
    }
    get multiColumnSort() {
        return this.nativeElement.multiColumnSort;
    }
    /** Callback for when a row is clicked. This allows for custom logic to run after each `<tr>` is created. */
    set rowCreated(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.rowCreated = value;
        });
    }
    get rowCreated() {
        return this.nativeElement.rowCreated;
    }
    /** Callback for when a cell is clicked. This allows for custom logic to run after each `<td>` is created. */
    set cellCreated(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.cellCreated = value;
        });
    }
    get cellCreated() {
        return this.nativeElement.cellCreated;
    }
    /** The template to use for the select all checkbox in the header. */
    set selectAllTemplate(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selectAllTemplate = value;
        });
    }
    get selectAllTemplate() {
        return this.nativeElement.selectAllTemplate;
    }
    /** Controls the alignment of the select checkbox. */
    set selectCheckboxAlignment(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selectCheckboxAlignment = value;
        });
    }
    get selectCheckboxAlignment() {
        return this.nativeElement.selectCheckboxAlignment;
    }
    /** Hides a column from the table. */
    hideColumn(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.hideColumn(...args));
    }
    /** Shows a hidden column in th table. */
    showColumn(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.showColumn(...args));
    }
    /** Determines if a column at the given index is hidden or not. */
    isColumnHidden(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.isColumnHidden(...args));
    }
    /** Returns the selected row instances. */
    getSelectedRows(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.getSelectedRows(...args));
    }
    /** Selects a row in the table. Only applicable if `select` is true. */
    selectRow(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.selectRow(...args));
    }
    /** Selects one or more rows in the table. Only applicable if `select` is true. */
    selectRows(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.selectRows(...args));
    }
    /** Deselects a single row in the table. */
    deselectRow(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.deselectRow(...args));
    }
    /** Deselects one or more rows in the table. */
    deselectRows(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.deselectRows(...args));
    }
    /** Clears all selected table rows. */
    clearSelections(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.clearSelections(...args));
    }
    /** Forces the table to re-render based on its current configuration. */
    render(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.render(...args));
    }
    /** Expands a collapsed row. */
    expandRow(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.expandRow(...args));
    }
    /** Collapses an expanded row. */
    collapseRow(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.collapseRow(...args));
    }
    /** Checks if a row is expanded or not. */
    isRowExpanded(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.isRowExpanded(...args));
    }
    /** Selects a rows by an index or array of indexes. */
    selectRowsByIndex(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.selectRowsByIndex(...args));
    }
    /** Deselects a rows by an index or array of indexes. */
    deselectRowsByIndex(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.deselectRowsByIndex(...args));
    }
    /** Checks if a row is selected or not. */
    isRowSelected(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.isRowSelected(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-table element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineTableComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: TableComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: TableComponent, selector: "forge-table", inputs: { data: "data", columnConfigurations: "columnConfigurations", select: ["select", "select", booleanAttribute], multiselect: ["multiselect", "multiselect", booleanAttribute], selectKey: "selectKey", tooltipSelect: "tooltipSelect", tooltipSelectAll: "tooltipSelectAll", dense: ["dense", "dense", booleanAttribute], roomy: ["roomy", "roomy", booleanAttribute], filter: ["filter", "filter", booleanAttribute], fixedHeaders: ["fixedHeaders", "fixedHeaders", booleanAttribute], layoutType: "layoutType", wrapContent: ["wrapContent", "wrapContent", booleanAttribute], resizable: ["resizable", "resizable", booleanAttribute], minResizeWidth: ["minResizeWidth", "minResizeWidth", numberAttribute], allowRowClick: ["allowRowClick", "allowRowClick", booleanAttribute], multiColumnSort: ["multiColumnSort", "multiColumnSort", booleanAttribute], rowCreated: "rowCreated", cellCreated: "cellCreated", selectAllTemplate: "selectAllTemplate", selectCheckboxAlignment: "selectCheckboxAlignment" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: TableComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-table',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { data: [{
                type: Input
            }], columnConfigurations: [{
                type: Input
            }], select: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], multiselect: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], selectKey: [{
                type: Input
            }], tooltipSelect: [{
                type: Input
            }], tooltipSelectAll: [{
                type: Input
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], roomy: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], filter: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], fixedHeaders: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], layoutType: [{
                type: Input
            }], wrapContent: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], resizable: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], minResizeWidth: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], allowRowClick: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], multiColumnSort: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], rowCreated: [{
                type: Input
            }], cellCreated: [{
                type: Input
            }], selectAllTemplate: [{
                type: Input
            }], selectCheckboxAlignment: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeTableModule {
    constructor() {
        defineTableComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTableModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeTableModule, declarations: [TableComponent], imports: [CommonModule], exports: [TableComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTableModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTableModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [TableComponent],
                    exports: [TableComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class TextFieldComponent {
    /** Gets a reference to the element that the popover should target for best alignment. */
    get popoverTargetElement() {
        return this.nativeElement.popoverTargetElement;
    }
    /** Whether the clear button appears when text has been entered. */
    set showClear(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.showClear = value;
        });
    }
    get showClear() {
        return this.nativeElement.showClear;
    }
    /** The position of the label relative to the field. */
    set labelPosition(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.labelPosition = value;
        });
    }
    get labelPosition() {
        return this.nativeElement.labelPosition;
    }
    /** The alignment of the label relative to the field. */
    set labelAlignment(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.labelAlignment = value;
        });
    }
    get labelAlignment() {
        return this.nativeElement.labelAlignment;
    }
    /** Whether the field is in an invalid state. */
    set invalid(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.invalid = value;
        });
    }
    get invalid() {
        return this.nativeElement.invalid;
    }
    /** Whether the field is required. */
    set required(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.required = value;
        });
    }
    get required() {
        return this.nativeElement.required;
    }
    /** Whether the field is optional. */
    set optional(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.optional = value;
        });
    }
    get optional() {
        return this.nativeElement.optional;
    }
    /** Whether the field is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** Whether the label should float above the field. Only applies when the label is inset. */
    set floatLabel(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.floatLabel = value;
        });
    }
    get floatLabel() {
        return this.nativeElement.floatLabel;
    }
    /** The variant of the field. */
    set variant(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.variant = value;
        });
    }
    get variant() {
        return this.nativeElement.variant;
    }
    /** The theme of the field. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    /** The shape of the field. */
    set shape(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.shape = value;
        });
    }
    get shape() {
        return this.nativeElement.shape;
    }
    /** The density of the field. */
    set density(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.density = value;
        });
    }
    get density() {
        return this.nativeElement.density;
    }
    /** Whether the field is dense. */
    set dense(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dense = value;
        });
    }
    get dense() {
        return this.nativeElement.dense;
    }
    /** Whether the field has a popover icon. */
    set popoverIcon(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popoverIcon = value;
        });
    }
    get popoverIcon() {
        return this.nativeElement.popoverIcon;
    }
    /** Whether the field's popover is expanded. */
    set popoverExpanded(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popoverExpanded = value;
        });
    }
    get popoverExpanded() {
        return this.nativeElement.popoverExpanded;
    }
    /** The inset of the support text. */
    set supportTextInset(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.supportTextInset = value;
        });
    }
    get supportTextInset() {
        return this.nativeElement.supportTextInset;
    }
    /** Floats the label immediately. Only applies when the label is inset. */
    floatLabelWithoutAnimation(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.floatLabelWithoutAnimation(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-text-field element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineTextFieldComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: TextFieldComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: TextFieldComponent, selector: "forge-text-field", inputs: { showClear: ["showClear", "showClear", booleanAttribute], labelPosition: "labelPosition", labelAlignment: "labelAlignment", invalid: ["invalid", "invalid", booleanAttribute], required: ["required", "required", booleanAttribute], optional: ["optional", "optional", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], floatLabel: ["floatLabel", "floatLabel", booleanAttribute], variant: "variant", theme: "theme", shape: "shape", density: "density", dense: ["dense", "dense", booleanAttribute], popoverIcon: ["popoverIcon", "popoverIcon", booleanAttribute], popoverExpanded: ["popoverExpanded", "popoverExpanded", booleanAttribute], supportTextInset: "supportTextInset" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: TextFieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-text-field',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { showClear: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], labelPosition: [{
                type: Input
            }], labelAlignment: [{
                type: Input
            }], invalid: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], required: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], optional: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], floatLabel: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], variant: [{
                type: Input
            }], theme: [{
                type: Input
            }], shape: [{
                type: Input
            }], density: [{
                type: Input
            }], dense: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], popoverIcon: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], popoverExpanded: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], supportTextInset: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeTextFieldModule {
    constructor() {
        defineTextFieldComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTextFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeTextFieldModule, declarations: [TextFieldComponent], imports: [CommonModule], exports: [TextFieldComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTextFieldModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTextFieldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [TextFieldComponent],
                    exports: [TextFieldComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class TimePickerComponent {
    /** The current value of the time picker. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Whether or not the time picker is open. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** Whether or not to allow seconds in the time picker. */
    set allowSeconds(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.allowSeconds = value;
        });
    }
    get allowSeconds() {
        return this.nativeElement.allowSeconds;
    }
    /** Whether or not the time picker input should be masked. */
    set masked(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.masked = value;
        });
    }
    get masked() {
        return this.nativeElement.masked;
    }
    /** Whether or not to show the mask format in the input. */
    set showMaskFormat(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.showMaskFormat = value;
        });
    }
    get showMaskFormat() {
        return this.nativeElement.showMaskFormat;
    }
    /** Whether or not to use 24-hour time. */
    set use24HourTime(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.use24HourTime = value;
        });
    }
    get use24HourTime() {
        return this.nativeElement.use24HourTime;
    }
    /** Whether or not to allow invalid times. */
    set allowInvalidTime(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.allowInvalidTime = value;
        });
    }
    get allowInvalidTime() {
        return this.nativeElement.allowInvalidTime;
    }
    /** The minimum time that can be selected. */
    set min(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.min = value;
        });
    }
    get min() {
        return this.nativeElement.min;
    }
    /** The maximum time that can be selected. */
    set max(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.max = value;
        });
    }
    get max() {
        return this.nativeElement.max;
    }
    /** An array of times that cannot be selected. */
    set restrictedTimes(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.restrictedTimes = value;
        });
    }
    get restrictedTimes() {
        return this.nativeElement.restrictedTimes;
    }
    /** The time to start the time picker at. */
    set startTime(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.startTime = value;
        });
    }
    get startTime() {
        return this.nativeElement.startTime;
    }
    /** The step interval for the time picker. */
    set step(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.step = value;
        });
    }
    get step() {
        return this.nativeElement.step;
    }
    /** Whether or not to allow manual input of the time. */
    set allowInput(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.allowInput = value;
        });
    }
    get allowInput() {
        return this.nativeElement.allowInput;
    }
    /** Whether or not to show a "Now" button. */
    set showNow(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.showNow = value;
        });
    }
    get showNow() {
        return this.nativeElement.showNow;
    }
    /** Whether or not to display hour options in dropdown. */
    set showHourOptions(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.showHourOptions = value;
        });
    }
    get showHourOptions() {
        return this.nativeElement.showHourOptions;
    }
    /** An array of custom time picker options. */
    set customOptions(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.customOptions = value;
        });
    }
    get customOptions() {
        return this.nativeElement.customOptions;
    }
    /** A callback function to validate the time. */
    set validationCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.validationCallback = value;
        });
    }
    get validationCallback() {
        return this.nativeElement.validationCallback;
    }
    /** A callback function to parse the time. */
    set parseCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.parseCallback = value;
        });
    }
    get parseCallback() {
        return this.nativeElement.parseCallback;
    }
    /** A callback function to format the time. */
    set formatCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.formatCallback = value;
        });
    }
    get formatCallback() {
        return this.nativeElement.formatCallback;
    }
    /** A callback function to coerce the time. */
    set coercionCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.coercionCallback = value;
        });
    }
    get coercionCallback() {
        return this.nativeElement.coercionCallback;
    }
    /** A callback function to prepare the mask. */
    set prepareMaskCallback(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.prepareMaskCallback = value;
        });
    }
    get prepareMaskCallback() {
        return this.nativeElement.prepareMaskCallback;
    }
    /** Whether or not the time picker is disabled. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** The classes to apply to the time picker popup. */
    set popupClasses(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popupClasses = value;
        });
    }
    get popupClasses() {
        return this.nativeElement.popupClasses;
    }
    /** Whether or not to allow the time picker to be a dropdown. */
    set allowDropdown(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.allowDropdown = value;
        });
    }
    get allowDropdown() {
        return this.nativeElement.allowDropdown;
    }
    /** The target element to attach the popup to. */
    set popupTarget(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.popupTarget = value;
        });
    }
    get popupTarget() {
        return this.nativeElement.popupTarget;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-time-picker element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineTimePickerComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: TimePickerComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: TimePickerComponent, selector: "forge-time-picker", inputs: { value: "value", open: ["open", "open", booleanAttribute], allowSeconds: ["allowSeconds", "allowSeconds", booleanAttribute], masked: ["masked", "masked", booleanAttribute], showMaskFormat: ["showMaskFormat", "showMaskFormat", booleanAttribute], use24HourTime: ["use24HourTime", "use24HourTime", booleanAttribute], allowInvalidTime: ["allowInvalidTime", "allowInvalidTime", booleanAttribute], min: "min", max: "max", restrictedTimes: "restrictedTimes", startTime: "startTime", step: ["step", "step", numberAttribute], allowInput: ["allowInput", "allowInput", booleanAttribute], showNow: ["showNow", "showNow", booleanAttribute], showHourOptions: ["showHourOptions", "showHourOptions", booleanAttribute], customOptions: "customOptions", validationCallback: "validationCallback", parseCallback: "parseCallback", formatCallback: "formatCallback", coercionCallback: "coercionCallback", prepareMaskCallback: "prepareMaskCallback", disabled: ["disabled", "disabled", booleanAttribute], popupClasses: "popupClasses", allowDropdown: ["allowDropdown", "allowDropdown", booleanAttribute], popupTarget: "popupTarget" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: TimePickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-time-picker',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { value: [{
                type: Input
            }], open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], allowSeconds: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], masked: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], showMaskFormat: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], use24HourTime: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], allowInvalidTime: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], restrictedTimes: [{
                type: Input
            }], startTime: [{
                type: Input
            }], step: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], allowInput: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], showNow: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], showHourOptions: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], customOptions: [{
                type: Input
            }], validationCallback: [{
                type: Input
            }], parseCallback: [{
                type: Input
            }], formatCallback: [{
                type: Input
            }], coercionCallback: [{
                type: Input
            }], prepareMaskCallback: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], popupClasses: [{
                type: Input
            }], allowDropdown: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], popupTarget: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeTimePickerProxyModule {
    constructor() {
        defineTimePickerComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTimePickerProxyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeTimePickerProxyModule, declarations: [TimePickerComponent], imports: [CommonModule], exports: [TimePickerComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTimePickerProxyModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTimePickerProxyModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [TimePickerComponent],
                    exports: [TimePickerComponent]
                }]
        }], ctorParameters: () => [] });

const TIME_PICKER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => TimePickerValueAccessor),
    multi: true
};
class TimePickerValueAccessor {
    timePickerChange(event) {
        this.change(event.detail);
    }
    blur() {
        this.onTouched();
    }
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    writeValue(value) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    change(value) {
        this.onChange(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: TimePickerValueAccessor, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.7", type: TimePickerValueAccessor, selector: "forge-time-picker[formControlName],forge-time-picker[formControl],forge-time-picker[ngModel]", host: { listeners: { "forge-time-picker-change": "timePickerChange($event)", "focusout": "blur()" } }, providers: [TIME_PICKER_VALUE_ACCESSOR], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: TimePickerValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    selector: 'forge-time-picker[formControlName],forge-time-picker[formControl],forge-time-picker[ngModel]',
                    providers: [TIME_PICKER_VALUE_ACCESSOR]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { timePickerChange: [{
                type: HostListener,
                args: ['forge-time-picker-change', ['$event']]
            }], blur: [{
                type: HostListener,
                args: ['focusout']
            }] } });

class ForgeTimePickerModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTimePickerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeTimePickerModule, declarations: [TimePickerValueAccessor], exports: [TimePickerValueAccessor,
            ForgeTimePickerProxyModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTimePickerModule, imports: [ForgeTimePickerProxyModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTimePickerModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        TimePickerValueAccessor
                    ],
                    exports: [
                        TimePickerValueAccessor,
                        ForgeTimePickerProxyModule
                    ]
                }]
        }] });

class ToastConfig {
}

class ToastInjector extends BaseInjector {
}

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ToastComponent {
    /** The open state. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** The duration in milliseconds that the toast is displayed. */
    set duration(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.duration = value;
        });
    }
    get duration() {
        return this.nativeElement.duration;
    }
    /** The placement of the toast. */
    set placement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.placement = value;
        });
    }
    get placement() {
        return this.nativeElement.placement;
    }
    /** The text for the action button. This controls the visibility of the action button. */
    set actionText(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.actionText = value;
        });
    }
    get actionText() {
        return this.nativeElement.actionText;
    }
    /** Whether the toast is dismissible (displays a close button). */
    set dismissible(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dismissible = value;
        });
    }
    get dismissible() {
        return this.nativeElement.dismissible;
    }
    /** The accessible label for the dismiss button. */
    set dismissLabel(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.dismissLabel = value;
        });
    }
    get dismissLabel() {
        return this.nativeElement.dismissLabel;
    }
    /** The theme of the toast. */
    set theme(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.theme = value;
        });
    }
    get theme() {
        return this.nativeElement.theme;
    }
    /** Shows the toast. */
    show(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.show(...args));
    }
    /** Hides the toast. */
    hide(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.hide(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-toast element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineToastComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ToastComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ToastComponent, selector: "forge-toast", inputs: { open: ["open", "open", booleanAttribute], duration: ["duration", "duration", numberAttribute], placement: "placement", actionText: "actionText", dismissible: ["dismissible", "dismissible", booleanAttribute], dismissLabel: "dismissLabel", theme: "theme" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ToastComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-toast',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], duration: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], placement: [{
                type: Input
            }], actionText: [{
                type: Input
            }], dismissible: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], dismissLabel: [{
                type: Input
            }], theme: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeToastModule {
    constructor() {
        defineToastComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeToastModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeToastModule, declarations: [ToastComponent], imports: [CommonModule], exports: [ToastComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeToastModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeToastModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [ToastComponent],
                    exports: [ToastComponent]
                }]
        }], ctorParameters: () => [] });

class ToastService {
    constructor(_appRef, _injector) {
        this._appRef = _appRef;
        this._injector = _injector;
        defineToastComponent();
    }
    /**
     * Creates and renders a toast component.
     * @param config The toast configuration.
     */
    show(configOrMessage, toastConfig) {
        const { component, message, actionHandler, ...config } = configOrMessage;
        let toastElement;
        let environmentInjector;
        let componentRef;
        const messageText = typeof configOrMessage === 'string' ? configOrMessage : configOrMessage.message;
        if (typeof messageText === 'string') {
            toastElement = ToastComponent$1.present({ message: messageText, ...config });
        }
        else if (component) {
            const providers = toastConfig ? [{ provide: ToastConfig, useValue: toastConfig }] : [];
            environmentInjector = createEnvironmentInjector(providers, this._injector);
            componentRef = createComponent(component, { environmentInjector });
            this._appRef.attachView(componentRef.hostView);
            const element = componentRef.hostView.rootNodes[0];
            toastElement = ToastComponent$1.present({ element, ...config });
            toastElement.addEventListener(TOAST_CONSTANTS.events.CLOSE, () => {
                environmentInjector?.destroy();
            });
        }
        else {
            throw new Error('Either a component or a message must be provided.');
        }
        if (toastElement && config.actionText && typeof actionHandler === 'function') {
            toastElement.addEventListener(TOAST_CONSTANTS.events.ACTION, actionHandler);
        }
        return {
            nativeElement: toastElement,
            close: async () => {
                environmentInjector?.destroy();
                componentRef?.destroy();
                await toastElement.hide();
                toastElement.remove();
            }
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ToastService, deps: [{ token: i0.ApplicationRef }, { token: i0.EnvironmentInjector }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ToastService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ToastService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: i0.ApplicationRef }, { type: i0.EnvironmentInjector }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ToolbarComponent {
    /** Controls whether a bottom divider (default) or top divider (true) is used. */
    set inverted(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.inverted = value;
        });
    }
    get inverted() {
        return this.nativeElement.inverted;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-toolbar element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineToolbarComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ToolbarComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ToolbarComponent, selector: "forge-toolbar", inputs: { inverted: ["inverted", "inverted", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ToolbarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-toolbar',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { inverted: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeToolbarModule {
    constructor() {
        defineToolbarComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeToolbarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeToolbarModule, declarations: [ToolbarComponent], imports: [CommonModule], exports: [ToolbarComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeToolbarModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeToolbarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [ToolbarComponent],
                    exports: [ToolbarComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class TooltipComponent {
    /** Whether or not the tooltip is open. */
    set open(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.open = value;
        });
    }
    get open() {
        return this.nativeElement.open;
    }
    /** The type of tooltip. Valid values are `presentation` (default), `label`, and `description`. */
    set type(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.type = value;
        });
    }
    get type() {
        return this.nativeElement.type;
    }
    /** The id of the element that the tooltip is anchored to. */
    set anchor(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.anchor = value;
        });
    }
    get anchor() {
        return this.nativeElement.anchor;
    }
    set anchorElement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.anchorElement = value;
        });
    }
    get anchorElement() {
        return this.nativeElement.anchorElement;
    }
    set target(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.target = value;
        });
    }
    get target() {
        return this.nativeElement.target;
    }
    /** The placement of the tooltip relative to the anchor element. */
    set placement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.placement = value;
        });
    }
    get placement() {
        return this.nativeElement.placement;
    }
    set position(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.position = value;
        });
    }
    get position() {
        return this.nativeElement.position;
    }
    /** The delay in milliseconds before the tooltip is shown. */
    set delay(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.delay = value;
        });
    }
    get delay() {
        return this.nativeElement.delay;
    }
    /** The offset in pixels between the tooltip and the anchor element. */
    set offset(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.offset = value;
        });
    }
    get offset() {
        return this.nativeElement.offset;
    }
    /** How the tooltip should place itself if there is not enough space at the desired placement. */
    set flip(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.flip = value;
        });
    }
    get flip() {
        return this.nativeElement.flip;
    }
    /** The id of the element that the tooltip should be constrained to. */
    set boundary(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.boundary = value;
        });
    }
    get boundary() {
        return this.nativeElement.boundary;
    }
    /** The element that the tooltip should be constrained to. */
    set boundaryElement(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.boundaryElement = value;
        });
    }
    get boundaryElement() {
        return this.nativeElement.boundaryElement;
    }
    /** The fallback placements of the tooltip relative to the anchor element. */
    set fallbackPlacements(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.fallbackPlacements = value;
        });
    }
    get fallbackPlacements() {
        return this.nativeElement.fallbackPlacements;
    }
    /** The trigger type(s) that will open the tooltip. Valid values are `hover` (default), `longpress`, and `focus`. */
    set triggerType(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.triggerType = value;
        });
    }
    get triggerType() {
        return this.nativeElement.triggerType;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-tooltip element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineTooltipComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: TooltipComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: TooltipComponent, selector: "forge-tooltip", inputs: { open: ["open", "open", booleanAttribute], type: "type", anchor: "anchor", anchorElement: "anchorElement", target: "target", placement: "placement", position: "position", delay: ["delay", "delay", numberAttribute], offset: ["offset", "offset", numberAttribute], flip: "flip", boundary: "boundary", boundaryElement: "boundaryElement", fallbackPlacements: "fallbackPlacements", triggerType: "triggerType" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: TooltipComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-tooltip',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { open: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], type: [{
                type: Input
            }], anchor: [{
                type: Input
            }], anchorElement: [{
                type: Input
            }], target: [{
                type: Input
            }], placement: [{
                type: Input
            }], position: [{
                type: Input
            }], delay: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], offset: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], flip: [{
                type: Input
            }], boundary: [{
                type: Input
            }], boundaryElement: [{
                type: Input
            }], fallbackPlacements: [{
                type: Input
            }], triggerType: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeTooltipModule {
    constructor() {
        defineTooltipComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTooltipModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeTooltipModule, declarations: [TooltipComponent], imports: [CommonModule], exports: [TooltipComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTooltipModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeTooltipModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [TooltipComponent],
                    exports: [TooltipComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ViewComponent {
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-view element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineViewComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ViewComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.7", type: ViewComponent, selector: "forge-view", ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-view',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeViewModule {
    constructor() {
        defineViewComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeViewModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeViewModule, declarations: [ViewComponent], imports: [CommonModule], exports: [ViewComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeViewModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeViewModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [ViewComponent],
                    exports: [ViewComponent]
                }]
        }], ctorParameters: () => [] });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
/**  */
class ViewSwitcherComponent {
    /** Gets/sets the currently visible view index. */
    set index(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.index = value;
        });
    }
    get index() {
        return this.nativeElement.index;
    }
    /** Gets/sets the animation type. */
    set animationType(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.animationType = value;
        });
    }
    get animationType() {
        return this.nativeElement.animationType;
    }
    /** Transitions to the next view. */
    next(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.next(...args));
    }
    /** Transitions to the previous view. */
    previous(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.previous(...args));
    }
    /** Transitions to the first view. */
    goToStart(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.goToStart(...args));
    }
    /** Transitions to the last view. */
    goToEnd(...args) {
        return this.zone.runOutsideAngular(() => this.nativeElement.goToEnd(...args));
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-view-switcher element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineViewSwitcherComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ViewSwitcherComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ViewSwitcherComponent, selector: "forge-view-switcher", inputs: { index: ["index", "index", numberAttribute], animationType: "animationType" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ViewSwitcherComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-view-switcher',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { index: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], animationType: [{
                type: Input
            }] } });

// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
class ForgeViewSwitcherModule {
    constructor() {
        defineViewSwitcherComponent();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeViewSwitcherModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeViewSwitcherModule, declarations: [ViewSwitcherComponent], imports: [CommonModule, ForgeViewModule], exports: [ViewSwitcherComponent, ForgeViewModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeViewSwitcherModule, imports: [CommonModule, ForgeViewModule, ForgeViewModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeViewSwitcherModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ForgeViewModule],
                    declarations: [ViewSwitcherComponent],
                    exports: [ViewSwitcherComponent, ForgeViewModule]
                }]
        }], ctorParameters: () => [] });

class ForgeModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.7", ngImport: i0, type: ForgeModule, exports: [ForgeAccordionModule,
            ForgeAppBarModule,
            ForgeAppBarHelpButtonModule,
            ForgeAppBarMenuButtonModule,
            ForgeAppBarNotificationButtonModule,
            ForgeAppBarProfileButtonModule,
            ForgeAppBarSearchModule,
            ForgeAutocompleteModule,
            ForgeAvatarModule,
            ForgeBackdropModule,
            ForgeBadgeModule,
            ForgeBannerModule,
            ForgeBottomSheetModule,
            ForgeButtonModule,
            ForgeButtonAreaModule,
            ForgeButtonToggleModule,
            ForgeButtonToggleGroupModule,
            ForgeCalendarModule,
            ForgeCardModule,
            ForgeCheckboxModule,
            ForgeChipModule,
            ForgeChipFieldModule,
            ForgeChipSetModule,
            ForgeCircularProgressModule,
            ForgeColorPickerModule,
            ForgeDatePickerModule,
            ForgeDateRangePickerModule,
            ForgeDeprecatedButtonModule,
            ForgeDeprecatedIconButtonModule,
            ForgeDialogModule,
            ForgeDividerModule,
            ForgeDrawerModule,
            ForgeExpansionPanelModule,
            ForgeFloatingActionButtonModule,
            ForgeFieldModule,
            ForgeFilePickerModule,
            ForgeFocusIndicatorModule,
            ForgeIconModule,
            ForgeIconButtonModule,
            ForgeInlineMessageModule,
            ForgeKeyboardShortcutModule,
            ForgeLabelModule,
            ForgeLabelValueModule,
            ForgeLinearProgressModule,
            ForgeListModule,
            ForgeListItemModule,
            ForgeMenuModule,
            ForgeMiniDrawerModule,
            ForgeModalDrawerModule,
            ForgeOpenIconModule,
            ForgeOptionModule,
            ForgeOptionGroupModule,
            ForgeOverlayModule,
            ForgePageStateModule,
            ForgePaginatorModule,
            ForgePopoverModule,
            ForgeProfileCardModule,
            ForgeRadioModule,
            ForgeRadioGroupModule,
            ForgeScaffoldModule,
            ForgeSelectModule,
            ForgeSelectDropdownModule,
            ForgeSkeletonModule,
            ForgeSkipLinkModule,
            ForgeSliderModule,
            ForgeSplitButtonModule,
            ForgeSplitViewModule,
            ForgeSplitViewPanelModule,
            ForgeStackModule,
            ForgeStateLayerModule,
            ForgeStepModule,
            ForgeStepperModule,
            ForgeSwitchModule,
            ForgeTabModule,
            ForgeTabBarModule,
            ForgeTableModule,
            ForgeTextFieldModule,
            ForgeTimePickerModule,
            ForgeToastModule,
            ForgeToolbarModule,
            ForgeTooltipModule,
            ForgeViewModule,
            ForgeViewSwitcherModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeModule, imports: [ForgeAccordionModule,
            ForgeAppBarModule,
            ForgeAppBarHelpButtonModule,
            ForgeAppBarMenuButtonModule,
            ForgeAppBarNotificationButtonModule,
            ForgeAppBarProfileButtonModule,
            ForgeAppBarSearchModule,
            ForgeAutocompleteModule,
            ForgeAvatarModule,
            ForgeBackdropModule,
            ForgeBadgeModule,
            ForgeBannerModule,
            ForgeBottomSheetModule,
            ForgeButtonModule,
            ForgeButtonAreaModule,
            ForgeButtonToggleModule,
            ForgeButtonToggleGroupModule,
            ForgeCalendarModule,
            ForgeCardModule,
            ForgeCheckboxModule,
            ForgeChipModule,
            ForgeChipFieldModule,
            ForgeChipSetModule,
            ForgeCircularProgressModule,
            ForgeColorPickerModule,
            ForgeDatePickerModule,
            ForgeDateRangePickerModule,
            ForgeDeprecatedButtonModule,
            ForgeDeprecatedIconButtonModule,
            ForgeDialogModule,
            ForgeDividerModule,
            ForgeDrawerModule,
            ForgeExpansionPanelModule,
            ForgeFloatingActionButtonModule,
            ForgeFieldModule,
            ForgeFilePickerModule,
            ForgeFocusIndicatorModule,
            ForgeIconModule,
            ForgeIconButtonModule,
            ForgeInlineMessageModule,
            ForgeKeyboardShortcutModule,
            ForgeLabelModule,
            ForgeLabelValueModule,
            ForgeLinearProgressModule,
            ForgeListModule,
            ForgeListItemModule,
            ForgeMenuModule,
            ForgeMiniDrawerModule,
            ForgeModalDrawerModule,
            ForgeOpenIconModule,
            ForgeOptionModule,
            ForgeOptionGroupModule,
            ForgeOverlayModule,
            ForgePageStateModule,
            ForgePaginatorModule,
            ForgePopoverModule,
            ForgeProfileCardModule,
            ForgeRadioModule,
            ForgeRadioGroupModule,
            ForgeScaffoldModule,
            ForgeSelectModule,
            ForgeSelectDropdownModule,
            ForgeSkeletonModule,
            ForgeSkipLinkModule,
            ForgeSliderModule,
            ForgeSplitButtonModule,
            ForgeSplitViewModule,
            ForgeSplitViewPanelModule,
            ForgeStackModule,
            ForgeStateLayerModule,
            ForgeStepModule,
            ForgeStepperModule,
            ForgeSwitchModule,
            ForgeTabModule,
            ForgeTabBarModule,
            ForgeTableModule,
            ForgeTextFieldModule,
            ForgeTimePickerModule,
            ForgeToastModule,
            ForgeToolbarModule,
            ForgeTooltipModule,
            ForgeViewModule,
            ForgeViewSwitcherModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ForgeModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        ForgeAccordionModule,
                        ForgeAppBarModule,
                        ForgeAppBarHelpButtonModule,
                        ForgeAppBarMenuButtonModule,
                        ForgeAppBarNotificationButtonModule,
                        ForgeAppBarProfileButtonModule,
                        ForgeAppBarSearchModule,
                        ForgeAutocompleteModule,
                        ForgeAvatarModule,
                        ForgeBackdropModule,
                        ForgeBadgeModule,
                        ForgeBannerModule,
                        ForgeBottomSheetModule,
                        ForgeButtonModule,
                        ForgeButtonAreaModule,
                        ForgeButtonToggleModule,
                        ForgeButtonToggleGroupModule,
                        ForgeCalendarModule,
                        ForgeCardModule,
                        ForgeCheckboxModule,
                        ForgeChipModule,
                        ForgeChipFieldModule,
                        ForgeChipSetModule,
                        ForgeCircularProgressModule,
                        ForgeColorPickerModule,
                        ForgeDatePickerModule,
                        ForgeDateRangePickerModule,
                        ForgeDeprecatedButtonModule,
                        ForgeDeprecatedIconButtonModule,
                        ForgeDialogModule,
                        ForgeDividerModule,
                        ForgeDrawerModule,
                        ForgeExpansionPanelModule,
                        ForgeFloatingActionButtonModule,
                        ForgeFieldModule,
                        ForgeFilePickerModule,
                        ForgeFocusIndicatorModule,
                        ForgeIconModule,
                        ForgeIconButtonModule,
                        ForgeInlineMessageModule,
                        ForgeKeyboardShortcutModule,
                        ForgeLabelModule,
                        ForgeLabelValueModule,
                        ForgeLinearProgressModule,
                        ForgeListModule,
                        ForgeListItemModule,
                        ForgeMenuModule,
                        ForgeMiniDrawerModule,
                        ForgeModalDrawerModule,
                        ForgeOpenIconModule,
                        ForgeOptionModule,
                        ForgeOptionGroupModule,
                        ForgeOverlayModule,
                        ForgePageStateModule,
                        ForgePaginatorModule,
                        ForgePopoverModule,
                        ForgeProfileCardModule,
                        ForgeRadioModule,
                        ForgeRadioGroupModule,
                        ForgeScaffoldModule,
                        ForgeSelectModule,
                        ForgeSelectDropdownModule,
                        ForgeSkeletonModule,
                        ForgeSkipLinkModule,
                        ForgeSliderModule,
                        ForgeSplitButtonModule,
                        ForgeSplitViewModule,
                        ForgeSplitViewPanelModule,
                        ForgeStackModule,
                        ForgeStateLayerModule,
                        ForgeStepModule,
                        ForgeStepperModule,
                        ForgeSwitchModule,
                        ForgeTabModule,
                        ForgeTabBarModule,
                        ForgeTableModule,
                        ForgeTextFieldModule,
                        ForgeTimePickerModule,
                        ForgeToastModule,
                        ForgeToolbarModule,
                        ForgeTooltipModule,
                        ForgeViewModule,
                        ForgeViewSwitcherModule
                    ]
                }]
        }] });

/*
 * Public API Surface of forge-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AUTOCOMPLETE_VALUE_ACCESSOR, AccordionComponent, AppBarComponent, AppBarHelpButtonComponent, AppBarMenuButtonComponent, AppBarNotificationButtonComponent, AppBarProfileButtonComponent, AppBarRouterNavigateDirective, AppBarSearchComponent, AutocompleteComponent, AutocompleteValueAccessor, AvatarComponent, BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR, BackdropComponent, BadgeComponent, BannerComponent, BaseInjector, BottomSheetComponent, BottomSheetConfig, BottomSheetInjector, BottomSheetRef, BottomSheetService, ButtonAreaComponent, ButtonComponent, ButtonToggleComponent, ButtonToggleGroupComponent, ButtonToggleGroupValueAccessor, CHECKBOX_VALUE_ACCESSOR, CHIP_VALUE_ACCESSOR, CalendarComponent, CardComponent, CheckboxComponent, CheckboxValueAccessor, ChipComponent, ChipFieldComponent, ChipSetComponent, ChipValueAccessor, CircularProgressComponent, ColorPickerComponent, DATEPICKER_VALUE_ACCESSOR, DATE_RANGE_PICKER_VALUE_ACCESSOR, DIALOG_DATA, DatePickerComponent, DatePickerValueAccessor, DateRangePickerComponent, DateRangePickerValueAccessor, DeprecatedButtonComponent, DeprecatedIconButtonComponent, DialogComponent, DialogConfig, DialogInjector, DialogRef, DialogService, DividerComponent, DrawerComponent, DynamicComponentService, ExpansionPanelComponent, FieldComponent, FilePickerComponent, FloatingActionButtonComponent, FocusIndicatorComponent, ForgeAccordionModule, ForgeAppBarHelpButtonModule, ForgeAppBarMenuButtonModule, ForgeAppBarModule, ForgeAppBarNotificationButtonModule, ForgeAppBarProfileButtonModule, ForgeAppBarProxyModule, ForgeAppBarSearchModule, ForgeAutocompleteModule, ForgeAutocompleteProxyModule, ForgeAvatarModule, ForgeBackdropModule, ForgeBadgeModule, ForgeBannerModule, ForgeBottomSheetModule, ForgeButtonAreaModule, ForgeButtonModule, ForgeButtonToggleGroupModule, ForgeButtonToggleModule, ForgeButtonToggleProxyModule, ForgeCalendarModule, ForgeCardModule, ForgeCheckboxModule, ForgeCheckboxProxyModule, ForgeChipFieldModule, ForgeChipModule, ForgeChipProxyModule, ForgeChipSetModule, ForgeCircularProgressModule, ForgeColorPickerModule, ForgeDatePickerModule, ForgeDatePickerProxyModule, ForgeDateRangePickerModule, ForgeDateRangePickerProxyModule, ForgeDeprecatedButtonModule, ForgeDeprecatedIconButtonModule, ForgeDialogModule, ForgeDividerModule, ForgeDrawerModule, ForgeExpansionPanelModule, ForgeFieldModule, ForgeFilePickerModule, ForgeFloatingActionButtonModule, ForgeFocusIndicatorModule, ForgeIconButtonModule, ForgeIconModule, ForgeInlineMessageModule, ForgeKeyboardShortcutModule, ForgeLabelModule, ForgeLabelValueModule, ForgeLinearProgressModule, ForgeListItemModule, ForgeListModule, ForgeMenuModule, ForgeMiniDrawerModule, ForgeModalDrawerModule, ForgeModule, ForgeOpenIconModule, ForgeOptionGroupModule, ForgeOptionModule, ForgeOverlayModule, ForgePageStateModule, ForgePaginatorModule, ForgePopoverModule, ForgePopoverProxyModule, ForgeProfileCardModule, ForgeRadioGroupModule, ForgeRadioModule, ForgeRadioProxyModule, ForgeScaffoldModule, ForgeSelectDropdownModule, ForgeSelectModule, ForgeSelectProxyModule, ForgeSkeletonModule, ForgeSkipLinkModule, ForgeSliderModule, ForgeSliderProxyModule, ForgeSplitButtonModule, ForgeSplitViewModule, ForgeSplitViewPanelModule, ForgeStackModule, ForgeStateLayerModule, ForgeStepModule, ForgeStepperModule, ForgeSwitchModule, ForgeSwitchProxyModule, ForgeTabBarModule, ForgeTabModule, ForgeTableModule, ForgeTextFieldModule, ForgeTimePickerModule, ForgeTimePickerProxyModule, ForgeToastModule, ForgeToolbarModule, ForgeTooltipModule, ForgeViewModule, ForgeViewSwitcherModule, IconButtonComponent, IconComponent, InlineMessageComponent, KeyboardShortcutComponent, LabelComponent, LabelValueComponent, LinearProgressComponent, ListComponent, ListItemComponent, MenuComponent, MiniDrawerComponent, ModalDrawerComponent, OpenIconComponent, OptionComponent, OptionGroupComponent, OverlayComponent, PageStateComponent, PaginatorComponent, PopoverComponent, PopoverConfig, PopoverDirective, PopoverInjector, PopoverRef, PopoverService, ProfileCardComponent, RADIO_VALUE_ACCESSOR, RadioComponent, RadioGroupComponent, RadioValueAccessor, SELECT_VALUE_ACCESSOR, SLIDER_VALUE_ACCESSOR, SWITCH_VALUE_ACCESSOR, ScaffoldComponent, SelectComponent, SelectDropdownComponent, SelectValueAccessor, SkeletonComponent, SkipLinkComponent, SliderComponent, SliderValueAccessor, SplitButtonComponent, SplitViewComponent, SplitViewPanelComponent, StackComponent, StateLayerComponent, StepComponent, StepperComponent, SwitchComponent, SwitchValueAccessor, TIME_PICKER_VALUE_ACCESSOR, TabBarComponent, TabComponent, TableComponent, TextFieldComponent, TimePickerComponent, TimePickerValueAccessor, ToastComponent, ToastConfig, ToastInjector, ToastService, ToolbarComponent, TooltipComponent, ViewComponent, ViewSwitcherComponent };
//# sourceMappingURL=tylertech-forge-angular.mjs.map
