"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const testing_1 = require("@angular-devkit/schematics/testing");
const path = require("path");
const collectionPath = path.join(__dirname, '../collection.json');
function defaultOptions() {
    return {
        manifest: 'src/custom-elements/test-manifest.json',
        importPath: '@tylertech/forge',
        exclude: '',
        outDir: '',
        outDirExcludePrefix: '',
        modulePrefix: '',
        useDefineFunction: false
    };
}
describe('custom-elements', () => {
    it('should generate a component and module for each element in a folder matching the tag name', () => __awaiter(void 0, void 0, void 0, function* () {
        const runner = new testing_1.SchematicTestRunner('schematics', collectionPath);
        const tree = yield runner
            .runSchematicAsync('custom-elements', defaultOptions(), schematics_1.Tree.empty())
            .toPromise();
        expect(tree.files).toEqual([
            '/forge-accordion/accordion.component.ts',
            '/forge-accordion/accordion.module.ts',
            '/forge-expansion-panel/expansion-panel.component.ts',
            '/forge-expansion-panel/expansion-panel.module.ts'
        ]);
    }));
    it('should overwrite a module in the target directory if it includes the standard comment indicating it was generated', () => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const runner = new testing_1.SchematicTestRunner('schematics', collectionPath);
        const oldGeneratedFileContent = `// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.\nold content`;
        const startingTree = schematics_1.Tree.empty();
        startingTree.create('forge-accordion/accordion.module.ts', oldGeneratedFileContent);
        const tree = yield runner
            .runSchematicAsync('custom-elements', defaultOptions(), startingTree)
            .toPromise();
        expect(tree.files).toEqual(jasmine.arrayContaining([
            '/forge-accordion/accordion.component.ts',
            '/forge-accordion/accordion.module.ts'
        ]));
        expect((_a = tree.get('forge-accordion/accordion.module.ts')) === null || _a === void 0 ? void 0 : _a.content.toString()).not.toEqual(oldGeneratedFileContent);
    }));
    it('should generating the module file ending in -proxy if one already exists in the target directory', () => __awaiter(void 0, void 0, void 0, function* () {
        var _b, _c;
        const runner = new testing_1.SchematicTestRunner('schematics', collectionPath);
        const startingTree = schematics_1.Tree.empty();
        const nonGeneratedContent = 'test';
        startingTree.create('forge-accordion/accordion.module.ts', nonGeneratedContent);
        const tree = yield runner
            .runSchematicAsync('custom-elements', defaultOptions(), startingTree)
            .toPromise();
        expect(tree.files).toEqual(jasmine.arrayContaining([
            '/forge-accordion/accordion.component.ts',
            '/forge-accordion/accordion.module.ts',
            '/forge-accordion/accordion-proxy.module.ts'
        ]));
        expect((_b = tree.get('forge-accordion/accordion.module.ts')) === null || _b === void 0 ? void 0 : _b.content.toString()).toEqual(nonGeneratedContent);
        expect((_c = tree.get('forge-accordion/accordion-proxy.module.ts')) === null || _c === void 0 ? void 0 : _c.content.toString()).toContain('export class AccordionProxyModule');
    }));
    it('should generate the folders in the outDir if specified', () => __awaiter(void 0, void 0, void 0, function* () {
        const runner = new testing_1.SchematicTestRunner('schematics', collectionPath);
        const tree = yield runner
            .runSchematicAsync('custom-elements', Object.assign(Object.assign({}, defaultOptions()), { outDir: 'test' }), schematics_1.Tree.empty())
            .toPromise();
        expect(tree.files).toEqual([
            '/test/forge-accordion/accordion.component.ts',
            '/test/forge-accordion/accordion.module.ts',
            '/test/forge-expansion-panel/expansion-panel.component.ts',
            '/test/forge-expansion-panel/expansion-panel.module.ts'
        ]);
    }));
    it('should omit the forge prefix from the folder if outDirExcludePrefix is specified', () => __awaiter(void 0, void 0, void 0, function* () {
        const runner = new testing_1.SchematicTestRunner('schematics', collectionPath);
        const tree = yield runner
            .runSchematicAsync('custom-elements', Object.assign(Object.assign({}, defaultOptions()), { outDirExcludePrefix: 'forge-' }), schematics_1.Tree.empty())
            .toPromise();
        expect(tree.files).toEqual([
            '/accordion/accordion.component.ts',
            '/accordion/accordion.module.ts',
            '/expansion-panel/expansion-panel.component.ts',
            '/expansion-panel/expansion-panel.module.ts',
        ]);
    }));
    it('should generate exclude a component by tag name', () => __awaiter(void 0, void 0, void 0, function* () {
        const runner = new testing_1.SchematicTestRunner('schematics', collectionPath);
        const tree = yield runner
            .runSchematicAsync('custom-elements', Object.assign(Object.assign({}, defaultOptions()), { exclude: 'forge-accordion, forge-expansion-panel' }), schematics_1.Tree.empty())
            .toPromise();
        expect(tree.files).toEqual([]);
    }));
    it('should use the built-in customElements.define function if useDefineFunction is false', () => __awaiter(void 0, void 0, void 0, function* () {
        const runner = new testing_1.SchematicTestRunner('schematics', collectionPath);
        const tree = yield runner
            .runSchematicAsync('custom-elements', Object.assign(Object.assign({}, defaultOptions()), { useDefineFunction: false }), schematics_1.Tree.empty())
            .toPromise();
        const componentFile = tree.readContent(tree.files[0]);
        const moduleFile = tree.readContent(tree.files[1]);
        expect(componentFile).toContain(`if (!window.customElements.get('forge-accordion')) {`);
        expect(componentFile).toContain(`window.customElements.define('forge-accordion', AccordionComponentCustomElement);`);
        expect(moduleFile).toContain(`import { AccordionComponent as AccordionComponentCustomElement } from '@tylertech/forge';`);
        expect(moduleFile).toContain(`if (!window.customElements.get('forge-accordion')) {`);
        expect(moduleFile).toContain(`window.customElements.define('forge-accordion', AccordionComponentCustomElement);`);
    }));
    it('should not generate inputs for readonly properties', () => __awaiter(void 0, void 0, void 0, function* () {
        const runner = new testing_1.SchematicTestRunner('schematics', collectionPath);
        const tree = yield runner
            .runSchematicAsync('custom-elements', Object.assign({}, defaultOptions()), schematics_1.Tree.empty())
            .toPromise();
        const componentFile = tree.readContent(tree.files[2]);
        expect(componentFile).toContain(`public get testReadonlyProperty`);
        expect(componentFile).not.toContain(`public set testReadonlyProperty`);
    }));
    it('should import and use booleanAttribute/numberAttribute transforms for @Input() properties ', () => __awaiter(void 0, void 0, void 0, function* () {
        const runner = new testing_1.SchematicTestRunner('schematics', collectionPath);
        const tree = yield runner
            .runSchematicAsync('custom-elements', Object.assign({}, defaultOptions()), schematics_1.Tree.empty())
            .toPromise();
        const componentFile = tree.readContent(tree.files[2]);
        expect(componentFile).toMatch(/import { [\w\s,]*booleanAttribute[\w\s,]* } from '@angular\/core';/);
        expect(componentFile).toMatch(/import { [\w\s,]*numberAttribute[\w\s,]* } from '@angular\/core';/);
        expect(componentFile).toMatch(/@Input\({ transform: booleanAttribute }\)[\r\n\s]*public set open/m);
        expect(componentFile).toMatch(/@Input\({ transform: numberAttribute }\)[\r\n\s]*public set testNumber/m);
    }));
    it('should not import booleanAttribute/numberAttribute if no usages ', () => __awaiter(void 0, void 0, void 0, function* () {
        const runner = new testing_1.SchematicTestRunner('schematics', collectionPath);
        const tree = yield runner
            .runSchematicAsync('custom-elements', Object.assign({}, defaultOptions()), schematics_1.Tree.empty())
            .toPromise();
        const componentFile = tree.readContent(tree.files[0]);
        expect(componentFile).not.toMatch(/import { [\w\s,]*booleanAttribute[\w\s,]* } from '@angular\/core';/);
        expect(componentFile).not.toMatch(/import { [\w\s,]*numberAttribute[\w\s,]* } from '@angular\/core';/);
    }));
    it('should generate components that expose the native element with tag name in description ', () => __awaiter(void 0, void 0, void 0, function* () {
        const runner = new testing_1.SchematicTestRunner('schematics', collectionPath);
        const tree = yield runner
            .runSchematicAsync('custom-elements', Object.assign({}, defaultOptions()), schematics_1.Tree.empty())
            .toPromise();
        const componentFile = tree.readContent(tree.files[2]);
        expect(componentFile).toMatch(/\/\*\* The forge-expansion-panel element. \*\/[\r\n\s]*public readonly nativeElement = this.elementRef.nativeElement;/m);
    }));
    it('should use the library define function if useDefineFunction is true', () => __awaiter(void 0, void 0, void 0, function* () {
        const runner = new testing_1.SchematicTestRunner('schematics', collectionPath);
        const tree = yield runner
            .runSchematicAsync('custom-elements', Object.assign(Object.assign({}, defaultOptions()), { useDefineFunction: true }), schematics_1.Tree.empty())
            .toPromise();
        const componentFile = tree.readContent(tree.files[0]);
        const moduleFile = tree.readContent(tree.files[1]);
        expect(componentFile).toContain(`, defineAccordionComponent } from '@tylertech/forge';`);
        expect(componentFile).toContain(`defineAccordionComponent()`);
        expect(moduleFile).toContain(`import { defineAccordionComponent } from '@tylertech/forge';`);
        expect(moduleFile).toContain(`defineAccordionComponent()`);
    }));
    it('should accept a config file rather than individual arguments', () => __awaiter(void 0, void 0, void 0, function* () {
        const runner = new testing_1.SchematicTestRunner('schematics', collectionPath);
        const tree = yield runner
            .runSchematicAsync('custom-elements', { config: 'src/custom-elements/test-config.json' }, schematics_1.Tree.empty())
            .toPromise();
        expect(tree.files).toEqual([
            '/test/accordion/accordion.component.ts',
            '/test/accordion/accordion.module.ts',
            '/test/expansion-panel/expansion-panel.component.ts',
            '/test/expansion-panel/expansion-panel.module.ts'
        ]);
    }));
    it('should accept a map of dependencies and generate imports/exports in the module', () => __awaiter(void 0, void 0, void 0, function* () {
        const runner = new testing_1.SchematicTestRunner('schematics', collectionPath);
        const tree = yield runner
            .runSchematicAsync('custom-elements', { config: 'src/custom-elements/test-config.json' }, schematics_1.Tree.empty())
            .toPromise();
        const accordionModuleFile = tree.readContent(tree.files[1]);
        expect(accordionModuleFile).toContain(`import { ForgeExpansionPanelModule } from '../expansion-panel/expansion-panel.module';`);
        expect(accordionModuleFile).toContain(`imports: [CommonModule, ForgeExpansionPanelModule]`);
        expect(accordionModuleFile).toContain(`exports: [AccordionComponent, ForgeExpansionPanelModule]`);
    }));
});
//# sourceMappingURL=index_spec.js.map