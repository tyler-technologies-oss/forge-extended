/**
 * @license
 * Copyright Tyler Technologies, Inc. 
 * License: Apache-2.0
 */
import { ForgeResizeObserver, getShadowElement } from '@tylertech/forge-core';
import { BaseAdapter } from '../../core/base/base-adapter';
import { SPLIT_VIEW_PANEL_CONSTANTS } from '../split-view-panel';
import { SPLIT_VIEW_CONSTANTS } from './split-view-constants';
export class SplitViewAdapter extends BaseAdapter {
    constructor(component) {
        super(component);
        this._root = getShadowElement(component, SPLIT_VIEW_CONSTANTS.selectors.ROOT);
    }
    registerSlotListener(listener) {
        this._root.addEventListener('slotchange', listener);
    }
    registerDidOpenListener(listener) {
        this._root.addEventListener(SPLIT_VIEW_PANEL_CONSTANTS.events.DID_OPEN, listener);
    }
    registerDidCloseListener(listener) {
        this._root.addEventListener(SPLIT_VIEW_PANEL_CONSTANTS.events.DID_CLOSE, listener);
    }
    observeResize(callback) {
        ForgeResizeObserver.observe(this._root, callback);
    }
    unobserveResize() {
        ForgeResizeObserver.unobserve(this._root);
    }
    /**
     * Gets all child panels.
     * @returns All child panels.
     */
    getSlottedPanels() {
        const nodeList = this._component.querySelectorAll(SPLIT_VIEW_CONSTANTS.selectors.PANEL);
        const panelArray = Array.from(nodeList);
        const immediateChildPanels = panelArray.filter(panel => panel.parentElement === this._component);
        return immediateChildPanels;
    }
    refitSlottedPanels(orientation) {
        // Check if the combined panel size is greater than the split view size along the relevant axis
        const size = orientation === 'horizontal' ? this._root.clientWidth : this._root.clientHeight;
        const panels = this.getSlottedPanels();
        const combinedPanelSize = panels
            .map(panel => {
            const panelRoot = panel.shadowRoot?.querySelector(SPLIT_VIEW_PANEL_CONSTANTS.selectors.ROOT);
            const panelSize = orientation === 'horizontal' ? panelRoot?.clientWidth : panelRoot?.clientHeight;
            return panelSize ?? 0;
        })
            .reduce((cur, acc) => cur + acc, 0);
        // Do nothing if all the panels fit
        if (combinedPanelSize <= size) {
            return;
        }
        // Get the size adjustment needed to fit
        let diff = combinedPanelSize - size;
        // Size down the panels as needed in reverse order, adjusting diff accordingly
        panels
            .slice()
            .reverse()
            .forEach(panel => {
            if (diff <= 0) {
                return;
            }
            const panelSize = panel.getContentSize();
            const collapsibleSize = panel.getCollapsibleSize();
            const reduceBy = Math.min(diff, collapsibleSize);
            const newSize = panelSize - reduceBy;
            panel.setContentSize(newSize);
            diff -= reduceBy;
        });
        // If there's still overflow nothing else can be done
    }
}
