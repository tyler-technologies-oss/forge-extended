class CorePropertyOptions {
    constructor(options) {
        this.get = true;
        this.set = true;
        if (options) {
            Object.assign(this, options);
        }
    }
}
const CORE_PROPERTY_NAME = '_core';
const corePropertyNotFoundMessage = (className, propertyName) => `${className}\'s core does not contain the property \"${propertyName}\"`;
const coreNotFoundMessage = (className) => `${className} does not have a core`;
function runIfVerified(target, propertyName, action) {
    if (target[CORE_PROPERTY_NAME]) {
        if (propertyName in target[CORE_PROPERTY_NAME]) {
            return action();
        }
        else {
            throw new Error(corePropertyNotFoundMessage(target.localName, propertyName));
        }
    }
    else {
        throw new Error(coreNotFoundMessage(target.localName));
    }
}
/**
 * This decorator is intended to be used on properties of a class that extends `HTMLElement` to dynamically
 * create getters and setters that interact with the `_core` member of the class.
 *
 * @param options The core property options.
 * @returns
 */
export function coreProperty(options) {
    const allOptions = new CorePropertyOptions(options);
    return (target, name, descriptor) => {
        let defaultGet;
        let defaultSet;
        const propertyName = name;
        const corePropertyName = ((options && options.name) || name).toString();
        if (descriptor) {
            defaultGet = descriptor.get;
            defaultSet = descriptor.set;
            descriptor.configurable = true;
            descriptor.enumerable = true;
            if (allOptions.set) {
                descriptor.set = function (value) {
                    return wireDescriptorSet(this, corePropertyName, attributes => {
                        const desc = Object.getOwnPropertyDescriptor(target, corePropertyName);
                        desc.set = attributes.set;
                        Reflect.defineProperty(target, propertyName, desc);
                        attributes.set(value);
                    }, defaultSet);
                };
            }
            if (allOptions.get) {
                descriptor.get = function () {
                    return wireDescriptorGet(this, corePropertyName, attributes => {
                        const desc = Object.getOwnPropertyDescriptor(target, corePropertyName);
                        desc.get = attributes.get;
                        Reflect.defineProperty(target, propertyName, desc);
                        return attributes.get();
                    }, defaultGet);
                };
            }
        }
        else {
            if (allOptions.set || allOptions.get) {
                const attributes = { configurable: true, enumerable: true };
                const get = {
                    get() {
                        const that = this;
                        return wireDescriptorGet(that, corePropertyName, attrs => {
                            let setter;
                            if (allOptions.set) {
                                setter = { ...set };
                            }
                            Reflect.defineProperty(that, corePropertyName, { configurable: true, enumerable: true, ...attrs, ...setter });
                            return attrs.get();
                        });
                    }
                };
                const set = {
                    set(value) {
                        const that = this;
                        return wireDescriptorSet(that, corePropertyName, attrs => {
                            let getter;
                            if (allOptions.get) {
                                getter = { ...get };
                            }
                            Reflect.defineProperty(that, corePropertyName, { configurable: true, enumerable: true, ...attrs, ...getter });
                            attrs.set(value);
                        });
                    }
                };
                if (allOptions.get) {
                    Object.assign(attributes, { ...get });
                }
                if (allOptions.set) {
                    Object.assign(attributes, { ...set });
                }
                Reflect.defineProperty(target, propertyName, attributes);
            }
        }
    };
}
function setCoreProperty(target, value, propertyName) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    target[CORE_PROPERTY_NAME][propertyName] = value;
}
function getCoreProperty(target, propertyName) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return target[CORE_PROPERTY_NAME][propertyName];
}
function wireDescriptorSet(target, propertyName, wireAction, defaultSet) {
    let attributes;
    if (defaultSet) {
        attributes = {
            set(value) {
                defaultSet.call(target, value);
                setCoreProperty(target, value, propertyName);
            }
        };
    }
    else {
        attributes = {
            set(value) {
                setCoreProperty(target, value, propertyName);
            }
        };
    }
    return runIfVerified(target, propertyName, () => wireAction(attributes));
}
function wireDescriptorGet(target, propertyName, wireAction, defaultGet) {
    let attributes;
    if (defaultGet) {
        attributes = {
            get() {
                defaultGet.call(target);
                return getCoreProperty(target, propertyName);
            }
        };
    }
    else {
        attributes = {
            get() {
                return getCoreProperty(target, propertyName);
            }
        };
    }
    return runIfVerified(target, propertyName, () => wireAction(attributes));
}
