import { ElementRef, ChangeDetectorRef, NgZone } from '@angular/core';
import { PopoverComponent as PopoverComponentCustomElement } from '@tylertech/forge';
import * as i0 from "@angular/core";
/**  */
export declare class PopoverComponent {
    protected elementRef: ElementRef<PopoverComponentCustomElement>;
    protected zone: NgZone;
    /** The forge-popover element. */
    readonly nativeElement: PopoverComponentCustomElement;
    /** Whether or not the popover should render an arrow. */
    set arrow(value: PopoverComponentCustomElement['arrow']);
    get arrow(): PopoverComponentCustomElement['arrow'];
    /** The animation type to use for the popover. Valid values are `'none'`, `'fade'`, `'slide'`, and `'zoom'` (default). */
    set animationType(value: PopoverComponentCustomElement['animationType']);
    get animationType(): PopoverComponentCustomElement['animationType'];
    /** The trigger type(s) to use for the popover. Valid values are `'click'` (default), `'hover'`, `'focus'`, and `'longpress'`. Multiple can be specified. */
    set triggerType(value: PopoverComponentCustomElement['triggerType']);
    get triggerType(): PopoverComponentCustomElement['triggerType'];
    /** The delay in milliseconds before a longpress event is detected. */
    set longpressDelay(value: PopoverComponentCustomElement['longpressDelay']);
    get longpressDelay(): PopoverComponentCustomElement['longpressDelay'];
    /** Whether or not the popover should remain open when the user hovers outside the popover. */
    set persistentHover(value: PopoverComponentCustomElement['persistentHover']);
    get persistentHover(): PopoverComponentCustomElement['persistentHover'];
    /** The delay in milliseconds before the popover is shown. */
    set hoverDelay(value: PopoverComponentCustomElement['hoverDelay']);
    get hoverDelay(): PopoverComponentCustomElement['hoverDelay'];
    /** The delay in milliseconds before the popover is dismissed when the user hovers outside of the popover. */
    set hoverDismissDelay(value: PopoverComponentCustomElement['hoverDismissDelay']);
    get hoverDismissDelay(): PopoverComponentCustomElement['hoverDismissDelay'];
    /** The preset to use for the popover. */
    set preset(value: PopoverComponentCustomElement['preset']);
    get preset(): PopoverComponentCustomElement['preset'];
    /** A readonly reference to the internal `<forge-overlay>` element instance. */
    get overlay(): PopoverComponentCustomElement['overlay'];
    /** The anchor element to position the overlay relative to. */
    set anchorElement(value: PopoverComponentCustomElement['anchorElement']);
    get anchorElement(): PopoverComponentCustomElement['anchorElement'];
    /** The IDREF of the anchor element to position the overlay relative to. */
    set anchor(value: PopoverComponentCustomElement['anchor']);
    get anchor(): PopoverComponentCustomElement['anchor'];
    /** Whether the overlay should not be anchored to an element. This allows for custom positioning. */
    set noAnchor(value: PopoverComponentCustomElement['noAnchor']);
    get noAnchor(): PopoverComponentCustomElement['noAnchor'];
    /** Whether the overlay is open. */
    set open(value: PopoverComponentCustomElement['open']);
    get open(): PopoverComponentCustomElement['open'];
    /** Whether the overlay is inline (not in the top-layer). */
    set inline(value: PopoverComponentCustomElement['inline']);
    get inline(): PopoverComponentCustomElement['inline'];
    /** The placement of the overlay. */
    set placement(value: PopoverComponentCustomElement['placement']);
    get placement(): PopoverComponentCustomElement['placement'];
    /** The position strategy of the overlay. */
    set positionStrategy(value: PopoverComponentCustomElement['positionStrategy']);
    get positionStrategy(): PopoverComponentCustomElement['positionStrategy'];
    /** The offset of the overlay. */
    set offset(value: PopoverComponentCustomElement['offset']);
    get offset(): PopoverComponentCustomElement['offset'];
    /** Whether the overlay should shift to fit within the viewport. */
    set shift(value: PopoverComponentCustomElement['shift']);
    get shift(): PopoverComponentCustomElement['shift'];
    /** The hide state of the overlay. */
    set hide(value: PopoverComponentCustomElement['hide']);
    get hide(): PopoverComponentCustomElement['hide'];
    /** Whether the overlay should persist when the anchor is removed. */
    set persistent(value: PopoverComponentCustomElement['persistent']);
    get persistent(): PopoverComponentCustomElement['persistent'];
    /** Whether the overlay should flip placements to another side fit within the viewport. */
    set flip(value: PopoverComponentCustomElement['flip']);
    get flip(): PopoverComponentCustomElement['flip'];
    /** An IDREF to boundary element to constrain the overlay within. */
    set boundary(value: PopoverComponentCustomElement['boundary']);
    get boundary(): PopoverComponentCustomElement['boundary'];
    /** The boundary element instance to constrain the overlay within. */
    set boundaryElement(value: PopoverComponentCustomElement['boundaryElement']);
    get boundaryElement(): PopoverComponentCustomElement['boundaryElement'];
    /** The fallback placements of the overlay. */
    set fallbackPlacements(value: PopoverComponentCustomElement['fallbackPlacements']);
    get fallbackPlacements(): PopoverComponentCustomElement['fallbackPlacements'];
    /** Hides the popover, and returns a `Promise` that resolves when the hide animation is complete. */
    hideAsync(...args: Parameters<PopoverComponentCustomElement['hideAsync']>): ReturnType<PopoverComponentCustomElement['hideAsync']>;
    /** Forces the overlay to reposition itself. */
    position(...args: Parameters<PopoverComponentCustomElement['position']>): ReturnType<PopoverComponentCustomElement['position']>;
    constructor(changeDetectorRef: ChangeDetectorRef, elementRef: ElementRef<PopoverComponentCustomElement>, zone: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<PopoverComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<PopoverComponent, "forge-popover", never, { "arrow": { "alias": "arrow"; "required": false; }; "animationType": { "alias": "animationType"; "required": false; }; "triggerType": { "alias": "triggerType"; "required": false; }; "longpressDelay": { "alias": "longpressDelay"; "required": false; }; "persistentHover": { "alias": "persistentHover"; "required": false; }; "hoverDelay": { "alias": "hoverDelay"; "required": false; }; "hoverDismissDelay": { "alias": "hoverDismissDelay"; "required": false; }; "preset": { "alias": "preset"; "required": false; }; "anchorElement": { "alias": "anchorElement"; "required": false; }; "anchor": { "alias": "anchor"; "required": false; }; "noAnchor": { "alias": "noAnchor"; "required": false; }; "open": { "alias": "open"; "required": false; }; "inline": { "alias": "inline"; "required": false; }; "placement": { "alias": "placement"; "required": false; }; "positionStrategy": { "alias": "positionStrategy"; "required": false; }; "offset": { "alias": "offset"; "required": false; }; "shift": { "alias": "shift"; "required": false; }; "hide": { "alias": "hide"; "required": false; }; "persistent": { "alias": "persistent"; "required": false; }; "flip": { "alias": "flip"; "required": false; }; "boundary": { "alias": "boundary"; "required": false; }; "boundaryElement": { "alias": "boundaryElement"; "required": false; }; "fallbackPlacements": { "alias": "fallbackPlacements"; "required": false; }; }, {}, never, ["*"], false, never>;
    static ngAcceptInputType_arrow: unknown;
    static ngAcceptInputType_longpressDelay: unknown;
    static ngAcceptInputType_persistentHover: unknown;
    static ngAcceptInputType_hoverDelay: unknown;
    static ngAcceptInputType_hoverDismissDelay: unknown;
    static ngAcceptInputType_noAnchor: unknown;
    static ngAcceptInputType_open: unknown;
    static ngAcceptInputType_inline: unknown;
    static ngAcceptInputType_shift: unknown;
    static ngAcceptInputType_persistent: unknown;
}
