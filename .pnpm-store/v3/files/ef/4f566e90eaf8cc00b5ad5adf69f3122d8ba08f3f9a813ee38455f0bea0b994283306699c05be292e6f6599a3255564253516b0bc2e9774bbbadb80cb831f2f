import ESM_COMPAT_Module from "node:module";
import { fileURLToPath as ESM_COMPAT_fileURLToPath } from 'node:url';
import { dirname as ESM_COMPAT_dirname } from 'node:path';
const __filename = ESM_COMPAT_fileURLToPath(import.meta.url);
const __dirname = ESM_COMPAT_dirname(__filename);
const require = ESM_COMPAT_Module.createRequire(import.meta.url);
var nN = Object.create;
var zf = Object.defineProperty;
var sN = Object.getOwnPropertyDescriptor;
var iN = Object.getOwnPropertyNames;
var aN = Object.getPrototypeOf, oN = Object.prototype.hasOwnProperty;
var s = (e, t) => zf(e, "name", { value: t, configurable: !0 }), ie = /* @__PURE__ */ ((e) => typeof require < "u" ? require : typeof Proxy <
"u" ? new Proxy(e, {
  get: (t, r) => (typeof require < "u" ? require : t)[r]
}) : e)(function(e) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + e + '" is not supported');
});
var T = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var lN = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of iN(t))
      !oN.call(e, i) && i !== r && zf(e, i, { get: () => t[i], enumerable: !(n = sN(t, i)) || n.enumerable });
  return e;
};
var Jn = (e, t, r) => (r = e != null ? nN(aN(e)) : {}, lN(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? zf(r, "default", { value: e, enumerable: !0 }) : r,
  e
));

// ../node_modules/@babel/types/lib/utils/shallowEqual.js
var fl = T((Jf) => {
  "use strict";
  Object.defineProperty(Jf, "__esModule", {
    value: !0
  });
  Jf.default = uN;
  function uN(e, t) {
    let r = Object.keys(t);
    for (let n of r)
      if (e[n] !== t[n])
        return !1;
    return !0;
  }
  s(uN, "shallowEqual");
});

// ../node_modules/@babel/types/lib/utils/deprecationWarning.js
var Aa = T((Xf) => {
  "use strict";
  Object.defineProperty(Xf, "__esModule", {
    value: !0
  });
  Xf.default = cN;
  var U1 = /* @__PURE__ */ new Set();
  function cN(e, t, r = "") {
    if (U1.has(e)) return;
    U1.add(e);
    let {
      internal: n,
      trace: i
    } = fN(1, 2);
    n || console.warn(`${r}\`${e}\` has been deprecated, please migrate to \`${t}\`
${i}`);
  }
  s(cN, "deprecationWarning");
  function fN(e, t) {
    let {
      stackTraceLimit: r,
      prepareStackTrace: n
    } = Error, i;
    if (Error.stackTraceLimit = 1 + e + t, Error.prepareStackTrace = function(o, l) {
      i = l;
    }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = n, !i) return {
      internal: !1,
      trace: ""
    };
    let a = i.slice(1 + e, 1 + e + t);
    return {
      internal: /[\\/]@babel[\\/]/.test(a[1].getFileName()),
      trace: a.map((o) => `    at ${o}`).join(`
`)
    };
  }
  s(fN, "captureShortStackTrace");
});

// ../node_modules/@babel/types/lib/validators/generated/index.js
var Tt = T((x) => {
  "use strict";
  Object.defineProperty(x, "__esModule", {
    value: !0
  });
  x.isAccessor = A4;
  x.isAnyTypeAnnotation = G3;
  x.isArgumentPlaceholder = Tk;
  x.isArrayExpression = pN;
  x.isArrayPattern = c3;
  x.isArrayTypeAnnotation = H3;
  x.isArrowFunctionExpression = f3;
  x.isAssignmentExpression = dN;
  x.isAssignmentPattern = u3;
  x.isAwaitExpression = k3;
  x.isBigIntLiteral = j3;
  x.isBinary = YF;
  x.isBinaryExpression = hN;
  x.isBindExpression = xk;
  x.isBlock = XF;
  x.isBlockParent = JF;
  x.isBlockStatement = bN;
  x.isBooleanLiteral = RN;
  x.isBooleanLiteralTypeAnnotation = z3;
  x.isBooleanTypeAnnotation = Y3;
  x.isBreakStatement = EN;
  x.isCallExpression = vN;
  x.isCatchClause = TN;
  x.isClass = x4;
  x.isClassAccessorProperty = U3;
  x.isClassBody = p3;
  x.isClassDeclaration = h3;
  x.isClassExpression = d3;
  x.isClassImplements = X3;
  x.isClassMethod = C3;
  x.isClassPrivateMethod = $3;
  x.isClassPrivateProperty = V3;
  x.isClassProperty = q3;
  x.isCompletionStatement = e4;
  x.isConditional = t4;
  x.isConditionalExpression = xN;
  x.isContinueStatement = SN;
  x.isDebuggerStatement = PN;
  x.isDecimalLiteral = Ik;
  x.isDeclaration = c4;
  x.isDeclareClass = Q3;
  x.isDeclareExportAllDeclaration = oB;
  x.isDeclareExportDeclaration = aB;
  x.isDeclareFunction = Z3;
  x.isDeclareInterface = eB;
  x.isDeclareModule = tB;
  x.isDeclareModuleExports = rB;
  x.isDeclareOpaqueType = sB;
  x.isDeclareTypeAlias = nB;
  x.isDeclareVariable = iB;
  x.isDeclaredPredicate = lB;
  x.isDecorator = Pk;
  x.isDirective = yN;
  x.isDirectiveLiteral = gN;
  x.isDoExpression = Ak;
  x.isDoWhileStatement = AN;
  x.isEmptyStatement = CN;
  x.isEmptyTypeAnnotation = EB;
  x.isEnumBody = N4;
  x.isEnumBooleanBody = HB;
  x.isEnumBooleanMember = XB;
  x.isEnumDeclaration = GB;
  x.isEnumDefaultedMember = ek;
  x.isEnumMember = B4;
  x.isEnumNumberBody = YB;
  x.isEnumNumberMember = QB;
  x.isEnumStringBody = zB;
  x.isEnumStringMember = ZB;
  x.isEnumSymbolBody = JB;
  x.isExistsTypeAnnotation = uB;
  x.isExportAllDeclaration = m3;
  x.isExportDeclaration = S4;
  x.isExportDefaultDeclaration = y3;
  x.isExportDefaultSpecifier = Ck;
  x.isExportNamedDeclaration = g3;
  x.isExportNamespaceSpecifier = L3;
  x.isExportSpecifier = b3;
  x.isExpression = HF;
  x.isExpressionStatement = wN;
  x.isExpressionWrapper = s4;
  x.isFile = DN;
  x.isFlow = w4;
  x.isFlowBaseAnnotation = I4;
  x.isFlowDeclaration = _4;
  x.isFlowPredicate = O4;
  x.isFlowType = D4;
  x.isFor = i4;
  x.isForInStatement = IN;
  x.isForOfStatement = E3;
  x.isForStatement = _N;
  x.isForXStatement = a4;
  x.isFunction = o4;
  x.isFunctionDeclaration = ON;
  x.isFunctionExpression = NN;
  x.isFunctionParent = l4;
  x.isFunctionTypeAnnotation = cB;
  x.isFunctionTypeParam = fB;
  x.isGenericTypeAnnotation = pB;
  x.isIdentifier = BN;
  x.isIfStatement = kN;
  x.isImmutable = m4;
  x.isImport = F3;
  x.isImportAttribute = Sk;
  x.isImportDeclaration = v3;
  x.isImportDefaultSpecifier = T3;
  x.isImportExpression = P3;
  x.isImportNamespaceSpecifier = x3;
  x.isImportOrExportDeclaration = V1;
  x.isImportSpecifier = S3;
  x.isIndexedAccessType = tk;
  x.isInferredPredicate = dB;
  x.isInterfaceDeclaration = mB;
  x.isInterfaceExtends = hB;
  x.isInterfaceTypeAnnotation = yB;
  x.isInterpreterDirective = mN;
  x.isIntersectionTypeAnnotation = gB;
  x.isJSX = k4;
  x.isJSXAttribute = nk;
  x.isJSXClosingElement = sk;
  x.isJSXClosingFragment = gk;
  x.isJSXElement = ik;
  x.isJSXEmptyExpression = ak;
  x.isJSXExpressionContainer = ok;
  x.isJSXFragment = mk;
  x.isJSXIdentifier = uk;
  x.isJSXMemberExpression = ck;
  x.isJSXNamespacedName = fk;
  x.isJSXOpeningElement = pk;
  x.isJSXOpeningFragment = yk;
  x.isJSXSpreadAttribute = dk;
  x.isJSXSpreadChild = lk;
  x.isJSXText = hk;
  x.isLVal = p4;
  x.isLabeledStatement = FN;
  x.isLiteral = h4;
  x.isLogicalExpression = UN;
  x.isLoop = r4;
  x.isMemberExpression = VN;
  x.isMetaProperty = A3;
  x.isMethod = g4;
  x.isMiscellaneous = F4;
  x.isMixedTypeAnnotation = bB;
  x.isModuleDeclaration = W4;
  x.isModuleExpression = _k;
  x.isModuleSpecifier = P4;
  x.isNewExpression = $N;
  x.isNoop = bk;
  x.isNullLiteral = MN;
  x.isNullLiteralTypeAnnotation = J3;
  x.isNullableTypeAnnotation = vB;
  x.isNumberLiteral = q4;
  x.isNumberLiteralTypeAnnotation = TB;
  x.isNumberTypeAnnotation = xB;
  x.isNumericLiteral = LN;
  x.isObjectExpression = KN;
  x.isObjectMember = b4;
  x.isObjectMethod = GN;
  x.isObjectPattern = w3;
  x.isObjectProperty = HN;
  x.isObjectTypeAnnotation = SB;
  x.isObjectTypeCallProperty = AB;
  x.isObjectTypeIndexer = CB;
  x.isObjectTypeInternalSlot = PB;
  x.isObjectTypeProperty = wB;
  x.isObjectTypeSpreadProperty = DB;
  x.isOpaqueType = IB;
  x.isOptionalCallExpression = R3;
  x.isOptionalIndexedAccessType = rk;
  x.isOptionalMemberExpression = M3;
  x.isParenthesizedExpression = XN;
  x.isPattern = T4;
  x.isPatternLike = f4;
  x.isPipelineBareFunction = Bk;
  x.isPipelinePrimaryTopicReference = kk;
  x.isPipelineTopicExpression = Nk;
  x.isPlaceholder = Ek;
  x.isPrivate = C4;
  x.isPrivateName = W3;
  x.isProgram = WN;
  x.isProperty = E4;
  x.isPureish = u4;
  x.isQualifiedTypeIdentifier = _B;
  x.isRecordExpression = wk;
  x.isRegExpLiteral = qN;
  x.isRegexLiteral = U4;
  x.isRestElement = YN;
  x.isRestProperty = V4;
  x.isReturnStatement = zN;
  x.isScopable = zF;
  x.isSequenceExpression = JN;
  x.isSpreadElement = D3;
  x.isSpreadProperty = $4;
  x.isStandardized = GF;
  x.isStatement = QF;
  x.isStaticBlock = K3;
  x.isStringLiteral = jN;
  x.isStringLiteralTypeAnnotation = OB;
  x.isStringTypeAnnotation = NB;
  x.isSuper = I3;
  x.isSwitchCase = QN;
  x.isSwitchStatement = ZN;
  x.isSymbolTypeAnnotation = BB;
  x.isTSAnyKeyword = Wk;
  x.isTSArrayType = cF;
  x.isTSAsExpression = IF;
  x.isTSBaseType = R4;
  x.isTSBigIntKeyword = Gk;
  x.isTSBooleanKeyword = Kk;
  x.isTSCallSignatureDeclaration = Rk;
  x.isTSConditionalType = gF;
  x.isTSConstructSignatureDeclaration = qk;
  x.isTSConstructorType = iF;
  x.isTSDeclareFunction = jk;
  x.isTSDeclareMethod = Lk;
  x.isTSEntityName = d4;
  x.isTSEnumDeclaration = NF;
  x.isTSEnumMember = BF;
  x.isTSExportAssignment = qF;
  x.isTSExpressionWithTypeArguments = PF;
  x.isTSExternalModuleReference = MF;
  x.isTSFunctionType = sF;
  x.isTSImportEqualsDeclaration = LF;
  x.isTSImportType = jF;
  x.isTSIndexSignature = $k;
  x.isTSIndexedAccessType = TF;
  x.isTSInferType = bF;
  x.isTSInstantiationExpression = DF;
  x.isTSInterfaceBody = CF;
  x.isTSInterfaceDeclaration = AF;
  x.isTSIntersectionType = yF;
  x.isTSIntrinsicKeyword = Hk;
  x.isTSLiteralType = SF;
  x.isTSMappedType = xF;
  x.isTSMethodSignature = Vk;
  x.isTSModuleBlock = FF;
  x.isTSModuleDeclaration = kF;
  x.isTSNamedTupleMember = hF;
  x.isTSNamespaceExportDeclaration = UF;
  x.isTSNeverKeyword = Yk;
  x.isTSNonNullExpression = RF;
  x.isTSNullKeyword = zk;
  x.isTSNumberKeyword = Jk;
  x.isTSObjectKeyword = Xk;
  x.isTSOptionalType = pF;
  x.isTSParameterProperty = Fk;
  x.isTSParenthesizedType = EF;
  x.isTSPropertySignature = Uk;
  x.isTSQualifiedName = Mk;
  x.isTSRestType = dF;
  x.isTSSatisfiesExpression = _F;
  x.isTSStringKeyword = Qk;
  x.isTSSymbolKeyword = Zk;
  x.isTSThisType = nF;
  x.isTSTupleType = fF;
  x.isTSType = M4;
  x.isTSTypeAliasDeclaration = wF;
  x.isTSTypeAnnotation = VF;
  x.isTSTypeAssertion = OF;
  x.isTSTypeElement = L4;
  x.isTSTypeLiteral = uF;
  x.isTSTypeOperator = vF;
  x.isTSTypeParameter = KF;
  x.isTSTypeParameterDeclaration = WF;
  x.isTSTypeParameterInstantiation = $F;
  x.isTSTypePredicate = oF;
  x.isTSTypeQuery = lF;
  x.isTSTypeReference = aF;
  x.isTSUndefinedKeyword = eF;
  x.isTSUnionType = mF;
  x.isTSUnknownKeyword = tF;
  x.isTSVoidKeyword = rF;
  x.isTaggedTemplateExpression = _3;
  x.isTemplateElement = O3;
  x.isTemplateLiteral = N3;
  x.isTerminatorless = ZF;
  x.isThisExpression = e3;
  x.isThisTypeAnnotation = kB;
  x.isThrowStatement = t3;
  x.isTopicReference = Ok;
  x.isTryStatement = r3;
  x.isTupleExpression = Dk;
  x.isTupleTypeAnnotation = FB;
  x.isTypeAlias = LB;
  x.isTypeAnnotation = MB;
  x.isTypeCastExpression = RB;
  x.isTypeParameter = qB;
  x.isTypeParameterDeclaration = UB;
  x.isTypeParameterInstantiation = VB;
  x.isTypeScript = j4;
  x.isTypeofTypeAnnotation = jB;
  x.isUnaryExpression = n3;
  x.isUnaryLike = v4;
  x.isUnionTypeAnnotation = $B;
  x.isUpdateExpression = s3;
  x.isUserWhitespacable = y4;
  x.isV8IntrinsicIdentifier = vk;
  x.isVariableDeclaration = i3;
  x.isVariableDeclarator = a3;
  x.isVariance = WB;
  x.isVoidTypeAnnotation = KB;
  x.isWhile = n4;
  x.isWhileStatement = o3;
  x.isWithStatement = l3;
  x.isYieldExpression = B3;
  var A = fl(), Ca = Aa();
  function pN(e, t) {
    return !e || e.type !== "ArrayExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(pN, "isArrayExpression");
  function dN(e, t) {
    return !e || e.type !== "AssignmentExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(dN, "isAssignmentExpression");
  function hN(e, t) {
    return !e || e.type !== "BinaryExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(hN, "isBinaryExpression");
  function mN(e, t) {
    return !e || e.type !== "InterpreterDirective" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(mN, "isInterpreterDirective");
  function yN(e, t) {
    return !e || e.type !== "Directive" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(yN, "isDirective");
  function gN(e, t) {
    return !e || e.type !== "DirectiveLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(gN, "isDirectiveLiteral");
  function bN(e, t) {
    return !e || e.type !== "BlockStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(bN, "isBlockStatement");
  function EN(e, t) {
    return !e || e.type !== "BreakStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(EN, "isBreakStatement");
  function vN(e, t) {
    return !e || e.type !== "CallExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(vN, "isCallExpression");
  function TN(e, t) {
    return !e || e.type !== "CatchClause" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(TN, "isCatchClause");
  function xN(e, t) {
    return !e || e.type !== "ConditionalExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(xN, "isConditionalExpression");
  function SN(e, t) {
    return !e || e.type !== "ContinueStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(SN, "isContinueStatement");
  function PN(e, t) {
    return !e || e.type !== "DebuggerStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(PN, "isDebuggerStatement");
  function AN(e, t) {
    return !e || e.type !== "DoWhileStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(AN, "isDoWhileStatement");
  function CN(e, t) {
    return !e || e.type !== "EmptyStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(CN, "isEmptyStatement");
  function wN(e, t) {
    return !e || e.type !== "ExpressionStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(wN, "isExpressionStatement");
  function DN(e, t) {
    return !e || e.type !== "File" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(DN, "isFile");
  function IN(e, t) {
    return !e || e.type !== "ForInStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(IN, "isForInStatement");
  function _N(e, t) {
    return !e || e.type !== "ForStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(_N, "isForStatement");
  function ON(e, t) {
    return !e || e.type !== "FunctionDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(ON, "isFunctionDeclaration");
  function NN(e, t) {
    return !e || e.type !== "FunctionExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(NN, "isFunctionExpression");
  function BN(e, t) {
    return !e || e.type !== "Identifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(BN, "isIdentifier");
  function kN(e, t) {
    return !e || e.type !== "IfStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(kN, "isIfStatement");
  function FN(e, t) {
    return !e || e.type !== "LabeledStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(FN, "isLabeledStatement");
  function jN(e, t) {
    return !e || e.type !== "StringLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(jN, "isStringLiteral");
  function LN(e, t) {
    return !e || e.type !== "NumericLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(LN, "isNumericLiteral");
  function MN(e, t) {
    return !e || e.type !== "NullLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(MN, "isNullLiteral");
  function RN(e, t) {
    return !e || e.type !== "BooleanLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(RN, "isBooleanLiteral");
  function qN(e, t) {
    return !e || e.type !== "RegExpLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(qN, "isRegExpLiteral");
  function UN(e, t) {
    return !e || e.type !== "LogicalExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(UN, "isLogicalExpression");
  function VN(e, t) {
    return !e || e.type !== "MemberExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(VN, "isMemberExpression");
  function $N(e, t) {
    return !e || e.type !== "NewExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s($N, "isNewExpression");
  function WN(e, t) {
    return !e || e.type !== "Program" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(WN, "isProgram");
  function KN(e, t) {
    return !e || e.type !== "ObjectExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(KN, "isObjectExpression");
  function GN(e, t) {
    return !e || e.type !== "ObjectMethod" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(GN, "isObjectMethod");
  function HN(e, t) {
    return !e || e.type !== "ObjectProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(HN, "isObjectProperty");
  function YN(e, t) {
    return !e || e.type !== "RestElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(YN, "isRestElement");
  function zN(e, t) {
    return !e || e.type !== "ReturnStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(zN, "isReturnStatement");
  function JN(e, t) {
    return !e || e.type !== "SequenceExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(JN, "isSequenceExpression");
  function XN(e, t) {
    return !e || e.type !== "ParenthesizedExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(XN, "isParenthesizedExpression");
  function QN(e, t) {
    return !e || e.type !== "SwitchCase" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(QN, "isSwitchCase");
  function ZN(e, t) {
    return !e || e.type !== "SwitchStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(ZN, "isSwitchStatement");
  function e3(e, t) {
    return !e || e.type !== "ThisExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(e3, "isThisExpression");
  function t3(e, t) {
    return !e || e.type !== "ThrowStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(t3, "isThrowStatement");
  function r3(e, t) {
    return !e || e.type !== "TryStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(r3, "isTryStatement");
  function n3(e, t) {
    return !e || e.type !== "UnaryExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(n3, "isUnaryExpression");
  function s3(e, t) {
    return !e || e.type !== "UpdateExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(s3, "isUpdateExpression");
  function i3(e, t) {
    return !e || e.type !== "VariableDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(i3, "isVariableDeclaration");
  function a3(e, t) {
    return !e || e.type !== "VariableDeclarator" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(a3, "isVariableDeclarator");
  function o3(e, t) {
    return !e || e.type !== "WhileStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(o3, "isWhileStatement");
  function l3(e, t) {
    return !e || e.type !== "WithStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(l3, "isWithStatement");
  function u3(e, t) {
    return !e || e.type !== "AssignmentPattern" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(u3, "isAssignmentPattern");
  function c3(e, t) {
    return !e || e.type !== "ArrayPattern" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(c3, "isArrayPattern");
  function f3(e, t) {
    return !e || e.type !== "ArrowFunctionExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(f3, "isArrowFunctionExpression");
  function p3(e, t) {
    return !e || e.type !== "ClassBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(p3, "isClassBody");
  function d3(e, t) {
    return !e || e.type !== "ClassExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(d3, "isClassExpression");
  function h3(e, t) {
    return !e || e.type !== "ClassDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(h3, "isClassDeclaration");
  function m3(e, t) {
    return !e || e.type !== "ExportAllDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(m3, "isExportAllDeclaration");
  function y3(e, t) {
    return !e || e.type !== "ExportDefaultDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(y3, "isExportDefaultDeclaration");
  function g3(e, t) {
    return !e || e.type !== "ExportNamedDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(g3, "isExportNamedDeclaration");
  function b3(e, t) {
    return !e || e.type !== "ExportSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(b3, "isExportSpecifier");
  function E3(e, t) {
    return !e || e.type !== "ForOfStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(E3, "isForOfStatement");
  function v3(e, t) {
    return !e || e.type !== "ImportDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(v3, "isImportDeclaration");
  function T3(e, t) {
    return !e || e.type !== "ImportDefaultSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(T3, "isImportDefaultSpecifier");
  function x3(e, t) {
    return !e || e.type !== "ImportNamespaceSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(x3, "isImportNamespaceSpecifier");
  function S3(e, t) {
    return !e || e.type !== "ImportSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(S3, "isImportSpecifier");
  function P3(e, t) {
    return !e || e.type !== "ImportExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(P3, "isImportExpression");
  function A3(e, t) {
    return !e || e.type !== "MetaProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(A3, "isMetaProperty");
  function C3(e, t) {
    return !e || e.type !== "ClassMethod" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(C3, "isClassMethod");
  function w3(e, t) {
    return !e || e.type !== "ObjectPattern" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(w3, "isObjectPattern");
  function D3(e, t) {
    return !e || e.type !== "SpreadElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(D3, "isSpreadElement");
  function I3(e, t) {
    return !e || e.type !== "Super" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(I3, "isSuper");
  function _3(e, t) {
    return !e || e.type !== "TaggedTemplateExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(_3, "isTaggedTemplateExpression");
  function O3(e, t) {
    return !e || e.type !== "TemplateElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(O3, "isTemplateElement");
  function N3(e, t) {
    return !e || e.type !== "TemplateLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(N3, "isTemplateLiteral");
  function B3(e, t) {
    return !e || e.type !== "YieldExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(B3, "isYieldExpression");
  function k3(e, t) {
    return !e || e.type !== "AwaitExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(k3, "isAwaitExpression");
  function F3(e, t) {
    return !e || e.type !== "Import" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(F3, "isImport");
  function j3(e, t) {
    return !e || e.type !== "BigIntLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(j3, "isBigIntLiteral");
  function L3(e, t) {
    return !e || e.type !== "ExportNamespaceSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(L3, "isExportNamespaceSpecifier");
  function M3(e, t) {
    return !e || e.type !== "OptionalMemberExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(M3, "isOptionalMemberExpression");
  function R3(e, t) {
    return !e || e.type !== "OptionalCallExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(R3, "isOptionalCallExpression");
  function q3(e, t) {
    return !e || e.type !== "ClassProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(q3, "isClassProperty");
  function U3(e, t) {
    return !e || e.type !== "ClassAccessorProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(U3, "isClassAccessorProperty");
  function V3(e, t) {
    return !e || e.type !== "ClassPrivateProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(V3, "isClassPrivateProperty");
  function $3(e, t) {
    return !e || e.type !== "ClassPrivateMethod" ? !1 : t == null || (0, A.default)(e, t);
  }
  s($3, "isClassPrivateMethod");
  function W3(e, t) {
    return !e || e.type !== "PrivateName" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(W3, "isPrivateName");
  function K3(e, t) {
    return !e || e.type !== "StaticBlock" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(K3, "isStaticBlock");
  function G3(e, t) {
    return !e || e.type !== "AnyTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(G3, "isAnyTypeAnnotation");
  function H3(e, t) {
    return !e || e.type !== "ArrayTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(H3, "isArrayTypeAnnotation");
  function Y3(e, t) {
    return !e || e.type !== "BooleanTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Y3, "isBooleanTypeAnnotation");
  function z3(e, t) {
    return !e || e.type !== "BooleanLiteralTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(z3, "isBooleanLiteralTypeAnnotation");
  function J3(e, t) {
    return !e || e.type !== "NullLiteralTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(J3, "isNullLiteralTypeAnnotation");
  function X3(e, t) {
    return !e || e.type !== "ClassImplements" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(X3, "isClassImplements");
  function Q3(e, t) {
    return !e || e.type !== "DeclareClass" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Q3, "isDeclareClass");
  function Z3(e, t) {
    return !e || e.type !== "DeclareFunction" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Z3, "isDeclareFunction");
  function eB(e, t) {
    return !e || e.type !== "DeclareInterface" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(eB, "isDeclareInterface");
  function tB(e, t) {
    return !e || e.type !== "DeclareModule" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(tB, "isDeclareModule");
  function rB(e, t) {
    return !e || e.type !== "DeclareModuleExports" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(rB, "isDeclareModuleExports");
  function nB(e, t) {
    return !e || e.type !== "DeclareTypeAlias" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(nB, "isDeclareTypeAlias");
  function sB(e, t) {
    return !e || e.type !== "DeclareOpaqueType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(sB, "isDeclareOpaqueType");
  function iB(e, t) {
    return !e || e.type !== "DeclareVariable" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(iB, "isDeclareVariable");
  function aB(e, t) {
    return !e || e.type !== "DeclareExportDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(aB, "isDeclareExportDeclaration");
  function oB(e, t) {
    return !e || e.type !== "DeclareExportAllDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(oB, "isDeclareExportAllDeclaration");
  function lB(e, t) {
    return !e || e.type !== "DeclaredPredicate" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(lB, "isDeclaredPredicate");
  function uB(e, t) {
    return !e || e.type !== "ExistsTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(uB, "isExistsTypeAnnotation");
  function cB(e, t) {
    return !e || e.type !== "FunctionTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(cB, "isFunctionTypeAnnotation");
  function fB(e, t) {
    return !e || e.type !== "FunctionTypeParam" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(fB, "isFunctionTypeParam");
  function pB(e, t) {
    return !e || e.type !== "GenericTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(pB, "isGenericTypeAnnotation");
  function dB(e, t) {
    return !e || e.type !== "InferredPredicate" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(dB, "isInferredPredicate");
  function hB(e, t) {
    return !e || e.type !== "InterfaceExtends" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(hB, "isInterfaceExtends");
  function mB(e, t) {
    return !e || e.type !== "InterfaceDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(mB, "isInterfaceDeclaration");
  function yB(e, t) {
    return !e || e.type !== "InterfaceTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(yB, "isInterfaceTypeAnnotation");
  function gB(e, t) {
    return !e || e.type !== "IntersectionTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(gB, "isIntersectionTypeAnnotation");
  function bB(e, t) {
    return !e || e.type !== "MixedTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(bB, "isMixedTypeAnnotation");
  function EB(e, t) {
    return !e || e.type !== "EmptyTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(EB, "isEmptyTypeAnnotation");
  function vB(e, t) {
    return !e || e.type !== "NullableTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(vB, "isNullableTypeAnnotation");
  function TB(e, t) {
    return !e || e.type !== "NumberLiteralTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(TB, "isNumberLiteralTypeAnnotation");
  function xB(e, t) {
    return !e || e.type !== "NumberTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(xB, "isNumberTypeAnnotation");
  function SB(e, t) {
    return !e || e.type !== "ObjectTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(SB, "isObjectTypeAnnotation");
  function PB(e, t) {
    return !e || e.type !== "ObjectTypeInternalSlot" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(PB, "isObjectTypeInternalSlot");
  function AB(e, t) {
    return !e || e.type !== "ObjectTypeCallProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(AB, "isObjectTypeCallProperty");
  function CB(e, t) {
    return !e || e.type !== "ObjectTypeIndexer" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(CB, "isObjectTypeIndexer");
  function wB(e, t) {
    return !e || e.type !== "ObjectTypeProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(wB, "isObjectTypeProperty");
  function DB(e, t) {
    return !e || e.type !== "ObjectTypeSpreadProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(DB, "isObjectTypeSpreadProperty");
  function IB(e, t) {
    return !e || e.type !== "OpaqueType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(IB, "isOpaqueType");
  function _B(e, t) {
    return !e || e.type !== "QualifiedTypeIdentifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(_B, "isQualifiedTypeIdentifier");
  function OB(e, t) {
    return !e || e.type !== "StringLiteralTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(OB, "isStringLiteralTypeAnnotation");
  function NB(e, t) {
    return !e || e.type !== "StringTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(NB, "isStringTypeAnnotation");
  function BB(e, t) {
    return !e || e.type !== "SymbolTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(BB, "isSymbolTypeAnnotation");
  function kB(e, t) {
    return !e || e.type !== "ThisTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(kB, "isThisTypeAnnotation");
  function FB(e, t) {
    return !e || e.type !== "TupleTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(FB, "isTupleTypeAnnotation");
  function jB(e, t) {
    return !e || e.type !== "TypeofTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(jB, "isTypeofTypeAnnotation");
  function LB(e, t) {
    return !e || e.type !== "TypeAlias" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(LB, "isTypeAlias");
  function MB(e, t) {
    return !e || e.type !== "TypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(MB, "isTypeAnnotation");
  function RB(e, t) {
    return !e || e.type !== "TypeCastExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(RB, "isTypeCastExpression");
  function qB(e, t) {
    return !e || e.type !== "TypeParameter" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(qB, "isTypeParameter");
  function UB(e, t) {
    return !e || e.type !== "TypeParameterDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(UB, "isTypeParameterDeclaration");
  function VB(e, t) {
    return !e || e.type !== "TypeParameterInstantiation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(VB, "isTypeParameterInstantiation");
  function $B(e, t) {
    return !e || e.type !== "UnionTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s($B, "isUnionTypeAnnotation");
  function WB(e, t) {
    return !e || e.type !== "Variance" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(WB, "isVariance");
  function KB(e, t) {
    return !e || e.type !== "VoidTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(KB, "isVoidTypeAnnotation");
  function GB(e, t) {
    return !e || e.type !== "EnumDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(GB, "isEnumDeclaration");
  function HB(e, t) {
    return !e || e.type !== "EnumBooleanBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(HB, "isEnumBooleanBody");
  function YB(e, t) {
    return !e || e.type !== "EnumNumberBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(YB, "isEnumNumberBody");
  function zB(e, t) {
    return !e || e.type !== "EnumStringBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(zB, "isEnumStringBody");
  function JB(e, t) {
    return !e || e.type !== "EnumSymbolBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(JB, "isEnumSymbolBody");
  function XB(e, t) {
    return !e || e.type !== "EnumBooleanMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(XB, "isEnumBooleanMember");
  function QB(e, t) {
    return !e || e.type !== "EnumNumberMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(QB, "isEnumNumberMember");
  function ZB(e, t) {
    return !e || e.type !== "EnumStringMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(ZB, "isEnumStringMember");
  function ek(e, t) {
    return !e || e.type !== "EnumDefaultedMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(ek, "isEnumDefaultedMember");
  function tk(e, t) {
    return !e || e.type !== "IndexedAccessType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(tk, "isIndexedAccessType");
  function rk(e, t) {
    return !e || e.type !== "OptionalIndexedAccessType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(rk, "isOptionalIndexedAccessType");
  function nk(e, t) {
    return !e || e.type !== "JSXAttribute" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(nk, "isJSXAttribute");
  function sk(e, t) {
    return !e || e.type !== "JSXClosingElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(sk, "isJSXClosingElement");
  function ik(e, t) {
    return !e || e.type !== "JSXElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(ik, "isJSXElement");
  function ak(e, t) {
    return !e || e.type !== "JSXEmptyExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(ak, "isJSXEmptyExpression");
  function ok(e, t) {
    return !e || e.type !== "JSXExpressionContainer" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(ok, "isJSXExpressionContainer");
  function lk(e, t) {
    return !e || e.type !== "JSXSpreadChild" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(lk, "isJSXSpreadChild");
  function uk(e, t) {
    return !e || e.type !== "JSXIdentifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(uk, "isJSXIdentifier");
  function ck(e, t) {
    return !e || e.type !== "JSXMemberExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(ck, "isJSXMemberExpression");
  function fk(e, t) {
    return !e || e.type !== "JSXNamespacedName" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(fk, "isJSXNamespacedName");
  function pk(e, t) {
    return !e || e.type !== "JSXOpeningElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(pk, "isJSXOpeningElement");
  function dk(e, t) {
    return !e || e.type !== "JSXSpreadAttribute" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(dk, "isJSXSpreadAttribute");
  function hk(e, t) {
    return !e || e.type !== "JSXText" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(hk, "isJSXText");
  function mk(e, t) {
    return !e || e.type !== "JSXFragment" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(mk, "isJSXFragment");
  function yk(e, t) {
    return !e || e.type !== "JSXOpeningFragment" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(yk, "isJSXOpeningFragment");
  function gk(e, t) {
    return !e || e.type !== "JSXClosingFragment" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(gk, "isJSXClosingFragment");
  function bk(e, t) {
    return !e || e.type !== "Noop" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(bk, "isNoop");
  function Ek(e, t) {
    return !e || e.type !== "Placeholder" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Ek, "isPlaceholder");
  function vk(e, t) {
    return !e || e.type !== "V8IntrinsicIdentifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(vk, "isV8IntrinsicIdentifier");
  function Tk(e, t) {
    return !e || e.type !== "ArgumentPlaceholder" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Tk, "isArgumentPlaceholder");
  function xk(e, t) {
    return !e || e.type !== "BindExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(xk, "isBindExpression");
  function Sk(e, t) {
    return !e || e.type !== "ImportAttribute" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Sk, "isImportAttribute");
  function Pk(e, t) {
    return !e || e.type !== "Decorator" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Pk, "isDecorator");
  function Ak(e, t) {
    return !e || e.type !== "DoExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Ak, "isDoExpression");
  function Ck(e, t) {
    return !e || e.type !== "ExportDefaultSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Ck, "isExportDefaultSpecifier");
  function wk(e, t) {
    return !e || e.type !== "RecordExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(wk, "isRecordExpression");
  function Dk(e, t) {
    return !e || e.type !== "TupleExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Dk, "isTupleExpression");
  function Ik(e, t) {
    return !e || e.type !== "DecimalLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Ik, "isDecimalLiteral");
  function _k(e, t) {
    return !e || e.type !== "ModuleExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(_k, "isModuleExpression");
  function Ok(e, t) {
    return !e || e.type !== "TopicReference" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Ok, "isTopicReference");
  function Nk(e, t) {
    return !e || e.type !== "PipelineTopicExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Nk, "isPipelineTopicExpression");
  function Bk(e, t) {
    return !e || e.type !== "PipelineBareFunction" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Bk, "isPipelineBareFunction");
  function kk(e, t) {
    return !e || e.type !== "PipelinePrimaryTopicReference" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(kk, "isPipelinePrimaryTopicReference");
  function Fk(e, t) {
    return !e || e.type !== "TSParameterProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Fk, "isTSParameterProperty");
  function jk(e, t) {
    return !e || e.type !== "TSDeclareFunction" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(jk, "isTSDeclareFunction");
  function Lk(e, t) {
    return !e || e.type !== "TSDeclareMethod" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Lk, "isTSDeclareMethod");
  function Mk(e, t) {
    return !e || e.type !== "TSQualifiedName" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Mk, "isTSQualifiedName");
  function Rk(e, t) {
    return !e || e.type !== "TSCallSignatureDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Rk, "isTSCallSignatureDeclaration");
  function qk(e, t) {
    return !e || e.type !== "TSConstructSignatureDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(qk, "isTSConstructSignatureDeclaration");
  function Uk(e, t) {
    return !e || e.type !== "TSPropertySignature" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Uk, "isTSPropertySignature");
  function Vk(e, t) {
    return !e || e.type !== "TSMethodSignature" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Vk, "isTSMethodSignature");
  function $k(e, t) {
    return !e || e.type !== "TSIndexSignature" ? !1 : t == null || (0, A.default)(e, t);
  }
  s($k, "isTSIndexSignature");
  function Wk(e, t) {
    return !e || e.type !== "TSAnyKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Wk, "isTSAnyKeyword");
  function Kk(e, t) {
    return !e || e.type !== "TSBooleanKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Kk, "isTSBooleanKeyword");
  function Gk(e, t) {
    return !e || e.type !== "TSBigIntKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Gk, "isTSBigIntKeyword");
  function Hk(e, t) {
    return !e || e.type !== "TSIntrinsicKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Hk, "isTSIntrinsicKeyword");
  function Yk(e, t) {
    return !e || e.type !== "TSNeverKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Yk, "isTSNeverKeyword");
  function zk(e, t) {
    return !e || e.type !== "TSNullKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(zk, "isTSNullKeyword");
  function Jk(e, t) {
    return !e || e.type !== "TSNumberKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Jk, "isTSNumberKeyword");
  function Xk(e, t) {
    return !e || e.type !== "TSObjectKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Xk, "isTSObjectKeyword");
  function Qk(e, t) {
    return !e || e.type !== "TSStringKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Qk, "isTSStringKeyword");
  function Zk(e, t) {
    return !e || e.type !== "TSSymbolKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(Zk, "isTSSymbolKeyword");
  function eF(e, t) {
    return !e || e.type !== "TSUndefinedKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(eF, "isTSUndefinedKeyword");
  function tF(e, t) {
    return !e || e.type !== "TSUnknownKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(tF, "isTSUnknownKeyword");
  function rF(e, t) {
    return !e || e.type !== "TSVoidKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(rF, "isTSVoidKeyword");
  function nF(e, t) {
    return !e || e.type !== "TSThisType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(nF, "isTSThisType");
  function sF(e, t) {
    return !e || e.type !== "TSFunctionType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(sF, "isTSFunctionType");
  function iF(e, t) {
    return !e || e.type !== "TSConstructorType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(iF, "isTSConstructorType");
  function aF(e, t) {
    return !e || e.type !== "TSTypeReference" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(aF, "isTSTypeReference");
  function oF(e, t) {
    return !e || e.type !== "TSTypePredicate" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(oF, "isTSTypePredicate");
  function lF(e, t) {
    return !e || e.type !== "TSTypeQuery" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(lF, "isTSTypeQuery");
  function uF(e, t) {
    return !e || e.type !== "TSTypeLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(uF, "isTSTypeLiteral");
  function cF(e, t) {
    return !e || e.type !== "TSArrayType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(cF, "isTSArrayType");
  function fF(e, t) {
    return !e || e.type !== "TSTupleType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(fF, "isTSTupleType");
  function pF(e, t) {
    return !e || e.type !== "TSOptionalType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(pF, "isTSOptionalType");
  function dF(e, t) {
    return !e || e.type !== "TSRestType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(dF, "isTSRestType");
  function hF(e, t) {
    return !e || e.type !== "TSNamedTupleMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(hF, "isTSNamedTupleMember");
  function mF(e, t) {
    return !e || e.type !== "TSUnionType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(mF, "isTSUnionType");
  function yF(e, t) {
    return !e || e.type !== "TSIntersectionType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(yF, "isTSIntersectionType");
  function gF(e, t) {
    return !e || e.type !== "TSConditionalType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(gF, "isTSConditionalType");
  function bF(e, t) {
    return !e || e.type !== "TSInferType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(bF, "isTSInferType");
  function EF(e, t) {
    return !e || e.type !== "TSParenthesizedType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(EF, "isTSParenthesizedType");
  function vF(e, t) {
    return !e || e.type !== "TSTypeOperator" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(vF, "isTSTypeOperator");
  function TF(e, t) {
    return !e || e.type !== "TSIndexedAccessType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(TF, "isTSIndexedAccessType");
  function xF(e, t) {
    return !e || e.type !== "TSMappedType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(xF, "isTSMappedType");
  function SF(e, t) {
    return !e || e.type !== "TSLiteralType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(SF, "isTSLiteralType");
  function PF(e, t) {
    return !e || e.type !== "TSExpressionWithTypeArguments" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(PF, "isTSExpressionWithTypeArguments");
  function AF(e, t) {
    return !e || e.type !== "TSInterfaceDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(AF, "isTSInterfaceDeclaration");
  function CF(e, t) {
    return !e || e.type !== "TSInterfaceBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(CF, "isTSInterfaceBody");
  function wF(e, t) {
    return !e || e.type !== "TSTypeAliasDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(wF, "isTSTypeAliasDeclaration");
  function DF(e, t) {
    return !e || e.type !== "TSInstantiationExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(DF, "isTSInstantiationExpression");
  function IF(e, t) {
    return !e || e.type !== "TSAsExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(IF, "isTSAsExpression");
  function _F(e, t) {
    return !e || e.type !== "TSSatisfiesExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(_F, "isTSSatisfiesExpression");
  function OF(e, t) {
    return !e || e.type !== "TSTypeAssertion" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(OF, "isTSTypeAssertion");
  function NF(e, t) {
    return !e || e.type !== "TSEnumDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(NF, "isTSEnumDeclaration");
  function BF(e, t) {
    return !e || e.type !== "TSEnumMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(BF, "isTSEnumMember");
  function kF(e, t) {
    return !e || e.type !== "TSModuleDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(kF, "isTSModuleDeclaration");
  function FF(e, t) {
    return !e || e.type !== "TSModuleBlock" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(FF, "isTSModuleBlock");
  function jF(e, t) {
    return !e || e.type !== "TSImportType" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(jF, "isTSImportType");
  function LF(e, t) {
    return !e || e.type !== "TSImportEqualsDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(LF, "isTSImportEqualsDeclaration");
  function MF(e, t) {
    return !e || e.type !== "TSExternalModuleReference" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(MF, "isTSExternalModuleReference");
  function RF(e, t) {
    return !e || e.type !== "TSNonNullExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(RF, "isTSNonNullExpression");
  function qF(e, t) {
    return !e || e.type !== "TSExportAssignment" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(qF, "isTSExportAssignment");
  function UF(e, t) {
    return !e || e.type !== "TSNamespaceExportDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(UF, "isTSNamespaceExportDeclaration");
  function VF(e, t) {
    return !e || e.type !== "TSTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(VF, "isTSTypeAnnotation");
  function $F(e, t) {
    return !e || e.type !== "TSTypeParameterInstantiation" ? !1 : t == null || (0, A.default)(e, t);
  }
  s($F, "isTSTypeParameterInstantiation");
  function WF(e, t) {
    return !e || e.type !== "TSTypeParameterDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(WF, "isTSTypeParameterDeclaration");
  function KF(e, t) {
    return !e || e.type !== "TSTypeParameter" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(KF, "isTSTypeParameter");
  function GF(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(GF, "isStandardized");
  function HF(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(HF, "isExpression");
  function YF(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(YF, "isBinary");
  function zF(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(zF, "isScopable");
  function JF(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(JF, "isBlockParent");
  function XF(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(XF, "isBlock");
  function QF(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(QF, "isStatement");
  function ZF(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(ZF, "isTerminatorless");
  function e4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(e4, "isCompletionStatement");
  function t4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(t4, "isConditional");
  function r4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(r4, "isLoop");
  function n4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(n4, "isWhile");
  function s4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(s4, "isExpressionWrapper");
  function i4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(i4, "isFor");
  function a4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(a4, "isForXStatement");
  function o4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(o4, "isFunction");
  function l4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(l4, "isFunctionParent");
  function u4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(u4, "isPureish");
  function c4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
        break;
      case "Placeholder":
        if (e.expectedNode === "Declaration") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(c4, "isDeclaration");
  function f4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(f4, "isPatternLike");
  function p4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(p4, "isLVal");
  function d4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (e.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(d4, "isTSEntityName");
  function h4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(h4, "isLiteral");
  function m4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(m4, "isImmutable");
  function y4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(y4, "isUserWhitespacable");
  function g4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(g4, "isMethod");
  function b4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(b4, "isObjectMember");
  function E4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(E4, "isProperty");
  function v4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(v4, "isUnaryLike");
  function T4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (e.expectedNode === "Pattern") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(T4, "isPattern");
  function x4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(x4, "isClass");
  function V1(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(V1, "isImportOrExportDeclaration");
  function S4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(S4, "isExportDeclaration");
  function P4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(P4, "isModuleSpecifier");
  function A4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(A4, "isAccessor");
  function C4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(C4, "isPrivate");
  function w4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(w4, "isFlow");
  function D4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(D4, "isFlowType");
  function I4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(I4, "isFlowBaseAnnotation");
  function _4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(_4, "isFlowDeclaration");
  function O4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(O4, "isFlowPredicate");
  function N4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(N4, "isEnumBody");
  function B4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(B4, "isEnumMember");
  function k4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(k4, "isJSX");
  function F4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(F4, "isMiscellaneous");
  function j4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(j4, "isTypeScript");
  function L4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(L4, "isTSTypeElement");
  function M4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(M4, "isTSType");
  function R4(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  s(R4, "isTSBaseType");
  function q4(e, t) {
    return (0, Ca.default)("isNumberLiteral", "isNumericLiteral"), !e || e.type !== "NumberLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(q4, "isNumberLiteral");
  function U4(e, t) {
    return (0, Ca.default)("isRegexLiteral", "isRegExpLiteral"), !e || e.type !== "RegexLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(U4, "isRegexLiteral");
  function V4(e, t) {
    return (0, Ca.default)("isRestProperty", "isRestElement"), !e || e.type !== "RestProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  s(V4, "isRestProperty");
  function $4(e, t) {
    return (0, Ca.default)("isSpreadProperty", "isSpreadElement"), !e || e.type !== "SpreadProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  s($4, "isSpreadProperty");
  function W4(e, t) {
    return (0, Ca.default)("isModuleDeclaration", "isImportOrExportDeclaration"), V1(e, t);
  }
  s(W4, "isModuleDeclaration");
});

// ../node_modules/@babel/types/lib/validators/matchesPattern.js
var Zf = T((Qf) => {
  "use strict";
  Object.defineProperty(Qf, "__esModule", {
    value: !0
  });
  Qf.default = K4;
  var wa = Tt();
  function K4(e, t, r) {
    if (!(0, wa.isMemberExpression)(e)) return !1;
    let n = Array.isArray(t) ? t : t.split("."), i = [], a;
    for (a = e; (0, wa.isMemberExpression)(a); a = a.object)
      i.push(a.property);
    if (i.push(a), i.length < n.length || !r && i.length > n.length) return !1;
    for (let o = 0, l = i.length - 1; o < n.length; o++, l--) {
      let u = i[l], c;
      if ((0, wa.isIdentifier)(u))
        c = u.name;
      else if ((0, wa.isStringLiteral)(u))
        c = u.value;
      else if ((0, wa.isThisExpression)(u))
        c = "this";
      else
        return !1;
      if (n[o] !== c) return !1;
    }
    return !0;
  }
  s(K4, "matchesPattern");
});

// ../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var tp = T((ep) => {
  "use strict";
  Object.defineProperty(ep, "__esModule", {
    value: !0
  });
  ep.default = H4;
  var G4 = Zf();
  function H4(e, t) {
    let r = e.split(".");
    return (n) => (0, G4.default)(n, r, t);
  }
  s(H4, "buildMatchMemberExpression");
});

// ../node_modules/@babel/types/lib/validators/react/isReactComponent.js
var $1 = T((pl) => {
  "use strict";
  Object.defineProperty(pl, "__esModule", {
    value: !0
  });
  pl.default = void 0;
  var Y4 = tp(), z4 = (0, Y4.default)("React.Component"), tEe = pl.default = z4;
});

// ../node_modules/@babel/types/lib/validators/react/isCompatTag.js
var W1 = T((rp) => {
  "use strict";
  Object.defineProperty(rp, "__esModule", {
    value: !0
  });
  rp.default = J4;
  function J4(e) {
    return !!e && /^[a-z]/.test(e);
  }
  s(J4, "isCompatTag");
});

// ../node_modules/to-fast-properties/index.js
var G1 = T((iEe, K1) => {
  "use strict";
  var Da = null;
  function Ia(e) {
    if (Da !== null && typeof Da.property) {
      let t = Da;
      return Da = Ia.prototype = null, t;
    }
    return Da = Ia.prototype = e ?? /* @__PURE__ */ Object.create(null), new Ia();
  }
  s(Ia, "FastObject");
  Ia();
  K1.exports = /* @__PURE__ */ s(function(t) {
    return Ia(t);
  }, "toFastproperties");
});

// ../node_modules/@babel/types/lib/validators/isType.js
var dl = T((np) => {
  "use strict";
  Object.defineProperty(np, "__esModule", {
    value: !0
  });
  np.default = X4;
  var H1 = Cr();
  function X4(e, t) {
    if (e === t) return !0;
    if (e == null || H1.ALIAS_KEYS[t]) return !1;
    let r = H1.FLIPPED_ALIAS_KEYS[t];
    if (r) {
      if (r[0] === e) return !0;
      for (let n of r)
        if (e === n) return !0;
    }
    return !1;
  }
  s(X4, "isType");
});

// ../node_modules/@babel/types/lib/validators/isPlaceholderType.js
var ip = T((sp) => {
  "use strict";
  Object.defineProperty(sp, "__esModule", {
    value: !0
  });
  sp.default = Z4;
  var Q4 = Cr();
  function Z4(e, t) {
    if (e === t) return !0;
    let r = Q4.PLACEHOLDERS_ALIAS[e];
    if (r) {
      for (let n of r)
        if (t === n) return !0;
    }
    return !1;
  }
  s(Z4, "isPlaceholderType");
});

// ../node_modules/@babel/types/lib/validators/is.js
var yi = T((ap) => {
  "use strict";
  Object.defineProperty(ap, "__esModule", {
    value: !0
  });
  ap.default = s8;
  var e8 = fl(), t8 = dl(), r8 = ip(), n8 = Cr();
  function s8(e, t, r) {
    return t ? (0, t8.default)(t.type, e) ? typeof r > "u" ? !0 : (0, e8.default)(t, r) : !r && t.type === "Placeholder" && e in n8.FLIPPED_ALIAS_KEYS ?
    (0, r8.default)(t.expectedNode, e) : !1 : !1;
  }
  s(s8, "is");
});

// ../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var Q1 = T((_a) => {
  "use strict";
  Object.defineProperty(_a, "__esModule", {
    value: !0
  });
  _a.isIdentifierChar = X1;
  _a.isIdentifierName = l8;
  _a.isIdentifierStart = J1;
  var lp = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  Y1 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", i8 = new RegExp("[" + lp + "]"), a8 = new RegExp("[" + lp + Y1 + "]");
  lp = Y1 = null;
  var z1 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], o8 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2,
  5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6,
  1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function op(e, t) {
    let r = 65536;
    for (let n = 0, i = t.length; n < i; n += 2) {
      if (r += t[n], r > e) return !1;
      if (r += t[n + 1], r >= e) return !0;
    }
    return !1;
  }
  s(op, "isInAstralSet");
  function J1(e) {
    return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && i8.test(String.fromCharCode(e)) :
    op(e, z1);
  }
  s(J1, "isIdentifierStart");
  function X1(e) {
    return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && a8.test(
    String.fromCharCode(e)) : op(e, z1) || op(e, o8);
  }
  s(X1, "isIdentifierChar");
  function l8(e) {
    let t = !0;
    for (let r = 0; r < e.length; r++) {
      let n = e.charCodeAt(r);
      if ((n & 64512) === 55296 && r + 1 < e.length) {
        let i = e.charCodeAt(++r);
        (i & 64512) === 56320 && (n = 65536 + ((n & 1023) << 10) + (i & 1023));
      }
      if (t) {
        if (t = !1, !J1(n))
          return !1;
      } else if (!X1(n))
        return !1;
    }
    return !t;
  }
  s(l8, "isIdentifierName");
});

// ../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var rE = T((_s) => {
  "use strict";
  Object.defineProperty(_s, "__esModule", {
    value: !0
  });
  _s.isKeyword = d8;
  _s.isReservedWord = Z1;
  _s.isStrictBindOnlyReservedWord = tE;
  _s.isStrictBindReservedWord = p8;
  _s.isStrictReservedWord = eE;
  var up = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, u8 = new Set(up.keyword), c8 = new Set(up.strict), f8 = new Set(up.strictBind);
  function Z1(e, t) {
    return t && e === "await" || e === "enum";
  }
  s(Z1, "isReservedWord");
  function eE(e, t) {
    return Z1(e, t) || c8.has(e);
  }
  s(eE, "isStrictReservedWord");
  function tE(e) {
    return f8.has(e);
  }
  s(tE, "isStrictBindOnlyReservedWord");
  function p8(e, t) {
    return eE(e, t) || tE(e);
  }
  s(p8, "isStrictBindReservedWord");
  function d8(e) {
    return u8.has(e);
  }
  s(d8, "isKeyword");
});

// ../node_modules/@babel/helper-validator-identifier/lib/index.js
var gi = T((on) => {
  "use strict";
  Object.defineProperty(on, "__esModule", {
    value: !0
  });
  Object.defineProperty(on, "isIdentifierChar", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return cp.isIdentifierChar;
    }, "get")
  });
  Object.defineProperty(on, "isIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return cp.isIdentifierName;
    }, "get")
  });
  Object.defineProperty(on, "isIdentifierStart", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return cp.isIdentifierStart;
    }, "get")
  });
  Object.defineProperty(on, "isKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Oa.isKeyword;
    }, "get")
  });
  Object.defineProperty(on, "isReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Oa.isReservedWord;
    }, "get")
  });
  Object.defineProperty(on, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Oa.isStrictBindOnlyReservedWord;
    }, "get")
  });
  Object.defineProperty(on, "isStrictBindReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Oa.isStrictBindReservedWord;
    }, "get")
  });
  Object.defineProperty(on, "isStrictReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Oa.isStrictReservedWord;
    }, "get")
  });
  var cp = Q1(), Oa = rE();
});

// ../node_modules/@babel/types/lib/validators/isValidIdentifier.js
var bi = T((pp) => {
  "use strict";
  Object.defineProperty(pp, "__esModule", {
    value: !0
  });
  pp.default = h8;
  var fp = gi();
  function h8(e, t = !0) {
    return typeof e != "string" || t && ((0, fp.isKeyword)(e) || (0, fp.isStrictReservedWord)(e, !0)) ? !1 : (0, fp.isIdentifierName)(e);
  }
  s(h8, "isValidIdentifier");
});

// ../node_modules/@babel/helper-string-parser/lib/index.js
var aE = T((Na) => {
  "use strict";
  Object.defineProperty(Na, "__esModule", {
    value: !0
  });
  Na.readCodePoint = iE;
  Na.readInt = sE;
  Na.readStringContents = y8;
  var m8 = /* @__PURE__ */ s(function(t) {
    return t >= 48 && t <= 57;
  }, "isDigit"), nE = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, hl = {
    bin: /* @__PURE__ */ s((e) => e === 48 || e === 49, "bin"),
    oct: /* @__PURE__ */ s((e) => e >= 48 && e <= 55, "oct"),
    dec: /* @__PURE__ */ s((e) => e >= 48 && e <= 57, "dec"),
    hex: /* @__PURE__ */ s((e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102, "hex")
  };
  function y8(e, t, r, n, i, a) {
    let o = r, l = n, u = i, c = "", f = null, p = r, {
      length: h
    } = t;
    for (; ; ) {
      if (r >= h) {
        a.unterminated(o, l, u), c += t.slice(p, r);
        break;
      }
      let y = t.charCodeAt(r);
      if (g8(e, y, t, r)) {
        c += t.slice(p, r);
        break;
      }
      if (y === 92) {
        c += t.slice(p, r);
        let v = b8(t, r, n, i, e === "template", a);
        v.ch === null && !f ? f = {
          pos: r,
          lineStart: n,
          curLine: i
        } : c += v.ch, {
          pos: r,
          lineStart: n,
          curLine: i
        } = v, p = r;
      } else y === 8232 || y === 8233 ? (++r, ++i, n = r) : y === 10 || y === 13 ? e === "template" ? (c += t.slice(p, r) + `
`, ++r, y === 13 && t.charCodeAt(r) === 10 && ++r, ++i, p = n = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: f,
      lineStart: n,
      curLine: i,
      containsInvalid: !!f
    };
  }
  s(y8, "readStringContents");
  function g8(e, t, r, n) {
    return e === "template" ? t === 96 || t === 36 && r.charCodeAt(n + 1) === 123 : t === (e === "double" ? 34 : 39);
  }
  s(g8, "isStringEnd");
  function b8(e, t, r, n, i, a) {
    let o = !i;
    t++;
    let l = /* @__PURE__ */ s((c) => ({
      pos: t,
      ch: c,
      lineStart: r,
      curLine: n
    }), "res"), u = e.charCodeAt(t++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: t
        } = dp(e, t, r, n, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: t
        } = iE(e, t, r, n, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        e.charCodeAt(t) === 10 && ++t;
      case 10:
        r = t, ++n;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (i)
          return l(null);
        a.strictNumericEscape(t - 1, r, n);
      default:
        if (u >= 48 && u <= 55) {
          let c = t - 1, p = /^[0-7]+/.exec(e.slice(c, t + 2))[0], h = parseInt(p, 8);
          h > 255 && (p = p.slice(0, -1), h = parseInt(p, 8)), t += p.length - 1;
          let y = e.charCodeAt(t);
          if (p !== "0" || y === 56 || y === 57) {
            if (i)
              return l(null);
            a.strictNumericEscape(c, r, n);
          }
          return l(String.fromCharCode(h));
        }
        return l(String.fromCharCode(u));
    }
  }
  s(b8, "readEscapedChar");
  function dp(e, t, r, n, i, a, o, l) {
    let u = t, c;
    return {
      n: c,
      pos: t
    } = sE(e, t, r, n, 16, i, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, n) : t = u - 1), {
      code: c,
      pos: t
    };
  }
  s(dp, "readHexChar");
  function sE(e, t, r, n, i, a, o, l, u, c) {
    let f = t, p = i === 16 ? nE.hex : nE.decBinOct, h = i === 16 ? hl.hex : i === 10 ? hl.dec : i === 8 ? hl.oct : hl.bin, y = !1, v = 0;
    for (let d = 0, b = a ?? 1 / 0; d < b; ++d) {
      let E = e.charCodeAt(t), I;
      if (E === 95 && l !== "bail") {
        let O = e.charCodeAt(t - 1), k = e.charCodeAt(t + 1);
        if (l) {
          if (Number.isNaN(k) || !h(k) || p.has(O) || p.has(k)) {
            if (c) return {
              n: null,
              pos: t
            };
            u.unexpectedNumericSeparator(t, r, n);
          }
        } else {
          if (c) return {
            n: null,
            pos: t
          };
          u.numericSeparatorInEscapeSequence(t, r, n);
        }
        ++t;
        continue;
      }
      if (E >= 97 ? I = E - 97 + 10 : E >= 65 ? I = E - 65 + 10 : m8(E) ? I = E - 48 : I = 1 / 0, I >= i) {
        if (I <= 9 && c)
          return {
            n: null,
            pos: t
          };
        if (I <= 9 && u.invalidDigit(t, r, n, i))
          I = 0;
        else if (o)
          I = 0, y = !0;
        else
          break;
      }
      ++t, v = v * i + I;
    }
    return t === f || a != null && t - f !== a || y ? {
      n: null,
      pos: t
    } : {
      n: v,
      pos: t
    };
  }
  s(sE, "readInt");
  function iE(e, t, r, n, i, a) {
    let o = e.charCodeAt(t), l;
    if (o === 123) {
      if (++t, {
        code: l,
        pos: t
      } = dp(e, t, r, n, e.indexOf("}", t) - t, !0, i, a), ++t, l !== null && l > 1114111)
        if (i)
          a.invalidCodePoint(t, r, n);
        else
          return {
            code: null,
            pos: t
          };
    } else
      ({
        code: l,
        pos: t
      } = dp(e, t, r, n, 4, !1, i, a));
    return {
      code: l,
      pos: t
    };
  }
  s(iE, "readCodePoint");
});

// ../node_modules/@babel/types/lib/constants/index.js
var Xn = T((Me) => {
  "use strict";
  Object.defineProperty(Me, "__esModule", {
    value: !0
  });
  Me.UPDATE_OPERATORS = Me.UNARY_OPERATORS = Me.STRING_UNARY_OPERATORS = Me.STATEMENT_OR_BLOCK_KEYS = Me.NUMBER_UNARY_OPERATORS = Me.NUMBER_BINARY_OPERATORS =
  Me.NOT_LOCAL_BINDING = Me.LOGICAL_OPERATORS = Me.INHERIT_KEYS = Me.FOR_INIT_KEYS = Me.FLATTENABLE_KEYS = Me.EQUALITY_BINARY_OPERATORS = Me.
  COMPARISON_BINARY_OPERATORS = Me.COMMENT_KEYS = Me.BOOLEAN_UNARY_OPERATORS = Me.BOOLEAN_NUMBER_BINARY_OPERATORS = Me.BOOLEAN_BINARY_OPERATORS =
  Me.BLOCK_SCOPED_SYMBOL = Me.BINARY_OPERATORS = Me.ASSIGNMENT_OPERATORS = void 0;
  var SEe = Me.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], PEe = Me.FLATTENABLE_KEYS = ["body", "expressions"], AEe = Me.
  FOR_INIT_KEYS = ["left", "init"], CEe = Me.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], E8 = Me.LOGICAL_OPERATORS =
  ["||", "&&", "??"], wEe = Me.UPDATE_OPERATORS = ["++", "--"], v8 = Me.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], T8 = Me.EQUALITY_BINARY_OPERATORS =
  ["==", "===", "!=", "!=="], x8 = Me.COMPARISON_BINARY_OPERATORS = [...T8, "in", "instanceof"], S8 = Me.BOOLEAN_BINARY_OPERATORS = [...x8, ...v8],
  oE = Me.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], DEe = Me.BINARY_OPERATORS = ["+", ...oE, ...S8,
  "|>"], IEe = Me.ASSIGNMENT_OPERATORS = ["=", "+=", ...oE.map((e) => e + "="), ...E8.map((e) => e + "=")], P8 = Me.BOOLEAN_UNARY_OPERATORS =
  ["delete", "!"], A8 = Me.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], C8 = Me.STRING_UNARY_OPERATORS = ["typeof"], _Ee = Me.UNARY_OPERATORS =
  ["void", "throw", ...P8, ...A8, ...C8], OEe = Me.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  }, NEe = Me.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), BEe = Me.NOT_LOCAL_BINDING = Symbol.for("should not be consid\
ered a local binding");
});

// ../node_modules/@babel/types/lib/definitions/utils.js
var xn = T((Xe) => {
  "use strict";
  Object.defineProperty(Xe, "__esModule", {
    value: !0
  });
  Xe.VISITOR_KEYS = Xe.NODE_PARENT_VALIDATIONS = Xe.NODE_FIELDS = Xe.FLIPPED_ALIAS_KEYS = Xe.DEPRECATED_KEYS = Xe.BUILDER_KEYS = Xe.ALIAS_KEYS =
  void 0;
  Xe.arrayOf = uE;
  Xe.arrayOfType = cE;
  Xe.assertEach = fE;
  Xe.assertNodeOrValueType = M8;
  Xe.assertNodeType = mp;
  Xe.assertOneOf = L8;
  Xe.assertOptionalChainStart = q8;
  Xe.assertShape = R8;
  Xe.assertValueType = bp;
  Xe.chain = pE;
  Xe.default = dE;
  Xe.defineAliasedType = $8;
  Xe.typeIs = gl;
  Xe.validate = gp;
  Xe.validateArrayOfType = j8;
  Xe.validateOptional = k8;
  Xe.validateOptionalType = F8;
  Xe.validateType = B8;
  var lE = yi(), yl = bl(), w8 = Xe.VISITOR_KEYS = {}, D8 = Xe.ALIAS_KEYS = {}, hp = Xe.FLIPPED_ALIAS_KEYS = {}, I8 = Xe.NODE_FIELDS = {}, _8 = Xe.
  BUILDER_KEYS = {}, O8 = Xe.DEPRECATED_KEYS = {}, N8 = Xe.NODE_PARENT_VALIDATIONS = {};
  function ml(e) {
    return Array.isArray(e) ? "array" : e === null ? "null" : typeof e;
  }
  s(ml, "getType");
  function gp(e) {
    return {
      validate: e
    };
  }
  s(gp, "validate");
  function gl(e) {
    return typeof e == "string" ? mp(e) : mp(...e);
  }
  s(gl, "typeIs");
  function B8(e) {
    return gp(gl(e));
  }
  s(B8, "validateType");
  function k8(e) {
    return {
      validate: e,
      optional: !0
    };
  }
  s(k8, "validateOptional");
  function F8(e) {
    return {
      validate: gl(e),
      optional: !0
    };
  }
  s(F8, "validateOptionalType");
  function uE(e) {
    return pE(bp("array"), fE(e));
  }
  s(uE, "arrayOf");
  function cE(e) {
    return uE(gl(e));
  }
  s(cE, "arrayOfType");
  function j8(e) {
    return gp(cE(e));
  }
  s(j8, "validateArrayOfType");
  function fE(e) {
    function t(r, n, i) {
      if (Array.isArray(i))
        for (let a = 0; a < i.length; a++) {
          let o = `${n}[${a}]`, l = i[a];
          e(r, o, l), process.env.BABEL_TYPES_8_BREAKING && (0, yl.validateChild)(r, o, l);
        }
    }
    return s(t, "validator"), t.each = e, t;
  }
  s(fE, "assertEach");
  function L8(...e) {
    function t(r, n, i) {
      if (!e.includes(i))
        throw new TypeError(`Property ${n} expected value to be one of ${JSON.stringify(e)} but got ${JSON.stringify(i)}`);
    }
    return s(t, "validate"), t.oneOf = e, t;
  }
  s(L8, "assertOneOf");
  function mp(...e) {
    function t(r, n, i) {
      for (let a of e)
        if ((0, lE.default)(a, i)) {
          (0, yl.validateChild)(r, n, i);
          return;
        }
      throw new TypeError(`Property ${n} of ${r.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(i?.
      type)}`);
    }
    return s(t, "validate"), t.oneOfNodeTypes = e, t;
  }
  s(mp, "assertNodeType");
  function M8(...e) {
    function t(r, n, i) {
      for (let a of e)
        if (ml(i) === a || (0, lE.default)(a, i)) {
          (0, yl.validateChild)(r, n, i);
          return;
        }
      throw new TypeError(`Property ${n} of ${r.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(i?.
      type)}`);
    }
    return s(t, "validate"), t.oneOfNodeOrValueTypes = e, t;
  }
  s(M8, "assertNodeOrValueType");
  function bp(e) {
    function t(r, n, i) {
      if (!(ml(i) === e))
        throw new TypeError(`Property ${n} expected type of ${e} but got ${ml(i)}`);
    }
    return s(t, "validate"), t.type = e, t;
  }
  s(bp, "assertValueType");
  function R8(e) {
    function t(r, n, i) {
      let a = [];
      for (let o of Object.keys(e))
        try {
          (0, yl.validateField)(r, o, i[o], e[o]);
        } catch (l) {
          if (l instanceof TypeError) {
            a.push(l.message);
            continue;
          }
          throw l;
        }
      if (a.length)
        throw new TypeError(`Property ${n} of ${r.type} expected to have the following:
${a.join(`
`)}`);
    }
    return s(t, "validate"), t.shapeOf = e, t;
  }
  s(R8, "assertShape");
  function q8() {
    function e(t) {
      var r;
      let n = t;
      for (; t; ) {
        let {
          type: i
        } = n;
        if (i === "OptionalCallExpression") {
          if (n.optional) return;
          n = n.callee;
          continue;
        }
        if (i === "OptionalMemberExpression") {
          if (n.optional) return;
          n = n.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${t.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chai\
n from ${(r = n) == null ? void 0 : r.type}`);
    }
    return s(e, "validate"), e;
  }
  s(q8, "assertOptionalChainStart");
  function pE(...e) {
    function t(...r) {
      for (let n of e)
        n(...r);
    }
    if (s(t, "validate"), t.chainOf = e, e.length >= 2 && "type" in e[0] && e[0].type === "array" && !("each" in e[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return t;
  }
  s(pE, "chain");
  var U8 = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], V8 = ["default", "optional", "deprecated",
  "validate"], yp = {};
  function $8(...e) {
    return (t, r = {}) => {
      let n = r.aliases;
      if (!n) {
        var i, a;
        r.inherits && (n = (i = yp[r.inherits].aliases) == null ? void 0 : i.slice()), (a = n) != null || (n = []), r.aliases = n;
      }
      let o = e.filter((l) => !n.includes(l));
      n.unshift(...o), dE(t, r);
    };
  }
  s($8, "defineAliasedType");
  function dE(e, t = {}) {
    let r = t.inherits && yp[t.inherits] || {}, n = t.fields;
    if (!n && (n = {}, r.fields)) {
      let l = Object.getOwnPropertyNames(r.fields);
      for (let u of l) {
        let c = r.fields[u], f = c.default;
        if (Array.isArray(f) ? f.length > 0 : f && typeof f == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        n[u] = {
          default: Array.isArray(f) ? [] : f,
          optional: c.optional,
          deprecated: c.deprecated,
          validate: c.validate
        };
      }
    }
    let i = t.visitor || r.visitor || [], a = t.aliases || r.aliases || [], o = t.builder || r.builder || t.visitor || [];
    for (let l of Object.keys(t))
      if (!U8.includes(l))
        throw new Error(`Unknown type option "${l}" on ${e}`);
    t.deprecatedAlias && (O8[t.deprecatedAlias] = e);
    for (let l of i.concat(o))
      n[l] = n[l] || {};
    for (let l of Object.keys(n)) {
      let u = n[l];
      u.default !== void 0 && !o.includes(l) && (u.optional = !0), u.default === void 0 ? u.default = null : !u.validate && u.default != null &&
      (u.validate = bp(ml(u.default)));
      for (let c of Object.keys(u))
        if (!V8.includes(c))
          throw new Error(`Unknown field key "${c}" on ${e}.${l}`);
    }
    w8[e] = t.visitor = i, _8[e] = t.builder = o, I8[e] = t.fields = n, D8[e] = t.aliases = a, a.forEach((l) => {
      hp[l] = hp[l] || [], hp[l].push(e);
    }), t.validate && (N8[e] = t.validate), yp[e] = t;
  }
  s(dE, "defineType");
});

// ../node_modules/@babel/types/lib/definitions/core.js
var vp = T((dr) => {
  "use strict";
  Object.defineProperty(dr, "__esModule", {
    value: !0
  });
  dr.patternLikeCommon = dr.functionTypeAnnotationCommon = dr.functionDeclarationCommon = dr.functionCommon = dr.classMethodOrPropertyCommon =
  dr.classMethodOrDeclareMethodCommon = void 0;
  var tr = yi(), W8 = bi(), hE = gi(), K8 = aE(), Ba = Xn(), m = xn(), te = (0, m.defineAliasedType)("Standardized");
  te("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeOrValueType)("null", "Expression", "Spread\
Element"))),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  te("AssignmentExpression", {
    fields: {
      operator: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, m.assertValueType)("string");
          let e = (0, m.assertOneOf)(...Ba.ASSIGNMENT_OPERATORS), t = (0, m.assertOneOf)("=");
          return function(r, n, i) {
            ((0, tr.default)("Pattern", r.left) ? t : e)(r, n, i);
          };
        }()
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, m.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "\
ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, m.assertNodeType)(
        "LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, m.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  te("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, m.assertOneOf)(...Ba.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          let e = (0, m.assertNodeType)("Expression"), t = (0, m.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(n, i, a) {
            (n.operator === "in" ? t : e)(n, i, a);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, m.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  te("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, m.assertValueType)("string")
      }
    }
  });
  te("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, m.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  te("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, m.assertValueType)("string")
      }
    }
  });
  te("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  te("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, m.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  te("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, m.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Expression", "SpreadElement", "Argu\
mentPlaceholder")))
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, m.assertOneOf)(!0, !1),
        optional: !0
      }
    }, {
      typeArguments: {
        validate: (0, m.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, m.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  te("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, m.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, m.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  te("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, m.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, m.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, m.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  te("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, m.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  te("DebuggerStatement", {
    aliases: ["Statement"]
  });
  te("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: (0, m.assertNodeType)("Expression")
      },
      body: {
        validate: (0, m.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  te("EmptyStatement", {
    aliases: ["Statement"]
  });
  te("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, m.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  te("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, m.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, m.assertEach)((0, m.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(
        () => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, m.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  });
  te("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, m.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "Array\
Pattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, m.assertNodeType)("Var\
iableDeclaration", "LVal")
      },
      right: {
        validate: (0, m.assertNodeType)("Expression")
      },
      body: {
        validate: (0, m.assertNodeType)("Statement")
      }
    }
  });
  te("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, m.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, m.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, m.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, m.assertNodeType)("Statement")
      }
    }
  });
  var Ei = /* @__PURE__ */ s(() => ({
    params: {
      validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  }), "functionCommon");
  dr.functionCommon = Ei;
  var Os = /* @__PURE__ */ s(() => ({
    returnType: {
      validate: (0, m.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, m.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "functionTypeAnnotationCommon");
  dr.functionTypeAnnotationCommon = Os;
  var mE = /* @__PURE__ */ s(() => Object.assign({}, Ei(), {
    declare: {
      validate: (0, m.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, m.assertNodeType)("Identifier"),
      optional: !0
    }
  }), "functionDeclarationCommon");
  dr.functionDeclarationCommon = mE;
  te("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, mE(), Os(), {
      body: {
        validate: (0, m.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, m.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function() {
      if (!process.env.BABEL_TYPES_8_BREAKING) return () => {
      };
      let e = (0, m.assertNodeType)("Identifier");
      return function(t, r, n) {
        (0, tr.default)("ExportDefaultDeclaration", t) || e(n, "id", n.id);
      };
    }()
  });
  te("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, Ei(), Os(), {
      id: {
        validate: (0, m.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, m.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, m.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  var vi = /* @__PURE__ */ s(() => ({
    typeAnnotation: {
      validate: (0, m.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, m.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))),
      optional: !0
    }
  }), "patternLikeCommon");
  dr.patternLikeCommon = vi;
  te("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, vi(), {
      name: {
        validate: (0, m.chain)((0, m.assertValueType)("string"), Object.assign(function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && !(0, W8.default)(r, !1))
            throw new TypeError(`"${r}" is not a valid identifier name`);
        }, {
          type: "string"
        }))
      }
    }),
    validate(e, t, r) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      let n = /\.(\w+)$/.exec(t);
      if (!n) return;
      let [, i] = n, a = {
        computed: !1
      };
      if (i === "property") {
        if ((0, tr.default)("MemberExpression", e, a) || (0, tr.default)("OptionalMemberExpression", e, a)) return;
      } else if (i === "key") {
        if ((0, tr.default)("Property", e, a) || (0, tr.default)("Method", e, a)) return;
      } else if (i === "exported") {
        if ((0, tr.default)("ExportSpecifier", e)) return;
      } else if (i === "imported") {
        if ((0, tr.default)("ImportSpecifier", e, {
          imported: r
        })) return;
      } else if (i === "meta" && (0, tr.default)("MetaProperty", e, {
        meta: r
      }))
        return;
      if (((0, hE.isKeyword)(r.name) || (0, hE.isReservedWord)(r.name, !1)) && r.name !== "this")
        throw new TypeError(`"${r.name}" is not a valid identifier`);
    }
  });
  te("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, m.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, m.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, m.assertNodeType)("Statement")
      }
    }
  });
  te("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, m.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, m.assertNodeType)("Statement")
      }
    }
  });
  te("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, m.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  te("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, m.chain)((0, m.assertValueType)("number"), Object.assign(function(e, t, r) {
          if (1 / r < 0 || !Number.isFinite(r)) {
            let n = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r}) instead.`);
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  te("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  te("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, m.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  te("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, m.assertValueType)("string")
      },
      flags: {
        validate: (0, m.chain)((0, m.assertValueType)("string"), Object.assign(function(e, t, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let n = /[^gimsuy]/.exec(r);
          if (n)
            throw new TypeError(`"${n[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })),
        default: ""
      }
    }
  });
  te("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, m.assertOneOf)(...Ba.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, m.assertNodeType)("Expression")
      },
      right: {
        validate: (0, m.assertNodeType)("Expression")
      }
    }
  });
  te("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, m.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          let e = (0, m.assertNodeType)("Identifier", "PrivateName"), t = (0, m.assertNodeType)("Expression"), r = /* @__PURE__ */ s(function(n, i, a) {
            (n.computed ? t : e)(n, i, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, m.assertOneOf)(!0, !1),
        optional: !0
      }
    })
  });
  te("NewExpression", {
    inherits: "CallExpression"
  });
  te("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, m.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, m.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  te("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ObjectMethod", "ObjectProperty", "S\
preadElement")))
      }
    }
  });
  te("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, Ei(), Os(), {
      kind: Object.assign({
        validate: (0, m.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let e = (0, m.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, m.assertNodeType)("Expres\
sion"), r = /* @__PURE__ */ s(function(n, i, a) {
            (n.computed ? t : e)(n, i, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r;
        }()
      },
      decorators: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))),
        optional: !0
      },
      body: {
        validate: (0, m.assertNodeType)("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  te("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let e = (0, m.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), t = (0, m.
          assertNodeType)("Expression");
          return Object.assign(function(n, i, a) {
            (n.computed ? t : e)(n, i, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, m.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: (0, m.chain)((0, m.assertValueType)("boolean"), Object.assign(function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && e.computed)
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, {
          type: "boolean"
        }), function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && !(0, tr.default)("Identifier", e.key))
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }),
        default: !1
      },
      decorators: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function() {
      let e = (0, m.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssert\
ion"), t = (0, m.assertNodeType)("Expression");
      return function(r, n, i) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        ((0, tr.default)("ObjectPattern", r) ? e : t)(i, "value", i.value);
      };
    }()
  });
  te("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, vi(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, m.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpressio\
n", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, m.assertNodeType)("LVal")
      }
    }),
    validate(e, t) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      let r = /(\w+)\[(\d+)\]/.exec(t);
      if (!r) throw new Error("Internal Babel error: malformed key.");
      let [, n, i] = r;
      if (e[n].length > +i + 1)
        throw new TypeError(`RestElement must be last element of ${n}`);
    }
  });
  te("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, m.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  te("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Expression")))
      }
    },
    aliases: ["Expression"]
  });
  te("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, m.assertNodeType)("Expression")
      }
    }
  });
  te("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, m.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Statement")))
      }
    }
  });
  te("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, m.assertNodeType)("Expression")
      },
      cases: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("SwitchCase")))
      }
    }
  });
  te("ThisExpression", {
    aliases: ["Expression"]
  });
  te("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, m.assertNodeType)("Expression")
      }
    }
  });
  te("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, m.chain)((0, m.assertNodeType)("BlockStatement"), Object.assign(function(e) {
          if (process.env.BABEL_TYPES_8_BREAKING && !e.handler && !e.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: !0,
        validate: (0, m.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, m.assertNodeType)("BlockStatement")
      }
    }
  });
  te("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, m.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, m.assertOneOf)(...Ba.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  te("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, m.assertNodeType)("Identifier", "MemberExpression") : (0, m.assertNodeType)("Expr\
ession")
      },
      operator: {
        validate: (0, m.assertOneOf)(...Ba.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  te("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, m.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, m.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("VariableDeclarator")))
      }
    },
    validate(e, t, r) {
      if (process.env.BABEL_TYPES_8_BREAKING && (0, tr.default)("ForXStatement", e, {
        left: r
      }) && r.declarations.length !== 1)
        throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${e.type}`);
    }
  });
  te("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, m.assertNodeType)("LVal");
          let e = (0, m.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), t = (0, m.assertNodeType)("Identifier");
          return function(r, n, i) {
            (r.init ? e : t)(r, n, i);
          };
        }()
      },
      definite: {
        optional: !0,
        validate: (0, m.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, m.assertNodeType)("Expression")
      }
    }
  });
  te("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, m.assertNodeType)("Expression")
      },
      body: {
        validate: (0, m.assertNodeType)("Statement")
      }
    }
  });
  te("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, m.assertNodeType)("Expression")
      },
      body: {
        validate: (0, m.assertNodeType)("Statement")
      }
    }
  });
  te("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, vi(), {
      left: {
        validate: (0, m.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExp\
ression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, m.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))),
        optional: !0
      }
    })
  });
  te("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, vi(), {
      elements: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  });
  te("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, Ei(), Os(), {
      expression: {
        validate: (0, m.assertValueType)("boolean")
      },
      body: {
        validate: (0, m.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, m.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  te("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ClassMethod", "ClassPrivateMethod",
        "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
      }
    }
  });
  te("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, m.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, m.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, m.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, m.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, m.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("TSExpressionWithTypeArguments", "Cl\
assImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, m.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  });
  te("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, m.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, m.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, m.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, m.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, m.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("TSExpressionWithTypeArguments", "Cl\
assImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, m.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, m.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, m.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: function() {
      let e = (0, m.assertNodeType)("Identifier");
      return function(t, r, n) {
        process.env.BABEL_TYPES_8_BREAKING && ((0, tr.default)("ExportDefaultDeclaration", t) || e(n, "id", n.id));
      };
    }()
  });
  te("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: (0, m.assertNodeType)("StringLiteral")
      },
      exportKind: (0, m.validateOptional)((0, m.assertOneOf)("type", "value")),
      attributes: {
        optional: !0,
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ImportAttribute")))
      }
    }
  });
  te("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: (0, m.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
      },
      exportKind: (0, m.validateOptional)((0, m.assertOneOf)("value"))
    }
  });
  te("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: !0,
        validate: (0, m.chain)((0, m.assertNodeType)("Declaration"), Object.assign(function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && e.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && e.source)
            throw new TypeError("Cannot export a declaration from a source");
        })
      },
      attributes: {
        optional: !0,
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        default: [],
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)(function() {
          let e = (0, m.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), t = (0, m.assertNodeType)(
          "ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? function(r, n, i) {
            (r.source ? e : t)(r, n, i);
          } : e;
        }()))
      },
      source: {
        validate: (0, m.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, m.validateOptional)((0, m.assertOneOf)("type", "value"))
    }
  });
  te("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, m.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, m.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, m.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  te("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, m.assertNodeType)("VariableDeclaration", "LVal");
          let e = (0, m.assertNodeType)("VariableDeclaration"), t = (0, m.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "\
ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(r, n, i) {
            (0, tr.default)("VariableDeclaration", i) ? e(r, n, i) : t(r, n, i);
          };
        }()
      },
      right: {
        validate: (0, m.assertNodeType)("Expression")
      },
      body: {
        validate: (0, m.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  });
  te("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: {
      attributes: {
        optional: !0,
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ImportAttribute")))
      },
      module: {
        optional: !0,
        validate: (0, m.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, m.assertOneOf)("source", "defer")
      },
      specifiers: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("ImportSpecifier", "ImportDefaultSpe\
cifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: (0, m.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, m.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  te("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, m.assertNodeType)("Identifier")
      }
    }
  });
  te("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, m.assertNodeType)("Identifier")
      }
    }
  });
  te("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, m.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, m.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, m.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  te("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, m.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, m.assertNodeType)("Expression")
      },
      options: {
        validate: (0, m.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  te("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, m.chain)((0, m.assertNodeType)("Identifier"), Object.assign(function(e, t, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let n;
          switch (r.name) {
            case "function":
              n = "sent";
              break;
            case "new":
              n = "target";
              break;
            case "import":
              n = "meta";
              break;
          }
          if (!(0, tr.default)("Identifier", e.property, {
            name: n
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: (0, m.assertNodeType)("Identifier")
      }
    }
  });
  var El = /* @__PURE__ */ s(() => ({
    abstract: {
      validate: (0, m.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, m.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, m.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, m.chain)(function() {
        let e = (0, m.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, m.assertNodeType)("Expressi\
on");
        return function(r, n, i) {
          (r.computed ? t : e)(r, n, i);
        };
      }(), (0, m.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  }), "classMethodOrPropertyCommon");
  dr.classMethodOrPropertyCommon = El;
  var Ep = /* @__PURE__ */ s(() => Object.assign({}, Ei(), El(), {
    params: {
      validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Identifier", "Pattern", "RestElement",
      "TSParameterProperty")))
    },
    kind: {
      validate: (0, m.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, m.chain)((0, m.assertValueType)("string"), (0, m.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))),
      optional: !0
    }
  }), "classMethodOrDeclareMethodCommon");
  dr.classMethodOrDeclareMethodCommon = Ep;
  te("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, Ep(), Os(), {
      body: {
        validate: (0, m.assertNodeType)("BlockStatement")
      }
    })
  });
  te("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, vi(), {
      properties: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("RestElement", "ObjectProperty")))
      }
    })
  });
  te("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, m.assertNodeType)("Expression")
      }
    }
  });
  te("Super", {
    aliases: ["Expression"]
  });
  te("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, m.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, m.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, m.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  te("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, m.chain)((0, m.assertShape)({
          raw: {
            validate: (0, m.assertValueType)("string")
          },
          cooked: {
            validate: (0, m.assertValueType)("string"),
            optional: !0
          }
        }), /* @__PURE__ */ s(function(t) {
          let r = t.value.raw, n = !1, i = /* @__PURE__ */ s(() => {
            throw new Error("Internal @babel/types error.");
          }, "error"), {
            str: a,
            firstInvalidLoc: o
          } = (0, K8.readStringContents)("template", r, 0, 0, 0, {
            unterminated() {
              n = !0;
            },
            strictNumericEscape: i,
            invalidEscapeSequence: i,
            numericSeparatorInEscapeSequence: i,
            unexpectedNumericSeparator: i,
            invalidDigit: i,
            invalidCodePoint: i
          });
          if (!n) throw new Error("Invalid raw");
          t.value.cooked = o ? null : a;
        }, "templateElementCookedValidator"))
      },
      tail: {
        default: !1
      }
    }
  });
  te("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("TemplateElement")))
      },
      expressions: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Expression", "TSType")), function(e, t, r) {
          if (e.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${e.type} quasis should be exactly one more than the number of expressions.
Expected ${r.length + 1} quasis but got ${e.quasis.length}`);
        })
      }
    }
  });
  te("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, m.chain)((0, m.assertValueType)("boolean"), Object.assign(function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && !e.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, m.assertNodeType)("Expression")
      }
    }
  });
  te("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, m.assertNodeType)("Expression")
      }
    }
  });
  te("Import", {
    aliases: ["Expression"]
  });
  te("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, m.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  te("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, m.assertNodeType)("Identifier")
      }
    }
  });
  te("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, m.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          let e = (0, m.assertNodeType)("Identifier"), t = (0, m.assertNodeType)("Expression");
          return Object.assign(function(n, i, a) {
            (n.computed ? t : e)(n, i, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, m.chain)((0, m.assertValueType)("boolean"), (0, m.assertOptionalChainStart)()) : (0, m.
        assertValueType)("boolean")
      }
    }
  });
  te("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: (0, m.assertNodeType)("Expression")
      },
      arguments: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Expression", "SpreadElement", "Argu\
mentPlaceholder")))
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, m.chain)((0, m.assertValueType)("boolean"), (0, m.assertOptionalChainStart)()) : (0, m.
        assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, m.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, m.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  te("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, El(), {
      value: {
        validate: (0, m.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, m.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, m.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, m.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, m.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, m.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  te("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, El(), {
      key: {
        validate: (0, m.chain)(function() {
          let e = (0, m.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), t = (0, m.assertNodeType)(
          "Expression");
          return function(r, n, i) {
            (r.computed ? t : e)(r, n, i);
          };
        }(), (0, m.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, m.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, m.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, m.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, m.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, m.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, m.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  te("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, m.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, m.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, m.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Decorator"))),
        optional: !0
      },
      static: {
        validate: (0, m.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, m.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, m.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, m.assertNodeType)("Variance"),
        optional: !0
      }
    }
  });
  te("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, Ep(), Os(), {
      kind: {
        validate: (0, m.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, m.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, m.assertNodeType)("BlockStatement")
      }
    })
  });
  te("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, m.assertNodeType)("Identifier")
      }
    }
  });
  te("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, m.chain)((0, m.assertValueType)("array"), (0, m.assertEach)((0, m.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
});

// ../node_modules/@babel/types/lib/definitions/flow.js
var yE = T(() => {
  "use strict";
  var L = xn(), ye = (0, L.defineAliasedType)("Flow"), Tp = /* @__PURE__ */ s((e) => {
    let t = e === "DeclareClass";
    ye(e, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...t ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, L.validateType)("Identifier"),
        typeParameters: (0, L.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, L.validateOptional)((0, L.arrayOfType)("InterfaceExtends"))
      }, t ? {
        mixins: (0, L.validateOptional)((0, L.arrayOfType)("InterfaceExtends")),
        implements: (0, L.validateOptional)((0, L.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, L.validateType)("ObjectTypeAnnotation")
      })
    });
  }, "defineInterfaceishType");
  ye("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ye("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, L.validateType)("FlowType")
    }
  });
  ye("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ye("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
  ye("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ye("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      typeParameters: (0, L.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Tp("DeclareClass");
  ye("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      predicate: (0, L.validateOptionalType)("DeclaredPredicate")
    }
  });
  Tp("DeclareInterface");
  ye("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, L.validateType)(["Identifier", "StringLiteral"]),
      body: (0, L.validateType)("BlockStatement"),
      kind: (0, L.validateOptional)((0, L.assertOneOf)("CommonJS", "ES"))
    }
  });
  ye("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, L.validateType)("TypeAnnotation")
    }
  });
  ye("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      typeParameters: (0, L.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, L.validateType)("FlowType")
    }
  });
  ye("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      typeParameters: (0, L.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, L.validateOptionalType)("FlowType"),
      impltype: (0, L.validateOptionalType)("FlowType")
    }
  });
  ye("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, L.validateType)("Identifier")
    }
  });
  ye("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, L.validateOptionalType)("Flow"),
      specifiers: (0, L.validateOptional)((0, L.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: (0, L.validateOptionalType)("StringLiteral"),
      default: (0, L.validateOptional)((0, L.assertValueType)("boolean"))
    }
  });
  ye("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, L.validateType)("StringLiteral"),
      exportKind: (0, L.validateOptional)((0, L.assertOneOf)("type", "value"))
    }
  });
  ye("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, L.validateType)("Flow")
    }
  });
  ye("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  ye("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, L.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, L.validate)((0, L.arrayOfType)("FunctionTypeParam")),
      rest: (0, L.validateOptionalType)("FunctionTypeParam"),
      this: (0, L.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, L.validateType)("FlowType")
    }
  });
  ye("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, L.validateOptionalType)("Identifier"),
      typeAnnotation: (0, L.validateType)("FlowType"),
      optional: (0, L.validateOptional)((0, L.assertValueType)("boolean"))
    }
  });
  ye("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, L.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, L.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  ye("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  ye("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, L.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, L.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Tp("InterfaceDeclaration");
  ye("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, L.validateOptional)((0, L.arrayOfType)("InterfaceExtends")),
      body: (0, L.validateType)("ObjectTypeAnnotation")
    }
  });
  ye("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, L.validate)((0, L.arrayOfType)("FlowType"))
    }
  });
  ye("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ye("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ye("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, L.validateType)("FlowType")
    }
  });
  ye("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, L.validate)((0, L.assertValueType)("number"))
    }
  });
  ye("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ye("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, L.validate)((0, L.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: {
        validate: (0, L.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, L.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, L.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, L.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, L.validateOptional)((0, L.assertValueType)("boolean"))
    }
  });
  ye("ObjectTypeInternalSlot", {
    visitor: ["id", "value"],
    builder: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      value: (0, L.validateType)("FlowType"),
      optional: (0, L.validate)((0, L.assertValueType)("boolean")),
      static: (0, L.validate)((0, L.assertValueType)("boolean")),
      method: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
  ye("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, L.validateType)("FlowType"),
      static: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
  ye("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, L.validateOptionalType)("Identifier"),
      key: (0, L.validateType)("FlowType"),
      value: (0, L.validateType)("FlowType"),
      static: (0, L.validate)((0, L.assertValueType)("boolean")),
      variance: (0, L.validateOptionalType)("Variance")
    }
  });
  ye("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, L.validateType)(["Identifier", "StringLiteral"]),
      value: (0, L.validateType)("FlowType"),
      kind: (0, L.validate)((0, L.assertOneOf)("init", "get", "set")),
      static: (0, L.validate)((0, L.assertValueType)("boolean")),
      proto: (0, L.validate)((0, L.assertValueType)("boolean")),
      optional: (0, L.validate)((0, L.assertValueType)("boolean")),
      variance: (0, L.validateOptionalType)("Variance"),
      method: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
  ye("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, L.validateType)("FlowType")
    }
  });
  ye("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      typeParameters: (0, L.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, L.validateOptionalType)("FlowType"),
      impltype: (0, L.validateType)("FlowType")
    }
  });
  ye("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      qualification: (0, L.validateType)(["Identifier", "QualifiedTypeIdentifier"])
    }
  });
  ye("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, L.validate)((0, L.assertValueType)("string"))
    }
  });
  ye("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ye("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ye("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ye("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, L.validate)((0, L.arrayOfType)("FlowType"))
    }
  });
  ye("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, L.validateType)("FlowType")
    }
  });
  ye("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      typeParameters: (0, L.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, L.validateType)("FlowType")
    }
  });
  ye("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, L.validateType)("FlowType")
    }
  });
  ye("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, L.validateType)("Expression"),
      typeAnnotation: (0, L.validateType)("TypeAnnotation")
    }
  });
  ye("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, L.validate)((0, L.assertValueType)("string")),
      bound: (0, L.validateOptionalType)("TypeAnnotation"),
      default: (0, L.validateOptionalType)("FlowType"),
      variance: (0, L.validateOptionalType)("Variance")
    }
  });
  ye("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, L.validate)((0, L.arrayOfType)("TypeParameter"))
    }
  });
  ye("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, L.validate)((0, L.arrayOfType)("FlowType"))
    }
  });
  ye("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, L.validate)((0, L.arrayOfType)("FlowType"))
    }
  });
  ye("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, L.validate)((0, L.assertOneOf)("minus", "plus"))
    }
  });
  ye("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ye("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      body: (0, L.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  });
  ye("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, L.validate)((0, L.assertValueType)("boolean")),
      members: (0, L.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
  ye("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, L.validate)((0, L.assertValueType)("boolean")),
      members: (0, L.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
  ye("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, L.validate)((0, L.assertValueType)("boolean")),
      members: (0, L.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
  ye("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, L.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
  ye("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      init: (0, L.validateType)("BooleanLiteral")
    }
  });
  ye("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      init: (0, L.validateType)("NumericLiteral")
    }
  });
  ye("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      init: (0, L.validateType)("StringLiteral")
    }
  });
  ye("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, L.validateType)("Identifier")
    }
  });
  ye("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, L.validateType)("FlowType"),
      indexType: (0, L.validateType)("FlowType")
    }
  });
  ye("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, L.validateType)("FlowType"),
      indexType: (0, L.validateType)("FlowType"),
      optional: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/jsx.js
var gE = T(() => {
  "use strict";
  var et = xn(), rr = (0, et.defineAliasedType)("JSX");
  rr("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, et.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, et.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  rr("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, et.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  rr("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, et.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, et.assertNodeType)("JSXClosingElement")
      },
      children: {
        validate: (0, et.chain)((0, et.assertValueType)("array"), (0, et.assertEach)((0, et.assertNodeType)("JSXText", "JSXExpressionContain\
er", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }, {
      selfClosing: {
        validate: (0, et.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  rr("JSXEmptyExpression", {});
  rr("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, et.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  rr("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, et.assertNodeType)("Expression")
      }
    }
  });
  rr("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, et.assertValueType)("string")
      }
    }
  });
  rr("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, et.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, et.assertNodeType)("JSXIdentifier")
      }
    }
  });
  rr("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, et.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, et.assertNodeType)("JSXIdentifier")
      }
    }
  });
  rr("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, et.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: {
        validate: (0, et.chain)((0, et.assertValueType)("array"), (0, et.assertEach)((0, et.assertNodeType)("JSXAttribute", "JSXSpreadAttrib\
ute")))
      },
      typeParameters: {
        validate: (0, et.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  rr("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, et.assertNodeType)("Expression")
      }
    }
  });
  rr("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, et.assertValueType)("string")
      }
    }
  });
  rr("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, et.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, et.assertNodeType)("JSXClosingFragment")
      },
      children: {
        validate: (0, et.chain)((0, et.assertValueType)("array"), (0, et.assertEach)((0, et.assertNodeType)("JSXText", "JSXExpressionContain\
er", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  });
  rr("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  rr("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// ../node_modules/@babel/types/lib/definitions/placeholders.js
var Pp = T((Qn) => {
  "use strict";
  Object.defineProperty(Qn, "__esModule", {
    value: !0
  });
  Qn.PLACEHOLDERS_FLIPPED_ALIAS = Qn.PLACEHOLDERS_ALIAS = Qn.PLACEHOLDERS = void 0;
  var G8 = xn(), H8 = Qn.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBo\
dy", "Pattern"], Sp = Qn.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (let e of H8) {
    let t = G8.ALIAS_KEYS[e];
    t != null && t.length && (Sp[e] = t);
  }
  var xp = Qn.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(Sp).forEach((e) => {
    Sp[e].forEach((t) => {
      hasOwnProperty.call(xp, t) || (xp[t] = []), xp[t].push(e);
    });
  });
});

// ../node_modules/@babel/types/lib/definitions/misc.js
var bE = T(() => {
  "use strict";
  var vl = xn(), Y8 = Pp(), Ap = (0, vl.defineAliasedType)("Miscellaneous");
  Ap("Noop", {
    visitor: []
  });
  Ap("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: (0, vl.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, vl.assertOneOf)(...Y8.PLACEHOLDERS)
      }
    }
  });
  Ap("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, vl.assertValueType)("string")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/experimental.js
var EE = T(() => {
  "use strict";
  var Qe = xn();
  (0, Qe.default)("ArgumentPlaceholder", {});
  (0, Qe.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, Qe.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, Qe.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  });
  (0, Qe.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, Qe.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, Qe.assertNodeType)("StringLiteral")
      }
    }
  });
  (0, Qe.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, Qe.assertNodeType)("Expression")
      }
    }
  });
  (0, Qe.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, Qe.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, Qe.assertValueType)("boolean"),
        default: !1
      }
    }
  });
  (0, Qe.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, Qe.assertNodeType)("Identifier")
      }
    }
  });
  (0, Qe.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, Qe.chain)((0, Qe.assertValueType)("array"), (0, Qe.assertEach)((0, Qe.assertNodeType)("ObjectProperty", "SpreadElement")))
      }
    }
  });
  (0, Qe.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, Qe.chain)((0, Qe.assertValueType)("array"), (0, Qe.assertEach)((0, Qe.assertNodeType)("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, Qe.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, Qe.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, Qe.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, Qe.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, Qe.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, Qe.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, Qe.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, Qe.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, Qe.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, Qe.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
});

// ../node_modules/@babel/types/lib/definitions/typescript.js
var wE = T(() => {
  "use strict";
  var $ = xn(), vE = vp(), z8 = yi(), we = (0, $.defineAliasedType)("TypeScript"), hr = (0, $.assertValueType)("boolean"), TE = /* @__PURE__ */ s(
  () => ({
    returnType: {
      validate: (0, $.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, $.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "tSFunctionTypeAnnotationCommon");
  we("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, $.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, $.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, $.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, $.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, $.chain)((0, $.assertValueType)("array"), (0, $.assertEach)((0, $.assertNodeType)("Decorator"))),
        optional: !0
      }
    }
  });
  we("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, vE.functionDeclarationCommon)(), TE())
  });
  we("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, vE.classMethodOrDeclareMethodCommon)(), TE())
  });
  we("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, $.validateType)("TSEntityName"),
      right: (0, $.validateType)("Identifier")
    }
  });
  var Tl = /* @__PURE__ */ s(() => ({
    typeParameters: (0, $.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, $.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
    typeAnnotation: (0, $.validateOptionalType)("TSTypeAnnotation")
  }), "signatureDeclarationCommon"), xE = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: Tl()
  };
  we("TSCallSignatureDeclaration", xE);
  we("TSConstructSignatureDeclaration", xE);
  var SE = /* @__PURE__ */ s(() => ({
    key: (0, $.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, $.validateOptional)(hr)
  }), "namedTypeElementCommon");
  we("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, SE(), {
      readonly: (0, $.validateOptional)(hr),
      typeAnnotation: (0, $.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        validate: (0, $.assertOneOf)("get", "set")
      }
    })
  });
  we("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, Tl(), SE(), {
      kind: {
        validate: (0, $.assertOneOf)("method", "get", "set")
      }
    })
  });
  we("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, $.validateOptional)(hr),
      static: (0, $.validateOptional)(hr),
      parameters: (0, $.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, $.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var J8 = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword",
  "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (let e of J8)
    we(e, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  we("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var PE = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  we("TSFunctionType", Object.assign({}, PE, {
    fields: Tl()
  }));
  we("TSConstructorType", Object.assign({}, PE, {
    fields: Object.assign({}, Tl(), {
      abstract: (0, $.validateOptional)(hr)
    })
  }));
  we("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, $.validateType)("TSEntityName"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  we("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, $.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, $.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, $.validateOptional)(hr)
    }
  });
  we("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, $.validateType)(["TSEntityName", "TSImportType"]),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  we("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, $.validateArrayOfType)("TSTypeElement")
    }
  });
  we("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, $.validateType)("TSType")
    }
  });
  we("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, $.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
    }
  });
  we("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, $.validateType)("TSType")
    }
  });
  we("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, $.validateType)("TSType")
    }
  });
  we("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, $.validateType)("Identifier"),
      optional: {
        validate: hr,
        default: !1
      },
      elementType: (0, $.validateType)("TSType")
    }
  });
  var AE = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, $.validateArrayOfType)("TSType")
    }
  };
  we("TSUnionType", AE);
  we("TSIntersectionType", AE);
  we("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, $.validateType)("TSType"),
      extendsType: (0, $.validateType)("TSType"),
      trueType: (0, $.validateType)("TSType"),
      falseType: (0, $.validateType)("TSType")
    }
  });
  we("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, $.validateType)("TSTypeParameter")
    }
  });
  we("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, $.validateType)("TSType")
    }
  });
  we("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, $.validate)((0, $.assertValueType)("string")),
      typeAnnotation: (0, $.validateType)("TSType")
    }
  });
  we("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, $.validateType)("TSType"),
      indexType: (0, $.validateType)("TSType")
    }
  });
  we("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, $.validateOptional)((0, $.assertOneOf)(!0, !1, "+", "-")),
      typeParameter: (0, $.validateType)("TSTypeParameter"),
      optional: (0, $.validateOptional)((0, $.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, $.validateOptionalType)("TSType"),
      nameType: (0, $.validateOptionalType)("TSType")
    }
  });
  we("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          let e = (0, $.assertNodeType)("NumericLiteral", "BigIntLiteral"), t = (0, $.assertOneOf)("-"), r = (0, $.assertNodeType)("NumericL\
iteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function n(i, a, o) {
            (0, z8.default)("UnaryExpression", o) ? (t(o, "operator", o.operator), e(o, "argument", o.argument)) : r(i, a, o);
          }
          return s(n, "validator"), n.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiter\
al", "UnaryExpression"], n;
        }()
      }
    }
  });
  we("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, $.validateType)("TSEntityName"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  we("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, $.validateOptional)(hr),
      id: (0, $.validateType)("Identifier"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, $.validateOptional)((0, $.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, $.validateType)("TSInterfaceBody")
    }
  });
  we("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, $.validateArrayOfType)("TSTypeElement")
    }
  });
  we("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, $.validateOptional)(hr),
      id: (0, $.validateType)("Identifier"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, $.validateType)("TSType")
    }
  });
  we("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, $.validateType)("Expression"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var CE = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, $.validateType)("Expression"),
      typeAnnotation: (0, $.validateType)("TSType")
    }
  };
  we("TSAsExpression", CE);
  we("TSSatisfiesExpression", CE);
  we("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, $.validateType)("TSType"),
      expression: (0, $.validateType)("Expression")
    }
  });
  we("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, $.validateOptional)(hr),
      const: (0, $.validateOptional)(hr),
      id: (0, $.validateType)("Identifier"),
      members: (0, $.validateArrayOfType)("TSEnumMember"),
      initializer: (0, $.validateOptionalType)("Expression")
    }
  });
  we("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, $.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, $.validateOptionalType)("Expression")
    }
  });
  we("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, $.validateOptional)(hr),
      global: (0, $.validateOptional)(hr),
      id: (0, $.validateType)(["Identifier", "StringLiteral"]),
      body: (0, $.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
    }
  });
  we("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, $.validateArrayOfType)("Statement")
    }
  });
  we("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, $.validateType)("StringLiteral"),
      qualifier: (0, $.validateOptionalType)("TSEntityName"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, $.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  we("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, $.validate)(hr),
      id: (0, $.validateType)("Identifier"),
      moduleReference: (0, $.validateType)(["TSEntityName", "TSExternalModuleReference"]),
      importKind: {
        validate: (0, $.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  we("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, $.validateType)("StringLiteral")
    }
  });
  we("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, $.validateType)("Expression")
    }
  });
  we("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, $.validateType)("Expression")
    }
  });
  we("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, $.validateType)("Identifier")
    }
  });
  we("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, $.assertNodeType)("TSType")
      }
    }
  });
  we("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, $.chain)((0, $.assertValueType)("array"), (0, $.assertEach)((0, $.assertNodeType)("TSType")))
      }
    }
  });
  we("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, $.chain)((0, $.assertValueType)("array"), (0, $.assertEach)((0, $.assertNodeType)("TSTypeParameter")))
      }
    }
  });
  we("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, $.assertValueType)("string")
      },
      in: {
        validate: (0, $.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, $.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, $.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, $.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, $.assertNodeType)("TSType"),
        optional: !0
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var DE = T((xl) => {
  "use strict";
  Object.defineProperty(xl, "__esModule", {
    value: !0
  });
  xl.DEPRECATED_ALIASES = void 0;
  var QEe = xl.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// ../node_modules/@babel/types/lib/definitions/index.js
var Cr = T((nr) => {
  "use strict";
  Object.defineProperty(nr, "__esModule", {
    value: !0
  });
  Object.defineProperty(nr, "ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ft.ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(nr, "BUILDER_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ft.BUILDER_KEYS;
    }, "get")
  });
  Object.defineProperty(nr, "DEPRECATED_ALIASES", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Cp.DEPRECATED_ALIASES;
    }, "get")
  });
  Object.defineProperty(nr, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ft.DEPRECATED_KEYS;
    }, "get")
  });
  Object.defineProperty(nr, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ft.FLIPPED_ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(nr, "NODE_FIELDS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ft.NODE_FIELDS;
    }, "get")
  });
  Object.defineProperty(nr, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ft.NODE_PARENT_VALIDATIONS;
    }, "get")
  });
  Object.defineProperty(nr, "PLACEHOLDERS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ka.PLACEHOLDERS;
    }, "get")
  });
  Object.defineProperty(nr, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ka.PLACEHOLDERS_ALIAS;
    }, "get")
  });
  Object.defineProperty(nr, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ka.PLACEHOLDERS_FLIPPED_ALIAS;
    }, "get")
  });
  nr.TYPES = void 0;
  Object.defineProperty(nr, "VISITOR_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ft.VISITOR_KEYS;
    }, "get")
  });
  var Zn = G1();
  vp();
  yE();
  gE();
  bE();
  EE();
  wE();
  var Ft = xn(), ka = Pp(), Cp = DE();
  Object.keys(Cp.DEPRECATED_ALIASES).forEach((e) => {
    Ft.FLIPPED_ALIAS_KEYS[e] = Ft.FLIPPED_ALIAS_KEYS[Cp.DEPRECATED_ALIASES[e]];
  });
  Zn(Ft.VISITOR_KEYS);
  Zn(Ft.ALIAS_KEYS);
  Zn(Ft.FLIPPED_ALIAS_KEYS);
  Zn(Ft.NODE_FIELDS);
  Zn(Ft.BUILDER_KEYS);
  Zn(Ft.DEPRECATED_KEYS);
  Zn(ka.PLACEHOLDERS_ALIAS);
  Zn(ka.PLACEHOLDERS_FLIPPED_ALIAS);
  var eve = nr.TYPES = [].concat(Object.keys(Ft.VISITOR_KEYS), Object.keys(Ft.FLIPPED_ALIAS_KEYS), Object.keys(Ft.DEPRECATED_KEYS));
});

// ../node_modules/@babel/types/lib/validators/validate.js
var bl = T((Fa) => {
  "use strict";
  Object.defineProperty(Fa, "__esModule", {
    value: !0
  });
  Fa.default = X8;
  Fa.validateChild = OE;
  Fa.validateField = _E;
  var IE = Cr();
  function X8(e, t, r) {
    if (!e) return;
    let n = IE.NODE_FIELDS[e.type];
    if (!n) return;
    let i = n[t];
    _E(e, t, r, i), OE(e, t, r);
  }
  s(X8, "validate");
  function _E(e, t, r, n) {
    n != null && n.validate && (n.optional && r == null || n.validate(e, t, r));
  }
  s(_E, "validateField");
  function OE(e, t, r) {
    if (r == null) return;
    let n = IE.NODE_PARENT_VALIDATIONS[r.type];
    n && n(e, t, r);
  }
  s(OE, "validateChild");
});

// ../node_modules/@babel/types/lib/builders/validateNode.js
var NE = T((wp) => {
  "use strict";
  Object.defineProperty(wp, "__esModule", {
    value: !0
  });
  wp.default = e6;
  var Q8 = bl(), Z8 = Pe();
  function e6(e) {
    let t = Z8.BUILDER_KEYS[e.type];
    for (let r of t)
      (0, Q8.default)(e, r, e[r]);
    return e;
  }
  s(e6, "validateNode");
});

// ../node_modules/@babel/types/lib/builders/generated/index.js
var sr = T((g) => {
  "use strict";
  Object.defineProperty(g, "__esModule", {
    value: !0
  });
  g.anyTypeAnnotation = O5;
  g.argumentPlaceholder = aL;
  g.arrayExpression = t6;
  g.arrayPattern = J6;
  g.arrayTypeAnnotation = N5;
  g.arrowFunctionExpression = X6;
  g.assignmentExpression = r6;
  g.assignmentPattern = z6;
  g.awaitExpression = E5;
  g.bigIntLiteral = T5;
  g.binaryExpression = n6;
  g.bindExpression = oL;
  g.blockStatement = o6;
  g.booleanLiteral = w6;
  g.booleanLiteralTypeAnnotation = k5;
  g.booleanTypeAnnotation = B5;
  g.breakStatement = l6;
  g.callExpression = u6;
  g.catchClause = c6;
  g.classAccessorProperty = C5;
  g.classBody = Q6;
  g.classDeclaration = e5;
  g.classExpression = Z6;
  g.classImplements = j5;
  g.classMethod = p5;
  g.classPrivateMethod = D5;
  g.classPrivateProperty = w5;
  g.classProperty = A5;
  g.conditionalExpression = f6;
  g.continueStatement = p6;
  g.debuggerStatement = d6;
  g.decimalLiteral = hL;
  g.declareClass = L5;
  g.declareExportAllDeclaration = G5;
  g.declareExportDeclaration = K5;
  g.declareFunction = M5;
  g.declareInterface = R5;
  g.declareModule = q5;
  g.declareModuleExports = U5;
  g.declareOpaqueType = $5;
  g.declareTypeAlias = V5;
  g.declareVariable = W5;
  g.declaredPredicate = H5;
  g.decorator = uL;
  g.directive = i6;
  g.directiveLiteral = a6;
  g.doExpression = cL;
  g.doWhileStatement = h6;
  g.emptyStatement = m6;
  g.emptyTypeAnnotation = sj;
  g.enumBooleanBody = Nj;
  g.enumBooleanMember = jj;
  g.enumDeclaration = Oj;
  g.enumDefaultedMember = Rj;
  g.enumNumberBody = Bj;
  g.enumNumberMember = Lj;
  g.enumStringBody = kj;
  g.enumStringMember = Mj;
  g.enumSymbolBody = Fj;
  g.existsTypeAnnotation = Y5;
  g.exportAllDeclaration = t5;
  g.exportDefaultDeclaration = r5;
  g.exportDefaultSpecifier = fL;
  g.exportNamedDeclaration = n5;
  g.exportNamespaceSpecifier = x5;
  g.exportSpecifier = s5;
  g.expressionStatement = y6;
  g.file = g6;
  g.forInStatement = b6;
  g.forOfStatement = i5;
  g.forStatement = E6;
  g.functionDeclaration = v6;
  g.functionExpression = T6;
  g.functionTypeAnnotation = z5;
  g.functionTypeParam = J5;
  g.genericTypeAnnotation = X5;
  g.identifier = x6;
  g.ifStatement = S6;
  g.import = v5;
  g.importAttribute = lL;
  g.importDeclaration = a5;
  g.importDefaultSpecifier = o5;
  g.importExpression = c5;
  g.importNamespaceSpecifier = l5;
  g.importSpecifier = u5;
  g.indexedAccessType = qj;
  g.inferredPredicate = Q5;
  g.interfaceDeclaration = ej;
  g.interfaceExtends = Z5;
  g.interfaceTypeAnnotation = tj;
  g.interpreterDirective = s6;
  g.intersectionTypeAnnotation = rj;
  g.jSXAttribute = g.jsxAttribute = Vj;
  g.jSXClosingElement = g.jsxClosingElement = $j;
  g.jSXClosingFragment = g.jsxClosingFragment = rL;
  g.jSXElement = g.jsxElement = Wj;
  g.jSXEmptyExpression = g.jsxEmptyExpression = Kj;
  g.jSXExpressionContainer = g.jsxExpressionContainer = Gj;
  g.jSXFragment = g.jsxFragment = eL;
  g.jSXIdentifier = g.jsxIdentifier = Yj;
  g.jSXMemberExpression = g.jsxMemberExpression = zj;
  g.jSXNamespacedName = g.jsxNamespacedName = Jj;
  g.jSXOpeningElement = g.jsxOpeningElement = Xj;
  g.jSXOpeningFragment = g.jsxOpeningFragment = tL;
  g.jSXSpreadAttribute = g.jsxSpreadAttribute = Qj;
  g.jSXSpreadChild = g.jsxSpreadChild = Hj;
  g.jSXText = g.jsxText = Zj;
  g.labeledStatement = P6;
  g.logicalExpression = D6;
  g.memberExpression = I6;
  g.metaProperty = f5;
  g.mixedTypeAnnotation = nj;
  g.moduleExpression = mL;
  g.newExpression = _6;
  g.noop = nL;
  g.nullLiteral = C6;
  g.nullLiteralTypeAnnotation = F5;
  g.nullableTypeAnnotation = ij;
  g.numberLiteral = OM;
  g.numberLiteralTypeAnnotation = aj;
  g.numberTypeAnnotation = oj;
  g.numericLiteral = BE;
  g.objectExpression = N6;
  g.objectMethod = B6;
  g.objectPattern = d5;
  g.objectProperty = k6;
  g.objectTypeAnnotation = lj;
  g.objectTypeCallProperty = cj;
  g.objectTypeIndexer = fj;
  g.objectTypeInternalSlot = uj;
  g.objectTypeProperty = pj;
  g.objectTypeSpreadProperty = dj;
  g.opaqueType = hj;
  g.optionalCallExpression = P5;
  g.optionalIndexedAccessType = Uj;
  g.optionalMemberExpression = S5;
  g.parenthesizedExpression = L6;
  g.pipelineBareFunction = bL;
  g.pipelinePrimaryTopicReference = EL;
  g.pipelineTopicExpression = gL;
  g.placeholder = sL;
  g.privateName = I5;
  g.program = O6;
  g.qualifiedTypeIdentifier = mj;
  g.recordExpression = pL;
  g.regExpLiteral = kE;
  g.regexLiteral = NM;
  g.restElement = FE;
  g.restProperty = BM;
  g.returnStatement = F6;
  g.sequenceExpression = j6;
  g.spreadElement = jE;
  g.spreadProperty = kM;
  g.staticBlock = _5;
  g.stringLiteral = A6;
  g.stringLiteralTypeAnnotation = yj;
  g.stringTypeAnnotation = gj;
  g.super = h5;
  g.switchCase = M6;
  g.switchStatement = R6;
  g.symbolTypeAnnotation = bj;
  g.taggedTemplateExpression = m5;
  g.templateElement = y5;
  g.templateLiteral = g5;
  g.thisExpression = q6;
  g.thisTypeAnnotation = Ej;
  g.throwStatement = U6;
  g.topicReference = yL;
  g.tryStatement = V6;
  g.tSAnyKeyword = g.tsAnyKeyword = IL;
  g.tSArrayType = g.tsArrayType = zL;
  g.tSAsExpression = g.tsAsExpression = hM;
  g.tSBigIntKeyword = g.tsBigIntKeyword = OL;
  g.tSBooleanKeyword = g.tsBooleanKeyword = _L;
  g.tSCallSignatureDeclaration = g.tsCallSignatureDeclaration = PL;
  g.tSConditionalType = g.tsConditionalType = rM;
  g.tSConstructSignatureDeclaration = g.tsConstructSignatureDeclaration = AL;
  g.tSConstructorType = g.tsConstructorType = WL;
  g.tSDeclareFunction = g.tsDeclareFunction = TL;
  g.tSDeclareMethod = g.tsDeclareMethod = xL;
  g.tSEnumDeclaration = g.tsEnumDeclaration = gM;
  g.tSEnumMember = g.tsEnumMember = bM;
  g.tSExportAssignment = g.tsExportAssignment = AM;
  g.tSExpressionWithTypeArguments = g.tsExpressionWithTypeArguments = uM;
  g.tSExternalModuleReference = g.tsExternalModuleReference = SM;
  g.tSFunctionType = g.tsFunctionType = $L;
  g.tSImportEqualsDeclaration = g.tsImportEqualsDeclaration = xM;
  g.tSImportType = g.tsImportType = TM;
  g.tSIndexSignature = g.tsIndexSignature = DL;
  g.tSIndexedAccessType = g.tsIndexedAccessType = aM;
  g.tSInferType = g.tsInferType = nM;
  g.tSInstantiationExpression = g.tsInstantiationExpression = dM;
  g.tSInterfaceBody = g.tsInterfaceBody = fM;
  g.tSInterfaceDeclaration = g.tsInterfaceDeclaration = cM;
  g.tSIntersectionType = g.tsIntersectionType = tM;
  g.tSIntrinsicKeyword = g.tsIntrinsicKeyword = NL;
  g.tSLiteralType = g.tsLiteralType = lM;
  g.tSMappedType = g.tsMappedType = oM;
  g.tSMethodSignature = g.tsMethodSignature = wL;
  g.tSModuleBlock = g.tsModuleBlock = vM;
  g.tSModuleDeclaration = g.tsModuleDeclaration = EM;
  g.tSNamedTupleMember = g.tsNamedTupleMember = ZL;
  g.tSNamespaceExportDeclaration = g.tsNamespaceExportDeclaration = CM;
  g.tSNeverKeyword = g.tsNeverKeyword = BL;
  g.tSNonNullExpression = g.tsNonNullExpression = PM;
  g.tSNullKeyword = g.tsNullKeyword = kL;
  g.tSNumberKeyword = g.tsNumberKeyword = FL;
  g.tSObjectKeyword = g.tsObjectKeyword = jL;
  g.tSOptionalType = g.tsOptionalType = XL;
  g.tSParameterProperty = g.tsParameterProperty = vL;
  g.tSParenthesizedType = g.tsParenthesizedType = sM;
  g.tSPropertySignature = g.tsPropertySignature = CL;
  g.tSQualifiedName = g.tsQualifiedName = SL;
  g.tSRestType = g.tsRestType = QL;
  g.tSSatisfiesExpression = g.tsSatisfiesExpression = mM;
  g.tSStringKeyword = g.tsStringKeyword = LL;
  g.tSSymbolKeyword = g.tsSymbolKeyword = ML;
  g.tSThisType = g.tsThisType = VL;
  g.tSTupleType = g.tsTupleType = JL;
  g.tSTypeAliasDeclaration = g.tsTypeAliasDeclaration = pM;
  g.tSTypeAnnotation = g.tsTypeAnnotation = wM;
  g.tSTypeAssertion = g.tsTypeAssertion = yM;
  g.tSTypeLiteral = g.tsTypeLiteral = YL;
  g.tSTypeOperator = g.tsTypeOperator = iM;
  g.tSTypeParameter = g.tsTypeParameter = _M;
  g.tSTypeParameterDeclaration = g.tsTypeParameterDeclaration = IM;
  g.tSTypeParameterInstantiation = g.tsTypeParameterInstantiation = DM;
  g.tSTypePredicate = g.tsTypePredicate = GL;
  g.tSTypeQuery = g.tsTypeQuery = HL;
  g.tSTypeReference = g.tsTypeReference = KL;
  g.tSUndefinedKeyword = g.tsUndefinedKeyword = RL;
  g.tSUnionType = g.tsUnionType = eM;
  g.tSUnknownKeyword = g.tsUnknownKeyword = qL;
  g.tSVoidKeyword = g.tsVoidKeyword = UL;
  g.tupleExpression = dL;
  g.tupleTypeAnnotation = vj;
  g.typeAlias = xj;
  g.typeAnnotation = Sj;
  g.typeCastExpression = Pj;
  g.typeParameter = Aj;
  g.typeParameterDeclaration = Cj;
  g.typeParameterInstantiation = wj;
  g.typeofTypeAnnotation = Tj;
  g.unaryExpression = $6;
  g.unionTypeAnnotation = Dj;
  g.updateExpression = W6;
  g.v8IntrinsicIdentifier = iL;
  g.variableDeclaration = K6;
  g.variableDeclarator = G6;
  g.variance = Ij;
  g.voidTypeAnnotation = _j;
  g.whileStatement = H6;
  g.withStatement = Y6;
  g.yieldExpression = b5;
  var N = NE(), Sl = Aa();
  function t6(e = []) {
    return (0, N.default)({
      type: "ArrayExpression",
      elements: e
    });
  }
  s(t6, "arrayExpression");
  function r6(e, t, r) {
    return (0, N.default)({
      type: "AssignmentExpression",
      operator: e,
      left: t,
      right: r
    });
  }
  s(r6, "assignmentExpression");
  function n6(e, t, r) {
    return (0, N.default)({
      type: "BinaryExpression",
      operator: e,
      left: t,
      right: r
    });
  }
  s(n6, "binaryExpression");
  function s6(e) {
    return (0, N.default)({
      type: "InterpreterDirective",
      value: e
    });
  }
  s(s6, "interpreterDirective");
  function i6(e) {
    return (0, N.default)({
      type: "Directive",
      value: e
    });
  }
  s(i6, "directive");
  function a6(e) {
    return (0, N.default)({
      type: "DirectiveLiteral",
      value: e
    });
  }
  s(a6, "directiveLiteral");
  function o6(e, t = []) {
    return (0, N.default)({
      type: "BlockStatement",
      body: e,
      directives: t
    });
  }
  s(o6, "blockStatement");
  function l6(e = null) {
    return (0, N.default)({
      type: "BreakStatement",
      label: e
    });
  }
  s(l6, "breakStatement");
  function u6(e, t) {
    return (0, N.default)({
      type: "CallExpression",
      callee: e,
      arguments: t
    });
  }
  s(u6, "callExpression");
  function c6(e = null, t) {
    return (0, N.default)({
      type: "CatchClause",
      param: e,
      body: t
    });
  }
  s(c6, "catchClause");
  function f6(e, t, r) {
    return (0, N.default)({
      type: "ConditionalExpression",
      test: e,
      consequent: t,
      alternate: r
    });
  }
  s(f6, "conditionalExpression");
  function p6(e = null) {
    return (0, N.default)({
      type: "ContinueStatement",
      label: e
    });
  }
  s(p6, "continueStatement");
  function d6() {
    return {
      type: "DebuggerStatement"
    };
  }
  s(d6, "debuggerStatement");
  function h6(e, t) {
    return (0, N.default)({
      type: "DoWhileStatement",
      test: e,
      body: t
    });
  }
  s(h6, "doWhileStatement");
  function m6() {
    return {
      type: "EmptyStatement"
    };
  }
  s(m6, "emptyStatement");
  function y6(e) {
    return (0, N.default)({
      type: "ExpressionStatement",
      expression: e
    });
  }
  s(y6, "expressionStatement");
  function g6(e, t = null, r = null) {
    return (0, N.default)({
      type: "File",
      program: e,
      comments: t,
      tokens: r
    });
  }
  s(g6, "file");
  function b6(e, t, r) {
    return (0, N.default)({
      type: "ForInStatement",
      left: e,
      right: t,
      body: r
    });
  }
  s(b6, "forInStatement");
  function E6(e = null, t = null, r = null, n) {
    return (0, N.default)({
      type: "ForStatement",
      init: e,
      test: t,
      update: r,
      body: n
    });
  }
  s(E6, "forStatement");
  function v6(e = null, t, r, n = !1, i = !1) {
    return (0, N.default)({
      type: "FunctionDeclaration",
      id: e,
      params: t,
      body: r,
      generator: n,
      async: i
    });
  }
  s(v6, "functionDeclaration");
  function T6(e = null, t, r, n = !1, i = !1) {
    return (0, N.default)({
      type: "FunctionExpression",
      id: e,
      params: t,
      body: r,
      generator: n,
      async: i
    });
  }
  s(T6, "functionExpression");
  function x6(e) {
    return (0, N.default)({
      type: "Identifier",
      name: e
    });
  }
  s(x6, "identifier");
  function S6(e, t, r = null) {
    return (0, N.default)({
      type: "IfStatement",
      test: e,
      consequent: t,
      alternate: r
    });
  }
  s(S6, "ifStatement");
  function P6(e, t) {
    return (0, N.default)({
      type: "LabeledStatement",
      label: e,
      body: t
    });
  }
  s(P6, "labeledStatement");
  function A6(e) {
    return (0, N.default)({
      type: "StringLiteral",
      value: e
    });
  }
  s(A6, "stringLiteral");
  function BE(e) {
    return (0, N.default)({
      type: "NumericLiteral",
      value: e
    });
  }
  s(BE, "numericLiteral");
  function C6() {
    return {
      type: "NullLiteral"
    };
  }
  s(C6, "nullLiteral");
  function w6(e) {
    return (0, N.default)({
      type: "BooleanLiteral",
      value: e
    });
  }
  s(w6, "booleanLiteral");
  function kE(e, t = "") {
    return (0, N.default)({
      type: "RegExpLiteral",
      pattern: e,
      flags: t
    });
  }
  s(kE, "regExpLiteral");
  function D6(e, t, r) {
    return (0, N.default)({
      type: "LogicalExpression",
      operator: e,
      left: t,
      right: r
    });
  }
  s(D6, "logicalExpression");
  function I6(e, t, r = !1, n = null) {
    return (0, N.default)({
      type: "MemberExpression",
      object: e,
      property: t,
      computed: r,
      optional: n
    });
  }
  s(I6, "memberExpression");
  function _6(e, t) {
    return (0, N.default)({
      type: "NewExpression",
      callee: e,
      arguments: t
    });
  }
  s(_6, "newExpression");
  function O6(e, t = [], r = "script", n = null) {
    return (0, N.default)({
      type: "Program",
      body: e,
      directives: t,
      sourceType: r,
      interpreter: n
    });
  }
  s(O6, "program");
  function N6(e) {
    return (0, N.default)({
      type: "ObjectExpression",
      properties: e
    });
  }
  s(N6, "objectExpression");
  function B6(e = "method", t, r, n, i = !1, a = !1, o = !1) {
    return (0, N.default)({
      type: "ObjectMethod",
      kind: e,
      key: t,
      params: r,
      body: n,
      computed: i,
      generator: a,
      async: o
    });
  }
  s(B6, "objectMethod");
  function k6(e, t, r = !1, n = !1, i = null) {
    return (0, N.default)({
      type: "ObjectProperty",
      key: e,
      value: t,
      computed: r,
      shorthand: n,
      decorators: i
    });
  }
  s(k6, "objectProperty");
  function FE(e) {
    return (0, N.default)({
      type: "RestElement",
      argument: e
    });
  }
  s(FE, "restElement");
  function F6(e = null) {
    return (0, N.default)({
      type: "ReturnStatement",
      argument: e
    });
  }
  s(F6, "returnStatement");
  function j6(e) {
    return (0, N.default)({
      type: "SequenceExpression",
      expressions: e
    });
  }
  s(j6, "sequenceExpression");
  function L6(e) {
    return (0, N.default)({
      type: "ParenthesizedExpression",
      expression: e
    });
  }
  s(L6, "parenthesizedExpression");
  function M6(e = null, t) {
    return (0, N.default)({
      type: "SwitchCase",
      test: e,
      consequent: t
    });
  }
  s(M6, "switchCase");
  function R6(e, t) {
    return (0, N.default)({
      type: "SwitchStatement",
      discriminant: e,
      cases: t
    });
  }
  s(R6, "switchStatement");
  function q6() {
    return {
      type: "ThisExpression"
    };
  }
  s(q6, "thisExpression");
  function U6(e) {
    return (0, N.default)({
      type: "ThrowStatement",
      argument: e
    });
  }
  s(U6, "throwStatement");
  function V6(e, t = null, r = null) {
    return (0, N.default)({
      type: "TryStatement",
      block: e,
      handler: t,
      finalizer: r
    });
  }
  s(V6, "tryStatement");
  function $6(e, t, r = !0) {
    return (0, N.default)({
      type: "UnaryExpression",
      operator: e,
      argument: t,
      prefix: r
    });
  }
  s($6, "unaryExpression");
  function W6(e, t, r = !1) {
    return (0, N.default)({
      type: "UpdateExpression",
      operator: e,
      argument: t,
      prefix: r
    });
  }
  s(W6, "updateExpression");
  function K6(e, t) {
    return (0, N.default)({
      type: "VariableDeclaration",
      kind: e,
      declarations: t
    });
  }
  s(K6, "variableDeclaration");
  function G6(e, t = null) {
    return (0, N.default)({
      type: "VariableDeclarator",
      id: e,
      init: t
    });
  }
  s(G6, "variableDeclarator");
  function H6(e, t) {
    return (0, N.default)({
      type: "WhileStatement",
      test: e,
      body: t
    });
  }
  s(H6, "whileStatement");
  function Y6(e, t) {
    return (0, N.default)({
      type: "WithStatement",
      object: e,
      body: t
    });
  }
  s(Y6, "withStatement");
  function z6(e, t) {
    return (0, N.default)({
      type: "AssignmentPattern",
      left: e,
      right: t
    });
  }
  s(z6, "assignmentPattern");
  function J6(e) {
    return (0, N.default)({
      type: "ArrayPattern",
      elements: e
    });
  }
  s(J6, "arrayPattern");
  function X6(e, t, r = !1) {
    return (0, N.default)({
      type: "ArrowFunctionExpression",
      params: e,
      body: t,
      async: r,
      expression: null
    });
  }
  s(X6, "arrowFunctionExpression");
  function Q6(e) {
    return (0, N.default)({
      type: "ClassBody",
      body: e
    });
  }
  s(Q6, "classBody");
  function Z6(e = null, t = null, r, n = null) {
    return (0, N.default)({
      type: "ClassExpression",
      id: e,
      superClass: t,
      body: r,
      decorators: n
    });
  }
  s(Z6, "classExpression");
  function e5(e = null, t = null, r, n = null) {
    return (0, N.default)({
      type: "ClassDeclaration",
      id: e,
      superClass: t,
      body: r,
      decorators: n
    });
  }
  s(e5, "classDeclaration");
  function t5(e) {
    return (0, N.default)({
      type: "ExportAllDeclaration",
      source: e
    });
  }
  s(t5, "exportAllDeclaration");
  function r5(e) {
    return (0, N.default)({
      type: "ExportDefaultDeclaration",
      declaration: e
    });
  }
  s(r5, "exportDefaultDeclaration");
  function n5(e = null, t = [], r = null) {
    return (0, N.default)({
      type: "ExportNamedDeclaration",
      declaration: e,
      specifiers: t,
      source: r
    });
  }
  s(n5, "exportNamedDeclaration");
  function s5(e, t) {
    return (0, N.default)({
      type: "ExportSpecifier",
      local: e,
      exported: t
    });
  }
  s(s5, "exportSpecifier");
  function i5(e, t, r, n = !1) {
    return (0, N.default)({
      type: "ForOfStatement",
      left: e,
      right: t,
      body: r,
      await: n
    });
  }
  s(i5, "forOfStatement");
  function a5(e, t) {
    return (0, N.default)({
      type: "ImportDeclaration",
      specifiers: e,
      source: t
    });
  }
  s(a5, "importDeclaration");
  function o5(e) {
    return (0, N.default)({
      type: "ImportDefaultSpecifier",
      local: e
    });
  }
  s(o5, "importDefaultSpecifier");
  function l5(e) {
    return (0, N.default)({
      type: "ImportNamespaceSpecifier",
      local: e
    });
  }
  s(l5, "importNamespaceSpecifier");
  function u5(e, t) {
    return (0, N.default)({
      type: "ImportSpecifier",
      local: e,
      imported: t
    });
  }
  s(u5, "importSpecifier");
  function c5(e, t = null) {
    return (0, N.default)({
      type: "ImportExpression",
      source: e,
      options: t
    });
  }
  s(c5, "importExpression");
  function f5(e, t) {
    return (0, N.default)({
      type: "MetaProperty",
      meta: e,
      property: t
    });
  }
  s(f5, "metaProperty");
  function p5(e = "method", t, r, n, i = !1, a = !1, o = !1, l = !1) {
    return (0, N.default)({
      type: "ClassMethod",
      kind: e,
      key: t,
      params: r,
      body: n,
      computed: i,
      static: a,
      generator: o,
      async: l
    });
  }
  s(p5, "classMethod");
  function d5(e) {
    return (0, N.default)({
      type: "ObjectPattern",
      properties: e
    });
  }
  s(d5, "objectPattern");
  function jE(e) {
    return (0, N.default)({
      type: "SpreadElement",
      argument: e
    });
  }
  s(jE, "spreadElement");
  function h5() {
    return {
      type: "Super"
    };
  }
  s(h5, "_super");
  function m5(e, t) {
    return (0, N.default)({
      type: "TaggedTemplateExpression",
      tag: e,
      quasi: t
    });
  }
  s(m5, "taggedTemplateExpression");
  function y5(e, t = !1) {
    return (0, N.default)({
      type: "TemplateElement",
      value: e,
      tail: t
    });
  }
  s(y5, "templateElement");
  function g5(e, t) {
    return (0, N.default)({
      type: "TemplateLiteral",
      quasis: e,
      expressions: t
    });
  }
  s(g5, "templateLiteral");
  function b5(e = null, t = !1) {
    return (0, N.default)({
      type: "YieldExpression",
      argument: e,
      delegate: t
    });
  }
  s(b5, "yieldExpression");
  function E5(e) {
    return (0, N.default)({
      type: "AwaitExpression",
      argument: e
    });
  }
  s(E5, "awaitExpression");
  function v5() {
    return {
      type: "Import"
    };
  }
  s(v5, "_import");
  function T5(e) {
    return (0, N.default)({
      type: "BigIntLiteral",
      value: e
    });
  }
  s(T5, "bigIntLiteral");
  function x5(e) {
    return (0, N.default)({
      type: "ExportNamespaceSpecifier",
      exported: e
    });
  }
  s(x5, "exportNamespaceSpecifier");
  function S5(e, t, r = !1, n) {
    return (0, N.default)({
      type: "OptionalMemberExpression",
      object: e,
      property: t,
      computed: r,
      optional: n
    });
  }
  s(S5, "optionalMemberExpression");
  function P5(e, t, r) {
    return (0, N.default)({
      type: "OptionalCallExpression",
      callee: e,
      arguments: t,
      optional: r
    });
  }
  s(P5, "optionalCallExpression");
  function A5(e, t = null, r = null, n = null, i = !1, a = !1) {
    return (0, N.default)({
      type: "ClassProperty",
      key: e,
      value: t,
      typeAnnotation: r,
      decorators: n,
      computed: i,
      static: a
    });
  }
  s(A5, "classProperty");
  function C5(e, t = null, r = null, n = null, i = !1, a = !1) {
    return (0, N.default)({
      type: "ClassAccessorProperty",
      key: e,
      value: t,
      typeAnnotation: r,
      decorators: n,
      computed: i,
      static: a
    });
  }
  s(C5, "classAccessorProperty");
  function w5(e, t = null, r = null, n = !1) {
    return (0, N.default)({
      type: "ClassPrivateProperty",
      key: e,
      value: t,
      decorators: r,
      static: n
    });
  }
  s(w5, "classPrivateProperty");
  function D5(e = "method", t, r, n, i = !1) {
    return (0, N.default)({
      type: "ClassPrivateMethod",
      kind: e,
      key: t,
      params: r,
      body: n,
      static: i
    });
  }
  s(D5, "classPrivateMethod");
  function I5(e) {
    return (0, N.default)({
      type: "PrivateName",
      id: e
    });
  }
  s(I5, "privateName");
  function _5(e) {
    return (0, N.default)({
      type: "StaticBlock",
      body: e
    });
  }
  s(_5, "staticBlock");
  function O5() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  s(O5, "anyTypeAnnotation");
  function N5(e) {
    return (0, N.default)({
      type: "ArrayTypeAnnotation",
      elementType: e
    });
  }
  s(N5, "arrayTypeAnnotation");
  function B5() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  s(B5, "booleanTypeAnnotation");
  function k5(e) {
    return (0, N.default)({
      type: "BooleanLiteralTypeAnnotation",
      value: e
    });
  }
  s(k5, "booleanLiteralTypeAnnotation");
  function F5() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  s(F5, "nullLiteralTypeAnnotation");
  function j5(e, t = null) {
    return (0, N.default)({
      type: "ClassImplements",
      id: e,
      typeParameters: t
    });
  }
  s(j5, "classImplements");
  function L5(e, t = null, r = null, n) {
    return (0, N.default)({
      type: "DeclareClass",
      id: e,
      typeParameters: t,
      extends: r,
      body: n
    });
  }
  s(L5, "declareClass");
  function M5(e) {
    return (0, N.default)({
      type: "DeclareFunction",
      id: e
    });
  }
  s(M5, "declareFunction");
  function R5(e, t = null, r = null, n) {
    return (0, N.default)({
      type: "DeclareInterface",
      id: e,
      typeParameters: t,
      extends: r,
      body: n
    });
  }
  s(R5, "declareInterface");
  function q5(e, t, r = null) {
    return (0, N.default)({
      type: "DeclareModule",
      id: e,
      body: t,
      kind: r
    });
  }
  s(q5, "declareModule");
  function U5(e) {
    return (0, N.default)({
      type: "DeclareModuleExports",
      typeAnnotation: e
    });
  }
  s(U5, "declareModuleExports");
  function V5(e, t = null, r) {
    return (0, N.default)({
      type: "DeclareTypeAlias",
      id: e,
      typeParameters: t,
      right: r
    });
  }
  s(V5, "declareTypeAlias");
  function $5(e, t = null, r = null) {
    return (0, N.default)({
      type: "DeclareOpaqueType",
      id: e,
      typeParameters: t,
      supertype: r
    });
  }
  s($5, "declareOpaqueType");
  function W5(e) {
    return (0, N.default)({
      type: "DeclareVariable",
      id: e
    });
  }
  s(W5, "declareVariable");
  function K5(e = null, t = null, r = null) {
    return (0, N.default)({
      type: "DeclareExportDeclaration",
      declaration: e,
      specifiers: t,
      source: r
    });
  }
  s(K5, "declareExportDeclaration");
  function G5(e) {
    return (0, N.default)({
      type: "DeclareExportAllDeclaration",
      source: e
    });
  }
  s(G5, "declareExportAllDeclaration");
  function H5(e) {
    return (0, N.default)({
      type: "DeclaredPredicate",
      value: e
    });
  }
  s(H5, "declaredPredicate");
  function Y5() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  s(Y5, "existsTypeAnnotation");
  function z5(e = null, t, r = null, n) {
    return (0, N.default)({
      type: "FunctionTypeAnnotation",
      typeParameters: e,
      params: t,
      rest: r,
      returnType: n
    });
  }
  s(z5, "functionTypeAnnotation");
  function J5(e = null, t) {
    return (0, N.default)({
      type: "FunctionTypeParam",
      name: e,
      typeAnnotation: t
    });
  }
  s(J5, "functionTypeParam");
  function X5(e, t = null) {
    return (0, N.default)({
      type: "GenericTypeAnnotation",
      id: e,
      typeParameters: t
    });
  }
  s(X5, "genericTypeAnnotation");
  function Q5() {
    return {
      type: "InferredPredicate"
    };
  }
  s(Q5, "inferredPredicate");
  function Z5(e, t = null) {
    return (0, N.default)({
      type: "InterfaceExtends",
      id: e,
      typeParameters: t
    });
  }
  s(Z5, "interfaceExtends");
  function ej(e, t = null, r = null, n) {
    return (0, N.default)({
      type: "InterfaceDeclaration",
      id: e,
      typeParameters: t,
      extends: r,
      body: n
    });
  }
  s(ej, "interfaceDeclaration");
  function tj(e = null, t) {
    return (0, N.default)({
      type: "InterfaceTypeAnnotation",
      extends: e,
      body: t
    });
  }
  s(tj, "interfaceTypeAnnotation");
  function rj(e) {
    return (0, N.default)({
      type: "IntersectionTypeAnnotation",
      types: e
    });
  }
  s(rj, "intersectionTypeAnnotation");
  function nj() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  s(nj, "mixedTypeAnnotation");
  function sj() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  s(sj, "emptyTypeAnnotation");
  function ij(e) {
    return (0, N.default)({
      type: "NullableTypeAnnotation",
      typeAnnotation: e
    });
  }
  s(ij, "nullableTypeAnnotation");
  function aj(e) {
    return (0, N.default)({
      type: "NumberLiteralTypeAnnotation",
      value: e
    });
  }
  s(aj, "numberLiteralTypeAnnotation");
  function oj() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  s(oj, "numberTypeAnnotation");
  function lj(e, t = [], r = [], n = [], i = !1) {
    return (0, N.default)({
      type: "ObjectTypeAnnotation",
      properties: e,
      indexers: t,
      callProperties: r,
      internalSlots: n,
      exact: i
    });
  }
  s(lj, "objectTypeAnnotation");
  function uj(e, t, r, n, i) {
    return (0, N.default)({
      type: "ObjectTypeInternalSlot",
      id: e,
      value: t,
      optional: r,
      static: n,
      method: i
    });
  }
  s(uj, "objectTypeInternalSlot");
  function cj(e) {
    return (0, N.default)({
      type: "ObjectTypeCallProperty",
      value: e,
      static: null
    });
  }
  s(cj, "objectTypeCallProperty");
  function fj(e = null, t, r, n = null) {
    return (0, N.default)({
      type: "ObjectTypeIndexer",
      id: e,
      key: t,
      value: r,
      variance: n,
      static: null
    });
  }
  s(fj, "objectTypeIndexer");
  function pj(e, t, r = null) {
    return (0, N.default)({
      type: "ObjectTypeProperty",
      key: e,
      value: t,
      variance: r,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    });
  }
  s(pj, "objectTypeProperty");
  function dj(e) {
    return (0, N.default)({
      type: "ObjectTypeSpreadProperty",
      argument: e
    });
  }
  s(dj, "objectTypeSpreadProperty");
  function hj(e, t = null, r = null, n) {
    return (0, N.default)({
      type: "OpaqueType",
      id: e,
      typeParameters: t,
      supertype: r,
      impltype: n
    });
  }
  s(hj, "opaqueType");
  function mj(e, t) {
    return (0, N.default)({
      type: "QualifiedTypeIdentifier",
      id: e,
      qualification: t
    });
  }
  s(mj, "qualifiedTypeIdentifier");
  function yj(e) {
    return (0, N.default)({
      type: "StringLiteralTypeAnnotation",
      value: e
    });
  }
  s(yj, "stringLiteralTypeAnnotation");
  function gj() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  s(gj, "stringTypeAnnotation");
  function bj() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  s(bj, "symbolTypeAnnotation");
  function Ej() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  s(Ej, "thisTypeAnnotation");
  function vj(e) {
    return (0, N.default)({
      type: "TupleTypeAnnotation",
      types: e
    });
  }
  s(vj, "tupleTypeAnnotation");
  function Tj(e) {
    return (0, N.default)({
      type: "TypeofTypeAnnotation",
      argument: e
    });
  }
  s(Tj, "typeofTypeAnnotation");
  function xj(e, t = null, r) {
    return (0, N.default)({
      type: "TypeAlias",
      id: e,
      typeParameters: t,
      right: r
    });
  }
  s(xj, "typeAlias");
  function Sj(e) {
    return (0, N.default)({
      type: "TypeAnnotation",
      typeAnnotation: e
    });
  }
  s(Sj, "typeAnnotation");
  function Pj(e, t) {
    return (0, N.default)({
      type: "TypeCastExpression",
      expression: e,
      typeAnnotation: t
    });
  }
  s(Pj, "typeCastExpression");
  function Aj(e = null, t = null, r = null) {
    return (0, N.default)({
      type: "TypeParameter",
      bound: e,
      default: t,
      variance: r,
      name: null
    });
  }
  s(Aj, "typeParameter");
  function Cj(e) {
    return (0, N.default)({
      type: "TypeParameterDeclaration",
      params: e
    });
  }
  s(Cj, "typeParameterDeclaration");
  function wj(e) {
    return (0, N.default)({
      type: "TypeParameterInstantiation",
      params: e
    });
  }
  s(wj, "typeParameterInstantiation");
  function Dj(e) {
    return (0, N.default)({
      type: "UnionTypeAnnotation",
      types: e
    });
  }
  s(Dj, "unionTypeAnnotation");
  function Ij(e) {
    return (0, N.default)({
      type: "Variance",
      kind: e
    });
  }
  s(Ij, "variance");
  function _j() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  s(_j, "voidTypeAnnotation");
  function Oj(e, t) {
    return (0, N.default)({
      type: "EnumDeclaration",
      id: e,
      body: t
    });
  }
  s(Oj, "enumDeclaration");
  function Nj(e) {
    return (0, N.default)({
      type: "EnumBooleanBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  s(Nj, "enumBooleanBody");
  function Bj(e) {
    return (0, N.default)({
      type: "EnumNumberBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  s(Bj, "enumNumberBody");
  function kj(e) {
    return (0, N.default)({
      type: "EnumStringBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  s(kj, "enumStringBody");
  function Fj(e) {
    return (0, N.default)({
      type: "EnumSymbolBody",
      members: e,
      hasUnknownMembers: null
    });
  }
  s(Fj, "enumSymbolBody");
  function jj(e) {
    return (0, N.default)({
      type: "EnumBooleanMember",
      id: e,
      init: null
    });
  }
  s(jj, "enumBooleanMember");
  function Lj(e, t) {
    return (0, N.default)({
      type: "EnumNumberMember",
      id: e,
      init: t
    });
  }
  s(Lj, "enumNumberMember");
  function Mj(e, t) {
    return (0, N.default)({
      type: "EnumStringMember",
      id: e,
      init: t
    });
  }
  s(Mj, "enumStringMember");
  function Rj(e) {
    return (0, N.default)({
      type: "EnumDefaultedMember",
      id: e
    });
  }
  s(Rj, "enumDefaultedMember");
  function qj(e, t) {
    return (0, N.default)({
      type: "IndexedAccessType",
      objectType: e,
      indexType: t
    });
  }
  s(qj, "indexedAccessType");
  function Uj(e, t) {
    return (0, N.default)({
      type: "OptionalIndexedAccessType",
      objectType: e,
      indexType: t,
      optional: null
    });
  }
  s(Uj, "optionalIndexedAccessType");
  function Vj(e, t = null) {
    return (0, N.default)({
      type: "JSXAttribute",
      name: e,
      value: t
    });
  }
  s(Vj, "jsxAttribute");
  function $j(e) {
    return (0, N.default)({
      type: "JSXClosingElement",
      name: e
    });
  }
  s($j, "jsxClosingElement");
  function Wj(e, t = null, r, n = null) {
    return (0, N.default)({
      type: "JSXElement",
      openingElement: e,
      closingElement: t,
      children: r,
      selfClosing: n
    });
  }
  s(Wj, "jsxElement");
  function Kj() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  s(Kj, "jsxEmptyExpression");
  function Gj(e) {
    return (0, N.default)({
      type: "JSXExpressionContainer",
      expression: e
    });
  }
  s(Gj, "jsxExpressionContainer");
  function Hj(e) {
    return (0, N.default)({
      type: "JSXSpreadChild",
      expression: e
    });
  }
  s(Hj, "jsxSpreadChild");
  function Yj(e) {
    return (0, N.default)({
      type: "JSXIdentifier",
      name: e
    });
  }
  s(Yj, "jsxIdentifier");
  function zj(e, t) {
    return (0, N.default)({
      type: "JSXMemberExpression",
      object: e,
      property: t
    });
  }
  s(zj, "jsxMemberExpression");
  function Jj(e, t) {
    return (0, N.default)({
      type: "JSXNamespacedName",
      namespace: e,
      name: t
    });
  }
  s(Jj, "jsxNamespacedName");
  function Xj(e, t, r = !1) {
    return (0, N.default)({
      type: "JSXOpeningElement",
      name: e,
      attributes: t,
      selfClosing: r
    });
  }
  s(Xj, "jsxOpeningElement");
  function Qj(e) {
    return (0, N.default)({
      type: "JSXSpreadAttribute",
      argument: e
    });
  }
  s(Qj, "jsxSpreadAttribute");
  function Zj(e) {
    return (0, N.default)({
      type: "JSXText",
      value: e
    });
  }
  s(Zj, "jsxText");
  function eL(e, t, r) {
    return (0, N.default)({
      type: "JSXFragment",
      openingFragment: e,
      closingFragment: t,
      children: r
    });
  }
  s(eL, "jsxFragment");
  function tL() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  s(tL, "jsxOpeningFragment");
  function rL() {
    return {
      type: "JSXClosingFragment"
    };
  }
  s(rL, "jsxClosingFragment");
  function nL() {
    return {
      type: "Noop"
    };
  }
  s(nL, "noop");
  function sL(e, t) {
    return (0, N.default)({
      type: "Placeholder",
      expectedNode: e,
      name: t
    });
  }
  s(sL, "placeholder");
  function iL(e) {
    return (0, N.default)({
      type: "V8IntrinsicIdentifier",
      name: e
    });
  }
  s(iL, "v8IntrinsicIdentifier");
  function aL() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  s(aL, "argumentPlaceholder");
  function oL(e, t) {
    return (0, N.default)({
      type: "BindExpression",
      object: e,
      callee: t
    });
  }
  s(oL, "bindExpression");
  function lL(e, t) {
    return (0, N.default)({
      type: "ImportAttribute",
      key: e,
      value: t
    });
  }
  s(lL, "importAttribute");
  function uL(e) {
    return (0, N.default)({
      type: "Decorator",
      expression: e
    });
  }
  s(uL, "decorator");
  function cL(e, t = !1) {
    return (0, N.default)({
      type: "DoExpression",
      body: e,
      async: t
    });
  }
  s(cL, "doExpression");
  function fL(e) {
    return (0, N.default)({
      type: "ExportDefaultSpecifier",
      exported: e
    });
  }
  s(fL, "exportDefaultSpecifier");
  function pL(e) {
    return (0, N.default)({
      type: "RecordExpression",
      properties: e
    });
  }
  s(pL, "recordExpression");
  function dL(e = []) {
    return (0, N.default)({
      type: "TupleExpression",
      elements: e
    });
  }
  s(dL, "tupleExpression");
  function hL(e) {
    return (0, N.default)({
      type: "DecimalLiteral",
      value: e
    });
  }
  s(hL, "decimalLiteral");
  function mL(e) {
    return (0, N.default)({
      type: "ModuleExpression",
      body: e
    });
  }
  s(mL, "moduleExpression");
  function yL() {
    return {
      type: "TopicReference"
    };
  }
  s(yL, "topicReference");
  function gL(e) {
    return (0, N.default)({
      type: "PipelineTopicExpression",
      expression: e
    });
  }
  s(gL, "pipelineTopicExpression");
  function bL(e) {
    return (0, N.default)({
      type: "PipelineBareFunction",
      callee: e
    });
  }
  s(bL, "pipelineBareFunction");
  function EL() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  s(EL, "pipelinePrimaryTopicReference");
  function vL(e) {
    return (0, N.default)({
      type: "TSParameterProperty",
      parameter: e
    });
  }
  s(vL, "tsParameterProperty");
  function TL(e = null, t = null, r, n = null) {
    return (0, N.default)({
      type: "TSDeclareFunction",
      id: e,
      typeParameters: t,
      params: r,
      returnType: n
    });
  }
  s(TL, "tsDeclareFunction");
  function xL(e = null, t, r = null, n, i = null) {
    return (0, N.default)({
      type: "TSDeclareMethod",
      decorators: e,
      key: t,
      typeParameters: r,
      params: n,
      returnType: i
    });
  }
  s(xL, "tsDeclareMethod");
  function SL(e, t) {
    return (0, N.default)({
      type: "TSQualifiedName",
      left: e,
      right: t
    });
  }
  s(SL, "tsQualifiedName");
  function PL(e = null, t, r = null) {
    return (0, N.default)({
      type: "TSCallSignatureDeclaration",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    });
  }
  s(PL, "tsCallSignatureDeclaration");
  function AL(e = null, t, r = null) {
    return (0, N.default)({
      type: "TSConstructSignatureDeclaration",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    });
  }
  s(AL, "tsConstructSignatureDeclaration");
  function CL(e, t = null) {
    return (0, N.default)({
      type: "TSPropertySignature",
      key: e,
      typeAnnotation: t,
      kind: null
    });
  }
  s(CL, "tsPropertySignature");
  function wL(e, t = null, r, n = null) {
    return (0, N.default)({
      type: "TSMethodSignature",
      key: e,
      typeParameters: t,
      parameters: r,
      typeAnnotation: n,
      kind: null
    });
  }
  s(wL, "tsMethodSignature");
  function DL(e, t = null) {
    return (0, N.default)({
      type: "TSIndexSignature",
      parameters: e,
      typeAnnotation: t
    });
  }
  s(DL, "tsIndexSignature");
  function IL() {
    return {
      type: "TSAnyKeyword"
    };
  }
  s(IL, "tsAnyKeyword");
  function _L() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  s(_L, "tsBooleanKeyword");
  function OL() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  s(OL, "tsBigIntKeyword");
  function NL() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  s(NL, "tsIntrinsicKeyword");
  function BL() {
    return {
      type: "TSNeverKeyword"
    };
  }
  s(BL, "tsNeverKeyword");
  function kL() {
    return {
      type: "TSNullKeyword"
    };
  }
  s(kL, "tsNullKeyword");
  function FL() {
    return {
      type: "TSNumberKeyword"
    };
  }
  s(FL, "tsNumberKeyword");
  function jL() {
    return {
      type: "TSObjectKeyword"
    };
  }
  s(jL, "tsObjectKeyword");
  function LL() {
    return {
      type: "TSStringKeyword"
    };
  }
  s(LL, "tsStringKeyword");
  function ML() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  s(ML, "tsSymbolKeyword");
  function RL() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  s(RL, "tsUndefinedKeyword");
  function qL() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  s(qL, "tsUnknownKeyword");
  function UL() {
    return {
      type: "TSVoidKeyword"
    };
  }
  s(UL, "tsVoidKeyword");
  function VL() {
    return {
      type: "TSThisType"
    };
  }
  s(VL, "tsThisType");
  function $L(e = null, t, r = null) {
    return (0, N.default)({
      type: "TSFunctionType",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    });
  }
  s($L, "tsFunctionType");
  function WL(e = null, t, r = null) {
    return (0, N.default)({
      type: "TSConstructorType",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    });
  }
  s(WL, "tsConstructorType");
  function KL(e, t = null) {
    return (0, N.default)({
      type: "TSTypeReference",
      typeName: e,
      typeParameters: t
    });
  }
  s(KL, "tsTypeReference");
  function GL(e, t = null, r = null) {
    return (0, N.default)({
      type: "TSTypePredicate",
      parameterName: e,
      typeAnnotation: t,
      asserts: r
    });
  }
  s(GL, "tsTypePredicate");
  function HL(e, t = null) {
    return (0, N.default)({
      type: "TSTypeQuery",
      exprName: e,
      typeParameters: t
    });
  }
  s(HL, "tsTypeQuery");
  function YL(e) {
    return (0, N.default)({
      type: "TSTypeLiteral",
      members: e
    });
  }
  s(YL, "tsTypeLiteral");
  function zL(e) {
    return (0, N.default)({
      type: "TSArrayType",
      elementType: e
    });
  }
  s(zL, "tsArrayType");
  function JL(e) {
    return (0, N.default)({
      type: "TSTupleType",
      elementTypes: e
    });
  }
  s(JL, "tsTupleType");
  function XL(e) {
    return (0, N.default)({
      type: "TSOptionalType",
      typeAnnotation: e
    });
  }
  s(XL, "tsOptionalType");
  function QL(e) {
    return (0, N.default)({
      type: "TSRestType",
      typeAnnotation: e
    });
  }
  s(QL, "tsRestType");
  function ZL(e, t, r = !1) {
    return (0, N.default)({
      type: "TSNamedTupleMember",
      label: e,
      elementType: t,
      optional: r
    });
  }
  s(ZL, "tsNamedTupleMember");
  function eM(e) {
    return (0, N.default)({
      type: "TSUnionType",
      types: e
    });
  }
  s(eM, "tsUnionType");
  function tM(e) {
    return (0, N.default)({
      type: "TSIntersectionType",
      types: e
    });
  }
  s(tM, "tsIntersectionType");
  function rM(e, t, r, n) {
    return (0, N.default)({
      type: "TSConditionalType",
      checkType: e,
      extendsType: t,
      trueType: r,
      falseType: n
    });
  }
  s(rM, "tsConditionalType");
  function nM(e) {
    return (0, N.default)({
      type: "TSInferType",
      typeParameter: e
    });
  }
  s(nM, "tsInferType");
  function sM(e) {
    return (0, N.default)({
      type: "TSParenthesizedType",
      typeAnnotation: e
    });
  }
  s(sM, "tsParenthesizedType");
  function iM(e) {
    return (0, N.default)({
      type: "TSTypeOperator",
      typeAnnotation: e,
      operator: null
    });
  }
  s(iM, "tsTypeOperator");
  function aM(e, t) {
    return (0, N.default)({
      type: "TSIndexedAccessType",
      objectType: e,
      indexType: t
    });
  }
  s(aM, "tsIndexedAccessType");
  function oM(e, t = null, r = null) {
    return (0, N.default)({
      type: "TSMappedType",
      typeParameter: e,
      typeAnnotation: t,
      nameType: r
    });
  }
  s(oM, "tsMappedType");
  function lM(e) {
    return (0, N.default)({
      type: "TSLiteralType",
      literal: e
    });
  }
  s(lM, "tsLiteralType");
  function uM(e, t = null) {
    return (0, N.default)({
      type: "TSExpressionWithTypeArguments",
      expression: e,
      typeParameters: t
    });
  }
  s(uM, "tsExpressionWithTypeArguments");
  function cM(e, t = null, r = null, n) {
    return (0, N.default)({
      type: "TSInterfaceDeclaration",
      id: e,
      typeParameters: t,
      extends: r,
      body: n
    });
  }
  s(cM, "tsInterfaceDeclaration");
  function fM(e) {
    return (0, N.default)({
      type: "TSInterfaceBody",
      body: e
    });
  }
  s(fM, "tsInterfaceBody");
  function pM(e, t = null, r) {
    return (0, N.default)({
      type: "TSTypeAliasDeclaration",
      id: e,
      typeParameters: t,
      typeAnnotation: r
    });
  }
  s(pM, "tsTypeAliasDeclaration");
  function dM(e, t = null) {
    return (0, N.default)({
      type: "TSInstantiationExpression",
      expression: e,
      typeParameters: t
    });
  }
  s(dM, "tsInstantiationExpression");
  function hM(e, t) {
    return (0, N.default)({
      type: "TSAsExpression",
      expression: e,
      typeAnnotation: t
    });
  }
  s(hM, "tsAsExpression");
  function mM(e, t) {
    return (0, N.default)({
      type: "TSSatisfiesExpression",
      expression: e,
      typeAnnotation: t
    });
  }
  s(mM, "tsSatisfiesExpression");
  function yM(e, t) {
    return (0, N.default)({
      type: "TSTypeAssertion",
      typeAnnotation: e,
      expression: t
    });
  }
  s(yM, "tsTypeAssertion");
  function gM(e, t) {
    return (0, N.default)({
      type: "TSEnumDeclaration",
      id: e,
      members: t
    });
  }
  s(gM, "tsEnumDeclaration");
  function bM(e, t = null) {
    return (0, N.default)({
      type: "TSEnumMember",
      id: e,
      initializer: t
    });
  }
  s(bM, "tsEnumMember");
  function EM(e, t) {
    return (0, N.default)({
      type: "TSModuleDeclaration",
      id: e,
      body: t
    });
  }
  s(EM, "tsModuleDeclaration");
  function vM(e) {
    return (0, N.default)({
      type: "TSModuleBlock",
      body: e
    });
  }
  s(vM, "tsModuleBlock");
  function TM(e, t = null, r = null) {
    return (0, N.default)({
      type: "TSImportType",
      argument: e,
      qualifier: t,
      typeParameters: r
    });
  }
  s(TM, "tsImportType");
  function xM(e, t) {
    return (0, N.default)({
      type: "TSImportEqualsDeclaration",
      id: e,
      moduleReference: t,
      isExport: null
    });
  }
  s(xM, "tsImportEqualsDeclaration");
  function SM(e) {
    return (0, N.default)({
      type: "TSExternalModuleReference",
      expression: e
    });
  }
  s(SM, "tsExternalModuleReference");
  function PM(e) {
    return (0, N.default)({
      type: "TSNonNullExpression",
      expression: e
    });
  }
  s(PM, "tsNonNullExpression");
  function AM(e) {
    return (0, N.default)({
      type: "TSExportAssignment",
      expression: e
    });
  }
  s(AM, "tsExportAssignment");
  function CM(e) {
    return (0, N.default)({
      type: "TSNamespaceExportDeclaration",
      id: e
    });
  }
  s(CM, "tsNamespaceExportDeclaration");
  function wM(e) {
    return (0, N.default)({
      type: "TSTypeAnnotation",
      typeAnnotation: e
    });
  }
  s(wM, "tsTypeAnnotation");
  function DM(e) {
    return (0, N.default)({
      type: "TSTypeParameterInstantiation",
      params: e
    });
  }
  s(DM, "tsTypeParameterInstantiation");
  function IM(e) {
    return (0, N.default)({
      type: "TSTypeParameterDeclaration",
      params: e
    });
  }
  s(IM, "tsTypeParameterDeclaration");
  function _M(e = null, t = null, r) {
    return (0, N.default)({
      type: "TSTypeParameter",
      constraint: e,
      default: t,
      name: r
    });
  }
  s(_M, "tsTypeParameter");
  function OM(e) {
    return (0, Sl.default)("NumberLiteral", "NumericLiteral", "The node type "), BE(e);
  }
  s(OM, "NumberLiteral");
  function NM(e, t = "") {
    return (0, Sl.default)("RegexLiteral", "RegExpLiteral", "The node type "), kE(e, t);
  }
  s(NM, "RegexLiteral");
  function BM(e) {
    return (0, Sl.default)("RestProperty", "RestElement", "The node type "), FE(e);
  }
  s(BM, "RestProperty");
  function kM(e) {
    return (0, Sl.default)("SpreadProperty", "SpreadElement", "The node type "), jE(e);
  }
  s(kM, "SpreadProperty");
});

// ../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var LE = T((Dp) => {
  "use strict";
  Object.defineProperty(Dp, "__esModule", {
    value: !0
  });
  Dp.default = LM;
  var FM = sr(), jM = Pe();
  function LM(e, t) {
    let r = e.value.split(/\r\n|\n|\r/), n = 0;
    for (let a = 0; a < r.length; a++)
      /[^ \t]/.exec(r[a]) && (n = a);
    let i = "";
    for (let a = 0; a < r.length; a++) {
      let o = r[a], l = a === 0, u = a === r.length - 1, c = a === n, f = o.replace(/\t/g, " ");
      l || (f = f.replace(/^ +/, "")), u || (f = f.replace(/ +$/, "")), f && (c || (f += " "), i += f);
    }
    i && t.push((0, jM.inherits)((0, FM.stringLiteral)(i), e));
  }
  s(LM, "cleanJSXElementLiteralChild");
});

// ../node_modules/@babel/types/lib/builders/react/buildChildren.js
var ME = T((_p) => {
  "use strict";
  Object.defineProperty(_p, "__esModule", {
    value: !0
  });
  _p.default = RM;
  var Ip = Tt(), MM = LE();
  function RM(e) {
    let t = [];
    for (let r = 0; r < e.children.length; r++) {
      let n = e.children[r];
      if ((0, Ip.isJSXText)(n)) {
        (0, MM.default)(n, t);
        continue;
      }
      (0, Ip.isJSXExpressionContainer)(n) && (n = n.expression), !(0, Ip.isJSXEmptyExpression)(n) && t.push(n);
    }
    return t;
  }
  s(RM, "buildChildren");
});

// ../node_modules/@babel/types/lib/validators/isNode.js
var Np = T((Op) => {
  "use strict";
  Object.defineProperty(Op, "__esModule", {
    value: !0
  });
  Op.default = UM;
  var qM = Cr();
  function UM(e) {
    return !!(e && qM.VISITOR_KEYS[e.type]);
  }
  s(UM, "isNode");
});

// ../node_modules/@babel/types/lib/asserts/assertNode.js
var RE = T((Bp) => {
  "use strict";
  Object.defineProperty(Bp, "__esModule", {
    value: !0
  });
  Bp.default = $M;
  var VM = Np();
  function $M(e) {
    if (!(0, VM.default)(e)) {
      var t;
      let r = (t = e?.type) != null ? t : JSON.stringify(e);
      throw new TypeError(`Not a valid node of type "${r}"`);
    }
  }
  s($M, "assertNode");
});

// ../node_modules/@babel/types/lib/asserts/generated/index.js
var qE = T((S) => {
  "use strict";
  Object.defineProperty(S, "__esModule", {
    value: !0
  });
  S.assertAccessor = iV;
  S.assertAnyTypeAnnotation = AR;
  S.assertArgumentPlaceholder = eq;
  S.assertArrayExpression = KM;
  S.assertArrayPattern = $9;
  S.assertArrayTypeAnnotation = CR;
  S.assertArrowFunctionExpression = W9;
  S.assertAssignmentExpression = GM;
  S.assertAssignmentPattern = V9;
  S.assertAwaitExpression = dR;
  S.assertBigIntLiteral = mR;
  S.assertBinary = wU;
  S.assertBinaryExpression = HM;
  S.assertBindExpression = tq;
  S.assertBlock = _U;
  S.assertBlockParent = IU;
  S.assertBlockStatement = XM;
  S.assertBooleanLiteral = b9;
  S.assertBooleanLiteralTypeAnnotation = DR;
  S.assertBooleanTypeAnnotation = wR;
  S.assertBreakStatement = QM;
  S.assertCallExpression = ZM;
  S.assertCatchClause = e9;
  S.assertClass = tV;
  S.assertClassAccessorProperty = vR;
  S.assertClassBody = K9;
  S.assertClassDeclaration = H9;
  S.assertClassExpression = G9;
  S.assertClassImplements = _R;
  S.assertClassMethod = iR;
  S.assertClassPrivateMethod = xR;
  S.assertClassPrivateProperty = TR;
  S.assertClassProperty = ER;
  S.assertCompletionStatement = BU;
  S.assertConditional = kU;
  S.assertConditionalExpression = t9;
  S.assertContinueStatement = r9;
  S.assertDebuggerStatement = n9;
  S.assertDecimalLiteral = lq;
  S.assertDeclaration = $U;
  S.assertDeclareClass = OR;
  S.assertDeclareExportAllDeclaration = qR;
  S.assertDeclareExportDeclaration = RR;
  S.assertDeclareFunction = NR;
  S.assertDeclareInterface = BR;
  S.assertDeclareModule = kR;
  S.assertDeclareModuleExports = FR;
  S.assertDeclareOpaqueType = LR;
  S.assertDeclareTypeAlias = jR;
  S.assertDeclareVariable = MR;
  S.assertDeclaredPredicate = UR;
  S.assertDecorator = nq;
  S.assertDirective = zM;
  S.assertDirectiveLiteral = JM;
  S.assertDoExpression = sq;
  S.assertDoWhileStatement = s9;
  S.assertEmptyStatement = i9;
  S.assertEmptyTypeAnnotation = QR;
  S.assertEnumBody = pV;
  S.assertEnumBooleanBody = C7;
  S.assertEnumBooleanMember = _7;
  S.assertEnumDeclaration = A7;
  S.assertEnumDefaultedMember = B7;
  S.assertEnumMember = dV;
  S.assertEnumNumberBody = w7;
  S.assertEnumNumberMember = O7;
  S.assertEnumStringBody = D7;
  S.assertEnumStringMember = N7;
  S.assertEnumSymbolBody = I7;
  S.assertExistsTypeAnnotation = VR;
  S.assertExportAllDeclaration = Y9;
  S.assertExportDeclaration = nV;
  S.assertExportDefaultDeclaration = z9;
  S.assertExportDefaultSpecifier = iq;
  S.assertExportNamedDeclaration = J9;
  S.assertExportNamespaceSpecifier = yR;
  S.assertExportSpecifier = X9;
  S.assertExpression = CU;
  S.assertExpressionStatement = a9;
  S.assertExpressionWrapper = LU;
  S.assertFile = o9;
  S.assertFlow = oV;
  S.assertFlowBaseAnnotation = uV;
  S.assertFlowDeclaration = cV;
  S.assertFlowPredicate = fV;
  S.assertFlowType = lV;
  S.assertFor = MU;
  S.assertForInStatement = l9;
  S.assertForOfStatement = Q9;
  S.assertForStatement = u9;
  S.assertForXStatement = RU;
  S.assertFunction = qU;
  S.assertFunctionDeclaration = c9;
  S.assertFunctionExpression = f9;
  S.assertFunctionParent = UU;
  S.assertFunctionTypeAnnotation = $R;
  S.assertFunctionTypeParam = WR;
  S.assertGenericTypeAnnotation = KR;
  S.assertIdentifier = p9;
  S.assertIfStatement = d9;
  S.assertImmutable = YU;
  S.assertImport = hR;
  S.assertImportAttribute = rq;
  S.assertImportDeclaration = Z9;
  S.assertImportDefaultSpecifier = eR;
  S.assertImportExpression = nR;
  S.assertImportNamespaceSpecifier = tR;
  S.assertImportOrExportDeclaration = rV;
  S.assertImportSpecifier = rR;
  S.assertIndexedAccessType = k7;
  S.assertInferredPredicate = GR;
  S.assertInterfaceDeclaration = YR;
  S.assertInterfaceExtends = HR;
  S.assertInterfaceTypeAnnotation = zR;
  S.assertInterpreterDirective = YM;
  S.assertIntersectionTypeAnnotation = JR;
  S.assertJSX = hV;
  S.assertJSXAttribute = j7;
  S.assertJSXClosingElement = L7;
  S.assertJSXClosingFragment = J7;
  S.assertJSXElement = M7;
  S.assertJSXEmptyExpression = R7;
  S.assertJSXExpressionContainer = q7;
  S.assertJSXFragment = Y7;
  S.assertJSXIdentifier = V7;
  S.assertJSXMemberExpression = $7;
  S.assertJSXNamespacedName = W7;
  S.assertJSXOpeningElement = K7;
  S.assertJSXOpeningFragment = z7;
  S.assertJSXSpreadAttribute = G7;
  S.assertJSXSpreadChild = U7;
  S.assertJSXText = H7;
  S.assertLVal = KU;
  S.assertLabeledStatement = h9;
  S.assertLiteral = HU;
  S.assertLogicalExpression = v9;
  S.assertLoop = FU;
  S.assertMemberExpression = T9;
  S.assertMetaProperty = sR;
  S.assertMethod = JU;
  S.assertMiscellaneous = mV;
  S.assertMixedTypeAnnotation = XR;
  S.assertModuleDeclaration = PV;
  S.assertModuleExpression = uq;
  S.assertModuleSpecifier = sV;
  S.assertNewExpression = x9;
  S.assertNoop = X7;
  S.assertNullLiteral = g9;
  S.assertNullLiteralTypeAnnotation = IR;
  S.assertNullableTypeAnnotation = ZR;
  S.assertNumberLiteral = vV;
  S.assertNumberLiteralTypeAnnotation = e7;
  S.assertNumberTypeAnnotation = t7;
  S.assertNumericLiteral = y9;
  S.assertObjectExpression = P9;
  S.assertObjectMember = XU;
  S.assertObjectMethod = A9;
  S.assertObjectPattern = aR;
  S.assertObjectProperty = C9;
  S.assertObjectTypeAnnotation = r7;
  S.assertObjectTypeCallProperty = s7;
  S.assertObjectTypeIndexer = i7;
  S.assertObjectTypeInternalSlot = n7;
  S.assertObjectTypeProperty = a7;
  S.assertObjectTypeSpreadProperty = o7;
  S.assertOpaqueType = l7;
  S.assertOptionalCallExpression = bR;
  S.assertOptionalIndexedAccessType = F7;
  S.assertOptionalMemberExpression = gR;
  S.assertParenthesizedExpression = _9;
  S.assertPattern = eV;
  S.assertPatternLike = WU;
  S.assertPipelineBareFunction = pq;
  S.assertPipelinePrimaryTopicReference = dq;
  S.assertPipelineTopicExpression = fq;
  S.assertPlaceholder = Q7;
  S.assertPrivate = aV;
  S.assertPrivateName = SR;
  S.assertProgram = S9;
  S.assertProperty = QU;
  S.assertPureish = VU;
  S.assertQualifiedTypeIdentifier = u7;
  S.assertRecordExpression = aq;
  S.assertRegExpLiteral = E9;
  S.assertRegexLiteral = TV;
  S.assertRestElement = w9;
  S.assertRestProperty = xV;
  S.assertReturnStatement = D9;
  S.assertScopable = DU;
  S.assertSequenceExpression = I9;
  S.assertSpreadElement = oR;
  S.assertSpreadProperty = SV;
  S.assertStandardized = AU;
  S.assertStatement = OU;
  S.assertStaticBlock = PR;
  S.assertStringLiteral = m9;
  S.assertStringLiteralTypeAnnotation = c7;
  S.assertStringTypeAnnotation = f7;
  S.assertSuper = lR;
  S.assertSwitchCase = O9;
  S.assertSwitchStatement = N9;
  S.assertSymbolTypeAnnotation = p7;
  S.assertTSAnyKeyword = Sq;
  S.assertTSArrayType = $q;
  S.assertTSAsExpression = lU;
  S.assertTSBaseType = EV;
  S.assertTSBigIntKeyword = Aq;
  S.assertTSBooleanKeyword = Pq;
  S.assertTSCallSignatureDeclaration = bq;
  S.assertTSConditionalType = Jq;
  S.assertTSConstructSignatureDeclaration = Eq;
  S.assertTSConstructorType = Mq;
  S.assertTSDeclareFunction = mq;
  S.assertTSDeclareMethod = yq;
  S.assertTSEntityName = GU;
  S.assertTSEnumDeclaration = fU;
  S.assertTSEnumMember = pU;
  S.assertTSExportAssignment = EU;
  S.assertTSExpressionWithTypeArguments = nU;
  S.assertTSExternalModuleReference = gU;
  S.assertTSFunctionType = Lq;
  S.assertTSImportEqualsDeclaration = yU;
  S.assertTSImportType = mU;
  S.assertTSIndexSignature = xq;
  S.assertTSIndexedAccessType = eU;
  S.assertTSInferType = Xq;
  S.assertTSInstantiationExpression = oU;
  S.assertTSInterfaceBody = iU;
  S.assertTSInterfaceDeclaration = sU;
  S.assertTSIntersectionType = zq;
  S.assertTSIntrinsicKeyword = Cq;
  S.assertTSLiteralType = rU;
  S.assertTSMappedType = tU;
  S.assertTSMethodSignature = Tq;
  S.assertTSModuleBlock = hU;
  S.assertTSModuleDeclaration = dU;
  S.assertTSNamedTupleMember = Hq;
  S.assertTSNamespaceExportDeclaration = vU;
  S.assertTSNeverKeyword = wq;
  S.assertTSNonNullExpression = bU;
  S.assertTSNullKeyword = Dq;
  S.assertTSNumberKeyword = Iq;
  S.assertTSObjectKeyword = _q;
  S.assertTSOptionalType = Kq;
  S.assertTSParameterProperty = hq;
  S.assertTSParenthesizedType = Qq;
  S.assertTSPropertySignature = vq;
  S.assertTSQualifiedName = gq;
  S.assertTSRestType = Gq;
  S.assertTSSatisfiesExpression = uU;
  S.assertTSStringKeyword = Oq;
  S.assertTSSymbolKeyword = Nq;
  S.assertTSThisType = jq;
  S.assertTSTupleType = Wq;
  S.assertTSType = bV;
  S.assertTSTypeAliasDeclaration = aU;
  S.assertTSTypeAnnotation = TU;
  S.assertTSTypeAssertion = cU;
  S.assertTSTypeElement = gV;
  S.assertTSTypeLiteral = Vq;
  S.assertTSTypeOperator = Zq;
  S.assertTSTypeParameter = PU;
  S.assertTSTypeParameterDeclaration = SU;
  S.assertTSTypeParameterInstantiation = xU;
  S.assertTSTypePredicate = qq;
  S.assertTSTypeQuery = Uq;
  S.assertTSTypeReference = Rq;
  S.assertTSUndefinedKeyword = Bq;
  S.assertTSUnionType = Yq;
  S.assertTSUnknownKeyword = kq;
  S.assertTSVoidKeyword = Fq;
  S.assertTaggedTemplateExpression = uR;
  S.assertTemplateElement = cR;
  S.assertTemplateLiteral = fR;
  S.assertTerminatorless = NU;
  S.assertThisExpression = B9;
  S.assertThisTypeAnnotation = d7;
  S.assertThrowStatement = k9;
  S.assertTopicReference = cq;
  S.assertTryStatement = F9;
  S.assertTupleExpression = oq;
  S.assertTupleTypeAnnotation = h7;
  S.assertTypeAlias = y7;
  S.assertTypeAnnotation = g7;
  S.assertTypeCastExpression = b7;
  S.assertTypeParameter = E7;
  S.assertTypeParameterDeclaration = v7;
  S.assertTypeParameterInstantiation = T7;
  S.assertTypeScript = yV;
  S.assertTypeofTypeAnnotation = m7;
  S.assertUnaryExpression = j9;
  S.assertUnaryLike = ZU;
  S.assertUnionTypeAnnotation = x7;
  S.assertUpdateExpression = L9;
  S.assertUserWhitespacable = zU;
  S.assertV8IntrinsicIdentifier = Z7;
  S.assertVariableDeclaration = M9;
  S.assertVariableDeclarator = R9;
  S.assertVariance = S7;
  S.assertVoidTypeAnnotation = P7;
  S.assertWhile = jU;
  S.assertWhileStatement = q9;
  S.assertWithStatement = U9;
  S.assertYieldExpression = pR;
  var WM = yi(), ja = Aa();
  function P(e, t, r) {
    if (!(0, WM.default)(e, t, r))
      throw new Error(`Expected type "${e}" with option ${JSON.stringify(r)}, but instead got "${t.type}".`);
  }
  s(P, "assert");
  function KM(e, t) {
    P("ArrayExpression", e, t);
  }
  s(KM, "assertArrayExpression");
  function GM(e, t) {
    P("AssignmentExpression", e, t);
  }
  s(GM, "assertAssignmentExpression");
  function HM(e, t) {
    P("BinaryExpression", e, t);
  }
  s(HM, "assertBinaryExpression");
  function YM(e, t) {
    P("InterpreterDirective", e, t);
  }
  s(YM, "assertInterpreterDirective");
  function zM(e, t) {
    P("Directive", e, t);
  }
  s(zM, "assertDirective");
  function JM(e, t) {
    P("DirectiveLiteral", e, t);
  }
  s(JM, "assertDirectiveLiteral");
  function XM(e, t) {
    P("BlockStatement", e, t);
  }
  s(XM, "assertBlockStatement");
  function QM(e, t) {
    P("BreakStatement", e, t);
  }
  s(QM, "assertBreakStatement");
  function ZM(e, t) {
    P("CallExpression", e, t);
  }
  s(ZM, "assertCallExpression");
  function e9(e, t) {
    P("CatchClause", e, t);
  }
  s(e9, "assertCatchClause");
  function t9(e, t) {
    P("ConditionalExpression", e, t);
  }
  s(t9, "assertConditionalExpression");
  function r9(e, t) {
    P("ContinueStatement", e, t);
  }
  s(r9, "assertContinueStatement");
  function n9(e, t) {
    P("DebuggerStatement", e, t);
  }
  s(n9, "assertDebuggerStatement");
  function s9(e, t) {
    P("DoWhileStatement", e, t);
  }
  s(s9, "assertDoWhileStatement");
  function i9(e, t) {
    P("EmptyStatement", e, t);
  }
  s(i9, "assertEmptyStatement");
  function a9(e, t) {
    P("ExpressionStatement", e, t);
  }
  s(a9, "assertExpressionStatement");
  function o9(e, t) {
    P("File", e, t);
  }
  s(o9, "assertFile");
  function l9(e, t) {
    P("ForInStatement", e, t);
  }
  s(l9, "assertForInStatement");
  function u9(e, t) {
    P("ForStatement", e, t);
  }
  s(u9, "assertForStatement");
  function c9(e, t) {
    P("FunctionDeclaration", e, t);
  }
  s(c9, "assertFunctionDeclaration");
  function f9(e, t) {
    P("FunctionExpression", e, t);
  }
  s(f9, "assertFunctionExpression");
  function p9(e, t) {
    P("Identifier", e, t);
  }
  s(p9, "assertIdentifier");
  function d9(e, t) {
    P("IfStatement", e, t);
  }
  s(d9, "assertIfStatement");
  function h9(e, t) {
    P("LabeledStatement", e, t);
  }
  s(h9, "assertLabeledStatement");
  function m9(e, t) {
    P("StringLiteral", e, t);
  }
  s(m9, "assertStringLiteral");
  function y9(e, t) {
    P("NumericLiteral", e, t);
  }
  s(y9, "assertNumericLiteral");
  function g9(e, t) {
    P("NullLiteral", e, t);
  }
  s(g9, "assertNullLiteral");
  function b9(e, t) {
    P("BooleanLiteral", e, t);
  }
  s(b9, "assertBooleanLiteral");
  function E9(e, t) {
    P("RegExpLiteral", e, t);
  }
  s(E9, "assertRegExpLiteral");
  function v9(e, t) {
    P("LogicalExpression", e, t);
  }
  s(v9, "assertLogicalExpression");
  function T9(e, t) {
    P("MemberExpression", e, t);
  }
  s(T9, "assertMemberExpression");
  function x9(e, t) {
    P("NewExpression", e, t);
  }
  s(x9, "assertNewExpression");
  function S9(e, t) {
    P("Program", e, t);
  }
  s(S9, "assertProgram");
  function P9(e, t) {
    P("ObjectExpression", e, t);
  }
  s(P9, "assertObjectExpression");
  function A9(e, t) {
    P("ObjectMethod", e, t);
  }
  s(A9, "assertObjectMethod");
  function C9(e, t) {
    P("ObjectProperty", e, t);
  }
  s(C9, "assertObjectProperty");
  function w9(e, t) {
    P("RestElement", e, t);
  }
  s(w9, "assertRestElement");
  function D9(e, t) {
    P("ReturnStatement", e, t);
  }
  s(D9, "assertReturnStatement");
  function I9(e, t) {
    P("SequenceExpression", e, t);
  }
  s(I9, "assertSequenceExpression");
  function _9(e, t) {
    P("ParenthesizedExpression", e, t);
  }
  s(_9, "assertParenthesizedExpression");
  function O9(e, t) {
    P("SwitchCase", e, t);
  }
  s(O9, "assertSwitchCase");
  function N9(e, t) {
    P("SwitchStatement", e, t);
  }
  s(N9, "assertSwitchStatement");
  function B9(e, t) {
    P("ThisExpression", e, t);
  }
  s(B9, "assertThisExpression");
  function k9(e, t) {
    P("ThrowStatement", e, t);
  }
  s(k9, "assertThrowStatement");
  function F9(e, t) {
    P("TryStatement", e, t);
  }
  s(F9, "assertTryStatement");
  function j9(e, t) {
    P("UnaryExpression", e, t);
  }
  s(j9, "assertUnaryExpression");
  function L9(e, t) {
    P("UpdateExpression", e, t);
  }
  s(L9, "assertUpdateExpression");
  function M9(e, t) {
    P("VariableDeclaration", e, t);
  }
  s(M9, "assertVariableDeclaration");
  function R9(e, t) {
    P("VariableDeclarator", e, t);
  }
  s(R9, "assertVariableDeclarator");
  function q9(e, t) {
    P("WhileStatement", e, t);
  }
  s(q9, "assertWhileStatement");
  function U9(e, t) {
    P("WithStatement", e, t);
  }
  s(U9, "assertWithStatement");
  function V9(e, t) {
    P("AssignmentPattern", e, t);
  }
  s(V9, "assertAssignmentPattern");
  function $9(e, t) {
    P("ArrayPattern", e, t);
  }
  s($9, "assertArrayPattern");
  function W9(e, t) {
    P("ArrowFunctionExpression", e, t);
  }
  s(W9, "assertArrowFunctionExpression");
  function K9(e, t) {
    P("ClassBody", e, t);
  }
  s(K9, "assertClassBody");
  function G9(e, t) {
    P("ClassExpression", e, t);
  }
  s(G9, "assertClassExpression");
  function H9(e, t) {
    P("ClassDeclaration", e, t);
  }
  s(H9, "assertClassDeclaration");
  function Y9(e, t) {
    P("ExportAllDeclaration", e, t);
  }
  s(Y9, "assertExportAllDeclaration");
  function z9(e, t) {
    P("ExportDefaultDeclaration", e, t);
  }
  s(z9, "assertExportDefaultDeclaration");
  function J9(e, t) {
    P("ExportNamedDeclaration", e, t);
  }
  s(J9, "assertExportNamedDeclaration");
  function X9(e, t) {
    P("ExportSpecifier", e, t);
  }
  s(X9, "assertExportSpecifier");
  function Q9(e, t) {
    P("ForOfStatement", e, t);
  }
  s(Q9, "assertForOfStatement");
  function Z9(e, t) {
    P("ImportDeclaration", e, t);
  }
  s(Z9, "assertImportDeclaration");
  function eR(e, t) {
    P("ImportDefaultSpecifier", e, t);
  }
  s(eR, "assertImportDefaultSpecifier");
  function tR(e, t) {
    P("ImportNamespaceSpecifier", e, t);
  }
  s(tR, "assertImportNamespaceSpecifier");
  function rR(e, t) {
    P("ImportSpecifier", e, t);
  }
  s(rR, "assertImportSpecifier");
  function nR(e, t) {
    P("ImportExpression", e, t);
  }
  s(nR, "assertImportExpression");
  function sR(e, t) {
    P("MetaProperty", e, t);
  }
  s(sR, "assertMetaProperty");
  function iR(e, t) {
    P("ClassMethod", e, t);
  }
  s(iR, "assertClassMethod");
  function aR(e, t) {
    P("ObjectPattern", e, t);
  }
  s(aR, "assertObjectPattern");
  function oR(e, t) {
    P("SpreadElement", e, t);
  }
  s(oR, "assertSpreadElement");
  function lR(e, t) {
    P("Super", e, t);
  }
  s(lR, "assertSuper");
  function uR(e, t) {
    P("TaggedTemplateExpression", e, t);
  }
  s(uR, "assertTaggedTemplateExpression");
  function cR(e, t) {
    P("TemplateElement", e, t);
  }
  s(cR, "assertTemplateElement");
  function fR(e, t) {
    P("TemplateLiteral", e, t);
  }
  s(fR, "assertTemplateLiteral");
  function pR(e, t) {
    P("YieldExpression", e, t);
  }
  s(pR, "assertYieldExpression");
  function dR(e, t) {
    P("AwaitExpression", e, t);
  }
  s(dR, "assertAwaitExpression");
  function hR(e, t) {
    P("Import", e, t);
  }
  s(hR, "assertImport");
  function mR(e, t) {
    P("BigIntLiteral", e, t);
  }
  s(mR, "assertBigIntLiteral");
  function yR(e, t) {
    P("ExportNamespaceSpecifier", e, t);
  }
  s(yR, "assertExportNamespaceSpecifier");
  function gR(e, t) {
    P("OptionalMemberExpression", e, t);
  }
  s(gR, "assertOptionalMemberExpression");
  function bR(e, t) {
    P("OptionalCallExpression", e, t);
  }
  s(bR, "assertOptionalCallExpression");
  function ER(e, t) {
    P("ClassProperty", e, t);
  }
  s(ER, "assertClassProperty");
  function vR(e, t) {
    P("ClassAccessorProperty", e, t);
  }
  s(vR, "assertClassAccessorProperty");
  function TR(e, t) {
    P("ClassPrivateProperty", e, t);
  }
  s(TR, "assertClassPrivateProperty");
  function xR(e, t) {
    P("ClassPrivateMethod", e, t);
  }
  s(xR, "assertClassPrivateMethod");
  function SR(e, t) {
    P("PrivateName", e, t);
  }
  s(SR, "assertPrivateName");
  function PR(e, t) {
    P("StaticBlock", e, t);
  }
  s(PR, "assertStaticBlock");
  function AR(e, t) {
    P("AnyTypeAnnotation", e, t);
  }
  s(AR, "assertAnyTypeAnnotation");
  function CR(e, t) {
    P("ArrayTypeAnnotation", e, t);
  }
  s(CR, "assertArrayTypeAnnotation");
  function wR(e, t) {
    P("BooleanTypeAnnotation", e, t);
  }
  s(wR, "assertBooleanTypeAnnotation");
  function DR(e, t) {
    P("BooleanLiteralTypeAnnotation", e, t);
  }
  s(DR, "assertBooleanLiteralTypeAnnotation");
  function IR(e, t) {
    P("NullLiteralTypeAnnotation", e, t);
  }
  s(IR, "assertNullLiteralTypeAnnotation");
  function _R(e, t) {
    P("ClassImplements", e, t);
  }
  s(_R, "assertClassImplements");
  function OR(e, t) {
    P("DeclareClass", e, t);
  }
  s(OR, "assertDeclareClass");
  function NR(e, t) {
    P("DeclareFunction", e, t);
  }
  s(NR, "assertDeclareFunction");
  function BR(e, t) {
    P("DeclareInterface", e, t);
  }
  s(BR, "assertDeclareInterface");
  function kR(e, t) {
    P("DeclareModule", e, t);
  }
  s(kR, "assertDeclareModule");
  function FR(e, t) {
    P("DeclareModuleExports", e, t);
  }
  s(FR, "assertDeclareModuleExports");
  function jR(e, t) {
    P("DeclareTypeAlias", e, t);
  }
  s(jR, "assertDeclareTypeAlias");
  function LR(e, t) {
    P("DeclareOpaqueType", e, t);
  }
  s(LR, "assertDeclareOpaqueType");
  function MR(e, t) {
    P("DeclareVariable", e, t);
  }
  s(MR, "assertDeclareVariable");
  function RR(e, t) {
    P("DeclareExportDeclaration", e, t);
  }
  s(RR, "assertDeclareExportDeclaration");
  function qR(e, t) {
    P("DeclareExportAllDeclaration", e, t);
  }
  s(qR, "assertDeclareExportAllDeclaration");
  function UR(e, t) {
    P("DeclaredPredicate", e, t);
  }
  s(UR, "assertDeclaredPredicate");
  function VR(e, t) {
    P("ExistsTypeAnnotation", e, t);
  }
  s(VR, "assertExistsTypeAnnotation");
  function $R(e, t) {
    P("FunctionTypeAnnotation", e, t);
  }
  s($R, "assertFunctionTypeAnnotation");
  function WR(e, t) {
    P("FunctionTypeParam", e, t);
  }
  s(WR, "assertFunctionTypeParam");
  function KR(e, t) {
    P("GenericTypeAnnotation", e, t);
  }
  s(KR, "assertGenericTypeAnnotation");
  function GR(e, t) {
    P("InferredPredicate", e, t);
  }
  s(GR, "assertInferredPredicate");
  function HR(e, t) {
    P("InterfaceExtends", e, t);
  }
  s(HR, "assertInterfaceExtends");
  function YR(e, t) {
    P("InterfaceDeclaration", e, t);
  }
  s(YR, "assertInterfaceDeclaration");
  function zR(e, t) {
    P("InterfaceTypeAnnotation", e, t);
  }
  s(zR, "assertInterfaceTypeAnnotation");
  function JR(e, t) {
    P("IntersectionTypeAnnotation", e, t);
  }
  s(JR, "assertIntersectionTypeAnnotation");
  function XR(e, t) {
    P("MixedTypeAnnotation", e, t);
  }
  s(XR, "assertMixedTypeAnnotation");
  function QR(e, t) {
    P("EmptyTypeAnnotation", e, t);
  }
  s(QR, "assertEmptyTypeAnnotation");
  function ZR(e, t) {
    P("NullableTypeAnnotation", e, t);
  }
  s(ZR, "assertNullableTypeAnnotation");
  function e7(e, t) {
    P("NumberLiteralTypeAnnotation", e, t);
  }
  s(e7, "assertNumberLiteralTypeAnnotation");
  function t7(e, t) {
    P("NumberTypeAnnotation", e, t);
  }
  s(t7, "assertNumberTypeAnnotation");
  function r7(e, t) {
    P("ObjectTypeAnnotation", e, t);
  }
  s(r7, "assertObjectTypeAnnotation");
  function n7(e, t) {
    P("ObjectTypeInternalSlot", e, t);
  }
  s(n7, "assertObjectTypeInternalSlot");
  function s7(e, t) {
    P("ObjectTypeCallProperty", e, t);
  }
  s(s7, "assertObjectTypeCallProperty");
  function i7(e, t) {
    P("ObjectTypeIndexer", e, t);
  }
  s(i7, "assertObjectTypeIndexer");
  function a7(e, t) {
    P("ObjectTypeProperty", e, t);
  }
  s(a7, "assertObjectTypeProperty");
  function o7(e, t) {
    P("ObjectTypeSpreadProperty", e, t);
  }
  s(o7, "assertObjectTypeSpreadProperty");
  function l7(e, t) {
    P("OpaqueType", e, t);
  }
  s(l7, "assertOpaqueType");
  function u7(e, t) {
    P("QualifiedTypeIdentifier", e, t);
  }
  s(u7, "assertQualifiedTypeIdentifier");
  function c7(e, t) {
    P("StringLiteralTypeAnnotation", e, t);
  }
  s(c7, "assertStringLiteralTypeAnnotation");
  function f7(e, t) {
    P("StringTypeAnnotation", e, t);
  }
  s(f7, "assertStringTypeAnnotation");
  function p7(e, t) {
    P("SymbolTypeAnnotation", e, t);
  }
  s(p7, "assertSymbolTypeAnnotation");
  function d7(e, t) {
    P("ThisTypeAnnotation", e, t);
  }
  s(d7, "assertThisTypeAnnotation");
  function h7(e, t) {
    P("TupleTypeAnnotation", e, t);
  }
  s(h7, "assertTupleTypeAnnotation");
  function m7(e, t) {
    P("TypeofTypeAnnotation", e, t);
  }
  s(m7, "assertTypeofTypeAnnotation");
  function y7(e, t) {
    P("TypeAlias", e, t);
  }
  s(y7, "assertTypeAlias");
  function g7(e, t) {
    P("TypeAnnotation", e, t);
  }
  s(g7, "assertTypeAnnotation");
  function b7(e, t) {
    P("TypeCastExpression", e, t);
  }
  s(b7, "assertTypeCastExpression");
  function E7(e, t) {
    P("TypeParameter", e, t);
  }
  s(E7, "assertTypeParameter");
  function v7(e, t) {
    P("TypeParameterDeclaration", e, t);
  }
  s(v7, "assertTypeParameterDeclaration");
  function T7(e, t) {
    P("TypeParameterInstantiation", e, t);
  }
  s(T7, "assertTypeParameterInstantiation");
  function x7(e, t) {
    P("UnionTypeAnnotation", e, t);
  }
  s(x7, "assertUnionTypeAnnotation");
  function S7(e, t) {
    P("Variance", e, t);
  }
  s(S7, "assertVariance");
  function P7(e, t) {
    P("VoidTypeAnnotation", e, t);
  }
  s(P7, "assertVoidTypeAnnotation");
  function A7(e, t) {
    P("EnumDeclaration", e, t);
  }
  s(A7, "assertEnumDeclaration");
  function C7(e, t) {
    P("EnumBooleanBody", e, t);
  }
  s(C7, "assertEnumBooleanBody");
  function w7(e, t) {
    P("EnumNumberBody", e, t);
  }
  s(w7, "assertEnumNumberBody");
  function D7(e, t) {
    P("EnumStringBody", e, t);
  }
  s(D7, "assertEnumStringBody");
  function I7(e, t) {
    P("EnumSymbolBody", e, t);
  }
  s(I7, "assertEnumSymbolBody");
  function _7(e, t) {
    P("EnumBooleanMember", e, t);
  }
  s(_7, "assertEnumBooleanMember");
  function O7(e, t) {
    P("EnumNumberMember", e, t);
  }
  s(O7, "assertEnumNumberMember");
  function N7(e, t) {
    P("EnumStringMember", e, t);
  }
  s(N7, "assertEnumStringMember");
  function B7(e, t) {
    P("EnumDefaultedMember", e, t);
  }
  s(B7, "assertEnumDefaultedMember");
  function k7(e, t) {
    P("IndexedAccessType", e, t);
  }
  s(k7, "assertIndexedAccessType");
  function F7(e, t) {
    P("OptionalIndexedAccessType", e, t);
  }
  s(F7, "assertOptionalIndexedAccessType");
  function j7(e, t) {
    P("JSXAttribute", e, t);
  }
  s(j7, "assertJSXAttribute");
  function L7(e, t) {
    P("JSXClosingElement", e, t);
  }
  s(L7, "assertJSXClosingElement");
  function M7(e, t) {
    P("JSXElement", e, t);
  }
  s(M7, "assertJSXElement");
  function R7(e, t) {
    P("JSXEmptyExpression", e, t);
  }
  s(R7, "assertJSXEmptyExpression");
  function q7(e, t) {
    P("JSXExpressionContainer", e, t);
  }
  s(q7, "assertJSXExpressionContainer");
  function U7(e, t) {
    P("JSXSpreadChild", e, t);
  }
  s(U7, "assertJSXSpreadChild");
  function V7(e, t) {
    P("JSXIdentifier", e, t);
  }
  s(V7, "assertJSXIdentifier");
  function $7(e, t) {
    P("JSXMemberExpression", e, t);
  }
  s($7, "assertJSXMemberExpression");
  function W7(e, t) {
    P("JSXNamespacedName", e, t);
  }
  s(W7, "assertJSXNamespacedName");
  function K7(e, t) {
    P("JSXOpeningElement", e, t);
  }
  s(K7, "assertJSXOpeningElement");
  function G7(e, t) {
    P("JSXSpreadAttribute", e, t);
  }
  s(G7, "assertJSXSpreadAttribute");
  function H7(e, t) {
    P("JSXText", e, t);
  }
  s(H7, "assertJSXText");
  function Y7(e, t) {
    P("JSXFragment", e, t);
  }
  s(Y7, "assertJSXFragment");
  function z7(e, t) {
    P("JSXOpeningFragment", e, t);
  }
  s(z7, "assertJSXOpeningFragment");
  function J7(e, t) {
    P("JSXClosingFragment", e, t);
  }
  s(J7, "assertJSXClosingFragment");
  function X7(e, t) {
    P("Noop", e, t);
  }
  s(X7, "assertNoop");
  function Q7(e, t) {
    P("Placeholder", e, t);
  }
  s(Q7, "assertPlaceholder");
  function Z7(e, t) {
    P("V8IntrinsicIdentifier", e, t);
  }
  s(Z7, "assertV8IntrinsicIdentifier");
  function eq(e, t) {
    P("ArgumentPlaceholder", e, t);
  }
  s(eq, "assertArgumentPlaceholder");
  function tq(e, t) {
    P("BindExpression", e, t);
  }
  s(tq, "assertBindExpression");
  function rq(e, t) {
    P("ImportAttribute", e, t);
  }
  s(rq, "assertImportAttribute");
  function nq(e, t) {
    P("Decorator", e, t);
  }
  s(nq, "assertDecorator");
  function sq(e, t) {
    P("DoExpression", e, t);
  }
  s(sq, "assertDoExpression");
  function iq(e, t) {
    P("ExportDefaultSpecifier", e, t);
  }
  s(iq, "assertExportDefaultSpecifier");
  function aq(e, t) {
    P("RecordExpression", e, t);
  }
  s(aq, "assertRecordExpression");
  function oq(e, t) {
    P("TupleExpression", e, t);
  }
  s(oq, "assertTupleExpression");
  function lq(e, t) {
    P("DecimalLiteral", e, t);
  }
  s(lq, "assertDecimalLiteral");
  function uq(e, t) {
    P("ModuleExpression", e, t);
  }
  s(uq, "assertModuleExpression");
  function cq(e, t) {
    P("TopicReference", e, t);
  }
  s(cq, "assertTopicReference");
  function fq(e, t) {
    P("PipelineTopicExpression", e, t);
  }
  s(fq, "assertPipelineTopicExpression");
  function pq(e, t) {
    P("PipelineBareFunction", e, t);
  }
  s(pq, "assertPipelineBareFunction");
  function dq(e, t) {
    P("PipelinePrimaryTopicReference", e, t);
  }
  s(dq, "assertPipelinePrimaryTopicReference");
  function hq(e, t) {
    P("TSParameterProperty", e, t);
  }
  s(hq, "assertTSParameterProperty");
  function mq(e, t) {
    P("TSDeclareFunction", e, t);
  }
  s(mq, "assertTSDeclareFunction");
  function yq(e, t) {
    P("TSDeclareMethod", e, t);
  }
  s(yq, "assertTSDeclareMethod");
  function gq(e, t) {
    P("TSQualifiedName", e, t);
  }
  s(gq, "assertTSQualifiedName");
  function bq(e, t) {
    P("TSCallSignatureDeclaration", e, t);
  }
  s(bq, "assertTSCallSignatureDeclaration");
  function Eq(e, t) {
    P("TSConstructSignatureDeclaration", e, t);
  }
  s(Eq, "assertTSConstructSignatureDeclaration");
  function vq(e, t) {
    P("TSPropertySignature", e, t);
  }
  s(vq, "assertTSPropertySignature");
  function Tq(e, t) {
    P("TSMethodSignature", e, t);
  }
  s(Tq, "assertTSMethodSignature");
  function xq(e, t) {
    P("TSIndexSignature", e, t);
  }
  s(xq, "assertTSIndexSignature");
  function Sq(e, t) {
    P("TSAnyKeyword", e, t);
  }
  s(Sq, "assertTSAnyKeyword");
  function Pq(e, t) {
    P("TSBooleanKeyword", e, t);
  }
  s(Pq, "assertTSBooleanKeyword");
  function Aq(e, t) {
    P("TSBigIntKeyword", e, t);
  }
  s(Aq, "assertTSBigIntKeyword");
  function Cq(e, t) {
    P("TSIntrinsicKeyword", e, t);
  }
  s(Cq, "assertTSIntrinsicKeyword");
  function wq(e, t) {
    P("TSNeverKeyword", e, t);
  }
  s(wq, "assertTSNeverKeyword");
  function Dq(e, t) {
    P("TSNullKeyword", e, t);
  }
  s(Dq, "assertTSNullKeyword");
  function Iq(e, t) {
    P("TSNumberKeyword", e, t);
  }
  s(Iq, "assertTSNumberKeyword");
  function _q(e, t) {
    P("TSObjectKeyword", e, t);
  }
  s(_q, "assertTSObjectKeyword");
  function Oq(e, t) {
    P("TSStringKeyword", e, t);
  }
  s(Oq, "assertTSStringKeyword");
  function Nq(e, t) {
    P("TSSymbolKeyword", e, t);
  }
  s(Nq, "assertTSSymbolKeyword");
  function Bq(e, t) {
    P("TSUndefinedKeyword", e, t);
  }
  s(Bq, "assertTSUndefinedKeyword");
  function kq(e, t) {
    P("TSUnknownKeyword", e, t);
  }
  s(kq, "assertTSUnknownKeyword");
  function Fq(e, t) {
    P("TSVoidKeyword", e, t);
  }
  s(Fq, "assertTSVoidKeyword");
  function jq(e, t) {
    P("TSThisType", e, t);
  }
  s(jq, "assertTSThisType");
  function Lq(e, t) {
    P("TSFunctionType", e, t);
  }
  s(Lq, "assertTSFunctionType");
  function Mq(e, t) {
    P("TSConstructorType", e, t);
  }
  s(Mq, "assertTSConstructorType");
  function Rq(e, t) {
    P("TSTypeReference", e, t);
  }
  s(Rq, "assertTSTypeReference");
  function qq(e, t) {
    P("TSTypePredicate", e, t);
  }
  s(qq, "assertTSTypePredicate");
  function Uq(e, t) {
    P("TSTypeQuery", e, t);
  }
  s(Uq, "assertTSTypeQuery");
  function Vq(e, t) {
    P("TSTypeLiteral", e, t);
  }
  s(Vq, "assertTSTypeLiteral");
  function $q(e, t) {
    P("TSArrayType", e, t);
  }
  s($q, "assertTSArrayType");
  function Wq(e, t) {
    P("TSTupleType", e, t);
  }
  s(Wq, "assertTSTupleType");
  function Kq(e, t) {
    P("TSOptionalType", e, t);
  }
  s(Kq, "assertTSOptionalType");
  function Gq(e, t) {
    P("TSRestType", e, t);
  }
  s(Gq, "assertTSRestType");
  function Hq(e, t) {
    P("TSNamedTupleMember", e, t);
  }
  s(Hq, "assertTSNamedTupleMember");
  function Yq(e, t) {
    P("TSUnionType", e, t);
  }
  s(Yq, "assertTSUnionType");
  function zq(e, t) {
    P("TSIntersectionType", e, t);
  }
  s(zq, "assertTSIntersectionType");
  function Jq(e, t) {
    P("TSConditionalType", e, t);
  }
  s(Jq, "assertTSConditionalType");
  function Xq(e, t) {
    P("TSInferType", e, t);
  }
  s(Xq, "assertTSInferType");
  function Qq(e, t) {
    P("TSParenthesizedType", e, t);
  }
  s(Qq, "assertTSParenthesizedType");
  function Zq(e, t) {
    P("TSTypeOperator", e, t);
  }
  s(Zq, "assertTSTypeOperator");
  function eU(e, t) {
    P("TSIndexedAccessType", e, t);
  }
  s(eU, "assertTSIndexedAccessType");
  function tU(e, t) {
    P("TSMappedType", e, t);
  }
  s(tU, "assertTSMappedType");
  function rU(e, t) {
    P("TSLiteralType", e, t);
  }
  s(rU, "assertTSLiteralType");
  function nU(e, t) {
    P("TSExpressionWithTypeArguments", e, t);
  }
  s(nU, "assertTSExpressionWithTypeArguments");
  function sU(e, t) {
    P("TSInterfaceDeclaration", e, t);
  }
  s(sU, "assertTSInterfaceDeclaration");
  function iU(e, t) {
    P("TSInterfaceBody", e, t);
  }
  s(iU, "assertTSInterfaceBody");
  function aU(e, t) {
    P("TSTypeAliasDeclaration", e, t);
  }
  s(aU, "assertTSTypeAliasDeclaration");
  function oU(e, t) {
    P("TSInstantiationExpression", e, t);
  }
  s(oU, "assertTSInstantiationExpression");
  function lU(e, t) {
    P("TSAsExpression", e, t);
  }
  s(lU, "assertTSAsExpression");
  function uU(e, t) {
    P("TSSatisfiesExpression", e, t);
  }
  s(uU, "assertTSSatisfiesExpression");
  function cU(e, t) {
    P("TSTypeAssertion", e, t);
  }
  s(cU, "assertTSTypeAssertion");
  function fU(e, t) {
    P("TSEnumDeclaration", e, t);
  }
  s(fU, "assertTSEnumDeclaration");
  function pU(e, t) {
    P("TSEnumMember", e, t);
  }
  s(pU, "assertTSEnumMember");
  function dU(e, t) {
    P("TSModuleDeclaration", e, t);
  }
  s(dU, "assertTSModuleDeclaration");
  function hU(e, t) {
    P("TSModuleBlock", e, t);
  }
  s(hU, "assertTSModuleBlock");
  function mU(e, t) {
    P("TSImportType", e, t);
  }
  s(mU, "assertTSImportType");
  function yU(e, t) {
    P("TSImportEqualsDeclaration", e, t);
  }
  s(yU, "assertTSImportEqualsDeclaration");
  function gU(e, t) {
    P("TSExternalModuleReference", e, t);
  }
  s(gU, "assertTSExternalModuleReference");
  function bU(e, t) {
    P("TSNonNullExpression", e, t);
  }
  s(bU, "assertTSNonNullExpression");
  function EU(e, t) {
    P("TSExportAssignment", e, t);
  }
  s(EU, "assertTSExportAssignment");
  function vU(e, t) {
    P("TSNamespaceExportDeclaration", e, t);
  }
  s(vU, "assertTSNamespaceExportDeclaration");
  function TU(e, t) {
    P("TSTypeAnnotation", e, t);
  }
  s(TU, "assertTSTypeAnnotation");
  function xU(e, t) {
    P("TSTypeParameterInstantiation", e, t);
  }
  s(xU, "assertTSTypeParameterInstantiation");
  function SU(e, t) {
    P("TSTypeParameterDeclaration", e, t);
  }
  s(SU, "assertTSTypeParameterDeclaration");
  function PU(e, t) {
    P("TSTypeParameter", e, t);
  }
  s(PU, "assertTSTypeParameter");
  function AU(e, t) {
    P("Standardized", e, t);
  }
  s(AU, "assertStandardized");
  function CU(e, t) {
    P("Expression", e, t);
  }
  s(CU, "assertExpression");
  function wU(e, t) {
    P("Binary", e, t);
  }
  s(wU, "assertBinary");
  function DU(e, t) {
    P("Scopable", e, t);
  }
  s(DU, "assertScopable");
  function IU(e, t) {
    P("BlockParent", e, t);
  }
  s(IU, "assertBlockParent");
  function _U(e, t) {
    P("Block", e, t);
  }
  s(_U, "assertBlock");
  function OU(e, t) {
    P("Statement", e, t);
  }
  s(OU, "assertStatement");
  function NU(e, t) {
    P("Terminatorless", e, t);
  }
  s(NU, "assertTerminatorless");
  function BU(e, t) {
    P("CompletionStatement", e, t);
  }
  s(BU, "assertCompletionStatement");
  function kU(e, t) {
    P("Conditional", e, t);
  }
  s(kU, "assertConditional");
  function FU(e, t) {
    P("Loop", e, t);
  }
  s(FU, "assertLoop");
  function jU(e, t) {
    P("While", e, t);
  }
  s(jU, "assertWhile");
  function LU(e, t) {
    P("ExpressionWrapper", e, t);
  }
  s(LU, "assertExpressionWrapper");
  function MU(e, t) {
    P("For", e, t);
  }
  s(MU, "assertFor");
  function RU(e, t) {
    P("ForXStatement", e, t);
  }
  s(RU, "assertForXStatement");
  function qU(e, t) {
    P("Function", e, t);
  }
  s(qU, "assertFunction");
  function UU(e, t) {
    P("FunctionParent", e, t);
  }
  s(UU, "assertFunctionParent");
  function VU(e, t) {
    P("Pureish", e, t);
  }
  s(VU, "assertPureish");
  function $U(e, t) {
    P("Declaration", e, t);
  }
  s($U, "assertDeclaration");
  function WU(e, t) {
    P("PatternLike", e, t);
  }
  s(WU, "assertPatternLike");
  function KU(e, t) {
    P("LVal", e, t);
  }
  s(KU, "assertLVal");
  function GU(e, t) {
    P("TSEntityName", e, t);
  }
  s(GU, "assertTSEntityName");
  function HU(e, t) {
    P("Literal", e, t);
  }
  s(HU, "assertLiteral");
  function YU(e, t) {
    P("Immutable", e, t);
  }
  s(YU, "assertImmutable");
  function zU(e, t) {
    P("UserWhitespacable", e, t);
  }
  s(zU, "assertUserWhitespacable");
  function JU(e, t) {
    P("Method", e, t);
  }
  s(JU, "assertMethod");
  function XU(e, t) {
    P("ObjectMember", e, t);
  }
  s(XU, "assertObjectMember");
  function QU(e, t) {
    P("Property", e, t);
  }
  s(QU, "assertProperty");
  function ZU(e, t) {
    P("UnaryLike", e, t);
  }
  s(ZU, "assertUnaryLike");
  function eV(e, t) {
    P("Pattern", e, t);
  }
  s(eV, "assertPattern");
  function tV(e, t) {
    P("Class", e, t);
  }
  s(tV, "assertClass");
  function rV(e, t) {
    P("ImportOrExportDeclaration", e, t);
  }
  s(rV, "assertImportOrExportDeclaration");
  function nV(e, t) {
    P("ExportDeclaration", e, t);
  }
  s(nV, "assertExportDeclaration");
  function sV(e, t) {
    P("ModuleSpecifier", e, t);
  }
  s(sV, "assertModuleSpecifier");
  function iV(e, t) {
    P("Accessor", e, t);
  }
  s(iV, "assertAccessor");
  function aV(e, t) {
    P("Private", e, t);
  }
  s(aV, "assertPrivate");
  function oV(e, t) {
    P("Flow", e, t);
  }
  s(oV, "assertFlow");
  function lV(e, t) {
    P("FlowType", e, t);
  }
  s(lV, "assertFlowType");
  function uV(e, t) {
    P("FlowBaseAnnotation", e, t);
  }
  s(uV, "assertFlowBaseAnnotation");
  function cV(e, t) {
    P("FlowDeclaration", e, t);
  }
  s(cV, "assertFlowDeclaration");
  function fV(e, t) {
    P("FlowPredicate", e, t);
  }
  s(fV, "assertFlowPredicate");
  function pV(e, t) {
    P("EnumBody", e, t);
  }
  s(pV, "assertEnumBody");
  function dV(e, t) {
    P("EnumMember", e, t);
  }
  s(dV, "assertEnumMember");
  function hV(e, t) {
    P("JSX", e, t);
  }
  s(hV, "assertJSX");
  function mV(e, t) {
    P("Miscellaneous", e, t);
  }
  s(mV, "assertMiscellaneous");
  function yV(e, t) {
    P("TypeScript", e, t);
  }
  s(yV, "assertTypeScript");
  function gV(e, t) {
    P("TSTypeElement", e, t);
  }
  s(gV, "assertTSTypeElement");
  function bV(e, t) {
    P("TSType", e, t);
  }
  s(bV, "assertTSType");
  function EV(e, t) {
    P("TSBaseType", e, t);
  }
  s(EV, "assertTSBaseType");
  function vV(e, t) {
    (0, ja.default)("assertNumberLiteral", "assertNumericLiteral"), P("NumberLiteral", e, t);
  }
  s(vV, "assertNumberLiteral");
  function TV(e, t) {
    (0, ja.default)("assertRegexLiteral", "assertRegExpLiteral"), P("RegexLiteral", e, t);
  }
  s(TV, "assertRegexLiteral");
  function xV(e, t) {
    (0, ja.default)("assertRestProperty", "assertRestElement"), P("RestProperty", e, t);
  }
  s(xV, "assertRestProperty");
  function SV(e, t) {
    (0, ja.default)("assertSpreadProperty", "assertSpreadElement"), P("SpreadProperty", e, t);
  }
  s(SV, "assertSpreadProperty");
  function PV(e, t) {
    (0, ja.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), P("ModuleDeclaration", e, t);
  }
  s(PV, "assertModuleDeclaration");
});

// ../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var UE = T((Pl) => {
  "use strict";
  Object.defineProperty(Pl, "__esModule", {
    value: !0
  });
  Pl.default = void 0;
  var $r = sr(), Eve = Pl.default = AV;
  function AV(e) {
    switch (e) {
      case "string":
        return (0, $r.stringTypeAnnotation)();
      case "number":
        return (0, $r.numberTypeAnnotation)();
      case "undefined":
        return (0, $r.voidTypeAnnotation)();
      case "boolean":
        return (0, $r.booleanTypeAnnotation)();
      case "function":
        return (0, $r.genericTypeAnnotation)((0, $r.identifier)("Function"));
      case "object":
        return (0, $r.genericTypeAnnotation)((0, $r.identifier)("Object"));
      case "symbol":
        return (0, $r.genericTypeAnnotation)((0, $r.identifier)("Symbol"));
      case "bigint":
        return (0, $r.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + e);
  }
  s(AV, "createTypeAnnotationBasedOnTypeof");
});

// ../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var Fp = T((kp) => {
  "use strict";
  Object.defineProperty(kp, "__esModule", {
    value: !0
  });
  kp.default = $E;
  var La = Tt();
  function VE(e) {
    return (0, La.isIdentifier)(e) ? e.name : `${e.id.name}.${VE(e.qualification)}`;
  }
  s(VE, "getQualifiedName");
  function $E(e) {
    let t = Array.from(e), r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < t.length; o++) {
      let l = t[o];
      if (l && !a.includes(l)) {
        if ((0, La.isAnyTypeAnnotation)(l))
          return [l];
        if ((0, La.isFlowBaseAnnotation)(l)) {
          n.set(l.type, l);
          continue;
        }
        if ((0, La.isUnionTypeAnnotation)(l)) {
          i.has(l.types) || (t.push(...l.types), i.add(l.types));
          continue;
        }
        if ((0, La.isGenericTypeAnnotation)(l)) {
          let u = VE(l.id);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = $E(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of n)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  s($E, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var WE = T((jp) => {
  "use strict";
  Object.defineProperty(jp, "__esModule", {
    value: !0
  });
  jp.default = DV;
  var CV = sr(), wV = Fp();
  function DV(e) {
    let t = (0, wV.default)(e);
    return t.length === 1 ? t[0] : (0, CV.unionTypeAnnotation)(t);
  }
  s(DV, "createFlowUnionType");
});

// ../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var HE = T((Lp) => {
  "use strict";
  Object.defineProperty(Lp, "__esModule", {
    value: !0
  });
  Lp.default = GE;
  var Ma = Tt();
  function KE(e) {
    return (0, Ma.isIdentifier)(e) ? e.name : `${e.right.name}.${KE(e.left)}`;
  }
  s(KE, "getQualifiedName");
  function GE(e) {
    let t = Array.from(e), r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < t.length; o++) {
      let l = t[o];
      if (l && !a.includes(l)) {
        if ((0, Ma.isTSAnyKeyword)(l))
          return [l];
        if ((0, Ma.isTSBaseType)(l)) {
          n.set(l.type, l);
          continue;
        }
        if ((0, Ma.isTSUnionType)(l)) {
          i.has(l.types) || (t.push(...l.types), i.add(l.types));
          continue;
        }
        if ((0, Ma.isTSTypeReference)(l) && l.typeParameters) {
          let u = KE(l.typeName);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = GE(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of n)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  s(GE, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var YE = T((Mp) => {
  "use strict";
  Object.defineProperty(Mp, "__esModule", {
    value: !0
  });
  Mp.default = NV;
  var IV = sr(), _V = HE(), OV = Tt();
  function NV(e) {
    let t = e.map((n) => (0, OV.isTSTypeAnnotation)(n) ? n.typeAnnotation : n), r = (0, _V.default)(t);
    return r.length === 1 ? r[0] : (0, IV.tsUnionType)(r);
  }
  s(NV, "createTSUnionType");
});

// ../node_modules/@babel/types/lib/builders/generated/uppercase.js
var zE = T((w) => {
  "use strict";
  Object.defineProperty(w, "__esModule", {
    value: !0
  });
  Object.defineProperty(w, "AnyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.anyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "ArgumentPlaceholder", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.argumentPlaceholder;
    }, "get")
  });
  Object.defineProperty(w, "ArrayExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.arrayExpression;
    }, "get")
  });
  Object.defineProperty(w, "ArrayPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.arrayPattern;
    }, "get")
  });
  Object.defineProperty(w, "ArrayTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.arrayTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "ArrowFunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.arrowFunctionExpression;
    }, "get")
  });
  Object.defineProperty(w, "AssignmentExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.assignmentExpression;
    }, "get")
  });
  Object.defineProperty(w, "AssignmentPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.assignmentPattern;
    }, "get")
  });
  Object.defineProperty(w, "AwaitExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.awaitExpression;
    }, "get")
  });
  Object.defineProperty(w, "BigIntLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.bigIntLiteral;
    }, "get")
  });
  Object.defineProperty(w, "BinaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.binaryExpression;
    }, "get")
  });
  Object.defineProperty(w, "BindExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.bindExpression;
    }, "get")
  });
  Object.defineProperty(w, "BlockStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.blockStatement;
    }, "get")
  });
  Object.defineProperty(w, "BooleanLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.booleanLiteral;
    }, "get")
  });
  Object.defineProperty(w, "BooleanLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.booleanLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "BooleanTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.booleanTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "BreakStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.breakStatement;
    }, "get")
  });
  Object.defineProperty(w, "CallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.callExpression;
    }, "get")
  });
  Object.defineProperty(w, "CatchClause", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.catchClause;
    }, "get")
  });
  Object.defineProperty(w, "ClassAccessorProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.classAccessorProperty;
    }, "get")
  });
  Object.defineProperty(w, "ClassBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.classBody;
    }, "get")
  });
  Object.defineProperty(w, "ClassDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.classDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "ClassExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.classExpression;
    }, "get")
  });
  Object.defineProperty(w, "ClassImplements", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.classImplements;
    }, "get")
  });
  Object.defineProperty(w, "ClassMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.classMethod;
    }, "get")
  });
  Object.defineProperty(w, "ClassPrivateMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.classPrivateMethod;
    }, "get")
  });
  Object.defineProperty(w, "ClassPrivateProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.classPrivateProperty;
    }, "get")
  });
  Object.defineProperty(w, "ClassProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.classProperty;
    }, "get")
  });
  Object.defineProperty(w, "ConditionalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.conditionalExpression;
    }, "get")
  });
  Object.defineProperty(w, "ContinueStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.continueStatement;
    }, "get")
  });
  Object.defineProperty(w, "DebuggerStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.debuggerStatement;
    }, "get")
  });
  Object.defineProperty(w, "DecimalLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.decimalLiteral;
    }, "get")
  });
  Object.defineProperty(w, "DeclareClass", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.declareClass;
    }, "get")
  });
  Object.defineProperty(w, "DeclareExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.declareExportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "DeclareExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.declareExportDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "DeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.declareFunction;
    }, "get")
  });
  Object.defineProperty(w, "DeclareInterface", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.declareInterface;
    }, "get")
  });
  Object.defineProperty(w, "DeclareModule", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.declareModule;
    }, "get")
  });
  Object.defineProperty(w, "DeclareModuleExports", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.declareModuleExports;
    }, "get")
  });
  Object.defineProperty(w, "DeclareOpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.declareOpaqueType;
    }, "get")
  });
  Object.defineProperty(w, "DeclareTypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.declareTypeAlias;
    }, "get")
  });
  Object.defineProperty(w, "DeclareVariable", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.declareVariable;
    }, "get")
  });
  Object.defineProperty(w, "DeclaredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.declaredPredicate;
    }, "get")
  });
  Object.defineProperty(w, "Decorator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.decorator;
    }, "get")
  });
  Object.defineProperty(w, "Directive", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.directive;
    }, "get")
  });
  Object.defineProperty(w, "DirectiveLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.directiveLiteral;
    }, "get")
  });
  Object.defineProperty(w, "DoExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.doExpression;
    }, "get")
  });
  Object.defineProperty(w, "DoWhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.doWhileStatement;
    }, "get")
  });
  Object.defineProperty(w, "EmptyStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.emptyStatement;
    }, "get")
  });
  Object.defineProperty(w, "EmptyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.emptyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "EnumBooleanBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.enumBooleanBody;
    }, "get")
  });
  Object.defineProperty(w, "EnumBooleanMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.enumBooleanMember;
    }, "get")
  });
  Object.defineProperty(w, "EnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.enumDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "EnumDefaultedMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.enumDefaultedMember;
    }, "get")
  });
  Object.defineProperty(w, "EnumNumberBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.enumNumberBody;
    }, "get")
  });
  Object.defineProperty(w, "EnumNumberMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.enumNumberMember;
    }, "get")
  });
  Object.defineProperty(w, "EnumStringBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.enumStringBody;
    }, "get")
  });
  Object.defineProperty(w, "EnumStringMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.enumStringMember;
    }, "get")
  });
  Object.defineProperty(w, "EnumSymbolBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.enumSymbolBody;
    }, "get")
  });
  Object.defineProperty(w, "ExistsTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.existsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "ExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.exportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "ExportDefaultDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.exportDefaultDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "ExportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.exportDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(w, "ExportNamedDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.exportNamedDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "ExportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.exportNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(w, "ExportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.exportSpecifier;
    }, "get")
  });
  Object.defineProperty(w, "ExpressionStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.expressionStatement;
    }, "get")
  });
  Object.defineProperty(w, "File", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.file;
    }, "get")
  });
  Object.defineProperty(w, "ForInStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.forInStatement;
    }, "get")
  });
  Object.defineProperty(w, "ForOfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.forOfStatement;
    }, "get")
  });
  Object.defineProperty(w, "ForStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.forStatement;
    }, "get")
  });
  Object.defineProperty(w, "FunctionDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.functionDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "FunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.functionExpression;
    }, "get")
  });
  Object.defineProperty(w, "FunctionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.functionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "FunctionTypeParam", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.functionTypeParam;
    }, "get")
  });
  Object.defineProperty(w, "GenericTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.genericTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.identifier;
    }, "get")
  });
  Object.defineProperty(w, "IfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.ifStatement;
    }, "get")
  });
  Object.defineProperty(w, "Import", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.import;
    }, "get")
  });
  Object.defineProperty(w, "ImportAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.importAttribute;
    }, "get")
  });
  Object.defineProperty(w, "ImportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.importDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "ImportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.importDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(w, "ImportExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.importExpression;
    }, "get")
  });
  Object.defineProperty(w, "ImportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.importNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(w, "ImportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.importSpecifier;
    }, "get")
  });
  Object.defineProperty(w, "IndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.indexedAccessType;
    }, "get")
  });
  Object.defineProperty(w, "InferredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.inferredPredicate;
    }, "get")
  });
  Object.defineProperty(w, "InterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.interfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "InterfaceExtends", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.interfaceExtends;
    }, "get")
  });
  Object.defineProperty(w, "InterfaceTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.interfaceTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "InterpreterDirective", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.interpreterDirective;
    }, "get")
  });
  Object.defineProperty(w, "IntersectionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.intersectionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "JSXAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.jsxAttribute;
    }, "get")
  });
  Object.defineProperty(w, "JSXClosingElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.jsxClosingElement;
    }, "get")
  });
  Object.defineProperty(w, "JSXClosingFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.jsxClosingFragment;
    }, "get")
  });
  Object.defineProperty(w, "JSXElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.jsxElement;
    }, "get")
  });
  Object.defineProperty(w, "JSXEmptyExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.jsxEmptyExpression;
    }, "get")
  });
  Object.defineProperty(w, "JSXExpressionContainer", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.jsxExpressionContainer;
    }, "get")
  });
  Object.defineProperty(w, "JSXFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.jsxFragment;
    }, "get")
  });
  Object.defineProperty(w, "JSXIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.jsxIdentifier;
    }, "get")
  });
  Object.defineProperty(w, "JSXMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.jsxMemberExpression;
    }, "get")
  });
  Object.defineProperty(w, "JSXNamespacedName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.jsxNamespacedName;
    }, "get")
  });
  Object.defineProperty(w, "JSXOpeningElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.jsxOpeningElement;
    }, "get")
  });
  Object.defineProperty(w, "JSXOpeningFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.jsxOpeningFragment;
    }, "get")
  });
  Object.defineProperty(w, "JSXSpreadAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.jsxSpreadAttribute;
    }, "get")
  });
  Object.defineProperty(w, "JSXSpreadChild", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.jsxSpreadChild;
    }, "get")
  });
  Object.defineProperty(w, "JSXText", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.jsxText;
    }, "get")
  });
  Object.defineProperty(w, "LabeledStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.labeledStatement;
    }, "get")
  });
  Object.defineProperty(w, "LogicalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.logicalExpression;
    }, "get")
  });
  Object.defineProperty(w, "MemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.memberExpression;
    }, "get")
  });
  Object.defineProperty(w, "MetaProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.metaProperty;
    }, "get")
  });
  Object.defineProperty(w, "MixedTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.mixedTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "ModuleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.moduleExpression;
    }, "get")
  });
  Object.defineProperty(w, "NewExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.newExpression;
    }, "get")
  });
  Object.defineProperty(w, "Noop", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.noop;
    }, "get")
  });
  Object.defineProperty(w, "NullLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.nullLiteral;
    }, "get")
  });
  Object.defineProperty(w, "NullLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.nullLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "NullableTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.nullableTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "NumberLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.numberLiteral;
    }, "get")
  });
  Object.defineProperty(w, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.numberLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "NumberTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.numberTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "NumericLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.numericLiteral;
    }, "get")
  });
  Object.defineProperty(w, "ObjectExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.objectExpression;
    }, "get")
  });
  Object.defineProperty(w, "ObjectMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.objectMethod;
    }, "get")
  });
  Object.defineProperty(w, "ObjectPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.objectPattern;
    }, "get")
  });
  Object.defineProperty(w, "ObjectProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.objectProperty;
    }, "get")
  });
  Object.defineProperty(w, "ObjectTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.objectTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "ObjectTypeCallProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.objectTypeCallProperty;
    }, "get")
  });
  Object.defineProperty(w, "ObjectTypeIndexer", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.objectTypeIndexer;
    }, "get")
  });
  Object.defineProperty(w, "ObjectTypeInternalSlot", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.objectTypeInternalSlot;
    }, "get")
  });
  Object.defineProperty(w, "ObjectTypeProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.objectTypeProperty;
    }, "get")
  });
  Object.defineProperty(w, "ObjectTypeSpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.objectTypeSpreadProperty;
    }, "get")
  });
  Object.defineProperty(w, "OpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.opaqueType;
    }, "get")
  });
  Object.defineProperty(w, "OptionalCallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.optionalCallExpression;
    }, "get")
  });
  Object.defineProperty(w, "OptionalIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.optionalIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(w, "OptionalMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.optionalMemberExpression;
    }, "get")
  });
  Object.defineProperty(w, "ParenthesizedExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.parenthesizedExpression;
    }, "get")
  });
  Object.defineProperty(w, "PipelineBareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.pipelineBareFunction;
    }, "get")
  });
  Object.defineProperty(w, "PipelinePrimaryTopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.pipelinePrimaryTopicReference;
    }, "get")
  });
  Object.defineProperty(w, "PipelineTopicExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.pipelineTopicExpression;
    }, "get")
  });
  Object.defineProperty(w, "Placeholder", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.placeholder;
    }, "get")
  });
  Object.defineProperty(w, "PrivateName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.privateName;
    }, "get")
  });
  Object.defineProperty(w, "Program", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.program;
    }, "get")
  });
  Object.defineProperty(w, "QualifiedTypeIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.qualifiedTypeIdentifier;
    }, "get")
  });
  Object.defineProperty(w, "RecordExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.recordExpression;
    }, "get")
  });
  Object.defineProperty(w, "RegExpLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.regExpLiteral;
    }, "get")
  });
  Object.defineProperty(w, "RegexLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.regexLiteral;
    }, "get")
  });
  Object.defineProperty(w, "RestElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.restElement;
    }, "get")
  });
  Object.defineProperty(w, "RestProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.restProperty;
    }, "get")
  });
  Object.defineProperty(w, "ReturnStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.returnStatement;
    }, "get")
  });
  Object.defineProperty(w, "SequenceExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.sequenceExpression;
    }, "get")
  });
  Object.defineProperty(w, "SpreadElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.spreadElement;
    }, "get")
  });
  Object.defineProperty(w, "SpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.spreadProperty;
    }, "get")
  });
  Object.defineProperty(w, "StaticBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.staticBlock;
    }, "get")
  });
  Object.defineProperty(w, "StringLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.stringLiteral;
    }, "get")
  });
  Object.defineProperty(w, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.stringLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "StringTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.stringTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "Super", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.super;
    }, "get")
  });
  Object.defineProperty(w, "SwitchCase", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.switchCase;
    }, "get")
  });
  Object.defineProperty(w, "SwitchStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.switchStatement;
    }, "get")
  });
  Object.defineProperty(w, "SymbolTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.symbolTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "TSAnyKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsAnyKeyword;
    }, "get")
  });
  Object.defineProperty(w, "TSArrayType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsArrayType;
    }, "get")
  });
  Object.defineProperty(w, "TSAsExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsAsExpression;
    }, "get")
  });
  Object.defineProperty(w, "TSBigIntKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsBigIntKeyword;
    }, "get")
  });
  Object.defineProperty(w, "TSBooleanKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsBooleanKeyword;
    }, "get")
  });
  Object.defineProperty(w, "TSCallSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsCallSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "TSConditionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsConditionalType;
    }, "get")
  });
  Object.defineProperty(w, "TSConstructSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsConstructSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "TSConstructorType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsConstructorType;
    }, "get")
  });
  Object.defineProperty(w, "TSDeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsDeclareFunction;
    }, "get")
  });
  Object.defineProperty(w, "TSDeclareMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsDeclareMethod;
    }, "get")
  });
  Object.defineProperty(w, "TSEnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsEnumDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "TSEnumMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsEnumMember;
    }, "get")
  });
  Object.defineProperty(w, "TSExportAssignment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsExportAssignment;
    }, "get")
  });
  Object.defineProperty(w, "TSExpressionWithTypeArguments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsExpressionWithTypeArguments;
    }, "get")
  });
  Object.defineProperty(w, "TSExternalModuleReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsExternalModuleReference;
    }, "get")
  });
  Object.defineProperty(w, "TSFunctionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsFunctionType;
    }, "get")
  });
  Object.defineProperty(w, "TSImportEqualsDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsImportEqualsDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "TSImportType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsImportType;
    }, "get")
  });
  Object.defineProperty(w, "TSIndexSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsIndexSignature;
    }, "get")
  });
  Object.defineProperty(w, "TSIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(w, "TSInferType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsInferType;
    }, "get")
  });
  Object.defineProperty(w, "TSInstantiationExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsInstantiationExpression;
    }, "get")
  });
  Object.defineProperty(w, "TSInterfaceBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsInterfaceBody;
    }, "get")
  });
  Object.defineProperty(w, "TSInterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsInterfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "TSIntersectionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsIntersectionType;
    }, "get")
  });
  Object.defineProperty(w, "TSIntrinsicKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsIntrinsicKeyword;
    }, "get")
  });
  Object.defineProperty(w, "TSLiteralType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsLiteralType;
    }, "get")
  });
  Object.defineProperty(w, "TSMappedType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsMappedType;
    }, "get")
  });
  Object.defineProperty(w, "TSMethodSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsMethodSignature;
    }, "get")
  });
  Object.defineProperty(w, "TSModuleBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsModuleBlock;
    }, "get")
  });
  Object.defineProperty(w, "TSModuleDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsModuleDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "TSNamedTupleMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsNamedTupleMember;
    }, "get")
  });
  Object.defineProperty(w, "TSNamespaceExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsNamespaceExportDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "TSNeverKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsNeverKeyword;
    }, "get")
  });
  Object.defineProperty(w, "TSNonNullExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsNonNullExpression;
    }, "get")
  });
  Object.defineProperty(w, "TSNullKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsNullKeyword;
    }, "get")
  });
  Object.defineProperty(w, "TSNumberKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsNumberKeyword;
    }, "get")
  });
  Object.defineProperty(w, "TSObjectKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsObjectKeyword;
    }, "get")
  });
  Object.defineProperty(w, "TSOptionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsOptionalType;
    }, "get")
  });
  Object.defineProperty(w, "TSParameterProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsParameterProperty;
    }, "get")
  });
  Object.defineProperty(w, "TSParenthesizedType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsParenthesizedType;
    }, "get")
  });
  Object.defineProperty(w, "TSPropertySignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsPropertySignature;
    }, "get")
  });
  Object.defineProperty(w, "TSQualifiedName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsQualifiedName;
    }, "get")
  });
  Object.defineProperty(w, "TSRestType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsRestType;
    }, "get")
  });
  Object.defineProperty(w, "TSSatisfiesExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsSatisfiesExpression;
    }, "get")
  });
  Object.defineProperty(w, "TSStringKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsStringKeyword;
    }, "get")
  });
  Object.defineProperty(w, "TSSymbolKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsSymbolKeyword;
    }, "get")
  });
  Object.defineProperty(w, "TSThisType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsThisType;
    }, "get")
  });
  Object.defineProperty(w, "TSTupleType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsTupleType;
    }, "get")
  });
  Object.defineProperty(w, "TSTypeAliasDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsTypeAliasDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "TSTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "TSTypeAssertion", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsTypeAssertion;
    }, "get")
  });
  Object.defineProperty(w, "TSTypeLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsTypeLiteral;
    }, "get")
  });
  Object.defineProperty(w, "TSTypeOperator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsTypeOperator;
    }, "get")
  });
  Object.defineProperty(w, "TSTypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsTypeParameter;
    }, "get")
  });
  Object.defineProperty(w, "TSTypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsTypeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "TSTypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsTypeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(w, "TSTypePredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsTypePredicate;
    }, "get")
  });
  Object.defineProperty(w, "TSTypeQuery", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsTypeQuery;
    }, "get")
  });
  Object.defineProperty(w, "TSTypeReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsTypeReference;
    }, "get")
  });
  Object.defineProperty(w, "TSUndefinedKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsUndefinedKeyword;
    }, "get")
  });
  Object.defineProperty(w, "TSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsUnionType;
    }, "get")
  });
  Object.defineProperty(w, "TSUnknownKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsUnknownKeyword;
    }, "get")
  });
  Object.defineProperty(w, "TSVoidKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tsVoidKeyword;
    }, "get")
  });
  Object.defineProperty(w, "TaggedTemplateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.taggedTemplateExpression;
    }, "get")
  });
  Object.defineProperty(w, "TemplateElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.templateElement;
    }, "get")
  });
  Object.defineProperty(w, "TemplateLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.templateLiteral;
    }, "get")
  });
  Object.defineProperty(w, "ThisExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.thisExpression;
    }, "get")
  });
  Object.defineProperty(w, "ThisTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.thisTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "ThrowStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.throwStatement;
    }, "get")
  });
  Object.defineProperty(w, "TopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.topicReference;
    }, "get")
  });
  Object.defineProperty(w, "TryStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tryStatement;
    }, "get")
  });
  Object.defineProperty(w, "TupleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tupleExpression;
    }, "get")
  });
  Object.defineProperty(w, "TupleTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.tupleTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "TypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.typeAlias;
    }, "get")
  });
  Object.defineProperty(w, "TypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.typeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "TypeCastExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.typeCastExpression;
    }, "get")
  });
  Object.defineProperty(w, "TypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.typeParameter;
    }, "get")
  });
  Object.defineProperty(w, "TypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.typeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "TypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.typeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(w, "TypeofTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.typeofTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "UnaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.unaryExpression;
    }, "get")
  });
  Object.defineProperty(w, "UnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.unionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "UpdateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.updateExpression;
    }, "get")
  });
  Object.defineProperty(w, "V8IntrinsicIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.v8IntrinsicIdentifier;
    }, "get")
  });
  Object.defineProperty(w, "VariableDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.variableDeclaration;
    }, "get")
  });
  Object.defineProperty(w, "VariableDeclarator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.variableDeclarator;
    }, "get")
  });
  Object.defineProperty(w, "Variance", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.variance;
    }, "get")
  });
  Object.defineProperty(w, "VoidTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.voidTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(w, "WhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.whileStatement;
    }, "get")
  });
  Object.defineProperty(w, "WithStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.withStatement;
    }, "get")
  });
  Object.defineProperty(w, "YieldExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return D.yieldExpression;
    }, "get")
  });
  var D = sr();
});

// ../node_modules/@babel/types/lib/builders/productions.js
var qp = T((Rp) => {
  "use strict";
  Object.defineProperty(Rp, "__esModule", {
    value: !0
  });
  Rp.buildUndefinedNode = BV;
  var JE = sr();
  function BV() {
    return (0, JE.unaryExpression)("void", (0, JE.numericLiteral)(0), !0);
  }
  s(BV, "buildUndefinedNode");
});

// ../node_modules/@babel/types/lib/clone/cloneNode.js
var es = T((Vp) => {
  "use strict";
  Object.defineProperty(Vp, "__esModule", {
    value: !0
  });
  Vp.default = kV;
  var XE = Cr(), QE = Tt(), {
    hasOwn: ln
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function ZE(e, t, r, n) {
    return e && typeof e.type == "string" ? ev(e, t, r, n) : e;
  }
  s(ZE, "cloneIfNode");
  function Up(e, t, r, n) {
    return Array.isArray(e) ? e.map((i) => ZE(i, t, r, n)) : ZE(e, t, r, n);
  }
  s(Up, "cloneIfNodeOrArray");
  function kV(e, t = !0, r = !1) {
    return ev(e, t, r, /* @__PURE__ */ new Map());
  }
  s(kV, "cloneNode");
  function ev(e, t = !0, r = !1, n) {
    if (!e) return e;
    let {
      type: i
    } = e, a = {
      type: e.type
    };
    if ((0, QE.isIdentifier)(e))
      a.name = e.name, ln(e, "optional") && typeof e.optional == "boolean" && (a.optional = e.optional), ln(e, "typeAnnotation") && (a.typeAnnotation =
      t ? Up(e.typeAnnotation, !0, r, n) : e.typeAnnotation), ln(e, "decorators") && (a.decorators = t ? Up(e.decorators, !0, r, n) : e.decorators);
    else if (ln(XE.NODE_FIELDS, i))
      for (let o of Object.keys(XE.NODE_FIELDS[i]))
        ln(e, o) && (t ? a[o] = (0, QE.isFile)(e) && o === "comments" ? Al(e.comments, t, r, n) : Up(e[o], !0, r, n) : a[o] = e[o]);
    else
      throw new Error(`Unknown node type: "${i}"`);
    return ln(e, "loc") && (r ? a.loc = null : a.loc = e.loc), ln(e, "leadingComments") && (a.leadingComments = Al(e.leadingComments, t, r, n)),
    ln(e, "innerComments") && (a.innerComments = Al(e.innerComments, t, r, n)), ln(e, "trailingComments") && (a.trailingComments = Al(e.trailingComments,
    t, r, n)), ln(e, "extra") && (a.extra = Object.assign({}, e.extra)), a;
  }
  s(ev, "cloneNodeInternal");
  function Al(e, t, r, n) {
    return !e || !t ? e : e.map((i) => {
      let a = n.get(i);
      if (a) return a;
      let {
        type: o,
        value: l,
        loc: u
      } = i, c = {
        type: o,
        value: l,
        loc: u
      };
      return r && (c.loc = null), n.set(i, c), c;
    });
  }
  s(Al, "maybeCloneComments");
});

// ../node_modules/@babel/types/lib/clone/clone.js
var tv = T(($p) => {
  "use strict";
  Object.defineProperty($p, "__esModule", {
    value: !0
  });
  $p.default = jV;
  var FV = es();
  function jV(e) {
    return (0, FV.default)(e, !1);
  }
  s(jV, "clone");
});

// ../node_modules/@babel/types/lib/clone/cloneDeep.js
var rv = T((Wp) => {
  "use strict";
  Object.defineProperty(Wp, "__esModule", {
    value: !0
  });
  Wp.default = MV;
  var LV = es();
  function MV(e) {
    return (0, LV.default)(e);
  }
  s(MV, "cloneDeep");
});

// ../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var nv = T((Kp) => {
  "use strict";
  Object.defineProperty(Kp, "__esModule", {
    value: !0
  });
  Kp.default = qV;
  var RV = es();
  function qV(e) {
    return (0, RV.default)(e, !0, !0);
  }
  s(qV, "cloneDeepWithoutLoc");
});

// ../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var sv = T((Gp) => {
  "use strict";
  Object.defineProperty(Gp, "__esModule", {
    value: !0
  });
  Gp.default = VV;
  var UV = es();
  function VV(e) {
    return (0, UV.default)(e, !1, !0);
  }
  s(VV, "cloneWithoutLoc");
});

// ../node_modules/@babel/types/lib/comments/addComments.js
var Yp = T((Hp) => {
  "use strict";
  Object.defineProperty(Hp, "__esModule", {
    value: !0
  });
  Hp.default = $V;
  function $V(e, t, r) {
    if (!r || !e) return e;
    let n = `${t}Comments`;
    return e[n] ? t === "leading" ? e[n] = r.concat(e[n]) : e[n].push(...r) : e[n] = r, e;
  }
  s($V, "addComments");
});

// ../node_modules/@babel/types/lib/comments/addComment.js
var iv = T((zp) => {
  "use strict";
  Object.defineProperty(zp, "__esModule", {
    value: !0
  });
  zp.default = KV;
  var WV = Yp();
  function KV(e, t, r, n) {
    return (0, WV.default)(e, t, [{
      type: n ? "CommentLine" : "CommentBlock",
      value: r
    }]);
  }
  s(KV, "addComment");
});

// ../node_modules/@babel/types/lib/utils/inherit.js
var Cl = T((Jp) => {
  "use strict";
  Object.defineProperty(Jp, "__esModule", {
    value: !0
  });
  Jp.default = GV;
  function GV(e, t, r) {
    t && r && (t[e] = Array.from(new Set([].concat(t[e], r[e]).filter(Boolean))));
  }
  s(GV, "inherit");
});

// ../node_modules/@babel/types/lib/comments/inheritInnerComments.js
var Qp = T((Xp) => {
  "use strict";
  Object.defineProperty(Xp, "__esModule", {
    value: !0
  });
  Xp.default = YV;
  var HV = Cl();
  function YV(e, t) {
    (0, HV.default)("innerComments", e, t);
  }
  s(YV, "inheritInnerComments");
});

// ../node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var ed = T((Zp) => {
  "use strict";
  Object.defineProperty(Zp, "__esModule", {
    value: !0
  });
  Zp.default = JV;
  var zV = Cl();
  function JV(e, t) {
    (0, zV.default)("leadingComments", e, t);
  }
  s(JV, "inheritLeadingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var rd = T((td) => {
  "use strict";
  Object.defineProperty(td, "__esModule", {
    value: !0
  });
  td.default = QV;
  var XV = Cl();
  function QV(e, t) {
    (0, XV.default)("trailingComments", e, t);
  }
  s(QV, "inheritTrailingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritsComments.js
var sd = T((nd) => {
  "use strict";
  Object.defineProperty(nd, "__esModule", {
    value: !0
  });
  nd.default = r$;
  var ZV = rd(), e$ = ed(), t$ = Qp();
  function r$(e, t) {
    return (0, ZV.default)(e, t), (0, e$.default)(e, t), (0, t$.default)(e, t), e;
  }
  s(r$, "inheritsComments");
});

// ../node_modules/@babel/types/lib/comments/removeComments.js
var av = T((id) => {
  "use strict";
  Object.defineProperty(id, "__esModule", {
    value: !0
  });
  id.default = s$;
  var n$ = Xn();
  function s$(e) {
    return n$.COMMENT_KEYS.forEach((t) => {
      e[t] = null;
    }), e;
  }
  s(s$, "removeComments");
});

// ../node_modules/@babel/types/lib/constants/generated/index.js
var ov = T((z) => {
  "use strict";
  Object.defineProperty(z, "__esModule", {
    value: !0
  });
  z.WHILE_TYPES = z.USERWHITESPACABLE_TYPES = z.UNARYLIKE_TYPES = z.TYPESCRIPT_TYPES = z.TSTYPE_TYPES = z.TSTYPEELEMENT_TYPES = z.TSENTITYNAME_TYPES =
  z.TSBASETYPE_TYPES = z.TERMINATORLESS_TYPES = z.STATEMENT_TYPES = z.STANDARDIZED_TYPES = z.SCOPABLE_TYPES = z.PUREISH_TYPES = z.PROPERTY_TYPES =
  z.PRIVATE_TYPES = z.PATTERN_TYPES = z.PATTERNLIKE_TYPES = z.OBJECTMEMBER_TYPES = z.MODULESPECIFIER_TYPES = z.MODULEDECLARATION_TYPES = z.MISCELLANEOUS_TYPES =
  z.METHOD_TYPES = z.LVAL_TYPES = z.LOOP_TYPES = z.LITERAL_TYPES = z.JSX_TYPES = z.IMPORTOREXPORTDECLARATION_TYPES = z.IMMUTABLE_TYPES = z.FUNCTION_TYPES =
  z.FUNCTIONPARENT_TYPES = z.FOR_TYPES = z.FORXSTATEMENT_TYPES = z.FLOW_TYPES = z.FLOWTYPE_TYPES = z.FLOWPREDICATE_TYPES = z.FLOWDECLARATION_TYPES =
  z.FLOWBASEANNOTATION_TYPES = z.EXPRESSION_TYPES = z.EXPRESSIONWRAPPER_TYPES = z.EXPORTDECLARATION_TYPES = z.ENUMMEMBER_TYPES = z.ENUMBODY_TYPES =
  z.DECLARATION_TYPES = z.CONDITIONAL_TYPES = z.COMPLETIONSTATEMENT_TYPES = z.CLASS_TYPES = z.BLOCK_TYPES = z.BLOCKPARENT_TYPES = z.BINARY_TYPES =
  z.ACCESSOR_TYPES = void 0;
  var _e = Cr(), aTe = z.STANDARDIZED_TYPES = _e.FLIPPED_ALIAS_KEYS.Standardized, oTe = z.EXPRESSION_TYPES = _e.FLIPPED_ALIAS_KEYS.Expression,
  lTe = z.BINARY_TYPES = _e.FLIPPED_ALIAS_KEYS.Binary, uTe = z.SCOPABLE_TYPES = _e.FLIPPED_ALIAS_KEYS.Scopable, cTe = z.BLOCKPARENT_TYPES = _e.
  FLIPPED_ALIAS_KEYS.BlockParent, fTe = z.BLOCK_TYPES = _e.FLIPPED_ALIAS_KEYS.Block, pTe = z.STATEMENT_TYPES = _e.FLIPPED_ALIAS_KEYS.Statement,
  dTe = z.TERMINATORLESS_TYPES = _e.FLIPPED_ALIAS_KEYS.Terminatorless, hTe = z.COMPLETIONSTATEMENT_TYPES = _e.FLIPPED_ALIAS_KEYS.CompletionStatement,
  mTe = z.CONDITIONAL_TYPES = _e.FLIPPED_ALIAS_KEYS.Conditional, yTe = z.LOOP_TYPES = _e.FLIPPED_ALIAS_KEYS.Loop, gTe = z.WHILE_TYPES = _e.FLIPPED_ALIAS_KEYS.
  While, bTe = z.EXPRESSIONWRAPPER_TYPES = _e.FLIPPED_ALIAS_KEYS.ExpressionWrapper, ETe = z.FOR_TYPES = _e.FLIPPED_ALIAS_KEYS.For, vTe = z.FORXSTATEMENT_TYPES =
  _e.FLIPPED_ALIAS_KEYS.ForXStatement, TTe = z.FUNCTION_TYPES = _e.FLIPPED_ALIAS_KEYS.Function, xTe = z.FUNCTIONPARENT_TYPES = _e.FLIPPED_ALIAS_KEYS.
  FunctionParent, STe = z.PUREISH_TYPES = _e.FLIPPED_ALIAS_KEYS.Pureish, PTe = z.DECLARATION_TYPES = _e.FLIPPED_ALIAS_KEYS.Declaration, ATe = z.
  PATTERNLIKE_TYPES = _e.FLIPPED_ALIAS_KEYS.PatternLike, CTe = z.LVAL_TYPES = _e.FLIPPED_ALIAS_KEYS.LVal, wTe = z.TSENTITYNAME_TYPES = _e.FLIPPED_ALIAS_KEYS.
  TSEntityName, DTe = z.LITERAL_TYPES = _e.FLIPPED_ALIAS_KEYS.Literal, ITe = z.IMMUTABLE_TYPES = _e.FLIPPED_ALIAS_KEYS.Immutable, _Te = z.USERWHITESPACABLE_TYPES =
  _e.FLIPPED_ALIAS_KEYS.UserWhitespacable, OTe = z.METHOD_TYPES = _e.FLIPPED_ALIAS_KEYS.Method, NTe = z.OBJECTMEMBER_TYPES = _e.FLIPPED_ALIAS_KEYS.
  ObjectMember, BTe = z.PROPERTY_TYPES = _e.FLIPPED_ALIAS_KEYS.Property, kTe = z.UNARYLIKE_TYPES = _e.FLIPPED_ALIAS_KEYS.UnaryLike, FTe = z.
  PATTERN_TYPES = _e.FLIPPED_ALIAS_KEYS.Pattern, jTe = z.CLASS_TYPES = _e.FLIPPED_ALIAS_KEYS.Class, i$ = z.IMPORTOREXPORTDECLARATION_TYPES =
  _e.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration, LTe = z.EXPORTDECLARATION_TYPES = _e.FLIPPED_ALIAS_KEYS.ExportDeclaration, MTe = z.MODULESPECIFIER_TYPES =
  _e.FLIPPED_ALIAS_KEYS.ModuleSpecifier, RTe = z.ACCESSOR_TYPES = _e.FLIPPED_ALIAS_KEYS.Accessor, qTe = z.PRIVATE_TYPES = _e.FLIPPED_ALIAS_KEYS.
  Private, UTe = z.FLOW_TYPES = _e.FLIPPED_ALIAS_KEYS.Flow, VTe = z.FLOWTYPE_TYPES = _e.FLIPPED_ALIAS_KEYS.FlowType, $Te = z.FLOWBASEANNOTATION_TYPES =
  _e.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, WTe = z.FLOWDECLARATION_TYPES = _e.FLIPPED_ALIAS_KEYS.FlowDeclaration, KTe = z.FLOWPREDICATE_TYPES =
  _e.FLIPPED_ALIAS_KEYS.FlowPredicate, GTe = z.ENUMBODY_TYPES = _e.FLIPPED_ALIAS_KEYS.EnumBody, HTe = z.ENUMMEMBER_TYPES = _e.FLIPPED_ALIAS_KEYS.
  EnumMember, YTe = z.JSX_TYPES = _e.FLIPPED_ALIAS_KEYS.JSX, zTe = z.MISCELLANEOUS_TYPES = _e.FLIPPED_ALIAS_KEYS.Miscellaneous, JTe = z.TYPESCRIPT_TYPES =
  _e.FLIPPED_ALIAS_KEYS.TypeScript, XTe = z.TSTYPEELEMENT_TYPES = _e.FLIPPED_ALIAS_KEYS.TSTypeElement, QTe = z.TSTYPE_TYPES = _e.FLIPPED_ALIAS_KEYS.
  TSType, ZTe = z.TSBASETYPE_TYPES = _e.FLIPPED_ALIAS_KEYS.TSBaseType, exe = z.MODULEDECLARATION_TYPES = i$;
});

// ../node_modules/@babel/types/lib/converters/toBlock.js
var ld = T((od) => {
  "use strict";
  Object.defineProperty(od, "__esModule", {
    value: !0
  });
  od.default = a$;
  var wl = Tt(), ad = sr();
  function a$(e, t) {
    if ((0, wl.isBlockStatement)(e))
      return e;
    let r = [];
    return (0, wl.isEmptyStatement)(e) ? r = [] : ((0, wl.isStatement)(e) || ((0, wl.isFunction)(t) ? e = (0, ad.returnStatement)(e) : e = (0, ad.
    expressionStatement)(e)), r = [e]), (0, ad.blockStatement)(r);
  }
  s(a$, "toBlock");
});

// ../node_modules/@babel/types/lib/converters/ensureBlock.js
var lv = T((ud) => {
  "use strict";
  Object.defineProperty(ud, "__esModule", {
    value: !0
  });
  ud.default = l$;
  var o$ = ld();
  function l$(e, t = "body") {
    let r = (0, o$.default)(e[t], e);
    return e[t] = r, r;
  }
  s(l$, "ensureBlock");
});

// ../node_modules/@babel/types/lib/converters/toIdentifier.js
var fd = T((cd) => {
  "use strict";
  Object.defineProperty(cd, "__esModule", {
    value: !0
  });
  cd.default = f$;
  var u$ = bi(), c$ = gi();
  function f$(e) {
    e = e + "";
    let t = "";
    for (let r of e)
      t += (0, c$.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
    return t = t.replace(/^[-0-9]+/, ""), t = t.replace(/[-\s]+(.)?/g, function(r, n) {
      return n ? n.toUpperCase() : "";
    }), (0, u$.default)(t) || (t = `_${t}`), t || "_";
  }
  s(f$, "toIdentifier");
});

// ../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var uv = T((pd) => {
  "use strict";
  Object.defineProperty(pd, "__esModule", {
    value: !0
  });
  pd.default = d$;
  var p$ = fd();
  function d$(e) {
    return e = (0, p$.default)(e), (e === "eval" || e === "arguments") && (e = "_" + e), e;
  }
  s(d$, "toBindingIdentifierName");
});

// ../node_modules/@babel/types/lib/converters/toComputedKey.js
var cv = T((dd) => {
  "use strict";
  Object.defineProperty(dd, "__esModule", {
    value: !0
  });
  dd.default = y$;
  var h$ = Tt(), m$ = sr();
  function y$(e, t = e.key || e.property) {
    return !e.computed && (0, h$.isIdentifier)(t) && (t = (0, m$.stringLiteral)(t.name)), t;
  }
  s(y$, "toComputedKey");
});

// ../node_modules/@babel/types/lib/converters/toExpression.js
var fv = T((Dl) => {
  "use strict";
  Object.defineProperty(Dl, "__esModule", {
    value: !0
  });
  Dl.default = void 0;
  var Ra = Tt(), pxe = Dl.default = g$;
  function g$(e) {
    if ((0, Ra.isExpressionStatement)(e) && (e = e.expression), (0, Ra.isExpression)(e))
      return e;
    if ((0, Ra.isClass)(e) ? e.type = "ClassExpression" : (0, Ra.isFunction)(e) && (e.type = "FunctionExpression"), !(0, Ra.isExpression)(e))
      throw new Error(`cannot turn ${e.type} to an expression`);
    return e;
  }
  s(g$, "toExpression");
});

// ../node_modules/@babel/types/lib/traverse/traverseFast.js
var yd = T((md) => {
  "use strict";
  Object.defineProperty(md, "__esModule", {
    value: !0
  });
  md.default = hd;
  var b$ = Cr();
  function hd(e, t, r) {
    if (!e) return;
    let n = b$.VISITOR_KEYS[e.type];
    if (n) {
      r = r || {}, t(e, r);
      for (let i of n) {
        let a = e[i];
        if (Array.isArray(a))
          for (let o of a)
            hd(o, t, r);
        else
          hd(a, t, r);
      }
    }
  }
  s(hd, "traverseFast");
});

// ../node_modules/@babel/types/lib/modifications/removeProperties.js
var bd = T((gd) => {
  "use strict";
  Object.defineProperty(gd, "__esModule", {
    value: !0
  });
  gd.default = T$;
  var E$ = Xn(), pv = ["tokens", "start", "end", "loc", "raw", "rawValue"], v$ = [...E$.COMMENT_KEYS, "comments", ...pv];
  function T$(e, t = {}) {
    let r = t.preserveComments ? pv : v$;
    for (let i of r)
      e[i] != null && (e[i] = void 0);
    for (let i of Object.keys(e))
      i[0] === "_" && e[i] != null && (e[i] = void 0);
    let n = Object.getOwnPropertySymbols(e);
    for (let i of n)
      e[i] = null;
  }
  s(T$, "removeProperties");
});

// ../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var vd = T((Ed) => {
  "use strict";
  Object.defineProperty(Ed, "__esModule", {
    value: !0
  });
  Ed.default = P$;
  var x$ = yd(), S$ = bd();
  function P$(e, t) {
    return (0, x$.default)(e, S$.default, t), e;
  }
  s(P$, "removePropertiesDeep");
});

// ../node_modules/@babel/types/lib/converters/toKeyAlias.js
var hv = T((Td) => {
  "use strict";
  Object.defineProperty(Td, "__esModule", {
    value: !0
  });
  Td.default = Ns;
  var dv = Tt(), A$ = es(), C$ = vd();
  function Ns(e, t = e.key) {
    let r;
    return e.kind === "method" ? Ns.increment() + "" : ((0, dv.isIdentifier)(t) ? r = t.name : (0, dv.isStringLiteral)(t) ? r = JSON.stringify(
    t.value) : r = JSON.stringify((0, C$.default)((0, A$.default)(t))), e.computed && (r = `[${r}]`), e.static && (r = `static:${r}`), r);
  }
  s(Ns, "toKeyAlias");
  Ns.uid = 0;
  Ns.increment = function() {
    return Ns.uid >= Number.MAX_SAFE_INTEGER ? Ns.uid = 0 : Ns.uid++;
  };
});

// ../node_modules/@babel/types/lib/converters/toStatement.js
var mv = T((_l) => {
  "use strict";
  Object.defineProperty(_l, "__esModule", {
    value: !0
  });
  _l.default = void 0;
  var Il = Tt(), w$ = sr(), Sxe = _l.default = D$;
  function D$(e, t) {
    if ((0, Il.isStatement)(e))
      return e;
    let r = !1, n;
    if ((0, Il.isClass)(e))
      r = !0, n = "ClassDeclaration";
    else if ((0, Il.isFunction)(e))
      r = !0, n = "FunctionDeclaration";
    else if ((0, Il.isAssignmentExpression)(e))
      return (0, w$.expressionStatement)(e);
    if (r && !e.id && (n = !1), !n) {
      if (t)
        return !1;
      throw new Error(`cannot turn ${e.type} to a statement`);
    }
    return e.type = n, e;
  }
  s(D$, "toStatement");
});

// ../node_modules/@babel/types/lib/converters/valueToNode.js
var yv = T((Ol) => {
  "use strict";
  Object.defineProperty(Ol, "__esModule", {
    value: !0
  });
  Ol.default = void 0;
  var I$ = bi(), Ht = sr(), Cxe = Ol.default = xd, _$ = Function.call.bind(Object.prototype.toString);
  function O$(e) {
    return _$(e) === "[object RegExp]";
  }
  s(O$, "isRegExp");
  function N$(e) {
    if (typeof e != "object" || e === null || Object.prototype.toString.call(e) !== "[object Object]")
      return !1;
    let t = Object.getPrototypeOf(e);
    return t === null || Object.getPrototypeOf(t) === null;
  }
  s(N$, "isPlainObject");
  function xd(e) {
    if (e === void 0)
      return (0, Ht.identifier)("undefined");
    if (e === !0 || e === !1)
      return (0, Ht.booleanLiteral)(e);
    if (e === null)
      return (0, Ht.nullLiteral)();
    if (typeof e == "string")
      return (0, Ht.stringLiteral)(e);
    if (typeof e == "number") {
      let t;
      if (Number.isFinite(e))
        t = (0, Ht.numericLiteral)(Math.abs(e));
      else {
        let r;
        Number.isNaN(e) ? r = (0, Ht.numericLiteral)(0) : r = (0, Ht.numericLiteral)(1), t = (0, Ht.binaryExpression)("/", r, (0, Ht.numericLiteral)(
        0));
      }
      return (e < 0 || Object.is(e, -0)) && (t = (0, Ht.unaryExpression)("-", t)), t;
    }
    if (O$(e)) {
      let t = e.source, r = /\/([a-z]*)$/.exec(e.toString())[1];
      return (0, Ht.regExpLiteral)(t, r);
    }
    if (Array.isArray(e))
      return (0, Ht.arrayExpression)(e.map(xd));
    if (N$(e)) {
      let t = [];
      for (let r of Object.keys(e)) {
        let n;
        (0, I$.default)(r) ? n = (0, Ht.identifier)(r) : n = (0, Ht.stringLiteral)(r), t.push((0, Ht.objectProperty)(n, xd(e[r])));
      }
      return (0, Ht.objectExpression)(t);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  s(xd, "valueToNode");
});

// ../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var gv = T((Sd) => {
  "use strict";
  Object.defineProperty(Sd, "__esModule", {
    value: !0
  });
  Sd.default = k$;
  var B$ = sr();
  function k$(e, t, r = !1) {
    return e.object = (0, B$.memberExpression)(e.object, e.property, e.computed), e.property = t, e.computed = !!r, e;
  }
  s(k$, "appendToMemberExpression");
});

// ../node_modules/@babel/types/lib/modifications/inherits.js
var Ev = T((Pd) => {
  "use strict";
  Object.defineProperty(Pd, "__esModule", {
    value: !0
  });
  Pd.default = j$;
  var bv = Xn(), F$ = sd();
  function j$(e, t) {
    if (!e || !t) return e;
    for (let r of bv.INHERIT_KEYS.optional)
      e[r] == null && (e[r] = t[r]);
    for (let r of Object.keys(t))
      r[0] === "_" && r !== "__clone" && (e[r] = t[r]);
    for (let r of bv.INHERIT_KEYS.force)
      e[r] = t[r];
    return (0, F$.default)(e, t), e;
  }
  s(j$, "inherits");
});

// ../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var vv = T((Ad) => {
  "use strict";
  Object.defineProperty(Ad, "__esModule", {
    value: !0
  });
  Ad.default = R$;
  var L$ = sr(), M$ = Pe();
  function R$(e, t) {
    if ((0, M$.isSuper)(e.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return e.object = (0, L$.memberExpression)(t, e.object), e;
  }
  s(R$, "prependToMemberExpression");
});

// ../node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js
var Tv = T((Cd) => {
  "use strict";
  Object.defineProperty(Cd, "__esModule", {
    value: !0
  });
  Cd.default = q$;
  function q$(e) {
    let t = [].concat(e), r = /* @__PURE__ */ Object.create(null);
    for (; t.length; ) {
      let n = t.pop();
      if (n)
        switch (n.type) {
          case "ArrayPattern":
            t.push(...n.elements);
            break;
          case "AssignmentExpression":
          case "AssignmentPattern":
          case "ForInStatement":
          case "ForOfStatement":
            t.push(n.left);
            break;
          case "ObjectPattern":
            t.push(...n.properties);
            break;
          case "ObjectProperty":
            t.push(n.value);
            break;
          case "RestElement":
          case "UpdateExpression":
            t.push(n.argument);
            break;
          case "UnaryExpression":
            n.operator === "delete" && t.push(n.argument);
            break;
          case "Identifier":
            r[n.name] = n;
            break;
          default:
            break;
        }
    }
    return r;
  }
  s(q$, "getAssignmentIdentifiers");
});

// ../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var qa = T((Dd) => {
  "use strict";
  Object.defineProperty(Dd, "__esModule", {
    value: !0
  });
  Dd.default = wd;
  var Sn = Tt();
  function wd(e, t, r, n) {
    let i = [].concat(e), a = /* @__PURE__ */ Object.create(null);
    for (; i.length; ) {
      let o = i.shift();
      if (!o || n && ((0, Sn.isAssignmentExpression)(o) || (0, Sn.isUnaryExpression)(o) || (0, Sn.isUpdateExpression)(o)))
        continue;
      if ((0, Sn.isIdentifier)(o)) {
        t ? (a[o.name] = a[o.name] || []).push(o) : a[o.name] = o;
        continue;
      }
      if ((0, Sn.isExportDeclaration)(o) && !(0, Sn.isExportAllDeclaration)(o)) {
        (0, Sn.isDeclaration)(o.declaration) && i.push(o.declaration);
        continue;
      }
      if (r) {
        if ((0, Sn.isFunctionDeclaration)(o)) {
          i.push(o.id);
          continue;
        }
        if ((0, Sn.isFunctionExpression)(o))
          continue;
      }
      let l = wd.keys[o.type];
      if (l)
        for (let u = 0; u < l.length; u++) {
          let c = l[u], f = o[c];
          f && (Array.isArray(f) ? i.push(...f) : i.push(f));
        }
    }
    return a;
  }
  s(wd, "getBindingIdentifiers");
  var U$ = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
  wd.keys = U$;
});

// ../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var xv = T((Nl) => {
  "use strict";
  Object.defineProperty(Nl, "__esModule", {
    value: !0
  });
  Nl.default = void 0;
  var V$ = qa(), Rxe = Nl.default = $$;
  function $$(e, t) {
    return (0, V$.default)(e, t, !0);
  }
  s($$, "getOuterBindingIdentifiers");
});

// ../node_modules/@babel/types/lib/retrievers/getFunctionName.js
var Pv = T((Id) => {
  "use strict";
  Object.defineProperty(Id, "__esModule", {
    value: !0
  });
  Id.default = K$;
  var wr = Tt();
  function W$(e) {
    return (0, wr.isNullLiteral)(e) ? "null" : (0, wr.isRegExpLiteral)(e) ? `/${e.pattern}/${e.flags}` : (0, wr.isTemplateLiteral)(e) ? e.quasis.
    map((t) => t.value.raw).join("") : e.value !== void 0 ? String(e.value) : null;
  }
  s(W$, "getNameFromLiteralId");
  function Sv(e) {
    if (!e.computed || (0, wr.isLiteral)(e.key))
      return e.key;
  }
  s(Sv, "getObjectMemberKey");
  function K$(e, t) {
    if ("id" in e && e.id)
      return {
        name: e.id.name,
        originalNode: e.id
      };
    let r = "", n;
    if ((0, wr.isObjectProperty)(t, {
      value: e
    }) ? n = Sv(t) : (0, wr.isObjectMethod)(e) || (0, wr.isClassMethod)(e) ? (n = Sv(e), e.kind === "get" ? r = "get " : e.kind === "set" &&
    (r = "set ")) : (0, wr.isVariableDeclarator)(t, {
      init: e
    }) ? n = t.id : (0, wr.isAssignmentExpression)(t, {
      operator: "=",
      right: e
    }) && (n = t.left), !n) return null;
    let i = (0, wr.isLiteral)(n) ? W$(n) : (0, wr.isIdentifier)(n) ? n.name : (0, wr.isPrivateName)(n) ? n.id.name : null;
    return i == null ? null : {
      name: r + i,
      originalNode: n
    };
  }
  s(K$, "getFunctionName");
});

// ../node_modules/@babel/types/lib/traverse/traverse.js
var Av = T((Od) => {
  "use strict";
  Object.defineProperty(Od, "__esModule", {
    value: !0
  });
  Od.default = H$;
  var G$ = Cr();
  function H$(e, t, r) {
    typeof t == "function" && (t = {
      enter: t
    });
    let {
      enter: n,
      exit: i
    } = t;
    _d(e, n, i, r, []);
  }
  s(H$, "traverse");
  function _d(e, t, r, n, i) {
    let a = G$.VISITOR_KEYS[e.type];
    if (a) {
      t && t(e, i, n);
      for (let o of a) {
        let l = e[o];
        if (Array.isArray(l))
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c && (i.push({
              node: e,
              key: o,
              index: u
            }), _d(c, t, r, n, i), i.pop());
          }
        else l && (i.push({
          node: e,
          key: o
        }), _d(l, t, r, n, i), i.pop());
      }
      r && r(e, i, n);
    }
  }
  s(_d, "traverseSimpleImpl");
});

// ../node_modules/@babel/types/lib/validators/isBinding.js
var Cv = T((Nd) => {
  "use strict";
  Object.defineProperty(Nd, "__esModule", {
    value: !0
  });
  Nd.default = z$;
  var Y$ = qa();
  function z$(e, t, r) {
    if (r && e.type === "Identifier" && t.type === "ObjectProperty" && r.type === "ObjectExpression")
      return !1;
    let n = Y$.default.keys[t.type];
    if (n)
      for (let i = 0; i < n.length; i++) {
        let a = n[i], o = t[a];
        if (Array.isArray(o)) {
          if (o.includes(e)) return !0;
        } else if (o === e) return !0;
      }
    return !1;
  }
  s(z$, "isBinding");
});

// ../node_modules/@babel/types/lib/validators/isLet.js
var kd = T((Bd) => {
  "use strict";
  Object.defineProperty(Bd, "__esModule", {
    value: !0
  });
  Bd.default = Q$;
  var J$ = Tt(), X$ = Xn();
  function Q$(e) {
    return (0, J$.isVariableDeclaration)(e) && (e.kind !== "var" || e[X$.BLOCK_SCOPED_SYMBOL]);
  }
  s(Q$, "isLet");
});

// ../node_modules/@babel/types/lib/validators/isBlockScoped.js
var Dv = T((Fd) => {
  "use strict";
  Object.defineProperty(Fd, "__esModule", {
    value: !0
  });
  Fd.default = eW;
  var wv = Tt(), Z$ = kd();
  function eW(e) {
    return (0, wv.isFunctionDeclaration)(e) || (0, wv.isClassDeclaration)(e) || (0, Z$.default)(e);
  }
  s(eW, "isBlockScoped");
});

// ../node_modules/@babel/types/lib/validators/isImmutable.js
var Iv = T((jd) => {
  "use strict";
  Object.defineProperty(jd, "__esModule", {
    value: !0
  });
  jd.default = nW;
  var tW = dl(), rW = Tt();
  function nW(e) {
    return (0, tW.default)(e.type, "Immutable") ? !0 : (0, rW.isIdentifier)(e) ? e.name === "undefined" : !1;
  }
  s(nW, "isImmutable");
});

// ../node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var Ov = T((Md) => {
  "use strict";
  Object.defineProperty(Md, "__esModule", {
    value: !0
  });
  Md.default = Ld;
  var _v = Cr();
  function Ld(e, t) {
    if (typeof e != "object" || typeof t != "object" || e == null || t == null)
      return e === t;
    if (e.type !== t.type)
      return !1;
    let r = Object.keys(_v.NODE_FIELDS[e.type] || e.type), n = _v.VISITOR_KEYS[e.type];
    for (let i of r) {
      let a = e[i], o = t[i];
      if (typeof a != typeof o)
        return !1;
      if (!(a == null && o == null)) {
        if (a == null || o == null)
          return !1;
        if (Array.isArray(a)) {
          if (!Array.isArray(o) || a.length !== o.length)
            return !1;
          for (let l = 0; l < a.length; l++)
            if (!Ld(a[l], o[l]))
              return !1;
          continue;
        }
        if (typeof a == "object" && !(n != null && n.includes(i))) {
          for (let l of Object.keys(a))
            if (a[l] !== o[l])
              return !1;
          continue;
        }
        if (!Ld(a, o))
          return !1;
      }
    }
    return !0;
  }
  s(Ld, "isNodesEquivalent");
});

// ../node_modules/@babel/types/lib/validators/isReferenced.js
var Nv = T((Rd) => {
  "use strict";
  Object.defineProperty(Rd, "__esModule", {
    value: !0
  });
  Rd.default = sW;
  function sW(e, t, r) {
    switch (t.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return t.property === e ? !!t.computed : t.object === e;
      case "JSXMemberExpression":
        return t.object === e;
      case "VariableDeclarator":
        return t.init === e;
      case "ArrowFunctionExpression":
        return t.body === e;
      case "PrivateName":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return t.key === e ? !!t.computed : !1;
      case "ObjectProperty":
        return t.key === e ? !!t.computed : !r || r.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return t.key === e ? !!t.computed : !0;
      case "ClassPrivateProperty":
        return t.key !== e;
      case "ClassDeclaration":
      case "ClassExpression":
        return t.superClass === e;
      case "AssignmentExpression":
        return t.right === e;
      case "AssignmentPattern":
        return t.right === e;
      case "LabeledStatement":
        return !1;
      case "CatchClause":
        return !1;
      case "RestElement":
        return !1;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return !1;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return !1;
      case "ExportSpecifier":
        return r != null && r.source ? !1 : t.local === e;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return !1;
      case "ImportAttribute":
        return !1;
      case "JSXAttribute":
        return !1;
      case "ObjectPattern":
      case "ArrayPattern":
        return !1;
      case "MetaProperty":
        return !1;
      case "ObjectTypeProperty":
        return t.key !== e;
      case "TSEnumMember":
        return t.id !== e;
      case "TSPropertySignature":
        return t.key === e ? !!t.computed : !0;
    }
    return !0;
  }
  s(sW, "isReferenced");
});

// ../node_modules/@babel/types/lib/validators/isScope.js
var Bv = T((qd) => {
  "use strict";
  Object.defineProperty(qd, "__esModule", {
    value: !0
  });
  qd.default = iW;
  var Bs = Tt();
  function iW(e, t) {
    return (0, Bs.isBlockStatement)(e) && ((0, Bs.isFunction)(t) || (0, Bs.isCatchClause)(t)) ? !1 : (0, Bs.isPattern)(e) && ((0, Bs.isFunction)(
    t) || (0, Bs.isCatchClause)(t)) ? !0 : (0, Bs.isScopable)(e);
  }
  s(iW, "isScope");
});

// ../node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var Fv = T((Ud) => {
  "use strict";
  Object.defineProperty(Ud, "__esModule", {
    value: !0
  });
  Ud.default = aW;
  var kv = Tt();
  function aW(e) {
    return (0, kv.isImportDefaultSpecifier)(e) || (0, kv.isIdentifier)(e.imported || e.exported, {
      name: "default"
    });
  }
  s(aW, "isSpecifierDefault");
});

// ../node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var jv = T((Vd) => {
  "use strict";
  Object.defineProperty(Vd, "__esModule", {
    value: !0
  });
  Vd.default = uW;
  var oW = bi(), lW = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implement\
s", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transie\
nt", "volatile"]);
  function uW(e) {
    return (0, oW.default)(e) && !lW.has(e);
  }
  s(uW, "isValidES3Identifier");
});

// ../node_modules/@babel/types/lib/validators/isVar.js
var Lv = T(($d) => {
  "use strict";
  Object.defineProperty($d, "__esModule", {
    value: !0
  });
  $d.default = pW;
  var cW = Tt(), fW = Xn();
  function pW(e) {
    return (0, cW.isVariableDeclaration)(e, {
      kind: "var"
    }) && !e[fW.BLOCK_SCOPED_SYMBOL];
  }
  s(pW, "isVar");
});

// ../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var Mv = T((Gd) => {
  "use strict";
  Object.defineProperty(Gd, "__esModule", {
    value: !0
  });
  Gd.default = Bl;
  var dW = qa(), ks = Tt(), Wd = sr(), Kd = qp(), hW = es();
  function Bl(e, t) {
    let r = [], n = !0;
    for (let i of e)
      if ((0, ks.isEmptyStatement)(i) || (n = !1), (0, ks.isExpression)(i))
        r.push(i);
      else if ((0, ks.isExpressionStatement)(i))
        r.push(i.expression);
      else if ((0, ks.isVariableDeclaration)(i)) {
        if (i.kind !== "var") return;
        for (let a of i.declarations) {
          let o = (0, dW.default)(a);
          for (let l of Object.keys(o))
            t.push({
              kind: i.kind,
              id: (0, hW.default)(o[l])
            });
          a.init && r.push((0, Wd.assignmentExpression)("=", a.id, a.init));
        }
        n = !0;
      } else if ((0, ks.isIfStatement)(i)) {
        let a = i.consequent ? Bl([i.consequent], t) : (0, Kd.buildUndefinedNode)(), o = i.alternate ? Bl([i.alternate], t) : (0, Kd.buildUndefinedNode)();
        if (!a || !o) return;
        r.push((0, Wd.conditionalExpression)(i.test, a, o));
      } else if ((0, ks.isBlockStatement)(i)) {
        let a = Bl(i.body, t);
        if (!a) return;
        r.push(a);
      } else if ((0, ks.isEmptyStatement)(i))
        e.indexOf(i) === 0 && (n = !0);
      else
        return;
    return n && r.push((0, Kd.buildUndefinedNode)()), r.length === 1 ? r[0] : (0, Wd.sequenceExpression)(r);
  }
  s(Bl, "gatherSequenceExpressions");
});

// ../node_modules/@babel/types/lib/converters/toSequenceExpression.js
var Rv = T((Hd) => {
  "use strict";
  Object.defineProperty(Hd, "__esModule", {
    value: !0
  });
  Hd.default = yW;
  var mW = Mv();
  function yW(e, t) {
    if (!(e != null && e.length)) return;
    let r = [], n = (0, mW.default)(e, r);
    if (n) {
      for (let i of r)
        t.push(i);
      return n;
    }
  }
  s(yW, "toSequenceExpression");
});

// ../node_modules/@babel/types/lib/index.js
var Pe = T((ee) => {
  "use strict";
  Object.defineProperty(ee, "__esModule", {
    value: !0
  });
  var Pn = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getAssignmentIdentifiers: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    getFunctionName: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0,
    __internal__deprecationWarning: !0
  };
  Object.defineProperty(ee, "__internal__deprecationWarning", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return vK.default;
    }, "get")
  });
  Object.defineProperty(ee, "addComment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return DW.default;
    }, "get")
  });
  Object.defineProperty(ee, "addComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return IW.default;
    }, "get")
  });
  Object.defineProperty(ee, "appendToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return WW.default;
    }, "get")
  });
  Object.defineProperty(ee, "assertNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return vW.default;
    }, "get")
  });
  Object.defineProperty(ee, "buildMatchMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return EK.default;
    }, "get")
  });
  Object.defineProperty(ee, "clone", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return PW.default;
    }, "get")
  });
  Object.defineProperty(ee, "cloneDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return AW.default;
    }, "get")
  });
  Object.defineProperty(ee, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return CW.default;
    }, "get")
  });
  Object.defineProperty(ee, "cloneNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return SW.default;
    }, "get")
  });
  Object.defineProperty(ee, "cloneWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return wW.default;
    }, "get")
  });
  Object.defineProperty(ee, "createFlowUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return qv.default;
    }, "get")
  });
  Object.defineProperty(ee, "createTSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return xW.default;
    }, "get")
  });
  Object.defineProperty(ee, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return TW.default;
    }, "get")
  });
  Object.defineProperty(ee, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return qv.default;
    }, "get")
  });
  Object.defineProperty(ee, "ensureBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return FW.default;
    }, "get")
  });
  Object.defineProperty(ee, "getAssignmentIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return JW.default;
    }, "get")
  });
  Object.defineProperty(ee, "getBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return XW.default;
    }, "get")
  });
  Object.defineProperty(ee, "getFunctionName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ZW.default;
    }, "get")
  });
  Object.defineProperty(ee, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return QW.default;
    }, "get")
  });
  Object.defineProperty(ee, "inheritInnerComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return _W.default;
    }, "get")
  });
  Object.defineProperty(ee, "inheritLeadingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return OW.default;
    }, "get")
  });
  Object.defineProperty(ee, "inheritTrailingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return BW.default;
    }, "get")
  });
  Object.defineProperty(ee, "inherits", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return KW.default;
    }, "get")
  });
  Object.defineProperty(ee, "inheritsComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return NW.default;
    }, "get")
  });
  Object.defineProperty(ee, "is", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rK.default;
    }, "get")
  });
  Object.defineProperty(ee, "isBinding", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return nK.default;
    }, "get")
  });
  Object.defineProperty(ee, "isBlockScoped", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return sK.default;
    }, "get")
  });
  Object.defineProperty(ee, "isImmutable", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return iK.default;
    }, "get")
  });
  Object.defineProperty(ee, "isLet", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return aK.default;
    }, "get")
  });
  Object.defineProperty(ee, "isNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return oK.default;
    }, "get")
  });
  Object.defineProperty(ee, "isNodesEquivalent", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return lK.default;
    }, "get")
  });
  Object.defineProperty(ee, "isPlaceholderType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return uK.default;
    }, "get")
  });
  Object.defineProperty(ee, "isReferenced", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return cK.default;
    }, "get")
  });
  Object.defineProperty(ee, "isScope", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return fK.default;
    }, "get")
  });
  Object.defineProperty(ee, "isSpecifierDefault", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return pK.default;
    }, "get")
  });
  Object.defineProperty(ee, "isType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return dK.default;
    }, "get")
  });
  Object.defineProperty(ee, "isValidES3Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return hK.default;
    }, "get")
  });
  Object.defineProperty(ee, "isValidIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return mK.default;
    }, "get")
  });
  Object.defineProperty(ee, "isVar", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return yK.default;
    }, "get")
  });
  Object.defineProperty(ee, "matchesPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return gK.default;
    }, "get")
  });
  Object.defineProperty(ee, "prependToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return GW.default;
    }, "get")
  });
  ee.react = void 0;
  Object.defineProperty(ee, "removeComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return kW.default;
    }, "get")
  });
  Object.defineProperty(ee, "removeProperties", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return HW.default;
    }, "get")
  });
  Object.defineProperty(ee, "removePropertiesDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return YW.default;
    }, "get")
  });
  Object.defineProperty(ee, "removeTypeDuplicates", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return zW.default;
    }, "get")
  });
  Object.defineProperty(ee, "shallowEqual", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return tK.default;
    }, "get")
  });
  Object.defineProperty(ee, "toBindingIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return jW.default;
    }, "get")
  });
  Object.defineProperty(ee, "toBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return LW.default;
    }, "get")
  });
  Object.defineProperty(ee, "toComputedKey", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return MW.default;
    }, "get")
  });
  Object.defineProperty(ee, "toExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return RW.default;
    }, "get")
  });
  Object.defineProperty(ee, "toIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return qW.default;
    }, "get")
  });
  Object.defineProperty(ee, "toKeyAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return UW.default;
    }, "get")
  });
  Object.defineProperty(ee, "toStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return VW.default;
    }, "get")
  });
  Object.defineProperty(ee, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return kl.default;
    }, "get")
  });
  Object.defineProperty(ee, "traverseFast", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return eK.default;
    }, "get")
  });
  Object.defineProperty(ee, "validate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return bK.default;
    }, "get")
  });
  Object.defineProperty(ee, "valueToNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $W.default;
    }, "get")
  });
  var gW = $1(), bW = W1(), EW = ME(), vW = RE(), Yd = qE();
  Object.keys(Yd).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Pn, e) || e in ee && ee[e] === Yd[e] || Object.defineProperty(
    ee, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Yd[e];
      }, "get")
    });
  });
  var TW = UE(), qv = WE(), xW = YE(), zd = sr();
  Object.keys(zd).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Pn, e) || e in ee && ee[e] === zd[e] || Object.defineProperty(
    ee, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return zd[e];
      }, "get")
    });
  });
  var Jd = zE();
  Object.keys(Jd).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Pn, e) || e in ee && ee[e] === Jd[e] || Object.defineProperty(
    ee, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Jd[e];
      }, "get")
    });
  });
  var Xd = qp();
  Object.keys(Xd).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Pn, e) || e in ee && ee[e] === Xd[e] || Object.defineProperty(
    ee, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Xd[e];
      }, "get")
    });
  });
  var SW = es(), PW = tv(), AW = rv(), CW = nv(), wW = sv(), DW = iv(), IW = Yp(), _W = Qp(), OW = ed(), NW = sd(), BW = rd(), kW = av(), Qd = ov();
  Object.keys(Qd).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Pn, e) || e in ee && ee[e] === Qd[e] || Object.defineProperty(
    ee, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Qd[e];
      }, "get")
    });
  });
  var Zd = Xn();
  Object.keys(Zd).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Pn, e) || e in ee && ee[e] === Zd[e] || Object.defineProperty(
    ee, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Zd[e];
      }, "get")
    });
  });
  var FW = lv(), jW = uv(), LW = ld(), MW = cv(), RW = fv(), qW = fd(), UW = hv(), VW = mv(), $W = yv(), eh = Cr();
  Object.keys(eh).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Pn, e) || e in ee && ee[e] === eh[e] || Object.defineProperty(
    ee, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return eh[e];
      }, "get")
    });
  });
  var WW = gv(), KW = Ev(), GW = vv(), HW = bd(), YW = vd(), zW = Fp(), JW = Tv(), XW = qa(), QW = xv(), ZW = Pv(), kl = Av();
  Object.keys(kl).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Pn, e) || e in ee && ee[e] === kl[e] || Object.defineProperty(
    ee, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return kl[e];
      }, "get")
    });
  });
  var eK = yd(), tK = fl(), rK = yi(), nK = Cv(), sK = Dv(), iK = Iv(), aK = kd(), oK = Np(), lK = Ov(), uK = ip(), cK = Nv(), fK = Bv(), pK = Fv(),
  dK = dl(), hK = jv(), mK = bi(), yK = Lv(), gK = Zf(), bK = bl(), EK = tp(), th = Tt();
  Object.keys(th).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Pn, e) || e in ee && ee[e] === th[e] || Object.defineProperty(
    ee, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return th[e];
      }, "get")
    });
  });
  var vK = Aa(), ySe = ee.react = {
    isReactComponent: gW.default,
    isCompatTag: bW.default,
    buildChildren: EW.default
  };
  ee.toSequenceExpression = Rv().default;
});

// ../node_modules/@babel/template/lib/formatters.js
var Uv = T((Dr) => {
  "use strict";
  Object.defineProperty(Dr, "__esModule", {
    value: !0
  });
  Dr.statements = Dr.statement = Dr.smart = Dr.program = Dr.expression = void 0;
  var TK = Pe(), {
    assertExpressionStatement: xK
  } = TK;
  function rh(e) {
    return {
      code: /* @__PURE__ */ s((t) => `/* @babel/template */;
${t}`, "code"),
      validate: /* @__PURE__ */ s(() => {
      }, "validate"),
      unwrap: /* @__PURE__ */ s((t) => e(t.program.body.slice(1)), "unwrap")
    };
  }
  s(rh, "makeStatementFormatter");
  var ESe = Dr.smart = rh((e) => e.length > 1 ? e : e[0]), vSe = Dr.statements = rh((e) => e), TSe = Dr.statement = rh((e) => {
    if (e.length === 0)
      throw new Error("Found nothing to return.");
    if (e.length > 1)
      throw new Error("Found multiple statements but wanted one");
    return e[0];
  }), SK = Dr.expression = {
    code: /* @__PURE__ */ s((e) => `(
${e}
)`, "code"),
    validate: /* @__PURE__ */ s((e) => {
      if (e.program.body.length > 1)
        throw new Error("Found multiple statements but wanted one");
      if (SK.unwrap(e).start === 0)
        throw new Error("Parse result included parens.");
    }, "validate"),
    unwrap: /* @__PURE__ */ s(({
      program: e
    }) => {
      let [t] = e.body;
      return xK(t), t.expression;
    }, "unwrap")
  }, xSe = Dr.program = {
    code: /* @__PURE__ */ s((e) => e, "code"),
    validate: /* @__PURE__ */ s(() => {
    }, "validate"),
    unwrap: /* @__PURE__ */ s((e) => e.program, "unwrap")
  };
});

// ../node_modules/@babel/template/lib/options.js
var Fl = T((Ua) => {
  "use strict";
  Object.defineProperty(Ua, "__esModule", {
    value: !0
  });
  Ua.merge = CK;
  Ua.normalizeReplacements = DK;
  Ua.validate = wK;
  var PK = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function AK(e, t) {
    if (e == null) return {};
    var r = {}, n = Object.keys(e), i, a;
    for (a = 0; a < n.length; a++)
      i = n[a], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
    return r;
  }
  s(AK, "_objectWithoutPropertiesLoose");
  function CK(e, t) {
    let {
      placeholderWhitelist: r = e.placeholderWhitelist,
      placeholderPattern: n = e.placeholderPattern,
      preserveComments: i = e.preserveComments,
      syntacticPlaceholders: a = e.syntacticPlaceholders
    } = t;
    return {
      parser: Object.assign({}, e.parser, t.parser),
      placeholderWhitelist: r,
      placeholderPattern: n,
      preserveComments: i,
      syntacticPlaceholders: a
    };
  }
  s(CK, "merge");
  function wK(e) {
    if (e != null && typeof e != "object")
      throw new Error("Unknown template options.");
    let t = e || {}, {
      placeholderWhitelist: r,
      placeholderPattern: n,
      preserveComments: i,
      syntacticPlaceholders: a
    } = t, o = AK(t, PK);
    if (r != null && !(r instanceof Set))
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    if (n != null && !(n instanceof RegExp) && n !== !1)
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    if (i != null && typeof i != "boolean")
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    if (a != null && typeof a != "boolean")
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    if (a === !0 && (r != null || n != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    return {
      parser: o,
      placeholderWhitelist: r || void 0,
      placeholderPattern: n ?? void 0,
      preserveComments: i ?? void 0,
      syntacticPlaceholders: a ?? void 0
    };
  }
  s(wK, "validate");
  function DK(e) {
    if (Array.isArray(e))
      return e.reduce((t, r, n) => (t["$" + n] = r, t), {});
    if (typeof e == "object" || e == null)
      return e || void 0;
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }
  s(DK, "normalizeReplacements");
});

// ../node_modules/@babel/parser/lib/index.js
var Ls = T((Xa) => {
  "use strict";
  Object.defineProperty(Xa, "__esModule", {
    value: !0
  });
  function IK(e, t) {
    if (e == null) return {};
    var r = {};
    for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
      if (t.includes(n)) continue;
      r[n] = e[n];
    }
    return r;
  }
  s(IK, "_objectWithoutPropertiesLoose");
  var cn = class {
    static {
      s(this, "Position");
    }
    constructor(t, r, n) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = r, this.index = n;
    }
  }, Ai = class {
    static {
      s(this, "SourceLocation");
    }
    constructor(t, r) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = r;
    }
  };
  function ar(e, t) {
    let {
      line: r,
      column: n,
      index: i
    } = e;
    return new cn(r, n + t, i + t);
  }
  s(ar, "createPositionWithColumnOffset");
  var Vv = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", _K = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: Vv
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: Vv
    }
  }, $v = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, Ml = /* @__PURE__ */ s((e) => e.type === "UpdateExpression" ? $v.UpdateExpression[`${e.prefix}`] : $v[e.type], "toNodeDescription"), OK = {
    AccessorIsGenerator: /* @__PURE__ */ s(({
      kind: e
    }) => `A ${e}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ s(({
      kind: e
    }) => `Missing initializer in ${e} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ s(({
      exportName: e
    }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ s(({
      phase: e
    }) => `'import.${e}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ s(({
      localName: e,
      exportName: t
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ s(({
      type: e
    }) => `'${e === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ s(({
      type: e
    }) => `Unsyntactic ${e === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ s(({
      importName: e
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: /* @__PURE__ */ s(({
      maxArgumentCount: e
    }) => `\`import()\` requires exactly ${e === 1 ? "one argument" : "one or two arguments"}.`, "ImportCallArity"),
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ s(({
      radix: e
    }) => `Expected number in radix ${e}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ s(({
      reservedWord: e
    }) => `Escape sequence in keyword ${e}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Invalid identifier ${e}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ s(({
      ancestor: e
    }) => `Invalid left-hand side in ${Ml(e)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ s(({
      ancestor: e
    }) => `Binding invalid left-hand side in ${Ml(e)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ s(({
      ancestor: e
    }) => `Invalid optional chaining in the left-hand side of ${Ml(e)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ s(({
      unexpected: e
    }) => `Unexpected character '${e}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Private name #${e} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ s(({
      labelName: e
    }) => `Label '${e}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ s(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling the parser plugin: ${e.map((t) => JSON.stringify(t)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ s(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((t) => JSON.stringify(t)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ s(({
      key: e
    }) => `Duplicate key "${e}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ s(({
      surrogateCharCode: e
    }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ s(({
      localName: e
    }) => `Export '${e}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Duplicate private name #${e}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ s(({
      keyword: e
    }) => `Unexpected keyword '${e}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ s(({
      reservedWord: e
    }) => `Unexpected reserved word '${e}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ s(({
      expected: e,
      unexpected: t
    }) => `Unexpected token${t ? ` '${t}'.` : ""}${e ? `, expected "${e}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ s(({
      target: e,
      onlyValidPropertyName: t
    }) => `The only valid meta property for ${e} is ${e}.${t}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Identifier '${e}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, NK = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ s(({
      referenceName: e
    }) => `Assigning to '${e}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ s(({
      bindingName: e
    }) => `Binding '${e}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, BK = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), kK = {
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ s(({
      token: e
    }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${e}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ s(({
      type: e
    }) => `Hack-style pipe body cannot be an unparenthesized ${Ml({
      type: e
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody"),
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }, FK = ["message"];
  function Wv(e, t, r) {
    Object.defineProperty(e, t, {
      enumerable: !1,
      configurable: !0,
      value: r
    });
  }
  s(Wv, "defineHidden");
  function jK({
    toMessage: e,
    code: t,
    reasonCode: r,
    syntaxPlugin: n
  }) {
    let i = r === "MissingPlugin" || r === "MissingOneOfPlugins";
    return /* @__PURE__ */ s(function a(o, l) {
      let u = new SyntaxError();
      return u.code = t, u.reasonCode = r, u.loc = o, u.pos = o.index, u.syntaxPlugin = n, i && (u.missingPlugin = l.missingPlugin), Wv(u, "\
clone", /* @__PURE__ */ s(function(f = {}) {
        var p;
        let {
          line: h,
          column: y,
          index: v
        } = (p = f.loc) != null ? p : o;
        return a(new cn(h, y, v), Object.assign({}, l, f.details));
      }, "clone")), Wv(u, "details", l), Object.defineProperty(u, "message", {
        configurable: !0,
        get() {
          let c = `${e(l)} (${o.line}:${o.column})`;
          return this.message = c, c;
        },
        set(c) {
          Object.defineProperty(this, "message", {
            value: c,
            writable: !0
          });
        }
      }), u;
    }, "constructor");
  }
  s(jK, "toParseErrorConstructor");
  function Dn(e, t) {
    if (Array.isArray(e))
      return (n) => Dn(n, e[0]);
    let r = {};
    for (let n of Object.keys(e)) {
      let i = e[n], a = typeof i == "string" ? {
        message: /* @__PURE__ */ s(() => i, "message")
      } : typeof i == "function" ? {
        message: i
      } : i, {
        message: o
      } = a, l = IK(a, FK), u = typeof o == "string" ? () => o : o;
      r[n] = jK(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: n,
        toMessage: u
      }, t ? {
        syntaxPlugin: t
      } : {}, l));
    }
    return r;
  }
  s(Dn, "ParseErrorEnum");
  var _ = Object.assign({}, Dn(_K), Dn(OK), Dn(NK), Dn`pipelineOperator`(kK)), {
    defineProperty: LK
  } = Object, Kv = /* @__PURE__ */ s((e, t) => {
    e && LK(e, t, {
      enumerable: !1,
      value: e[t]
    });
  }, "toUnenumerable");
  function Va(e) {
    return Kv(e.loc.start, "index"), Kv(e.loc.end, "index"), e;
  }
  s(Va, "toESTreeLocation");
  var MK = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "ESTreeParserMixin");
    }
    parse() {
      let r = Va(super.parse());
      return this.options.tokens && (r.tokens = r.tokens.map(Va)), r;
    }
    parseRegExpLiteral({
      pattern: r,
      flags: n
    }) {
      let i = null;
      try {
        i = new RegExp(r, n);
      } catch {
      }
      let a = this.estreeParseLiteral(i);
      return a.regex = {
        pattern: r,
        flags: n
      }, a;
    }
    parseBigIntLiteral(r) {
      let n;
      try {
        n = BigInt(r);
      } catch {
        n = null;
      }
      let i = this.estreeParseLiteral(n);
      return i.bigint = String(i.value || r), i;
    }
    parseDecimalLiteral(r) {
      let i = this.estreeParseLiteral(null);
      return i.decimal = String(i.value || r), i;
    }
    estreeParseLiteral(r) {
      return this.parseLiteral(r, "Literal");
    }
    parseStringLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNumericLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    directiveToStmt(r) {
      let n = r.value;
      delete r.value, n.type = "Literal", n.raw = n.extra.raw, n.value = n.extra.expressionValue;
      let i = r;
      return i.type = "ExpressionStatement", i.expression = n, i.directive = n.extra.rawValue, delete n.extra, i;
    }
    initFunction(r, n) {
      super.initFunction(r, n), r.expression = !1;
    }
    checkDeclaration(r) {
      r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
    }
    getObjectOrClassMethodParams(r) {
      return r.value.params;
    }
    isValidDirective(r) {
      var n;
      return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((n = r.expression.
      extra) != null && n.parenthesized);
    }
    parseBlockBody(r, n, i, a, o) {
      super.parseBlockBody(r, n, i, a, o);
      let l = r.directives.map((u) => this.directiveToStmt(u));
      r.body = l.concat(r.body), delete r.directives;
    }
    pushClassMethod(r, n, i, a, o, l) {
      this.parseMethod(n, i, a, o, l, "ClassMethod", !0), n.typeParameters && (n.value.typeParameters = n.typeParameters, delete n.typeParameters),
      r.body.push(n);
    }
    parsePrivateName() {
      let r = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
    }
    convertPrivateNameToPrivateIdentifier(r) {
      let n = super.getPrivateNameSV(r);
      return r = r, delete r.id, r.name = n, r.type = "PrivateIdentifier", r;
    }
    isPrivateName(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
    }
    getPrivateNameSV(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
    }
    parseLiteral(r, n) {
      let i = super.parseLiteral(r, n);
      return i.raw = i.extra.raw, delete i.extra, i;
    }
    parseFunctionBody(r, n, i = !1) {
      super.parseFunctionBody(r, n, i), r.expression = r.body.type !== "BlockStatement";
    }
    parseMethod(r, n, i, a, o, l, u = !1) {
      let c = this.startNode();
      return c.kind = r.kind, c = super.parseMethod(c, n, i, a, o, l, u), c.type = "FunctionExpression", delete c.kind, r.value = c, l === "\
ClassPrivateMethod" && (r.computed = !1), this.finishNode(r, "MethodDefinition");
    }
    nameIsConstructor(r) {
      return r.type === "Literal" ? r.value === "constructor" : super.nameIsConstructor(r);
    }
    parseClassProperty(...r) {
      let n = super.parseClassProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (n.type = "PropertyDefinition"), n;
    }
    parseClassPrivateProperty(...r) {
      let n = super.parseClassPrivateProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (n.type = "PropertyDefinition", n.computed = !1), n;
    }
    parseObjectMethod(r, n, i, a, o) {
      let l = super.parseObjectMethod(r, n, i, a, o);
      return l && (l.type = "Property", l.kind === "method" && (l.kind = "init"), l.shorthand = !1), l;
    }
    parseObjectProperty(r, n, i, a) {
      let o = super.parseObjectProperty(r, n, i, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(r, n, i) {
      return r === "Property" ? "value" : super.isValidLVal(r, n, i);
    }
    isAssignable(r, n) {
      return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, n) : super.isAssignable(r, n);
    }
    toAssignable(r, n = !1) {
      if (r != null && this.isObjectProperty(r)) {
        let {
          key: i,
          value: a
        } = r;
        this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(a, n);
      } else
        super.toAssignable(r, n);
    }
    toAssignableObjectExpressionProp(r, n, i) {
      r.type === "Property" && (r.kind === "get" || r.kind === "set") ? this.raise(_.PatternHasAccessor, r.key) : r.type === "Property" && r.
      method ? this.raise(_.PatternHasMethod, r.key) : super.toAssignableObjectExpressionProp(r, n, i);
    }
    finishCallExpression(r, n) {
      let i = super.finishCallExpression(r, n);
      if (i.callee.type === "Import") {
        if (i.type = "ImportExpression", i.source = i.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var a, o;
          i.options = (a = i.arguments[1]) != null ? a : null, i.attributes = (o = i.arguments[1]) != null ? o : null;
        }
        delete i.arguments, delete i.callee;
      }
      return i;
    }
    toReferencedArguments(r) {
      r.type !== "ImportExpression" && super.toReferencedArguments(r);
    }
    parseExport(r, n) {
      let i = this.state.lastTokStartLoc, a = super.parseExport(r, n);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, i);
          }
          break;
      }
      return a;
    }
    parseSubscript(r, n, i, a) {
      let o = super.parseSubscript(r, n, i, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let l = this.startNodeAtNode(o);
          return l.expression = o, this.finishNode(l, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(r) {
      return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
    }
    hasPropertyAsPrivateName(r) {
      return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
    }
    isObjectProperty(r) {
      return r.type === "Property" && r.kind === "init" && !r.method;
    }
    isObjectMethod(r) {
      return r.type === "Property" && (r.method || r.kind === "get" || r.kind === "set");
    }
    finishNodeAt(r, n, i) {
      return Va(super.finishNodeAt(r, n, i));
    }
    resetStartLocation(r, n) {
      super.resetStartLocation(r, n), Va(r);
    }
    resetEndLocation(r, n = this.state.lastTokEndLoc) {
      super.resetEndLocation(r, n), Va(r);
    }
  }, "estree"), js = class {
    static {
      s(this, "TokContext");
    }
    constructor(t, r) {
      this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!r;
    }
  }, at = {
    brace: new js("{"),
    j_oTag: new js("<tag"),
    j_cTag: new js("</tag"),
    j_expr: new js("<tag>...</tag>", !0)
  };
  at.template = new js("`", !0);
  var Ue = !0, se = !0, nh = !0, $a = !0, ts = !0, RK = !0, Ul = class {
    static {
      s(this, "ExportedTokenType");
    }
    constructor(t, r = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = r.keyword,
      this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop,
      this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.
      updateContext = null;
    }
  }, Ih = /* @__PURE__ */ new Map();
  function Ye(e, t = {}) {
    t.keyword = e;
    let r = xe(e, t);
    return Ih.set(e, r), r;
  }
  s(Ye, "createKeyword");
  function ir(e, t) {
    return xe(e, {
      beforeExpr: Ue,
      binop: t
    });
  }
  s(ir, "createBinop");
  var Ha = -1, Cn = [], _h = [], Oh = [], Nh = [], Bh = [], kh = [];
  function xe(e, t = {}) {
    var r, n, i, a;
    return ++Ha, _h.push(e), Oh.push((r = t.binop) != null ? r : -1), Nh.push((n = t.beforeExpr) != null ? n : !1), Bh.push((i = t.startsExpr) !=
    null ? i : !1), kh.push((a = t.prefix) != null ? a : !1), Cn.push(new Ul(e, t)), Ha;
  }
  s(xe, "createToken");
  function qe(e, t = {}) {
    var r, n, i, a;
    return ++Ha, Ih.set(e, Ha), _h.push(e), Oh.push((r = t.binop) != null ? r : -1), Nh.push((n = t.beforeExpr) != null ? n : !1), Bh.push((i =
    t.startsExpr) != null ? i : !1), kh.push((a = t.prefix) != null ? a : !1), Cn.push(new Ul("name", t)), Ha;
  }
  s(qe, "createKeywordLike");
  var qK = {
    bracketL: xe("[", {
      beforeExpr: Ue,
      startsExpr: se
    }),
    bracketHashL: xe("#[", {
      beforeExpr: Ue,
      startsExpr: se
    }),
    bracketBarL: xe("[|", {
      beforeExpr: Ue,
      startsExpr: se
    }),
    bracketR: xe("]"),
    bracketBarR: xe("|]"),
    braceL: xe("{", {
      beforeExpr: Ue,
      startsExpr: se
    }),
    braceBarL: xe("{|", {
      beforeExpr: Ue,
      startsExpr: se
    }),
    braceHashL: xe("#{", {
      beforeExpr: Ue,
      startsExpr: se
    }),
    braceR: xe("}"),
    braceBarR: xe("|}"),
    parenL: xe("(", {
      beforeExpr: Ue,
      startsExpr: se
    }),
    parenR: xe(")"),
    comma: xe(",", {
      beforeExpr: Ue
    }),
    semi: xe(";", {
      beforeExpr: Ue
    }),
    colon: xe(":", {
      beforeExpr: Ue
    }),
    doubleColon: xe("::", {
      beforeExpr: Ue
    }),
    dot: xe("."),
    question: xe("?", {
      beforeExpr: Ue
    }),
    questionDot: xe("?."),
    arrow: xe("=>", {
      beforeExpr: Ue
    }),
    template: xe("template"),
    ellipsis: xe("...", {
      beforeExpr: Ue
    }),
    backQuote: xe("`", {
      startsExpr: se
    }),
    dollarBraceL: xe("${", {
      beforeExpr: Ue,
      startsExpr: se
    }),
    templateTail: xe("...`", {
      startsExpr: se
    }),
    templateNonTail: xe("...${", {
      beforeExpr: Ue,
      startsExpr: se
    }),
    at: xe("@"),
    hash: xe("#", {
      startsExpr: se
    }),
    interpreterDirective: xe("#!..."),
    eq: xe("=", {
      beforeExpr: Ue,
      isAssign: $a
    }),
    assign: xe("_=", {
      beforeExpr: Ue,
      isAssign: $a
    }),
    slashAssign: xe("_=", {
      beforeExpr: Ue,
      isAssign: $a
    }),
    xorAssign: xe("_=", {
      beforeExpr: Ue,
      isAssign: $a
    }),
    moduloAssign: xe("_=", {
      beforeExpr: Ue,
      isAssign: $a
    }),
    incDec: xe("++/--", {
      prefix: ts,
      postfix: RK,
      startsExpr: se
    }),
    bang: xe("!", {
      beforeExpr: Ue,
      prefix: ts,
      startsExpr: se
    }),
    tilde: xe("~", {
      beforeExpr: Ue,
      prefix: ts,
      startsExpr: se
    }),
    doubleCaret: xe("^^", {
      startsExpr: se
    }),
    doubleAt: xe("@@", {
      startsExpr: se
    }),
    pipeline: ir("|>", 0),
    nullishCoalescing: ir("??", 1),
    logicalOR: ir("||", 1),
    logicalAND: ir("&&", 2),
    bitwiseOR: ir("|", 3),
    bitwiseXOR: ir("^", 4),
    bitwiseAND: ir("&", 5),
    equality: ir("==/!=/===/!==", 6),
    lt: ir("</>/<=/>=", 7),
    gt: ir("</>/<=/>=", 7),
    relational: ir("</>/<=/>=", 7),
    bitShift: ir("<</>>/>>>", 8),
    bitShiftL: ir("<</>>/>>>", 8),
    bitShiftR: ir("<</>>/>>>", 8),
    plusMin: xe("+/-", {
      beforeExpr: Ue,
      binop: 9,
      prefix: ts,
      startsExpr: se
    }),
    modulo: xe("%", {
      binop: 10,
      startsExpr: se
    }),
    star: xe("*", {
      binop: 10
    }),
    slash: ir("/", 10),
    exponent: xe("**", {
      beforeExpr: Ue,
      binop: 11,
      rightAssociative: !0
    }),
    _in: Ye("in", {
      beforeExpr: Ue,
      binop: 7
    }),
    _instanceof: Ye("instanceof", {
      beforeExpr: Ue,
      binop: 7
    }),
    _break: Ye("break"),
    _case: Ye("case", {
      beforeExpr: Ue
    }),
    _catch: Ye("catch"),
    _continue: Ye("continue"),
    _debugger: Ye("debugger"),
    _default: Ye("default", {
      beforeExpr: Ue
    }),
    _else: Ye("else", {
      beforeExpr: Ue
    }),
    _finally: Ye("finally"),
    _function: Ye("function", {
      startsExpr: se
    }),
    _if: Ye("if"),
    _return: Ye("return", {
      beforeExpr: Ue
    }),
    _switch: Ye("switch"),
    _throw: Ye("throw", {
      beforeExpr: Ue,
      prefix: ts,
      startsExpr: se
    }),
    _try: Ye("try"),
    _var: Ye("var"),
    _const: Ye("const"),
    _with: Ye("with"),
    _new: Ye("new", {
      beforeExpr: Ue,
      startsExpr: se
    }),
    _this: Ye("this", {
      startsExpr: se
    }),
    _super: Ye("super", {
      startsExpr: se
    }),
    _class: Ye("class", {
      startsExpr: se
    }),
    _extends: Ye("extends", {
      beforeExpr: Ue
    }),
    _export: Ye("export"),
    _import: Ye("import", {
      startsExpr: se
    }),
    _null: Ye("null", {
      startsExpr: se
    }),
    _true: Ye("true", {
      startsExpr: se
    }),
    _false: Ye("false", {
      startsExpr: se
    }),
    _typeof: Ye("typeof", {
      beforeExpr: Ue,
      prefix: ts,
      startsExpr: se
    }),
    _void: Ye("void", {
      beforeExpr: Ue,
      prefix: ts,
      startsExpr: se
    }),
    _delete: Ye("delete", {
      beforeExpr: Ue,
      prefix: ts,
      startsExpr: se
    }),
    _do: Ye("do", {
      isLoop: nh,
      beforeExpr: Ue
    }),
    _for: Ye("for", {
      isLoop: nh
    }),
    _while: Ye("while", {
      isLoop: nh
    }),
    _as: qe("as", {
      startsExpr: se
    }),
    _assert: qe("assert", {
      startsExpr: se
    }),
    _async: qe("async", {
      startsExpr: se
    }),
    _await: qe("await", {
      startsExpr: se
    }),
    _defer: qe("defer", {
      startsExpr: se
    }),
    _from: qe("from", {
      startsExpr: se
    }),
    _get: qe("get", {
      startsExpr: se
    }),
    _let: qe("let", {
      startsExpr: se
    }),
    _meta: qe("meta", {
      startsExpr: se
    }),
    _of: qe("of", {
      startsExpr: se
    }),
    _sent: qe("sent", {
      startsExpr: se
    }),
    _set: qe("set", {
      startsExpr: se
    }),
    _source: qe("source", {
      startsExpr: se
    }),
    _static: qe("static", {
      startsExpr: se
    }),
    _using: qe("using", {
      startsExpr: se
    }),
    _yield: qe("yield", {
      startsExpr: se
    }),
    _asserts: qe("asserts", {
      startsExpr: se
    }),
    _checks: qe("checks", {
      startsExpr: se
    }),
    _exports: qe("exports", {
      startsExpr: se
    }),
    _global: qe("global", {
      startsExpr: se
    }),
    _implements: qe("implements", {
      startsExpr: se
    }),
    _intrinsic: qe("intrinsic", {
      startsExpr: se
    }),
    _infer: qe("infer", {
      startsExpr: se
    }),
    _is: qe("is", {
      startsExpr: se
    }),
    _mixins: qe("mixins", {
      startsExpr: se
    }),
    _proto: qe("proto", {
      startsExpr: se
    }),
    _require: qe("require", {
      startsExpr: se
    }),
    _satisfies: qe("satisfies", {
      startsExpr: se
    }),
    _keyof: qe("keyof", {
      startsExpr: se
    }),
    _readonly: qe("readonly", {
      startsExpr: se
    }),
    _unique: qe("unique", {
      startsExpr: se
    }),
    _abstract: qe("abstract", {
      startsExpr: se
    }),
    _declare: qe("declare", {
      startsExpr: se
    }),
    _enum: qe("enum", {
      startsExpr: se
    }),
    _module: qe("module", {
      startsExpr: se
    }),
    _namespace: qe("namespace", {
      startsExpr: se
    }),
    _interface: qe("interface", {
      startsExpr: se
    }),
    _type: qe("type", {
      startsExpr: se
    }),
    _opaque: qe("opaque", {
      startsExpr: se
    }),
    name: xe("name", {
      startsExpr: se
    }),
    string: xe("string", {
      startsExpr: se
    }),
    num: xe("num", {
      startsExpr: se
    }),
    bigint: xe("bigint", {
      startsExpr: se
    }),
    decimal: xe("decimal", {
      startsExpr: se
    }),
    regexp: xe("regexp", {
      startsExpr: se
    }),
    privateName: xe("#name", {
      startsExpr: se
    }),
    eof: xe("eof"),
    jsxName: xe("jsxName"),
    jsxText: xe("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: xe("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: xe("jsxTagEnd"),
    placeholder: xe("%%", {
      startsExpr: !0
    })
  };
  function tt(e) {
    return e >= 93 && e <= 132;
  }
  s(tt, "tokenIsIdentifier");
  function UK(e) {
    return e <= 92;
  }
  s(UK, "tokenKeywordOrIdentifierIsKeyword");
  function Wr(e) {
    return e >= 58 && e <= 132;
  }
  s(Wr, "tokenIsKeywordOrIdentifier");
  function nT(e) {
    return e >= 58 && e <= 136;
  }
  s(nT, "tokenIsLiteralPropertyName");
  function VK(e) {
    return Nh[e];
  }
  s(VK, "tokenComesBeforeExpression");
  function uh(e) {
    return Bh[e];
  }
  s(uh, "tokenCanStartExpression");
  function $K(e) {
    return e >= 29 && e <= 33;
  }
  s($K, "tokenIsAssignment");
  function Gv(e) {
    return e >= 129 && e <= 131;
  }
  s(Gv, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function WK(e) {
    return e >= 90 && e <= 92;
  }
  s(WK, "tokenIsLoop");
  function Fh(e) {
    return e >= 58 && e <= 92;
  }
  s(Fh, "tokenIsKeyword");
  function KK(e) {
    return e >= 39 && e <= 59;
  }
  s(KK, "tokenIsOperator");
  function GK(e) {
    return e === 34;
  }
  s(GK, "tokenIsPostfix");
  function HK(e) {
    return kh[e];
  }
  s(HK, "tokenIsPrefix");
  function YK(e) {
    return e >= 121 && e <= 123;
  }
  s(YK, "tokenIsTSTypeOperator");
  function zK(e) {
    return e >= 124 && e <= 130;
  }
  s(zK, "tokenIsTSDeclarationStart");
  function ns(e) {
    return _h[e];
  }
  s(ns, "tokenLabelName");
  function Rl(e) {
    return Oh[e];
  }
  s(Rl, "tokenOperatorPrecedence");
  function JK(e) {
    return e === 57;
  }
  s(JK, "tokenIsRightAssociative");
  function Vl(e) {
    return e >= 24 && e <= 25;
  }
  s(Vl, "tokenIsTemplate");
  function An(e) {
    return Cn[e];
  }
  s(An, "getExportedToken");
  Cn[8].updateContext = (e) => {
    e.pop();
  }, Cn[5].updateContext = Cn[7].updateContext = Cn[23].updateContext = (e) => {
    e.push(at.brace);
  }, Cn[22].updateContext = (e) => {
    e[e.length - 1] === at.template ? e.pop() : e.push(at.template);
  }, Cn[142].updateContext = (e) => {
    e.push(at.j_expr, at.j_oTag);
  };
  var jh = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  sT = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", XK = new RegExp("[" + jh + "]"), QK = new RegExp("[" + jh + sT + "]");
  jh = sT = null;
  var iT = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], ZK = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2,
  5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6,
  1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function ch(e, t) {
    let r = 65536;
    for (let n = 0, i = t.length; n < i; n += 2) {
      if (r += t[n], r > e) return !1;
      if (r += t[n + 1], r >= e) return !0;
    }
    return !1;
  }
  s(ch, "isInAstralSet");
  function wn(e) {
    return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && XK.test(String.fromCharCode(e)) :
    ch(e, iT);
  }
  s(wn, "isIdentifierStart");
  function xi(e) {
    return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && QK.test(
    String.fromCharCode(e)) : ch(e, iT) || ch(e, ZK);
  }
  s(xi, "isIdentifierChar");
  var Lh = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, eG = new Set(Lh.keyword), tG = new Set(Lh.strict), rG = new Set(Lh.strictBind);
  function aT(e, t) {
    return t && e === "await" || e === "enum";
  }
  s(aT, "isReservedWord");
  function oT(e, t) {
    return aT(e, t) || tG.has(e);
  }
  s(oT, "isStrictReservedWord");
  function lT(e) {
    return rG.has(e);
  }
  s(lT, "isStrictBindOnlyReservedWord");
  function uT(e, t) {
    return oT(e, t) || lT(e);
  }
  s(uT, "isStrictBindReservedWord");
  function nG(e) {
    return eG.has(e);
  }
  s(nG, "isKeyword");
  function sG(e, t, r) {
    return e === 64 && t === 64 && wn(r);
  }
  s(sG, "isIteratorStart");
  var iG = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function aG(e) {
    return iG.has(e);
  }
  s(aG, "canBeReservedWord");
  var Ya = class {
    static {
      s(this, "Scope");
    }
    constructor(t) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = t;
    }
  }, za = class {
    static {
      s(this, "ScopeHandler");
    }
    constructor(t, r) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t,
      this.inModule = r;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let t = this.currentThisScopeFlags();
      return (t & 64) > 0 && (t & 2) === 0;
    }
    get inStaticBlock() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 128)
          return !0;
        if (r & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(t) {
      return new Ya(t);
    }
    enter(t) {
      this.scopeStack.push(this.createScope(t));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(t) {
      return !!(t.flags & 130 || !this.parser.inModule && t.flags & 1);
    }
    declareName(t, r, n) {
      let i = this.currentScope();
      if (r & 8 || r & 16) {
        this.checkRedeclarationInScope(i, t, r, n);
        let a = i.names.get(t) || 0;
        r & 16 ? a = a | 4 : (i.firstLexicalName || (i.firstLexicalName = t), a = a | 2), i.names.set(t, a), r & 8 && this.maybeExportDefined(
        i, t);
      } else if (r & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (i = this.scopeStack[a], this.checkRedeclarationInScope(i, t, r, n), i.names.set(
        t, (i.names.get(t) || 0) | 1), this.maybeExportDefined(i, t), !(i.flags & 387)); --a)
          ;
      this.parser.inModule && i.flags & 1 && this.undefinedExports.delete(t);
    }
    maybeExportDefined(t, r) {
      this.parser.inModule && t.flags & 1 && this.undefinedExports.delete(r);
    }
    checkRedeclarationInScope(t, r, n, i) {
      this.isRedeclaredInScope(t, r, n) && this.parser.raise(_.VarRedeclaration, i, {
        identifierName: r
      });
    }
    isRedeclaredInScope(t, r, n) {
      if (!(n & 1)) return !1;
      if (n & 8)
        return t.names.has(r);
      let i = t.names.get(r);
      return n & 16 ? (i & 2) > 0 || !this.treatFunctionsAsVarInScope(t) && (i & 1) > 0 : (i & 2) > 0 && !(t.flags & 8 && t.firstLexicalName ===
      r) || !this.treatFunctionsAsVarInScope(t) && (i & 4) > 0;
    }
    checkLocalExport(t) {
      let {
        name: r
      } = t;
      this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, t.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 387)
          return r;
      }
    }
    currentThisScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 451 && !(r & 4))
          return r;
      }
    }
  }, fh = class extends Ya {
    static {
      s(this, "FlowScope");
    }
    constructor(...t) {
      super(...t), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, ph = class extends za {
    static {
      s(this, "FlowScopeHandler");
    }
    createScope(t) {
      return new fh(t);
    }
    declareName(t, r, n) {
      let i = this.currentScope();
      if (r & 2048) {
        this.checkRedeclarationInScope(i, t, r, n), this.maybeExportDefined(i, t), i.declareFunctions.add(t);
        return;
      }
      super.declareName(t, r, n);
    }
    isRedeclaredInScope(t, r, n) {
      if (super.isRedeclaredInScope(t, r, n)) return !0;
      if (n & 2048 && !t.declareFunctions.has(r)) {
        let i = t.names.get(r);
        return (i & 4) > 0 || (i & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(t) {
      this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
    }
  }, dh = class {
    static {
      s(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(t) {
      if (typeof t == "string")
        return this.plugins.has(t);
      {
        let [r, n] = t;
        if (!this.hasPlugin(r))
          return !1;
        let i = this.plugins.get(r);
        for (let a of Object.keys(n))
          if (i?.[a] !== n[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(t, r) {
      var n;
      return (n = this.plugins.get(t)) == null ? void 0 : n[r];
    }
  };
  function cT(e, t) {
    e.trailingComments === void 0 ? e.trailingComments = t : e.trailingComments.unshift(...t);
  }
  s(cT, "setTrailingComments");
  function oG(e, t) {
    e.leadingComments === void 0 ? e.leadingComments = t : e.leadingComments.unshift(...t);
  }
  s(oG, "setLeadingComments");
  function Ja(e, t) {
    e.innerComments === void 0 ? e.innerComments = t : e.innerComments.unshift(...t);
  }
  s(Ja, "setInnerComments");
  function Wa(e, t, r) {
    let n = null, i = t.length;
    for (; n === null && i > 0; )
      n = t[--i];
    n === null || n.start > r.start ? Ja(e, r.comments) : cT(n, r.comments);
  }
  s(Wa, "adjustInnerComments");
  var hh = class extends dh {
    static {
      s(this, "CommentsParser");
    }
    addComment(t) {
      this.filename && (t.loc.filename = this.filename);
      let {
        commentsLen: r
      } = this.state;
      this.comments.length !== r && (this.comments.length = r), this.comments.push(t), this.state.commentsLen++;
    }
    processComment(t) {
      let {
        commentStack: r
      } = this.state, n = r.length;
      if (n === 0) return;
      let i = n - 1, a = r[i];
      a.start === t.end && (a.leadingNode = t, i--);
      let {
        start: o
      } = t;
      for (; i >= 0; i--) {
        let l = r[i], u = l.end;
        if (u > o)
          l.containingNode = t, this.finalizeComment(l), r.splice(i, 1);
        else {
          u === o && (l.trailingNode = t);
          break;
        }
      }
    }
    finalizeComment(t) {
      let {
        comments: r
      } = t;
      if (t.leadingNode !== null || t.trailingNode !== null)
        t.leadingNode !== null && cT(t.leadingNode, r), t.trailingNode !== null && oG(t.trailingNode, r);
      else {
        let {
          containingNode: n,
          start: i
        } = t;
        if (this.input.charCodeAt(i - 1) === 44)
          switch (n.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              Wa(n, n.properties, t);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              Wa(n, n.arguments, t);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              Wa(n, n.params, t);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              Wa(n, n.elements, t);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              Wa(n, n.specifiers, t);
              break;
            default:
              Ja(n, r);
          }
        else
          Ja(n, r);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: t
      } = this.state;
      for (let r = t.length - 1; r >= 0; r--)
        this.finalizeComment(t[r]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(t) {
      let {
        commentStack: r
      } = this.state, {
        length: n
      } = r;
      if (n === 0) return;
      let i = r[n - 1];
      i.leadingNode === t && (i.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(t) {
      let {
        commentStack: r
      } = this.state, {
        length: n
      } = r;
      n !== 0 && (r[n - 1].trailingNode === t ? r[n - 1].trailingNode = null : n >= 2 && r[n - 2].trailingNode === t && (r[n - 2].trailingNode =
      null));
    }
    takeSurroundingComments(t, r, n) {
      let {
        commentStack: i
      } = this.state, a = i.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = i[o], u = l.end;
        if (l.start === n)
          l.leadingNode = t;
        else if (u === r)
          l.trailingNode = t;
        else if (u < r)
          break;
      }
    }
  }, lG = /\r\n|[\r\n\u2028\u2029]/, jl = new RegExp(lG.source, "g");
  function Si(e) {
    switch (e) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  s(Si, "isNewLine");
  function Hv(e, t, r) {
    for (let n = t; n < r; n++)
      if (Si(e.charCodeAt(n)))
        return !0;
    return !1;
  }
  s(Hv, "hasNewLine");
  var sh = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ih = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function uG(e) {
    switch (e) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  s(uG, "isWhitespace");
  var mh = class e {
    static {
      s(this, "State");
    }
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.
      potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [at.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(t) {
      t ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: t,
      sourceType: r,
      startLine: n,
      startColumn: i
    }) {
      this.strict = t === !1 ? !1 : t === !0 ? !0 : r === "module", this.curLine = n, this.lineStart = -i, this.startLoc = this.endLoc = new cn(
      n, i, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(t) {
      t ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(t) {
      t ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(t) {
      t ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(t) {
      t ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(t) {
      t ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(t) {
      t ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(t) {
      t ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(t) {
      t ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(t) {
      t ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(t) {
      t ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(t) {
      t ? this.flags |= 2048 : this.flags &= -2049;
    }
    get hasTopLevelAwait() {
      return (this.flags & 4096) > 0;
    }
    set hasTopLevelAwait(t) {
      t ? this.flags |= 4096 : this.flags &= -4097;
    }
    curPosition() {
      return new cn(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      let t = new e();
      return t.flags = this.flags, t.curLine = this.curLine, t.lineStart = this.lineStart, t.startLoc = this.startLoc, t.endLoc = this.endLoc,
      t.errors = this.errors.slice(), t.potentialArrowAt = this.potentialArrowAt, t.noArrowAt = this.noArrowAt.slice(), t.noArrowParamsConversionAt =
      this.noArrowParamsConversionAt.slice(), t.topicContext = this.topicContext, t.labels = this.labels.slice(), t.commentsLen = this.commentsLen,
      t.commentStack = this.commentStack.slice(), t.pos = this.pos, t.type = this.type, t.value = this.value, t.start = this.start, t.end = this.
      end, t.lastTokEndLoc = this.lastTokEndLoc, t.lastTokStartLoc = this.lastTokStartLoc, t.context = this.context.slice(), t.firstInvalidTemplateEscapePos =
      this.firstInvalidTemplateEscapePos, t.strictErrors = this.strictErrors, t.tokensLength = this.tokensLength, t;
    }
  }, cG = /* @__PURE__ */ s(function(t) {
    return t >= 48 && t <= 57;
  }, "isDigit"), Yv = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Ll = {
    bin: /* @__PURE__ */ s((e) => e === 48 || e === 49, "bin"),
    oct: /* @__PURE__ */ s((e) => e >= 48 && e <= 55, "oct"),
    dec: /* @__PURE__ */ s((e) => e >= 48 && e <= 57, "dec"),
    hex: /* @__PURE__ */ s((e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102, "hex")
  };
  function zv(e, t, r, n, i, a) {
    let o = r, l = n, u = i, c = "", f = null, p = r, {
      length: h
    } = t;
    for (; ; ) {
      if (r >= h) {
        a.unterminated(o, l, u), c += t.slice(p, r);
        break;
      }
      let y = t.charCodeAt(r);
      if (fG(e, y, t, r)) {
        c += t.slice(p, r);
        break;
      }
      if (y === 92) {
        c += t.slice(p, r);
        let v = pG(t, r, n, i, e === "template", a);
        v.ch === null && !f ? f = {
          pos: r,
          lineStart: n,
          curLine: i
        } : c += v.ch, {
          pos: r,
          lineStart: n,
          curLine: i
        } = v, p = r;
      } else y === 8232 || y === 8233 ? (++r, ++i, n = r) : y === 10 || y === 13 ? e === "template" ? (c += t.slice(p, r) + `
`, ++r, y === 13 && t.charCodeAt(r) === 10 && ++r, ++i, p = n = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: f,
      lineStart: n,
      curLine: i,
      containsInvalid: !!f
    };
  }
  s(zv, "readStringContents");
  function fG(e, t, r, n) {
    return e === "template" ? t === 96 || t === 36 && r.charCodeAt(n + 1) === 123 : t === (e === "double" ? 34 : 39);
  }
  s(fG, "isStringEnd");
  function pG(e, t, r, n, i, a) {
    let o = !i;
    t++;
    let l = /* @__PURE__ */ s((c) => ({
      pos: t,
      ch: c,
      lineStart: r,
      curLine: n
    }), "res"), u = e.charCodeAt(t++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: t
        } = yh(e, t, r, n, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: t
        } = pT(e, t, r, n, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        e.charCodeAt(t) === 10 && ++t;
      case 10:
        r = t, ++n;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (i)
          return l(null);
        a.strictNumericEscape(t - 1, r, n);
      default:
        if (u >= 48 && u <= 55) {
          let c = t - 1, p = /^[0-7]+/.exec(e.slice(c, t + 2))[0], h = parseInt(p, 8);
          h > 255 && (p = p.slice(0, -1), h = parseInt(p, 8)), t += p.length - 1;
          let y = e.charCodeAt(t);
          if (p !== "0" || y === 56 || y === 57) {
            if (i)
              return l(null);
            a.strictNumericEscape(c, r, n);
          }
          return l(String.fromCharCode(h));
        }
        return l(String.fromCharCode(u));
    }
  }
  s(pG, "readEscapedChar");
  function yh(e, t, r, n, i, a, o, l) {
    let u = t, c;
    return {
      n: c,
      pos: t
    } = fT(e, t, r, n, 16, i, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, n) : t = u - 1), {
      code: c,
      pos: t
    };
  }
  s(yh, "readHexChar");
  function fT(e, t, r, n, i, a, o, l, u, c) {
    let f = t, p = i === 16 ? Yv.hex : Yv.decBinOct, h = i === 16 ? Ll.hex : i === 10 ? Ll.dec : i === 8 ? Ll.oct : Ll.bin, y = !1, v = 0;
    for (let d = 0, b = a ?? 1 / 0; d < b; ++d) {
      let E = e.charCodeAt(t), I;
      if (E === 95 && l !== "bail") {
        let O = e.charCodeAt(t - 1), k = e.charCodeAt(t + 1);
        if (l) {
          if (Number.isNaN(k) || !h(k) || p.has(O) || p.has(k)) {
            if (c) return {
              n: null,
              pos: t
            };
            u.unexpectedNumericSeparator(t, r, n);
          }
        } else {
          if (c) return {
            n: null,
            pos: t
          };
          u.numericSeparatorInEscapeSequence(t, r, n);
        }
        ++t;
        continue;
      }
      if (E >= 97 ? I = E - 97 + 10 : E >= 65 ? I = E - 65 + 10 : cG(E) ? I = E - 48 : I = 1 / 0, I >= i) {
        if (I <= 9 && c)
          return {
            n: null,
            pos: t
          };
        if (I <= 9 && u.invalidDigit(t, r, n, i))
          I = 0;
        else if (o)
          I = 0, y = !0;
        else
          break;
      }
      ++t, v = v * i + I;
    }
    return t === f || a != null && t - f !== a || y ? {
      n: null,
      pos: t
    } : {
      n: v,
      pos: t
    };
  }
  s(fT, "readInt");
  function pT(e, t, r, n, i, a) {
    let o = e.charCodeAt(t), l;
    if (o === 123) {
      if (++t, {
        code: l,
        pos: t
      } = yh(e, t, r, n, e.indexOf("}", t) - t, !0, i, a), ++t, l !== null && l > 1114111)
        if (i)
          a.invalidCodePoint(t, r, n);
        else
          return {
            code: null,
            pos: t
          };
    } else
      ({
        code: l,
        pos: t
      } = yh(e, t, r, n, 4, !1, i, a));
    return {
      code: l,
      pos: t
    };
  }
  s(pT, "readCodePoint");
  function Ka(e, t, r) {
    return new cn(r, e - t, e);
  }
  s(Ka, "buildPosition");
  var dG = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), un = class {
    static {
      s(this, "Token");
    }
    constructor(t) {
      this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new Ai(t.startLoc, t.endLoc);
    }
  }, gh = class extends hh {
    static {
      s(this, "Tokenizer");
    }
    constructor(t, r) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ s((n, i, a, o) => this.options.errorRecovery ? (this.raise(_.InvalidDigit, Ka(n, i, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(_.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(_.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(_.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(_.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ s((n, i, a) => {
          this.recordStrictModeErrors(_.StrictNumericEscape, Ka(n, i, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ s((n, i, a) => {
          throw this.raise(_.UnterminatedString, Ka(n - 1, i, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(_.StrictNumericEscape),
        unterminated: /* @__PURE__ */ s((n, i, a) => {
          throw this.raise(_.UnterminatedTemplate, Ka(n, i, a));
        }, "unterminated")
      }), this.state = new mh(), this.state.init(t), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(t) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new un(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.
      state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(t) {
      return this.match(t) ? (this.next(), !0) : !1;
    }
    match(t) {
      return this.state.type === t;
    }
    createLookaheadState(t) {
      return {
        pos: t.pos,
        value: null,
        type: t.type,
        start: t.start,
        end: t.end,
        context: [this.curContext()],
        inType: t.inType,
        startLoc: t.startLoc,
        lastTokEndLoc: t.lastTokEndLoc,
        curLine: t.curLine,
        lineStart: t.lineStart,
        curPosition: t.curPosition
      };
    }
    lookahead() {
      let t = this.state;
      this.state = this.createLookaheadState(t), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let r = this.state;
      return this.state = t, r;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(t) {
      return sh.lastIndex = t, sh.test(this.input) ? sh.lastIndex : t;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(t) {
      return ih.lastIndex = t, ih.test(this.input) ? ih.lastIndex : t;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(t) {
      let r = this.input.charCodeAt(t);
      if ((r & 64512) === 55296 && ++t < this.input.length) {
        let n = this.input.charCodeAt(t);
        (n & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (n & 1023));
      }
      return r;
    }
    setStrict(t) {
      this.state.strict = t, t && (this.state.strictErrors.forEach(([r, n]) => this.raise(r, n)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(t) {
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let n = this.state.pos, i = this.input.indexOf(t, n + 2);
      if (i === -1)
        throw this.raise(_.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = i + t.length, jl.lastIndex = n + 2; jl.test(this.input) && jl.lastIndex <= i; )
        ++this.state.curLine, this.state.lineStart = jl.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(n + 2, i),
        start: n,
        end: i + t.length,
        loc: new Ai(r, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(a), a;
    }
    skipLineComment(t) {
      let r = this.state.pos, n;
      this.isLookahead || (n = this.state.curPosition());
      let i = this.input.charCodeAt(this.state.pos += t);
      if (this.state.pos < this.length)
        for (; !Si(i) && ++this.state.pos < this.length; )
          i = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(r + t, a),
        start: r,
        end: a,
        loc: new Ai(n, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(l), l;
    }
    skipSpace() {
      let t = this.state.pos, r = [];
      e: for (; this.state.pos < this.length; ) {
        let n = this.input.charCodeAt(this.state.pos);
        switch (n) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let i = this.skipBlockComment("*/");
                i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                break;
              }
              case 47: {
                let i = this.skipLineComment(2);
                i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (uG(n))
              ++this.state.pos;
            else if (n === 45 && !this.inModule && this.options.annexB) {
              let i = this.state.pos;
              if (this.input.charCodeAt(i + 1) === 45 && this.input.charCodeAt(i + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else if (n === 60 && !this.inModule && this.options.annexB) {
              let i = this.state.pos;
              if (this.input.charCodeAt(i + 1) === 33 && this.input.charCodeAt(i + 2) === 45 && this.input.charCodeAt(i + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (r.length > 0) {
        let n = this.state.pos, i = {
          start: t,
          end: n,
          comments: r,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(i);
      }
    }
    finishToken(t, r) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let n = this.state.type;
      this.state.type = t, this.state.value = r, this.isLookahead || this.updateContext(n);
    }
    replaceToken(t) {
      this.state.type = t, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let t = this.state.pos + 1, r = this.codePointAtPos(t);
      if (r >= 48 && r <= 57)
        throw this.raise(_.UnexpectedDigitAfterHash, this.state.curPosition());
      if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(r === 123 ? _.RecordExpressionHashIncorrectStartSyntaxType : _.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
      } else wn(r) ? (++this.state.pos, this.finishToken(138, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(138, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t >= 48 && t <= 57) {
        this.readNumber(!0);
        return;
      }
      t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t !== 33) return !1;
      let r = this.state.pos;
      for (this.state.pos += 1; !Si(t) && ++this.state.pos < this.length; )
        t = this.input.charCodeAt(this.state.pos);
      let n = this.input.slice(r + 2, this.state.pos);
      return this.finishToken(28, n), !0;
    }
    readToken_mult_modulo(t) {
      let r = t === 42 ? 55 : 54, n = 1, i = this.input.charCodeAt(this.state.pos + 1);
      t === 42 && i === 42 && (n++, i = this.input.charCodeAt(this.state.pos + 2), r = 57), i === 61 && !this.state.inType && (n++, r = t ===
      37 ? 33 : 30), this.finishOp(r, n);
    }
    readToken_pipe_amp(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === t) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
        return;
      }
      if (t === 124) {
        if (r === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(_.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(_.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (r === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(t === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === t) {
        this.finishOp(34, 2);
        return;
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: t
      } = this.state, r = this.input.charCodeAt(t + 1);
      if (r === 60) {
        if (this.input.charCodeAt(t + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: t
      } = this.state, r = this.input.charCodeAt(t + 1);
      if (r === 62) {
        let n = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(t + n) === 61) {
          this.finishOp(30, n + 1);
          return;
        }
        this.finishOp(52, n);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (t === 61 && r === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(t === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let t = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
      t === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(t) {
      switch (t) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(_.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(_.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let r = this.input.charCodeAt(this.state.pos + 1);
          if (r === 120 || r === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(t);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(t);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(t);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(t);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(t);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (wn(t)) {
            this.readWord(t);
            return;
          }
      }
      throw this.raise(_.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(t)
      });
    }
    finishOp(t, r) {
      let n = this.input.slice(this.state.pos, this.state.pos + r);
      this.state.pos += r, this.finishToken(t, n);
    }
    readRegexp() {
      let t = this.state.startLoc, r = this.state.start + 1, n, i, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(_.UnterminatedRegExp, ar(t, 1));
        let c = this.input.charCodeAt(a);
        if (Si(c))
          throw this.raise(_.UnterminatedRegExp, ar(t, 1));
        if (n)
          n = !1;
        else {
          if (c === 91)
            i = !0;
          else if (c === 93 && i)
            i = !1;
          else if (c === 47 && !i)
            break;
          n = c === 92;
        }
      }
      let o = this.input.slice(r, a);
      ++a;
      let l = "", u = /* @__PURE__ */ s(() => ar(t, a + 2 - r), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), f = String.fromCharCode(c);
        if (dG.has(c))
          c === 118 ? l.includes("u") && this.raise(_.IncompatibleRegExpUVFlags, u()) : c === 117 && l.includes("v") && this.raise(_.IncompatibleRegExpUVFlags,
          u()), l.includes(f) && this.raise(_.DuplicateRegExpFlags, u());
        else if (xi(c) || c === 92)
          this.raise(_.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += f;
      }
      this.state.pos = a, this.finishToken(137, {
        pattern: o,
        flags: l
      });
    }
    readInt(t, r, n = !1, i = !0) {
      let {
        n: a,
        pos: o
      } = fT(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, r, n, i, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(t) {
      let r = this.state.curPosition(), n = !1;
      this.state.pos += 2;
      let i = this.readInt(t);
      i == null && this.raise(_.InvalidDigit, ar(r, 2), {
        radix: t
      });
      let a = this.input.charCodeAt(this.state.pos);
      if (a === 110)
        ++this.state.pos, n = !0;
      else if (a === 109)
        throw this.raise(_.InvalidDecimal, r);
      if (wn(this.codePointAtPos(this.state.pos)))
        throw this.raise(_.NumberIdentifier, this.state.curPosition());
      if (n) {
        let o = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, o);
        return;
      }
      this.finishToken(134, i);
    }
    readNumber(t) {
      let r = this.state.pos, n = this.state.curPosition(), i = !1, a = !1, o = !1, l = !1, u = !1;
      !t && this.readInt(10) === null && this.raise(_.InvalidNumber, this.state.curPosition());
      let c = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
      if (c) {
        let y = this.input.slice(r, this.state.pos);
        if (this.recordStrictModeErrors(_.StrictOctalLiteral, n), !this.state.strict) {
          let v = y.indexOf("_");
          v > 0 && this.raise(_.ZeroDigitNumericSeparator, ar(n, v));
        }
        u = c && !/[89]/.test(y);
      }
      let f = this.input.charCodeAt(this.state.pos);
      if (f === 46 && !u && (++this.state.pos, this.readInt(10), i = !0, f = this.input.charCodeAt(this.state.pos)), (f === 69 || f === 101) &&
      !u && (f = this.input.charCodeAt(++this.state.pos), (f === 43 || f === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      _.InvalidOrMissingExponent, n), i = !0, l = !0, f = this.input.charCodeAt(this.state.pos)), f === 110 && ((i || c) && this.raise(_.InvalidBigIntLiteral,
      n), ++this.state.pos, a = !0), f === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (l || c) && this.raise(_.InvalidDecimal,
      n), ++this.state.pos, o = !0), wn(this.codePointAtPos(this.state.pos)))
        throw this.raise(_.NumberIdentifier, this.state.curPosition());
      let p = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(135, p);
        return;
      }
      if (o) {
        this.finishToken(136, p);
        return;
      }
      let h = u ? parseInt(p, 8) : parseFloat(p);
      this.finishToken(134, h);
    }
    readCodePoint(t) {
      let {
        code: r,
        pos: n
      } = pT(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
      return this.state.pos = n, r;
    }
    readString(t) {
      let {
        str: r,
        pos: n,
        curLine: i,
        lineStart: a
      } = zv(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = n + 1, this.state.lineStart = a, this.state.curLine = i, this.finishToken(133, r);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let t = this.input[this.state.pos], {
        str: r,
        firstInvalidLoc: n,
        pos: i,
        curLine: a,
        lineStart: o
      } = zv("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = i + 1, this.state.lineStart = o, this.state.curLine = a, n && (this.state.firstInvalidTemplateEscapePos = new cn(n.curLine,
      n.pos - n.lineStart, n.pos)), this.input.codePointAt(i) === 96 ? this.finishToken(24, n ? null : t + r + "`") : (this.state.pos++, this.
      finishToken(25, n ? null : t + r + "${"));
    }
    recordStrictModeErrors(t, r) {
      let n = r.index;
      this.state.strict && !this.state.strictErrors.has(n) ? this.raise(t, r) : this.state.strictErrors.set(n, [t, r]);
    }
    readWord1(t) {
      this.state.containsEsc = !1;
      let r = "", n = this.state.pos, i = this.state.pos;
      for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (xi(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, r += this.input.slice(i, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === n ? wn : xi;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(_.MissingUnicodeEscape, this.state.curPosition()), i = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(_.EscapedCharNotAnIdentifier, o), r += String.fromCodePoint(u)), i = this.state.pos;
        } else
          break;
      }
      return r + this.input.slice(i, this.state.pos);
    }
    readWord(t) {
      let r = this.readWord1(t), n = Ih.get(r);
      n !== void 0 ? this.finishToken(n, ns(n)) : this.finishToken(132, r);
    }
    checkKeywordEscapes() {
      let {
        type: t
      } = this.state;
      Fh(t) && this.state.containsEsc && this.raise(_.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: ns(t)
      });
    }
    raise(t, r, n = {}) {
      let i = r instanceof cn ? r : r.loc.start, a = t(i, n);
      if (!this.options.errorRecovery) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(t, r, n = {}) {
      let i = r instanceof cn ? r : r.loc.start, a = i.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = t(i, n);
        if (u.loc.index < a) break;
      }
      return this.raise(t, r, n);
    }
    updateContext(t) {
    }
    unexpected(t, r) {
      throw this.raise(_.UnexpectedToken, t ?? this.state.startLoc, {
        expected: r ? ns(r) : null
      });
    }
    expectPlugin(t, r) {
      if (this.hasPlugin(t))
        return !0;
      throw this.raise(_.MissingPlugin, r ?? this.state.startLoc, {
        missingPlugin: [t]
      });
    }
    expectOnePlugin(t) {
      if (!t.some((r) => this.hasPlugin(r)))
        throw this.raise(_.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: t
        });
    }
    errorBuilder(t) {
      return (r, n, i) => {
        this.raise(t, Ka(r, n, i));
      };
    }
  }, bh = class {
    static {
      s(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, Eh = class {
    static {
      s(this, "ClassScopeHandler");
    }
    constructor(t) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new bh());
    }
    exit() {
      let t = this.stack.pop(), r = this.current();
      for (let [n, i] of Array.from(t.undefinedPrivateNames))
        r ? r.undefinedPrivateNames.has(n) || r.undefinedPrivateNames.set(n, i) : this.parser.raise(_.InvalidPrivateFieldResolution, i, {
          identifierName: n
        });
    }
    declarePrivateName(t, r, n) {
      let {
        privateNames: i,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = i.has(t);
      if (r & 3) {
        let u = l && a.get(t);
        if (u) {
          let c = u & 4, f = r & 4, p = u & 3, h = r & 3;
          l = p === h || c !== f, l || a.delete(t);
        } else l || a.set(t, r);
      }
      l && this.parser.raise(_.PrivateNameRedeclaration, n, {
        identifierName: t
      }), i.add(t), o.delete(t);
    }
    usePrivateName(t, r) {
      let n;
      for (n of this.stack)
        if (n.privateNames.has(t)) return;
      n ? n.undefinedPrivateNames.set(t, r) : this.parser.raise(_.InvalidPrivateFieldResolution, r, {
        identifierName: t
      });
    }
  }, Ci = class {
    static {
      s(this, "ExpressionScope");
    }
    constructor(t = 0) {
      this.type = t;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, $l = class extends Ci {
    static {
      s(this, "ArrowHeadParsingScope");
    }
    constructor(t) {
      super(t), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(t, r) {
      let n = r.index;
      this.declarationErrors.set(n, [t, r]);
    }
    clearDeclarationError(t) {
      this.declarationErrors.delete(t);
    }
    iterateErrors(t) {
      this.declarationErrors.forEach(t);
    }
  }, vh = class {
    static {
      s(this, "ExpressionScopeHandler");
    }
    constructor(t) {
      this.parser = void 0, this.stack = [new Ci()], this.parser = t;
    }
    enter(t) {
      this.stack.push(t);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(t, r) {
      let n = r.loc.start, {
        stack: i
      } = this, a = i.length - 1, o = i[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(t, n);
        else
          return;
        o = i[--a];
      }
      this.parser.raise(t, n);
    }
    recordArrowParameterBindingError(t, r) {
      let {
        stack: n
      } = this, i = n[n.length - 1], a = r.loc.start;
      if (i.isCertainlyParameterDeclaration())
        this.parser.raise(t, a);
      else if (i.canBeArrowParameterDeclaration())
        i.recordDeclarationError(t, a);
      else
        return;
    }
    recordAsyncArrowParametersError(t) {
      let {
        stack: r
      } = this, n = r.length - 1, i = r[n];
      for (; i.canBeArrowParameterDeclaration(); )
        i.type === 2 && i.recordDeclarationError(_.AwaitBindingIdentifier, t), i = r[--n];
    }
    validateAsPattern() {
      let {
        stack: t
      } = this, r = t[t.length - 1];
      r.canBeArrowParameterDeclaration() && r.iterateErrors(([n, i]) => {
        this.parser.raise(n, i);
        let a = t.length - 2, o = t[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(i.index), o = t[--a];
      });
    }
  };
  function hG() {
    return new Ci(3);
  }
  s(hG, "newParameterDeclarationScope");
  function mG() {
    return new $l(1);
  }
  s(mG, "newArrowHeadScope");
  function yG() {
    return new $l(2);
  }
  s(yG, "newAsyncArrowScope");
  function dT() {
    return new Ci();
  }
  s(dT, "newExpressionScope");
  var Th = class {
    static {
      s(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(t) {
      this.stacks.push(t);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function ql(e, t) {
    return (e ? 2 : 0) | (t ? 1 : 0);
  }
  s(ql, "functionFlags");
  var xh = class extends gh {
    static {
      s(this, "UtilParser");
    }
    addExtra(t, r, n, i = !0) {
      if (!t) return;
      let {
        extra: a
      } = t;
      a == null && (a = {}, t.extra = a), i ? a[r] = n : Object.defineProperty(a, r, {
        enumerable: i,
        value: n
      });
    }
    isContextual(t) {
      return this.state.type === t && !this.state.containsEsc;
    }
    isUnparsedContextual(t, r) {
      let n = t + r.length;
      if (this.input.slice(t, n) === r) {
        let i = this.input.charCodeAt(n);
        return !(xi(i) || (i & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(t) {
      let r = this.nextTokenStart();
      return this.isUnparsedContextual(r, t);
    }
    eatContextual(t) {
      return this.isContextual(t) ? (this.next(), !0) : !1;
    }
    expectContextual(t, r) {
      if (!this.eatContextual(t)) {
        if (r != null)
          throw this.raise(r, this.state.startLoc);
        this.unexpected(null, t);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return Hv(this.input, this.state.lastTokEndLoc.index, this.state.start);
    }
    hasFollowingLineBreak() {
      return Hv(this.input, this.state.end, this.nextTokenStart());
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(t = !0) {
      (t ? this.isLineTerminator() : this.eat(13)) || this.raise(_.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(t, r) {
      this.eat(t) || this.unexpected(r, t);
    }
    tryParse(t, r = this.state.clone()) {
      let n = {
        node: null
      };
      try {
        let i = t((a = null) => {
          throw n.node = a, n;
        });
        if (this.state.errors.length > r.errors.length) {
          let a = this.state;
          return this.state = r, this.state.tokensLength = a.tokensLength, {
            node: i,
            error: a.errors[r.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: i,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (i) {
        let a = this.state;
        if (this.state = r, i instanceof SyntaxError)
          return {
            node: null,
            error: i,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (i === n)
          return {
            node: n.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw i;
      }
    }
    checkExpressionErrors(t, r) {
      if (!t) return !1;
      let {
        shorthandAssignLoc: n,
        doubleProtoLoc: i,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = t, l = !!n || !!i || !!o || !!a;
      if (!r)
        return l;
      n != null && this.raise(_.InvalidCoverInitializedName, n), i != null && this.raise(_.DuplicateProto, i), a != null && this.raise(_.UnexpectedPrivateField,
      a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return nT(this.state.type);
    }
    isPrivateName(t) {
      return t.type === "PrivateName";
    }
    getPrivateNameSV(t) {
      return t.id.name;
    }
    hasPropertyAsPrivateName(t) {
      return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
    }
    isObjectProperty(t) {
      return t.type === "ObjectProperty";
    }
    isObjectMethod(t) {
      return t.type === "ObjectMethod";
    }
    initializeScopes(t = this.options.sourceType === "module") {
      let r = this.state.labels;
      this.state.labels = [];
      let n = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let i = this.inModule;
      this.inModule = t;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, t);
      let l = this.prodParam;
      this.prodParam = new Th();
      let u = this.classScope;
      this.classScope = new Eh(this);
      let c = this.expressionScope;
      return this.expressionScope = new vh(this), () => {
        this.state.labels = r, this.exportedIdentifiers = n, this.inModule = i, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let t = 0;
      this.inModule && (t |= 2), this.scope.enter(1), this.prodParam.enter(t);
    }
    checkDestructuringPrivate(t) {
      let {
        privateKeyLoc: r
      } = t;
      r !== null && this.expectPlugin("destructuringPrivate", r);
    }
  }, Pi = class {
    static {
      s(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, wi = class {
    static {
      s(this, "Node");
    }
    constructor(t, r, n) {
      this.type = "", this.start = r, this.end = 0, this.loc = new Ai(n), t != null && t.options.ranges && (this.range = [r, 0]), t != null &&
      t.filename && (this.loc.filename = t.filename);
    }
  }, Mh = wi.prototype;
  Mh.__clone = function() {
    let e = new wi(void 0, this.start, this.loc.start), t = Object.keys(this);
    for (let r = 0, n = t.length; r < n; r++) {
      let i = t[r];
      i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (e[i] = this[i]);
    }
    return e;
  };
  function gG(e) {
    return In(e);
  }
  s(gG, "clonePlaceholder");
  function In(e) {
    let {
      type: t,
      start: r,
      end: n,
      loc: i,
      range: a,
      extra: o,
      name: l
    } = e, u = Object.create(Mh);
    return u.type = t, u.start = r, u.end = n, u.loc = i, u.range = a, u.extra = o, u.name = l, t === "Placeholder" && (u.expectedNode = e.expectedNode),
    u;
  }
  s(In, "cloneIdentifier");
  function bG(e) {
    let {
      type: t,
      start: r,
      end: n,
      loc: i,
      range: a,
      extra: o
    } = e;
    if (t === "Placeholder")
      return gG(e);
    let l = Object.create(Mh);
    return l.type = t, l.start = r, l.end = n, l.loc = i, l.range = a, e.raw !== void 0 ? l.raw = e.raw : l.extra = o, l.value = e.value, l;
  }
  s(bG, "cloneStringLiteral");
  var Sh = class extends xh {
    static {
      s(this, "NodeUtils");
    }
    startNode() {
      let t = this.state.startLoc;
      return new wi(this, t.index, t);
    }
    startNodeAt(t) {
      return new wi(this, t.index, t);
    }
    startNodeAtNode(t) {
      return this.startNodeAt(t.loc.start);
    }
    finishNode(t, r) {
      return this.finishNodeAt(t, r, this.state.lastTokEndLoc);
    }
    finishNodeAt(t, r, n) {
      return t.type = r, t.end = n.index, t.loc.end = n, this.options.ranges && (t.range[1] = n.index), this.options.attachComment && this.processComment(
      t), t;
    }
    resetStartLocation(t, r) {
      t.start = r.index, t.loc.start = r, this.options.ranges && (t.range[0] = r.index);
    }
    resetEndLocation(t, r = this.state.lastTokEndLoc) {
      t.end = r.index, t.loc.end = r, this.options.ranges && (t.range[1] = r.index);
    }
    resetStartLocationFromNode(t, r) {
      this.resetStartLocation(t, r.loc.start);
    }
  }, EG = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "stat\
ic", "string", "true", "typeof", "void"]), Ae = Dn`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ s(({
      reservedType: e
    }) => `Cannot overwrite reserved type ${e}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ s(({
      memberName: e,
      enumName: t
    }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ s(({
      memberName: e,
      enumName: t
    }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ s(({
      enumName: e
    }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ s(({
      invalidEnumType: e,
      enumName: t
    }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ s(({
      enumName: e
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t,
      explicitType: r
    }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t
    }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t
    }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t
    }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ s(({
      enumName: e
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ s(({
      reservedType: e
    }) => `Unexpected reserved type ${e}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ s(({
      unsupportedExportKind: e,
      suggestion: t
    }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function vG(e) {
    return e.type === "DeclareExportAllDeclaration" || e.type === "DeclareExportDeclaration" && (!e.declaration || e.declaration.type !== "T\
ypeAlias" && e.declaration.type !== "InterfaceDeclaration");
  }
  s(vG, "isEsModuleType");
  function Jv(e) {
    return e.importKind === "type" || e.importKind === "typeof";
  }
  s(Jv, "hasTypeImportKind");
  var TG = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function xG(e, t) {
    let r = [], n = [];
    for (let i = 0; i < e.length; i++)
      (t(e[i], i, e) ? r : n).push(e[i]);
    return [r, n];
  }
  s(xG, "partition");
  var SG = /\*?\s*@((?:no)?flow)\b/, PG = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "FlowParserMixin");
    }
    constructor(...r) {
      super(...r), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return ph;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(r, n) {
      r !== 133 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, n);
    }
    addComment(r) {
      if (this.flowPragma === void 0) {
        let n = SG.exec(r.value);
        if (n) if (n[1] === "flow")
          this.flowPragma = "flow";
        else if (n[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(r);
    }
    flowParseTypeInitialiser(r) {
      let n = this.state.inType;
      this.state.inType = !0, this.expect(r || 14);
      let i = this.flowParseType();
      return this.state.inType = n, i;
    }
    flowParsePredicate() {
      let r = this.startNode(), n = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > n.index + 1 && this.raise(Ae.UnexpectedSpaceBetweenModuloChecks,
      n), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let r = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let n = null, i = null;
      return this.match(54) ? (this.state.inType = r, i = this.flowParsePredicate()) : (n = this.flowParseType(), this.state.inType = r, this.
      match(54) && (i = this.flowParsePredicate())), [n, i];
    }
    flowParseDeclareClass(r) {
      return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
    }
    flowParseDeclareFunction(r) {
      this.next();
      let n = r.id = this.parseIdentifier(), i = this.startNode(), a = this.startNode();
      this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return i.params = o.params, i.rest = o.rest, i.this = o._this, this.expect(11), [i.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), n.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      n), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
    }
    flowParseDeclare(r, n) {
      if (this.match(80))
        return this.flowParseDeclareClass(r);
      if (this.match(68))
        return this.flowParseDeclareFunction(r);
      if (this.match(74))
        return this.flowParseDeclareVariable(r);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(r) : (n && this.raise(Ae.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(r));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(r);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(r);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(r);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(r, n);
      this.unexpected();
    }
    flowParseDeclareVariable(r) {
      return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(),
      this.finishNode(r, "DeclareVariable");
    }
    flowParseDeclareModule(r) {
      this.scope.enter(0), this.match(133) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
      let n = r.body = this.startNode(), i = n.body = [];
      for (this.expect(5); !this.match(8); ) {
        let l = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(Ae.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), super.parseImport(l)) : (this.expectContextual(125, Ae.UnsupportedStatementInDeclareModule), l = this.flowParseDeclare(
        l, !0)), i.push(l);
      }
      this.scope.exit(), this.expect(8), this.finishNode(n, "BlockStatement");
      let a = null, o = !1;
      return i.forEach((l) => {
        vG(l) ? (a === "CommonJS" && this.raise(Ae.AmbiguousDeclareModuleKind, l), a = "ES") : l.type === "DeclareModuleExports" && (o && this.
        raise(Ae.DuplicateDeclareModuleExports, l), a === "ES" && this.raise(Ae.AmbiguousDeclareModuleKind, l), a = "CommonJS", o = !0);
      }), r.kind = a || "CommonJS", this.finishNode(r, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(r, n) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(),
        this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !n) {
        let i = this.state.value;
        throw this.raise(Ae.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: i,
          suggestion: TG[i]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.
        exportKind), r.type = "Declare" + r.type, r;
      this.unexpected();
    }
    flowParseDeclareModuleExports(r) {
      return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(r) {
      this.next();
      let n = this.flowParseTypeAlias(r);
      return n.type = "DeclareTypeAlias", n;
    }
    flowParseDeclareOpaqueType(r) {
      this.next();
      let n = this.flowParseOpaqueType(r, !0);
      return n.type = "DeclareOpaqueType", n;
    }
    flowParseDeclareInterface(r) {
      return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
    }
    flowParseInterfaceish(r, n) {
      if (r.id = this.flowParseRestrictedIdentifier(!n, !0), this.scope.declareName(r.id.name, n ? 17 : 8201, r.id.loc.start), this.match(47) ?
      r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (!n && this.eat(12));
      if (n) {
        if (r.implements = [], r.mixins = [], this.eatContextual(117))
          do
            r.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            r.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      r.body = this.flowParseObjectType({
        allowStatic: n,
        allowExact: !1,
        allowSpread: !1,
        allowProto: n,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let r = this.startNode();
      return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() :
      r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
    }
    flowParseInterface(r) {
      return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
    }
    checkNotUnderscore(r) {
      r === "_" && this.raise(Ae.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(r, n, i) {
      EG.has(r) && this.raise(i ? Ae.AssignReservedType : Ae.UnexpectedReservedType, n, {
        reservedType: r
      });
    }
    flowParseRestrictedIdentifier(r, n) {
      return this.checkReservedType(this.state.value, this.state.startLoc, n), this.parseIdentifier(r);
    }
    flowParseTypeAlias(r) {
      return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.
      typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(r, "TypeAlias");
    }
    flowParseOpaqueType(r, n) {
      return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.
      start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.
      match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, n || (r.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(r, "OpaqueType");
    }
    flowParseTypeParameter(r = !1) {
      let n = this.state.startLoc, i = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return i.name = o.name, i.variance = a, i.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) :
      r && this.raise(Ae.MissingTypeParamDefault, n), this.finishNode(i, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let r = this.state.inType, n = this.startNode();
      n.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let i = !1;
      do {
        let a = this.flowParseTypeParameter(i);
        n.params.push(a), a.default && (i = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = r, this.finishNode(n, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      let r = this.startNode(), n = this.state.inType;
      r.params = [], this.state.inType = !0, this.expect(47);
      let i = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = !1; !this.match(48); )
        r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = i, this.expect(48), this.state.inType = n, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      let r = this.startNode(), n = this.state.inType;
      for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = n, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let r = this.startNode();
      if (this.expectContextual(129), r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return r.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(r, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(r, n, i) {
      return r.static = n, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) :
      (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = i, this.finishNode(
      r, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(r, n) {
      return r.static = n, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method =
      !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.
      optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(r) {
      for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(r, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(r, n) {
      let i = this.startNode();
      return r.static = n, r.value = this.flowParseObjectTypeMethodish(i), this.finishNode(r, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: r,
      allowExact: n,
      allowSpread: i,
      allowProto: a,
      allowInexact: o
    }) {
      let l = this.state.inType;
      this.state.inType = !0;
      let u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let c, f, p = !1;
      for (n && this.match(6) ? (this.expect(6), c = 9, f = !0) : (this.expect(5), c = 8, f = !1), u.exact = f; !this.match(c); ) {
        let y = !1, v = null, d = null, b = this.startNode();
        if (a && this.isContextual(118)) {
          let I = this.lookahead();
          I.type !== 14 && I.type !== 17 && (this.next(), v = this.state.startLoc, r = !1);
        }
        if (r && this.isContextual(106)) {
          let I = this.lookahead();
          I.type !== 14 && I.type !== 17 && (this.next(), y = !0);
        }
        let E = this.flowParseVariance();
        if (this.eat(0))
          v != null && this.unexpected(v), this.eat(0) ? (E && this.unexpected(E.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          b, y))) : u.indexers.push(this.flowParseObjectTypeIndexer(b, y, E));
        else if (this.match(10) || this.match(47))
          v != null && this.unexpected(v), E && this.unexpected(E.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(b, y));
        else {
          let I = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let k = this.lookahead();
            nT(k.type) && (I = this.state.value, this.next());
          }
          let O = this.flowParseObjectTypeProperty(b, y, v, E, I, i, o ?? !f);
          O === null ? (p = !0, d = this.state.lastTokStartLoc) : u.properties.push(O);
        }
        this.flowObjectTypeSemicolon(), d && !this.match(8) && !this.match(9) && this.raise(Ae.UnexpectedExplicitInexactInObject, d);
      }
      this.expect(c), i && (u.inexact = p);
      let h = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = l, h;
    }
    flowParseObjectTypeProperty(r, n, i, a, o, l, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(Ae.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(Ae.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(Ae.InexactVariance, a), null) : (l || this.raise(
        Ae.UnexpectedSpreadType, this.state.lastTokStartLoc), i != null && this.unexpected(i), a && this.raise(Ae.SpreadVariance, a), r.argument =
        this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
      {
        r.key = this.flowParseObjectPropertyKey(), r.static = n, r.proto = i != null, r.kind = o;
        let c = !1;
        return this.match(47) || this.match(10) ? (r.method = !0, i != null && this.unexpected(i), a && this.unexpected(a.loc.start), r.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(r),
        !l && r.key.name === "constructor" && r.value.this && this.raise(Ae.ThisParamBannedInConstructor, r.value.this)) : (o !== "init" && this.
        unexpected(), r.method = !1, this.eat(17) && (c = !0), r.value = this.flowParseTypeInitialiser(), r.variance = a), r.optional = c, this.
        finishNode(r, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(r) {
      let n = r.kind === "get" ? 0 : 1, i = r.value.params.length + (r.value.rest ? 1 : 0);
      r.value.this && this.raise(r.kind === "get" ? Ae.GetterMayNotHaveThisParam : Ae.SetterMayNotHaveThisParam, r.value.this), i !== n && this.
      raise(r.kind === "get" ? _.BadGetterArity : _.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(_.BadSetterRestParameter,
      r);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(r, n) {
      var i;
      (i = r) != null || (r = this.state.startLoc);
      let a = n || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let o = this.startNodeAt(r);
        o.qualification = a, o.id = this.flowParseRestrictedIdentifier(!0), a = this.finishNode(o, "QualifiedTypeIdentifier");
      }
      return a;
    }
    flowParseGenericType(r, n) {
      let i = this.startNodeAt(r);
      return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(r, n), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(i, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let r = this.startNode();
      return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let r = this.startNode();
      for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(r) {
      let n = null, i = !1, a = null, o = this.startNode(), l = this.lookahead(), u = this.state.type === 78;
      return l.type === 14 || l.type === 17 ? (u && !r && this.raise(Ae.ThisParamMustBeFirst, o), n = this.parseIdentifier(u), this.eat(17) &&
      (i = !0, u && this.raise(Ae.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = n,
      o.optional = i, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(r) {
      let n = this.startNodeAt(r.loc.start);
      return n.name = null, n.optional = !1, n.typeAnnotation = r, this.finishNode(n, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(r = []) {
      let n = null, i = null;
      for (this.match(78) && (i = this.flowParseFunctionTypeParam(!0), i.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (n = this.flowParseFunctionTypeParam(!1)), {
        params: r,
        rest: n,
        _this: i
      };
    }
    flowIdentToTypeAnnotation(r, n, i) {
      switch (i.name) {
        case "any":
          return this.finishNode(n, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(n, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(n, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(n, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(n, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(n, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(n, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(i.name), this.flowParseGenericType(r, i);
      }
    }
    flowParsePrimaryType() {
      let r = this.state.startLoc, n = this.startNode(), i, a, o = !1, l = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = l, a;
        case 47: {
          let u = this.startNode();
          return u.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), u.params =
          i.params, u.rest = i.rest, u.this = i._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), this.finishNode(
          u, "FunctionTypeAnnotation");
        }
        case 10: {
          let u = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (tt(this.state.type) || this.match(78)) {
              let c = this.lookahead().type;
              o = c !== 17 && c !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = l, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : i = this.flowParseFunctionTypeParams(),
          u.params = i.params, u.rest = i.rest, u.this = i._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), u.typeParameters =
          null, this.finishNode(u, "FunctionTypeAnnotation");
        }
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return n.value = this.match(85), this.next(), this.finishNode(n, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(134))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", n);
            if (this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", n);
            throw this.raise(Ae.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(n, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(n, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(n, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(n, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (Fh(this.state.type)) {
            let u = ns(this.state.type);
            return this.next(), super.createIdentifier(n, u);
          } else if (tt(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, n, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let r = this.state.startLoc, n = this.flowParsePrimaryType(), i = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(r), o = this.eat(18);
        i = i || o, this.expect(0), !o && this.match(3) ? (a.elementType = n, this.next(), n = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = n, a.indexType = this.flowParseType(), this.expect(3), i ? (a.optional = o, n = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : n = this.finishNode(a, "IndexedAccessType"));
      }
      return n;
    }
    flowParsePrefixType() {
      let r = this.startNode();
      return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let r = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let n = this.startNodeAt(r.loc.start);
        return n.params = [this.reinterpretTypeAsFunctionTypeParam(r)], n.rest = null, n.this = null, n.returnType = this.flowParseType(), n.
        typeParameters = null, this.finishNode(n, "FunctionTypeAnnotation");
      }
      return r;
    }
    flowParseIntersectionType() {
      let r = this.startNode();
      this.eat(45);
      let n = this.flowParseAnonFunctionWithoutParens();
      for (r.types = [n]; this.eat(45); )
        r.types.push(this.flowParseAnonFunctionWithoutParens());
      return r.types.length === 1 ? n : this.finishNode(r, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let r = this.startNode();
      this.eat(43);
      let n = this.flowParseIntersectionType();
      for (r.types = [n]; this.eat(43); )
        r.types.push(this.flowParseIntersectionType());
      return r.types.length === 1 ? n : this.finishNode(r, "UnionTypeAnnotation");
    }
    flowParseType() {
      let r = this.state.inType;
      this.state.inType = !0;
      let n = this.flowParseUnionType();
      return this.state.inType = r, n;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let r = this.state.startLoc, n = this.parseIdentifier();
        return this.flowParseGenericType(r, n);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let r = this.startNode();
      return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(r) {
      let n = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (n.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(n)), n;
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    flowParseVariance() {
      let r = null;
      return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(
      r, "Variance")) : r;
    }
    parseFunctionBody(r, n, i = !1) {
      if (n) {
        this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, i));
        return;
      }
      super.parseFunctionBody(r, !1, i);
    }
    parseFunctionBodyAndFinish(r, n, i = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(r, n, i);
    }
    parseStatementLike(r) {
      if (this.state.strict && this.isContextual(129)) {
        let i = this.lookahead();
        if (Wr(i.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      }
      let n = super.parseStatementLike(r);
      return this.flowPragma === void 0 && !this.isValidDirective(n) && (this.flowPragma = null), n;
    }
    parseExpressionStatement(r, n, i) {
      if (n.type === "Identifier") {
        if (n.name === "declare") {
          if (this.match(80) || tt(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(r);
        } else if (tt(this.state.type)) {
          if (n.name === "interface")
            return this.flowParseInterface(r);
          if (n.name === "type")
            return this.flowParseTypeAlias(r);
          if (n.name === "opaque")
            return this.flowParseOpaqueType(r, !1);
        }
      }
      return super.parseExpressionStatement(r, n, i);
    }
    shouldParseExportDeclaration() {
      let {
        type: r
      } = this.state;
      return Gv(r) || this.shouldParseEnums() && r === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: r
      } = this.state;
      return Gv(r) || this.shouldParseEnums() && r === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(r, n, i) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let h = this.lookaheadCharCode();
        if (h === 44 || h === 61 || h === 58 || h === 41)
          return this.setOptionalParametersError(i), r;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, l = this.startNodeAt(n), {
        consequent: u,
        failed: c
      } = this.tryParseConditionalConsequent(), [f, p] = this.getArrowLikeExpressions(u);
      if (c || p.length > 0) {
        let h = [...o];
        if (p.length > 0) {
          this.state = a, this.state.noArrowAt = h;
          for (let y = 0; y < p.length; y++)
            h.push(p[y].start);
          ({
            consequent: u,
            failed: c
          } = this.tryParseConditionalConsequent()), [f, p] = this.getArrowLikeExpressions(u);
        }
        c && f.length > 1 && this.raise(Ae.AmbiguousConditionalArrow, a.startLoc), c && f.length === 1 && (this.state = a, h.push(f[0].start),
        this.state.noArrowAt = h, {
          consequent: u,
          failed: c
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = o, this.expect(14), l.test = r, l.consequent = u, l.alternate = this.
      forwardNoArrowParamsConversionAt(l, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(l, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let r = this.parseMaybeAssignAllowIn(), n = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: r,
        failed: n
      };
    }
    getArrowLikeExpressions(r, n) {
      let i = [r], a = [];
      for (; i.length !== 0; ) {
        let o = i.pop();
        o.type === "ArrowFunctionExpression" && o.body.type !== "BlockStatement" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(
        o) : a.push(o), i.push(o.body)) : o.type === "ConditionalExpression" && (i.push(o.consequent), i.push(o.alternate));
      }
      return n ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : xG(a, (o) => o.params.every((l) => this.isAssignable(l, !0)));
    }
    finishArrowValidation(r) {
      var n;
      this.toAssignableList(r.params, (n = r.extra) == null ? void 0 : n.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(r, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(r, n) {
      let i;
      return this.state.noArrowParamsConversionAt.includes(r.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), i = n(),
      this.state.noArrowParamsConversionAt.pop()) : i = n(), i;
    }
    parseParenItem(r, n) {
      let i = super.parseParenItem(r, n);
      if (this.eat(17) && (i.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(n);
        return a.expression = i, a.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(a, "TypeCastExpression");
      }
      return i;
    }
    assertModuleNodeAllowed(r) {
      r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind ===
      "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
    }
    parseExportDeclaration(r) {
      if (this.isContextual(130)) {
        r.exportKind = "type";
        let n = this.startNode();
        return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(
        n);
      } else if (this.isContextual(131)) {
        r.exportKind = "type";
        let n = this.startNode();
        return this.next(), this.flowParseOpaqueType(n, !1);
      } else if (this.isContextual(129)) {
        r.exportKind = "type";
        let n = this.startNode();
        return this.next(), this.flowParseInterface(n);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        r.exportKind = "value";
        let n = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(n);
      } else
        return super.parseExportDeclaration(r);
    }
    eatExportStar(r) {
      return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(r) {
      let {
        startLoc: n
      } = this.state, i = super.maybeParseExportNamespaceSpecifier(r);
      return i && r.exportKind === "type" && this.unexpected(n), i;
    }
    parseClassId(r, n, i) {
      super.parseClassId(r, n, i), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(r, n, i) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(r, n))
          return;
        n.declare = !0;
      }
      super.parseClassMember(r, n, i), n.declare && (n.type !== "ClassProperty" && n.type !== "ClassPrivateProperty" && n.type !== "Property\
Definition" ? this.raise(Ae.DeclareClassElement, a) : n.value && this.raise(Ae.DeclareClassFieldInitializer, n.value));
    }
    isIterator(r) {
      return r === "iterator" || r === "asyncIterator";
    }
    readIterator() {
      let r = super.readWord1(), n = "@@" + r;
      (!this.isIterator(r) || !this.state.inType) && this.raise(_.InvalidIdentifier, this.state.curPosition(), {
        identifierName: n
      }), this.finishToken(132, n);
    }
    getTokenFromCode(r) {
      let n = this.input.charCodeAt(this.state.pos + 1);
      r === 123 && n === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.
      state.inType && r === 63 ? n === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : sG(r, n, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
    }
    isAssignable(r, n) {
      return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, n) : super.isAssignable(r, n);
    }
    toAssignable(r, n = !1) {
      !n && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.
      toAssignable(r, n);
    }
    toAssignableList(r, n, i) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, n, i);
    }
    toReferencedList(r, n) {
      for (let a = 0; a < r.length; a++) {
        var i;
        let o = r[a];
        o && o.type === "TypeCastExpression" && !((i = o.extra) != null && i.parenthesized) && (r.length > 1 || !n) && this.raise(Ae.TypeCastInPattern,
        o.typeAnnotation);
      }
      return r;
    }
    parseArrayLike(r, n, i, a) {
      let o = super.parseArrayLike(r, n, i, a);
      return n && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(r, n, i) {
      return r === "TypeCastExpression" || super.isValidLVal(r, n, i);
    }
    parseClassProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(r) {
      return !this.match(14) && super.isNonstaticConstructor(r);
    }
    pushClassMethod(r, n, i, a, o, l) {
      if (n.variance && this.unexpected(n.variance.loc.start), delete n.variance, this.match(47) && (n.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(r, n, i, a, o, l), n.params && o) {
        let u = n.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Ae.ThisParamBannedInConstructor, n);
      } else if (n.type === "MethodDefinition" && o && n.value.params) {
        let u = n.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Ae.ThisParamBannedInConstructor, n);
      }
    }
    pushClassPrivateMethod(r, n, i, a) {
      n.variance && this.unexpected(n.variance.loc.start), delete n.variance, this.match(47) && (n.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(r, n, i, a);
    }
    parseClassSuper(r) {
      if (super.parseClassSuper(r), r.superClass && this.match(47) && (r.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.
      isContextual(113)) {
        this.next();
        let n = r.implements = [];
        do {
          let i = this.startNode();
          i.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.
          typeParameters = null, n.push(this.finishNode(i, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(r) {
      super.checkGetterSetterParams(r);
      let n = this.getObjectOrClassMethodParams(r);
      if (n.length > 0) {
        let i = n[0];
        this.isThisParam(i) && r.kind === "get" ? this.raise(Ae.GetterMayNotHaveThisParam, i) : this.isThisParam(i) && this.raise(Ae.SetterMayNotHaveThisParam,
        i);
      }
    }
    parsePropertyNamePrefixOperator(r) {
      r.variance = this.flowParseVariance();
    }
    parseObjPropValue(r, n, i, a, o, l, u) {
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
      let c;
      this.match(47) && !l && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let f = super.parseObjPropValue(r, n, i, a, o, l, u);
      return c && ((f.value || f).typeParameters = c), f;
    }
    parseAssignableListItemTypes(r) {
      return this.eat(17) && (r.type !== "Identifier" && this.raise(Ae.PatternIsOptional, r), this.isThisParam(r) && this.raise(Ae.ThisParamMayNotBeOptional,
      r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(Ae.ThisParamAnnotationRequired,
      r), this.match(29) && this.isThisParam(r) && this.raise(Ae.ThisParamNoDefault, r), this.resetEndLocation(r), r;
    }
    parseMaybeDefault(r, n) {
      let i = super.parseMaybeDefault(r, n);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(Ae.TypeBeforeInitializer,
      i.typeAnnotation), i;
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(Ae.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(r, n, i) {
      n.local = Jv(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(n,
      i));
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        if (!r) return !0;
        let n = this.lookaheadCharCode();
        return n === 123 || n === 42;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, n, i, a) {
      if (super.applyImportPhase(r, n, i, a), n) {
        if (!i && this.match(65))
          return;
        r.exportKind = i === "type" ? i : "value";
      } else
        i === "type" && this.match(55) && this.unexpected(), r.importKind = i === "type" || i === "typeof" ? i : "value";
    }
    parseImportSpecifier(r, n, i, a, o) {
      let l = r.imported, u = null;
      l.type === "Identifier" && (l.name === "type" ? u = "type" : l.name === "typeof" && (u = "typeof"));
      let c = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let p = this.parseIdentifier(!0);
        u !== null && !Wr(this.state.type) ? (r.imported = p, r.importKind = u, r.local = In(p)) : (r.imported = l, r.importKind = null, r.local =
        this.parseIdentifier());
      } else {
        if (u !== null && Wr(this.state.type))
          r.imported = this.parseIdentifier(!0), r.importKind = u;
        else {
          if (n)
            throw this.raise(_.ImportBindingIsString, r, {
              importName: l.value
            });
          r.imported = l, r.importKind = null;
        }
        this.eatContextual(93) ? r.local = this.parseIdentifier() : (c = !0, r.local = In(r.imported));
      }
      let f = Jv(r);
      return i && f && this.raise(Ae.ImportTypeShorthandOnlyInPureImport, r), (i || f) && this.checkReservedType(r.local.name, r.local.loc.start,
      !0), c && !i && !f && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(r, n) {
      let i = r.kind;
      i !== "get" && i !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      r, n);
    }
    parseVarId(r, n) {
      super.parseVarId(r, n), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, n) {
      if (this.match(14)) {
        let i = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
      }
      return super.parseAsyncArrowFromCallExpression(r, n);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(r, n) {
      var i;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(r, n), a), !o.error) return o.node;
        let {
          context: c
        } = this.state, f = c[c.length - 1];
        (f === at.j_oTag || f === at.j_expr) && c.pop();
      }
      if ((i = o) != null && i.error || this.match(47)) {
        var l, u;
        a = a || this.state.clone();
        let c, f = this.tryParse((h) => {
          var y;
          c = this.flowParseTypeParameterDeclaration();
          let v = this.forwardNoArrowParamsConversionAt(c, () => {
            let b = super.parseMaybeAssign(r, n);
            return this.resetStartLocationFromNode(b, c), b;
          });
          (y = v.extra) != null && y.parenthesized && h();
          let d = this.maybeUnwrapTypeCastExpression(v);
          return d.type !== "ArrowFunctionExpression" && h(), d.typeParameters = c, this.resetStartLocationFromNode(d, c), v;
        }, a), p = null;
        if (f.node && this.maybeUnwrapTypeCastExpression(f.node).type === "ArrowFunctionExpression") {
          if (!f.error && !f.aborted)
            return f.node.async && this.raise(Ae.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), f.node;
          p = f.node;
        }
        if ((l = o) != null && l.node)
          return this.state = o.failState, o.node;
        if (p)
          return this.state = f.failState, p;
        throw (u = o) != null && u.thrown ? o.error : f.thrown ? f.error : this.raise(Ae.UnexpectedTokenAfterTypeParameter, c);
      }
      return super.parseMaybeAssign(r, n);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let n = this.tryParse(() => {
          let i = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (n.thrown) return null;
        n.error && (this.state = n.failState), r.returnType = n.node.typeAnnotation ? this.finishNode(n.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(r);
    }
    shouldParseArrow(r) {
      return this.match(14) || super.shouldParseArrow(r);
    }
    setArrowFunctionParameters(r, n) {
      this.state.noArrowParamsConversionAt.includes(r.start) ? r.params = n : super.setArrowFunctionParameters(r, n);
    }
    checkParams(r, n, i, a = !0) {
      if (!(i && this.state.noArrowParamsConversionAt.includes(r.start))) {
        for (let o = 0; o < r.params.length; o++)
          this.isThisParam(r.params[o]) && o > 0 && this.raise(Ae.ThisParamMustBeFirst, r.params[o]);
        super.checkParams(r, n, i, a);
      }
    }
    parseParenAndDistinguishExpression(r) {
      return super.parseParenAndDistinguishExpression(r && !this.state.noArrowAt.includes(this.state.start));
    }
    parseSubscripts(r, n, i) {
      if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.includes(n.index)) {
        this.next();
        let a = this.startNodeAt(n);
        a.callee = r, a.arguments = super.parseCallExpressionArguments(11, !1), r = this.finishNode(a, "CallExpression");
      } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(n) || u(), a);
        if (!o.error && !o.aborted) return o.node;
        let l = this.tryParse(() => super.parseSubscripts(r, n, i), a);
        if (l.node && !l.error) return l.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (l.node)
          return this.state = l.failState, l.node;
        throw o.error || l.error;
      }
      return super.parseSubscripts(r, n, i);
    }
    parseSubscript(r, n, i, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, i)
          return a.stop = !0, r;
        this.next();
        let o = this.startNodeAt(n);
        return o.callee = r, o.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), o.arguments = this.parseCallExpressionArguments(
        11, !1), o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!i && this.shouldParseTypes() && this.match(47)) {
        let o = this.startNodeAt(n);
        o.callee = r;
        let l = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(11, !1), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (l.node)
          return l.error && (this.state = l.failState), l.node;
      }
      return super.parseSubscript(r, n, i, a);
    }
    parseNewCallee(r) {
      super.parseNewCallee(r);
      let n = null;
      this.shouldParseTypes() && this.match(47) && (n = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments =
      n;
    }
    parseAsyncArrowWithTypeParameters(r) {
      let n = this.startNodeAt(r);
      if (this.parseFunctionParams(n, !1), !!this.parseArrow(n))
        return super.parseArrowExpression(n, void 0, !0);
    }
    readToken_mult_modulo(r) {
      let n = this.input.charCodeAt(this.state.pos + 1);
      if (r === 42 && n === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(r);
    }
    readToken_pipe_amp(r) {
      let n = this.input.charCodeAt(this.state.pos + 1);
      if (r === 124 && n === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(r);
    }
    parseTopLevel(r, n) {
      let i = super.parseTopLevel(r, n);
      return this.state.hasFlowComment && this.raise(Ae.UnterminatedFlowComment, this.state.curPosition()), i;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(Ae.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let r = this.skipFlowComment();
        r && (this.state.pos += r, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: r
      } = this.state, n = 2;
      for (; [32, 9].includes(this.input.charCodeAt(r + n)); )
        n++;
      let i = this.input.charCodeAt(n + r), a = this.input.charCodeAt(n + r + 1);
      return i === 58 && a === 58 ? n + 2 : this.input.slice(n + r, n + r + 12) === "flow-include" ? n + 12 : i === 58 && a !== 58 ? n : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(_.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(r, {
      enumName: n,
      memberName: i
    }) {
      this.raise(Ae.EnumBooleanMemberNotInitialized, r, {
        memberName: i,
        enumName: n
      });
    }
    flowEnumErrorInvalidMemberInitializer(r, n) {
      return this.raise(n.explicitType ? n.explicitType === "symbol" ? Ae.EnumInvalidMemberInitializerSymbolType : Ae.EnumInvalidMemberInitializerPrimaryType :
      Ae.EnumInvalidMemberInitializerUnknownType, r, n);
    }
    flowEnumErrorNumberMemberNotInitialized(r, n) {
      this.raise(Ae.EnumNumberMemberNotInitialized, r, n);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(r, n) {
      this.raise(Ae.EnumStringMemberInconsistentlyInitialized, r, n);
    }
    flowEnumMemberInit() {
      let r = this.state.startLoc, n = /* @__PURE__ */ s(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 134: {
          let i = this.parseNumericLiteral(this.state.value);
          return n() ? {
            type: "number",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 133: {
          let i = this.parseStringLiteral(this.state.value);
          return n() ? {
            type: "string",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 85:
        case 86: {
          let i = this.parseBooleanLiteral(this.match(85));
          return n() ? {
            type: "boolean",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        default:
          return {
            type: "invalid",
            loc: r
          };
      }
    }
    flowEnumMemberRaw() {
      let r = this.state.startLoc, n = this.parseIdentifier(!0), i = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: r
      };
      return {
        id: n,
        init: i
      };
    }
    flowEnumCheckExplicitTypeMismatch(r, n, i) {
      let {
        explicitType: a
      } = n;
      a !== null && a !== i && this.flowEnumErrorInvalidMemberInitializer(r, n);
    }
    flowEnumMembers({
      enumName: r,
      explicitType: n
    }) {
      let i = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let l = this.startNode(), {
          id: u,
          init: c
        } = this.flowEnumMemberRaw(), f = u.name;
        if (f === "")
          continue;
        /^[a-z]/.test(f) && this.raise(Ae.EnumInvalidMemberName, u, {
          memberName: f,
          suggestion: f[0].toUpperCase() + f.slice(1),
          enumName: r
        }), i.has(f) && this.raise(Ae.EnumDuplicateMemberName, u, {
          memberName: f,
          enumName: r
        }), i.add(f);
        let p = {
          enumName: r,
          explicitType: n,
          memberName: f
        };
        switch (l.id = u, c.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, p, "boolean"), l.init = c.value, a.booleanMembers.push(this.finishNode(l, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, p, "number"), l.init = c.value, a.numberMembers.push(this.finishNode(l, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, p, "string"), l.init = c.value, a.stringMembers.push(this.finishNode(l, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(c.loc, p);
          case "none":
            switch (n) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(c.loc, p);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(c.loc, p);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(r, n, {
      enumName: i
    }) {
      if (r.length === 0)
        return n;
      if (n.length === 0)
        return r;
      if (n.length > r.length) {
        for (let a of r)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: i
          });
        return n;
      } else {
        for (let a of n)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: i
          });
        return r;
      }
    }
    flowEnumParseExplicitType({
      enumName: r
    }) {
      if (!this.eatContextual(102)) return null;
      if (!tt(this.state.type))
        throw this.raise(Ae.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: r
        });
      let {
        value: n
      } = this.state;
      return this.next(), n !== "boolean" && n !== "number" && n !== "string" && n !== "symbol" && this.raise(Ae.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: r,
        invalidEnumType: n
      }), n;
    }
    flowEnumBody(r, n) {
      let i = n.name, a = n.loc.start, o = this.flowEnumParseExplicitType({
        enumName: i
      });
      this.expect(5);
      let {
        members: l,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: i,
        explicitType: o
      });
      switch (r.hasUnknownMembers = u, o) {
        case "boolean":
          return r.explicitType = !0, r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        case "number":
          return r.explicitType = !0, r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        case "string":
          return r.explicitType = !0, r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
            enumName: i
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        case "symbol":
          return r.members = l.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
        default: {
          let c = /* @__PURE__ */ s(() => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody")), "empty");
          r.explicitType = !1;
          let f = l.booleanMembers.length, p = l.numberMembers.length, h = l.stringMembers.length, y = l.defaultedMembers.length;
          if (!f && !p && !h && !y)
            return c();
          if (!f && !p)
            return r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
              enumName: i
            }), this.expect(8), this.finishNode(r, "EnumStringBody");
          if (!p && !h && f >= y) {
            for (let v of l.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(v.loc.start, {
                enumName: i,
                memberName: v.id.name
              });
            return r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
          } else if (!f && !h && p >= y) {
            for (let v of l.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(v.loc.start, {
                enumName: i,
                memberName: v.id.name
              });
            return r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
          } else
            return this.raise(Ae.EnumInconsistentMemberValues, a, {
              enumName: i
            }), c();
        }
      }
    }
    flowParseEnumDeclaration(r) {
      let n = this.parseIdentifier();
      return r.id = n, r.body = this.flowEnumBody(this.startNode(), n), this.finishNode(r, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      let r = this.nextTokenStart();
      if (this.input.charCodeAt(r) === 60) {
        let n = this.input.charCodeAt(r + 1);
        return n !== 60 && n !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(r) {
      return r.type === "TypeCastExpression" ? r.expression : r;
    }
  }, "flow"), AG = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, Fs = Dn`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ s(({
      openingTagName: e
    }) => `Expected corresponding JSX closing tag for <${e}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ s(({
      unexpected: e,
      HTMLEntity: t
    }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function rs(e) {
    return e ? e.type === "JSXOpeningFragment" || e.type === "JSXClosingFragment" : !1;
  }
  s(rs, "isFragment");
  function Ti(e) {
    if (e.type === "JSXIdentifier")
      return e.name;
    if (e.type === "JSXNamespacedName")
      return e.namespace.name + ":" + e.name.name;
    if (e.type === "JSXMemberExpression")
      return Ti(e.object) + "." + Ti(e.property);
    throw new Error("Node had unexpected type: " + e.type);
  }
  s(Ti, "getQualifiedJSXName");
  var CG = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let r = "", n = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Fs.UnterminatedJsxContent, this.state.startLoc);
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(i);
              return;
            }
            r += this.input.slice(n, this.state.pos), this.finishToken(141, r);
            return;
          case 38:
            r += this.input.slice(n, this.state.pos), r += this.jsxReadEntity(), n = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            Si(i) ? (r += this.input.slice(n, this.state.pos), r += this.jsxReadNewLine(!0), n = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(r) {
      let n = this.input.charCodeAt(this.state.pos), i;
      return ++this.state.pos, n === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = r ? `
` : `\r
`) : i = String.fromCharCode(n), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
    }
    jsxReadString(r) {
      let n = "", i = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(_.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === r) break;
        a === 38 ? (n += this.input.slice(i, this.state.pos), n += this.jsxReadEntity(), i = this.state.pos) : Si(a) ? (n += this.input.slice(
        i, this.state.pos), n += this.jsxReadNewLine(!1), i = this.state.pos) : ++this.state.pos;
      }
      n += this.input.slice(i, this.state.pos++), this.finishToken(133, n);
    }
    jsxReadEntity() {
      let r = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let n = 10;
        this.codePointAtPos(this.state.pos) === 120 && (n = 16, ++this.state.pos);
        let i = this.readInt(n, void 0, !1, "bail");
        if (i !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(i);
      } else {
        let n = 0, i = !1;
        for (; n++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (i) {
          let a = this.input.slice(r, this.state.pos), o = AG[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = r, "&";
    }
    jsxReadWord() {
      let r, n = this.state.pos;
      do
        r = this.input.charCodeAt(++this.state.pos);
      while (xi(r) || r === 45);
      this.finishToken(140, this.input.slice(n, this.state.pos));
    }
    jsxParseIdentifier() {
      let r = this.startNode();
      return this.match(140) ? r.name = this.state.value : Fh(this.state.type) ? r.name = ns(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(r, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let r = this.state.startLoc, n = this.jsxParseIdentifier();
      if (!this.eat(14)) return n;
      let i = this.startNodeAt(r);
      return i.namespace = n, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let r = this.state.startLoc, n = this.jsxParseNamespacedName();
      if (n.type === "JSXNamespacedName")
        return n;
      for (; this.eat(16); ) {
        let i = this.startNodeAt(r);
        i.object = n, i.property = this.jsxParseIdentifier(), n = this.finishNode(i, "JSXMemberExpression");
      }
      return n;
    }
    jsxParseAttributeValue() {
      let r;
      switch (this.state.type) {
        case 5:
          return r = this.startNode(), this.setContext(at.brace), this.next(), r = this.jsxParseExpressionContainer(r, at.j_oTag), r.expression.
          type === "JSXEmptyExpression" && this.raise(Fs.AttributeIsEmpty, r), r;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(Fs.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let r = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(r) {
      return this.next(), r.expression = this.parseExpression(), this.setContext(at.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(r, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(r, n) {
      if (this.match(8))
        r.expression = this.jsxParseEmptyExpression();
      else {
        let i = this.parseExpression();
        r.expression = i;
      }
      return this.setContext(n), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let r = this.startNode();
      return this.match(5) ? (this.setContext(at.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      at.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(),
      r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(r) {
      let n = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(n, "JSXOpeningFragment") : (n.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      n));
    }
    jsxParseOpeningElementAfterName(r) {
      let n = [];
      for (; !this.match(56) && !this.match(143); )
        n.push(this.jsxParseAttribute());
      return r.attributes = n, r.selfClosing = this.eat(56), this.expect(143), this.finishNode(r, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(r) {
      let n = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(n, "JSXClosingFragment") : (n.name = this.jsxParseElementName(), this.expect(143), this.finishNode(
      n, "JSXClosingElement"));
    }
    jsxParseElementAt(r) {
      let n = this.startNodeAt(r), i = [], a = this.jsxParseOpeningElementAt(r), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 142:
              if (r = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(r);
                break e;
              }
              i.push(this.jsxParseElementAt(r));
              break;
            case 141:
              i.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              let l = this.startNode();
              this.setContext(at.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(l)) : i.push(this.jsxParseExpressionContainer(
              l, at.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        rs(a) && !rs(o) && o !== null ? this.raise(Fs.MissingClosingTagFragment, o) : !rs(a) && rs(o) ? this.raise(Fs.MissingClosingTagElement,
        o, {
          openingTagName: Ti(a.name)
        }) : !rs(a) && !rs(o) && Ti(o.name) !== Ti(a.name) && this.raise(Fs.MissingClosingTagElement, o, {
          openingTagName: Ti(a.name)
        });
      }
      if (rs(a) ? (n.openingFragment = a, n.closingFragment = o) : (n.openingElement = a, n.closingElement = o), n.children = i, this.match(
      47))
        throw this.raise(Fs.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return rs(a) ? this.finishNode(n, "JSXFragment") : this.finishNode(n, "JSXElement");
    }
    jsxParseElement() {
      let r = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(r);
    }
    setContext(r) {
      let {
        context: n
      } = this.state;
      n[n.length - 1] = r;
    }
    parseExprAtom(r) {
      return this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(
      142), this.jsxParseElement()) : super.parseExprAtom(r);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(r) {
      let n = this.curContext();
      if (n === at.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (n === at.j_oTag || n === at.j_cTag) {
        if (wn(r)) {
          this.jsxReadWord();
          return;
        }
        if (r === 62) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        if ((r === 34 || r === 39) && n === at.j_oTag) {
          this.jsxReadString(r);
          return;
        }
      }
      if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(142);
        return;
      }
      super.getTokenFromCode(r);
    }
    updateContext(r) {
      let {
        context: n,
        type: i
      } = this.state;
      if (i === 56 && r === 142)
        n.splice(-2, 2, at.j_cTag), this.state.canStartJSXElement = !1;
      else if (i === 142)
        n.push(at.j_oTag);
      else if (i === 143) {
        let a = n[n.length - 1];
        a === at.j_oTag && r === 56 || a === at.j_cTag ? (n.pop(), this.state.canStartJSXElement = n[n.length - 1] === at.j_expr) : (this.setContext(
        at.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = VK(i);
    }
  }, "jsx"), Ph = class extends Ya {
    static {
      s(this, "TypeScriptScope");
    }
    constructor(...t) {
      super(...t), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, Ah = class extends za {
    static {
      s(this, "TypeScriptScopeHandler");
    }
    constructor(...t) {
      super(...t), this.importsStack = [];
    }
    createScope(t) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new Ph(t);
    }
    enter(t) {
      t === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
    }
    exit() {
      let t = super.exit();
      return t === 256 && this.importsStack.pop(), t;
    }
    hasImport(t, r) {
      let n = this.importsStack.length;
      if (this.importsStack[n - 1].has(t))
        return !0;
      if (!r && n > 1) {
        for (let i = 0; i < n - 1; i++)
          if (this.importsStack[i].has(t)) return !0;
      }
      return !1;
    }
    declareName(t, r, n) {
      if (r & 4096) {
        this.hasImport(t, !0) && this.parser.raise(_.VarRedeclaration, n, {
          identifierName: t
        }), this.importsStack[this.importsStack.length - 1].add(t);
        return;
      }
      let i = this.currentScope(), a = i.tsNames.get(t) || 0;
      if (r & 1024) {
        this.maybeExportDefined(i, t), i.tsNames.set(t, a | 16);
        return;
      }
      super.declareName(t, r, n), r & 2 && (r & 1 || (this.checkRedeclarationInScope(i, t, r, n), this.maybeExportDefined(i, t)), a = a | 1),
      r & 256 && (a = a | 2), r & 512 && (a = a | 4), r & 128 && (a = a | 8), a && i.tsNames.set(t, a);
    }
    isRedeclaredInScope(t, r, n) {
      let i = t.tsNames.get(r);
      if ((i & 2) > 0) {
        if (n & 256) {
          let a = !!(n & 512), o = (i & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return n & 128 && (i & 8) > 0 ? t.names.get(r) & 2 ? !!(n & 1) : !1 : n & 2 && (i & 1) > 0 ? !0 : super.isRedeclaredInScope(t, r, n);
    }
    checkLocalExport(t) {
      let {
        name: r
      } = t;
      if (this.hasImport(r)) return;
      let n = this.scopeStack.length;
      for (let i = n - 1; i >= 0; i--) {
        let o = this.scopeStack[i].tsNames.get(r);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(t);
    }
  }, hT = /* @__PURE__ */ s((e) => e.type === "ParenthesizedExpression" ? hT(e.expression) : e, "unwrapParenthesizedExpression"), Ch = class extends Sh {
    static {
      s(this, "LValParser");
    }
    toAssignable(t, r = !1) {
      var n, i;
      let a;
      switch ((t.type === "ParenthesizedExpression" || (n = t.extra) != null && n.parenthesized) && (a = hT(t), r ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(_.InvalidParenthesizedAssignment, t) : a.type !== "MemberExpression" && !this.isOptionalMemberExpression(
      a) && this.raise(_.InvalidParenthesizedAssignment, t) : this.raise(_.InvalidParenthesizedAssignment, t)), t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          t.type = "ObjectPattern";
          for (let l = 0, u = t.properties.length, c = u - 1; l < u; l++) {
            var o;
            let f = t.properties[l], p = l === c;
            this.toAssignableObjectExpressionProp(f, p, r), p && f.type === "RestElement" && (o = t.extra) != null && o.trailingCommaLoc && this.
            raise(_.RestTrailingComma, t.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: l,
            value: u
          } = t;
          this.isPrivateName(l) && this.classScope.usePrivateName(this.getPrivateNameSV(l), l.loc.start), this.toAssignable(u, r);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          t.type = "ArrayPattern", this.toAssignableList(t.elements, (i = t.extra) == null ? void 0 : i.trailingCommaLoc, r);
          break;
        case "AssignmentExpression":
          t.operator !== "=" && this.raise(_.MissingEqInAssignment, t.left.loc.end), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(
          t.left, r);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, r);
          break;
      }
    }
    toAssignableObjectExpressionProp(t, r, n) {
      if (t.type === "ObjectMethod")
        this.raise(t.kind === "get" || t.kind === "set" ? _.PatternHasAccessor : _.PatternHasMethod, t.key);
      else if (t.type === "SpreadElement") {
        t.type = "RestElement";
        let i = t.argument;
        this.checkToRestConversion(i, !1), this.toAssignable(i, n), r || this.raise(_.RestTrailingComma, t);
      } else
        this.toAssignable(t, n);
    }
    toAssignableList(t, r, n) {
      let i = t.length - 1;
      for (let a = 0; a <= i; a++) {
        let o = t[a];
        if (o) {
          if (o.type === "SpreadElement") {
            o.type = "RestElement";
            let l = o.argument;
            this.checkToRestConversion(l, !0), this.toAssignable(l, n);
          } else
            this.toAssignable(o, n);
          o.type === "RestElement" && (a < i ? this.raise(_.RestTrailingComma, o) : r && this.raise(_.RestTrailingComma, r));
        }
      }
    }
    isAssignable(t, r) {
      switch (t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let n = t.properties.length - 1;
          return t.properties.every((i, a) => i.type !== "ObjectMethod" && (a === n || i.type !== "SpreadElement") && this.isAssignable(i));
        }
        case "ObjectProperty":
          return this.isAssignable(t.value);
        case "SpreadElement":
          return this.isAssignable(t.argument);
        case "ArrayExpression":
          return t.elements.every((n) => n === null || this.isAssignable(n));
        case "AssignmentExpression":
          return t.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(t.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !r;
        default:
          return !1;
      }
    }
    toReferencedList(t, r) {
      return t;
    }
    toReferencedListDeep(t, r) {
      this.toReferencedList(t, r);
      for (let n of t)
        n?.type === "ArrayExpression" && this.toReferencedListDeep(n.elements);
    }
    parseSpread(t) {
      let r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      let t = this.startNode();
      return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let t = this.startNode();
          return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(t, r, n) {
      let i = n & 1, a = [], o = !0;
      for (; !this.eat(t); )
        if (o ? o = !1 : this.expect(12), i && this.match(12))
          a.push(null);
        else {
          if (this.eat(t))
            break;
          if (this.match(21)) {
            if (a.push(this.parseAssignableListItemTypes(this.parseRestBinding(), n)), !this.checkCommaAfterRest(r)) {
              this.expect(t);
              break;
            }
          } else {
            let l = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(_.UnsupportedParameterDecorator, this.state.startLoc); this.match(
            26); )
              l.push(this.parseDecorator());
            a.push(this.parseAssignableListItem(n, l));
          }
        }
      return a;
    }
    parseBindingRestProperty(t) {
      return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
    }
    parseBindingProperty() {
      let {
        type: t,
        startLoc: r
      } = this.state;
      if (t === 21)
        return this.parseBindingRestProperty(this.startNode());
      let n = this.startNode();
      return t === 138 ? (this.expectPlugin("destructuringPrivate", r), this.classScope.usePrivateName(this.state.value, r), n.key = this.parsePrivateName()) :
      this.parsePropertyName(n), n.method = !1, this.parseObjPropValue(n, r, !1, !1, !0, !1);
    }
    parseAssignableListItem(t, r) {
      let n = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(n, t);
      let i = this.parseMaybeDefault(n.loc.start, n);
      return r.length && (n.decorators = r), i;
    }
    parseAssignableListItemTypes(t, r) {
      return t;
    }
    parseMaybeDefault(t, r) {
      var n, i;
      if ((n = t) != null || (t = this.state.startLoc), r = (i = r) != null ? i : this.parseBindingAtom(), !this.eat(29)) return r;
      let a = this.startNodeAt(t);
      return a.left = r, a.right = this.parseMaybeAssignAllowIn(), this.finishNode(a, "AssignmentPattern");
    }
    isValidLVal(t, r, n) {
      switch (t) {
        case "AssignmentPattern":
          return "left";
        case "RestElement":
          return "argument";
        case "ObjectProperty":
          return "value";
        case "ParenthesizedExpression":
          return "expression";
        case "ArrayPattern":
          return "elements";
        case "ObjectPattern":
          return "properties";
      }
      return !1;
    }
    isOptionalMemberExpression(t) {
      return t.type === "OptionalMemberExpression";
    }
    checkLVal(t, r, n = 64, i = !1, a = !1, o = !1) {
      var l;
      let u = t.type;
      if (this.isObjectMethod(t)) return;
      let c = this.isOptionalMemberExpression(t);
      if (c || u === "MemberExpression") {
        c && (this.expectPlugin("optionalChainingAssign", t.loc.start), r.type !== "AssignmentExpression" && this.raise(_.InvalidLhsOptionalChaining,
        t, {
          ancestor: r
        })), n !== 64 && this.raise(_.InvalidPropertyBindingPattern, t);
        return;
      }
      if (u === "Identifier") {
        this.checkIdentifier(t, n, a);
        let {
          name: d
        } = t;
        i && (i.has(d) ? this.raise(_.ParamDupe, t) : i.add(d));
        return;
      }
      let f = this.isValidLVal(u, !(o || (l = t.extra) != null && l.parenthesized) && r.type === "AssignmentExpression", n);
      if (f === !0) return;
      if (f === !1) {
        let d = n === 64 ? _.InvalidLhs : _.InvalidLhsBinding;
        this.raise(d, t, {
          ancestor: r
        });
        return;
      }
      let p, h;
      typeof f == "string" ? (p = f, h = u === "ParenthesizedExpression") : [p, h] = f;
      let y = u === "ArrayPattern" || u === "ObjectPattern" ? {
        type: u
      } : r, v = t[p];
      if (Array.isArray(v))
        for (let d of v)
          d && this.checkLVal(d, y, n, i, a, h);
      else v && this.checkLVal(v, y, n, i, a, h);
    }
    checkIdentifier(t, r, n = !1) {
      this.state.strict && (n ? uT(t.name, this.inModule) : lT(t.name)) && (r === 64 ? this.raise(_.StrictEvalArguments, t, {
        referenceName: t.name
      }) : this.raise(_.StrictEvalArgumentsBinding, t, {
        bindingName: t.name
      })), r & 8192 && t.name === "let" && this.raise(_.LetInLexicalBinding, t), r & 64 || this.declareNameFromIdentifier(t, r);
    }
    declareNameFromIdentifier(t, r) {
      this.scope.declareName(t.name, r, t.loc.start);
    }
    checkToRestConversion(t, r) {
      switch (t.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(t.expression, r);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (r) break;
        default:
          this.raise(_.InvalidRestAssignmentPattern, t);
      }
    }
    checkCommaAfterRest(t) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? _.RestTrailingComma : _.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  };
  function wG(e) {
    if (e == null)
      throw new Error(`Unexpected ${e} value.`);
    return e;
  }
  s(wG, "nonNull");
  function Xv(e) {
    if (!e)
      throw new Error("Assert fail");
  }
  s(Xv, "assert");
  var me = Dn`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ s(({
      methodName: e
    }) => `Method '${e}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ s(({
      propertyName: e
    }) => `Property '${e}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or nu\
meric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ s(({
      kind: e
    }) => `'declare' is not allowed in ${e}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ s(({
      modifier: e
    }) => "Accessibility modifier already seen.", "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ s(({
      modifier: e
    }) => `Duplicate modifier: '${e}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ s(({
      token: e
    }) => `'${e}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ s(({
      modifiers: e
    }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ s(({
      modifier: e
    }) => `Index signatures cannot have an accessibility modifier ('${e}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: /* @__PURE__ */ s(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ s(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ s(({
      modifier: e
    }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifiersOrder: /* @__PURE__ */ s(({
      orderedModifiers: e
    }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ s(({
      modifier: e
    }) => `Private elements cannot have an accessibility modifier ('${e}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ s(({
      typeParameterName: e
    }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ s(({
      type: e
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`, "UnsupportedSignatureParameterKind")
  });
  function DG(e) {
    switch (e) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  s(DG, "keywordTypeFromName");
  function Qv(e) {
    return e === "private" || e === "public" || e === "protected";
  }
  s(Qv, "tsIsAccessModifier");
  function IG(e) {
    return e === "in" || e === "out";
  }
  s(IG, "tsIsVarianceAnnotations");
  var _G = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "TypeScriptParserMixin");
    }
    constructor(...r) {
      super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: me.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: me.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: me.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return Ah;
    }
    tsIsIdentifier() {
      return tt(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.
      hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(r, n) {
      if (!tt(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let i = this.state.value;
      if (r.includes(i)) {
        if (n && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return i;
      }
    }
    tsParseModifiers({
      allowedModifiers: r,
      disallowedModifiers: n,
      stopOnStartOfClassStaticBlock: i,
      errorTemplate: a = me.InvalidModifierOnTypeMember
    }, o) {
      let l = /* @__PURE__ */ s((c, f, p, h) => {
        f === p && o[h] && this.raise(me.InvalidModifiersOrder, c, {
          orderedModifiers: [p, h]
        });
      }, "enforceOrder"), u = /* @__PURE__ */ s((c, f, p, h) => {
        (o[p] && f === h || o[h] && f === p) && this.raise(me.IncompatibleModifiers, c, {
          modifiers: [p, h]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: c
        } = this.state, f = this.tsParseModifier(r.concat(n ?? []), i);
        if (!f) break;
        Qv(f) ? o.accessibility ? this.raise(me.DuplicateAccessibilityModifier, c, {
          modifier: f
        }) : (l(c, f, f, "override"), l(c, f, f, "static"), l(c, f, f, "readonly"), o.accessibility = f) : IG(f) ? (o[f] && this.raise(me.DuplicateModifier,
        c, {
          modifier: f
        }), o[f] = !0, l(c, f, "in", "out")) : (hasOwnProperty.call(o, f) ? this.raise(me.DuplicateModifier, c, {
          modifier: f
        }) : (l(c, f, "static", "readonly"), l(c, f, "static", "override"), l(c, f, "override", "readonly"), l(c, f, "abstract", "override"),
        u(c, f, "declare", "override"), u(c, f, "static", "abstract")), o[f] = !0), n != null && n.includes(f) && this.raise(a, c, {
          modifier: f
        });
      }
    }
    tsIsListTerminator(r) {
      switch (r) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(r, n) {
      let i = [];
      for (; !this.tsIsListTerminator(r); )
        i.push(n());
      return i;
    }
    tsParseDelimitedList(r, n, i) {
      return wG(this.tsParseDelimitedListWorker(r, n, !0, i));
    }
    tsParseDelimitedListWorker(r, n, i, a) {
      let o = [], l = -1;
      for (; !this.tsIsListTerminator(r); ) {
        l = -1;
        let u = n();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          l = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(r))
          break;
        i && this.expect(12);
        return;
      }
      return a && (a.value = l), o;
    }
    tsParseBracketedList(r, n, i, a, o) {
      a || (i ? this.expect(0) : this.expect(47));
      let l = this.tsParseDelimitedList(r, n, o);
      return i ? this.expect(3) : this.expect(48), l;
    }
    tsParseImportType() {
      let r = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(me.UnsupportedImportTypeArgument, this.state.startLoc), r.argument =
      super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (r.options = null), this.eat(12) &&
      (this.expectImportAttributesPlugin(), this.match(11) || (r.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11),
      this.eat(16) && (r.qualifier = this.tsParseEntityName()), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(
      r, "TSImportType");
    }
    tsParseEntityName(r = !0) {
      let n = this.parseIdentifier(r);
      for (; this.eat(16); ) {
        let i = this.startNodeAtNode(n);
        i.left = n, i.right = this.parseIdentifier(r), n = this.finishNode(i, "TSQualifiedName");
      }
      return n;
    }
    tsParseTypeReference() {
      let r = this.startNode();
      return r.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSTypeReference");
    }
    tsParseThisTypePredicate(r) {
      this.next();
      let n = this.startNodeAtNode(r);
      return n.parameterName = r, n.typeAnnotation = this.tsParseTypeAnnotation(!1), n.asserts = !1, this.finishNode(n, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let r = this.startNode();
      return this.next(), this.finishNode(r, "TSThisType");
    }
    tsParseTypeQuery() {
      let r = this.startNode();
      return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() &&
      this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
    }
    tsParseTypeParameter(r) {
      let n = this.startNode();
      return r(n), n.name = this.tsParseTypeParameterName(), n.constraint = this.tsEatThenParseType(81), n.default = this.tsEatThenParseType(
      29), this.finishNode(n, "TSTypeParameter");
    }
    tsTryParseTypeParameters(r) {
      if (this.match(47))
        return this.tsParseTypeParameters(r);
    }
    tsParseTypeParameters(r) {
      let n = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let i = {
        value: -1
      };
      return n.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, i), n.params.
      length === 0 && this.raise(me.EmptyTypeParameters, n), i.value !== -1 && this.addExtra(n, "trailingComma", i.value), this.finishNode(n,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(r, n) {
      let i = r === 19, a = "parameters", o = "typeAnnotation";
      n.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), n[a] = this.tsParseBindingListForSignature(),
      i ? n[o] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (n[o] = this.tsParseTypeOrTypePredicateAnnotation(r));
    }
    tsParseBindingListForSignature() {
      let r = super.parseBindingList(11, 41, 2);
      for (let n of r) {
        let {
          type: i
        } = n;
        (i === "AssignmentPattern" || i === "TSParameterProperty") && this.raise(me.UnsupportedSignatureParameterKind, n, {
          type: i
        });
      }
      return r;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(r, n) {
      return this.tsFillSignature(14, n), this.tsParseTypeMemberSemicolon(), this.finishNode(n, r);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), tt(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(r) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let n = this.parseIdentifier();
      n.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(n), this.expect(3), r.parameters = [n];
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(r, n) {
      this.eat(17) && (r.optional = !0);
      let i = r;
      if (this.match(10) || this.match(47)) {
        n && this.raise(me.ReadonlyForMethodSignature, r);
        let a = i;
        a.kind && this.match(47) && this.raise(me.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, a), this.
        tsParseTypeMemberSemicolon();
        let o = "parameters", l = "typeAnnotation";
        if (a.kind === "get")
          a[o].length > 0 && (this.raise(_.BadGetterArity, this.state.curPosition()), this.isThisParam(a[o][0]) && this.raise(me.AccesorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (a.kind === "set") {
          if (a[o].length !== 1)
            this.raise(_.BadSetterArity, this.state.curPosition());
          else {
            let u = a[o][0];
            this.isThisParam(u) && this.raise(me.AccesorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.
            optional && this.raise(me.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(
            me.SetAccesorCannotHaveRestParameter, this.state.curPosition());
          }
          a[l] && this.raise(me.SetAccesorCannotHaveReturnType, a[l]);
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = i;
        n && (a.readonly = !0);
        let o = this.tsTryParseTypeAnnotation();
        return o && (a.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let r = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
      if (this.match(77)) {
        let i = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.
        createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, r);
      let n = this.tsTryParseIndexSignature(r);
      return n || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
    }
    tsParseTypeLiteral() {
      let r = this.startNode();
      return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), r;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      let r = this.startNode();
      return r.name = this.tsParseTypeParameterName(), r.constraint = this.tsExpectThenParseType(58), this.finishNode(r, "TSTypeParameter");
    }
    tsParseMappedType() {
      let r = this.startNode();
      return this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(
      122) && (r.readonly = !0), this.expect(0), r.typeParameter = this.tsParseMappedTypeParameter(), r.nameType = this.eatContextual(93) ? this.
      tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) &&
      (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(r, "TSMappedType");
    }
    tsParseTupleType() {
      let r = this.startNode();
      r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let n = !1;
      return r.elementTypes.forEach((i) => {
        let {
          type: a
        } = i;
        n && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && i.optional) && this.raise(me.OptionalTypeBeforeRequired,
        i), n || (n = a === "TSNamedTupleMember" && i.optional || a === "TSOptionalType");
      }), this.finishNode(r, "TSTupleType");
    }
    tsParseTupleElementType() {
      let {
        startLoc: r
      } = this.state, n = this.eat(21), i, a, o, l, c = Wr(this.state.type) ? this.lookaheadCharCode() : null;
      if (c === 58)
        i = !0, o = !1, a = this.parseIdentifier(!0), this.expect(14), l = this.tsParseType();
      else if (c === 63) {
        o = !0;
        let f = this.state.startLoc, p = this.state.value, h = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (i = !0, a = this.createIdentifier(this.startNodeAt(f), p), this.expect(17), this.expect(14), l = this.
        tsParseType()) : (i = !1, l = h, this.expect(17));
      } else
        l = this.tsParseType(), o = this.eat(17), i = this.eat(14);
      if (i) {
        let f;
        a ? (f = this.startNodeAtNode(a), f.optional = o, f.label = a, f.elementType = l, this.eat(17) && (f.optional = !0, this.raise(me.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (f = this.startNodeAtNode(l), f.optional = o, this.raise(me.InvalidTupleMemberLabel, l), f.label = l,
        f.elementType = this.tsParseType()), l = this.finishNode(f, "TSNamedTupleMember");
      } else if (o) {
        let f = this.startNodeAtNode(l);
        f.typeAnnotation = l, l = this.finishNode(f, "TSOptionalType");
      }
      if (n) {
        let f = this.startNodeAt(r);
        f.typeAnnotation = l, l = this.finishNode(f, "TSRestType");
      }
      return l;
    }
    tsParseParenthesizedType() {
      let r = this.startNode();
      return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(r, n) {
      let i = this.startNode();
      return r === "TSConstructorType" && (i.abstract = !!n, n && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, i)), this.finishNode(i, r);
    }
    tsParseLiteralTypeNode() {
      let r = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          r.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(r, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      let r = this.startNode();
      return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let r = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let r = this.startNode(), n = this.lookahead();
            return n.type !== 134 && n.type !== 135 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: r
          } = this.state;
          if (tt(r) || r === 88 || r === 84) {
            let n = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : DG(this.state.value);
            if (n !== void 0 && this.lookaheadCharCode() !== 46) {
              let i = this.startNode();
              return this.next(), this.finishNode(i, n);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let r = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let n = this.startNodeAtNode(r);
          n.elementType = r, this.expect(3), r = this.finishNode(n, "TSArrayType");
        } else {
          let n = this.startNodeAtNode(r);
          n.objectType = r, n.indexType = this.tsParseType(), this.expect(3), r = this.finishNode(n, "TSIndexedAccessType");
        }
      return r;
    }
    tsParseTypeOperator() {
      let r = this.startNode(), n = this.state.value;
      return this.next(), r.operator = n, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), n === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      r), this.finishNode(r, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(r) {
      switch (r.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(me.UnexpectedReadonly, r);
      }
    }
    tsParseInferType() {
      let r = this.startNode();
      this.expectContextual(115);
      let n = this.startNode();
      return n.name = this.tsParseTypeParameterName(), n.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter =
      this.finishNode(n, "TSTypeParameter"), this.finishNode(r, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return r;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return YK(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(r, n, i) {
      let a = this.startNode(), o = this.eat(i), l = [];
      do
        l.push(n());
      while (this.eat(i));
      return l.length === 1 && !o ? l[0] : (a.types = l, this.finishNode(a, r));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (tt(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: r
        } = this.state, n = r.length;
        try {
          return this.parseObjectLike(8, !0), r.length === n;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: r
        } = this.state, n = r.length;
        try {
          return super.parseBindingList(3, 93, 1), r.length === n;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(r) {
      return this.tsInType(() => {
        let n = this.startNode();
        this.expect(r);
        let i = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (i.parameterName = u, i.asserts = !0, i.typeAnnotation = null, u = this.finishNode(i, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(u, i), u.asserts = !0), n.typeAnnotation = u, this.finishNode(n, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (i.parameterName = this.parseIdentifier(), i.asserts = a, i.typeAnnotation = null, n.typeAnnotation = this.finishNode(i,
          "TSTypePredicate"), this.finishNode(n, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, n);
        let l = this.tsParseTypeAnnotation(!1);
        return i.parameterName = o, i.typeAnnotation = l, i.asserts = a, n.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(
        n, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let r = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), r;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let r = this.state.containsEsc;
      return this.next(), !tt(this.state.type) && !this.match(78) ? !1 : (r && this.raise(_.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(r = !0, n = this.startNode()) {
      return this.tsInType(() => {
        r && this.expect(14), n.typeAnnotation = this.tsParseType();
      }), this.finishNode(n, "TSTypeAnnotation");
    }
    tsParseType() {
      Xv(this.state.inType);
      let r = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return r;
      let n = this.startNodeAtNode(r);
      return n.checkType = r, n.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), n.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), n.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(n, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(me.ReservedTypeAssertion, this.state.startLoc);
      let r = this.startNode();
      return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
    }
    tsParseHeritageClause(r) {
      let n = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
        let a = this.startNode();
        return a.expression = this.tsParseEntityName(), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
        a, "TSExpressionWithTypeArguments");
      });
      return i.length || this.raise(me.EmptyHeritageClauseType, n, {
        token: r
      }), i;
    }
    tsParseInterfaceDeclaration(r, n = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), n.declare && (r.declare = !0), tt(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, 130)) : (r.id = null, this.raise(me.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
      let i = this.startNode();
      return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(
      r, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(r) {
      return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
        if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().
        type !== 16) {
          let n = this.startNode();
          return this.next(), this.finishNode(n, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
    }
    tsInNoContext(r) {
      let n = this.state.context;
      this.state.context = [n[0]];
      try {
        return r();
      } finally {
        this.state.context = n;
      }
    }
    tsInType(r) {
      let n = this.state.inType;
      this.state.inType = !0;
      try {
        return r();
      } finally {
        this.state.inType = n;
      }
    }
    tsInDisallowConditionalTypesContext(r) {
      let n = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = n;
      }
    }
    tsInAllowConditionalTypesContext(r) {
      let n = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = n;
      }
    }
    tsEatThenParseType(r) {
      if (this.match(r))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(r) {
      return this.tsInType(() => (this.expect(r), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let r = this.startNode();
      return r.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
    }
    tsParseEnumDeclaration(r, n = {}) {
      return n.const && (r.const = !0), n.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(r, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      let r = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      r, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(r, n = !1) {
      if (r.id = this.parseIdentifier(), n || this.checkIdentifier(r.id, 1024), this.eat(16)) {
        let i = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(i, !0), r.body = i;
      } else
        this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(r) {
      return this.isContextual(112) ? (r.global = !0, r.id = this.parseIdentifier()) : this.match(133) ? r.id = super.parseStringLiteral(this.
      state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(),
      this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(r, n, i) {
      r.isExport = i || !1, r.id = n || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return r.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(me.ImportAliasHasImportType, a), r.moduleReference =
      a, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      let r = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
    }
    tsLookAhead(r) {
      let n = this.state.clone(), i = r();
      return this.state = n, i;
    }
    tsTryParseAndCatch(r) {
      let n = this.tryParse((i) => r() || i());
      if (!(n.aborted || !n.node))
        return n.error && (this.state = n.failState), n.node;
    }
    tsTryParse(r) {
      let n = this.state.clone(), i = r();
      if (i !== void 0 && i !== !1)
        return i;
      this.state = n;
    }
    tsTryParseDeclare(r) {
      if (this.isLineTerminator())
        return;
      let n = this.state.type, i;
      return this.isContextual(100) && (n = 74, i = "let"), this.tsInAmbientContext(() => {
        switch (n) {
          case 68:
            return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
          case 80:
            return r.declare = !0, this.parseClass(r, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(r, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(r);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, i || this.state.value,
            !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
              const: !0,
              declare: !0
            }));
          case 129: {
            let a = this.tsParseInterfaceDeclaration(r, {
              declare: !0
            });
            if (a) return a;
          }
          default:
            if (tt(n))
              return this.tsParseDeclaration(r, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(r, n, i) {
      switch (n.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(r);
          return a && (a.declare = !0), a;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let a = r;
            return a.global = !0, a.id = n, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(a,
            "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(r, n.name, !1, i);
      }
    }
    tsParseDeclaration(r, n, i, a) {
      switch (n) {
        case "abstract":
          if (this.tsCheckLineTerminator(i) && (this.match(80) || tt(this.state.type)))
            return this.tsParseAbstractDeclaration(r, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(i)) {
            if (this.match(133))
              return this.tsParseAmbientExternalModuleDeclaration(r);
            if (tt(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(r);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(i) && tt(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(r);
          break;
        case "type":
          if (this.tsCheckLineTerminator(i) && tt(this.state.type))
            return this.tsParseTypeAliasDeclaration(r);
          break;
      }
    }
    tsCheckLineTerminator(r) {
      return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(r) {
      if (!this.match(47)) return;
      let n = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let i = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(r);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = n, !!i)
        return super.parseArrowExpression(i, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let r = this.startNode();
      return r.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments",
      this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(me.EmptyTypeArguments, r) : !this.state.inType && this.curContext() ===
      at.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return zK(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(r, n) {
      let i = this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, l = a.override, u = a.readonly;
      !(r & 4) && (o || u || l) && this.raise(me.UnexpectedParameterModifier, i);
      let c = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(c, r);
      let f = this.parseMaybeDefault(c.loc.start, c);
      if (o || u || l) {
        let p = this.startNodeAt(i);
        return n.length && (p.decorators = n), o && (p.accessibility = o), u && (p.readonly = u), l && (p.override = l), f.type !== "Identif\
ier" && f.type !== "AssignmentPattern" && this.raise(me.UnsupportedParameterPropertyKind, p), p.parameter = f, this.finishNode(p, "TSParamet\
erProperty");
      }
      return n.length && (c.decorators = n), f;
    }
    isSimpleParameter(r) {
      return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
    }
    tsDisallowOptionalPattern(r) {
      for (let n of r.params)
        n.type !== "Identifier" && n.optional && !this.state.isAmbientContext && this.raise(me.PatternIsOptional, n);
    }
    setArrowFunctionParameters(r, n, i) {
      super.setArrowFunctionParameters(r, n, i), this.tsDisallowOptionalPattern(r);
    }
    parseFunctionBodyAndFinish(r, n, i = !1) {
      this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = n === "FunctionDeclaration" ? "TSDeclareFunction" : n === "ClassMethod" || n === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(me.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, a, i) : (this.tsDisallowOptionalPattern(
      r), super.parseFunctionBodyAndFinish(r, n, i));
    }
    registerFunctionStatementId(r) {
      !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
    }
    tsCheckForInvalidTypeCasts(r) {
      r.forEach((n) => {
        n?.type === "TSTypeCastExpression" && this.raise(me.UnexpectedTypeAnnotation, n.typeAnnotation);
      });
    }
    toReferencedList(r, n) {
      return this.tsCheckForInvalidTypeCasts(r), r;
    }
    parseArrayLike(r, n, i, a) {
      let o = super.parseArrayLike(r, n, i, a);
      return o.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(o.elements), o;
    }
    parseSubscript(r, n, i, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let l = this.startNodeAt(n);
        return l.expression = r, this.finishNode(l, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (i)
          return a.stop = !0, r;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let l, u = this.tsTryParseAndCatch(() => {
          if (!i && this.atPossibleAsyncArrow(r)) {
            let h = this.tsTryParseGenericAsyncArrowFunction(n);
            if (h)
              return h;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c) return;
          if (o && !this.match(10)) {
            l = this.state.curPosition();
            return;
          }
          if (Vl(this.state.type)) {
            let h = super.parseTaggedTemplateExpression(r, n, a);
            return h.typeParameters = c, h;
          }
          if (!i && this.eat(10)) {
            let h = this.startNodeAt(n);
            return h.callee = r, h.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(h.arguments), h.typeParameters =
            c, a.optionalChainMember && (h.optional = o), this.finishCallExpression(h, a.optionalChainMember);
          }
          let f = this.state.type;
          if (f === 48 || f === 52 || f !== 10 && uh(f) && !this.hasPrecedingLineBreak())
            return;
          let p = this.startNodeAt(n);
          return p.expression = r, p.typeParameters = c, this.finishNode(p, "TSInstantiationExpression");
        });
        if (l && this.unexpected(l, 10), u)
          return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          me.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
      }
      return super.parseSubscript(r, n, i, a);
    }
    parseNewCallee(r) {
      var n;
      super.parseNewCallee(r);
      let {
        callee: i
      } = r;
      i.type === "TSInstantiationExpression" && !((n = i.extra) != null && n.parenthesized) && (r.typeParameters = i.typeParameters, r.callee =
      i.expression);
    }
    parseExprOp(r, n, i) {
      let a;
      if (Rl(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(n);
        return o.expression = r, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(_.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, n, i);
      }
      return super.parseExprOp(r, n, i);
    }
    checkReservedWord(r, n, i, a) {
      this.state.isAmbientContext || super.checkReservedWord(r, n, i, a);
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(me.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        let n = this.lookaheadCharCode();
        return r ? n === 123 || n === 42 : n !== 61;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, n, i, a) {
      super.applyImportPhase(r, n, i, a), n ? r.exportKind = i === "type" ? "type" : "value" : r.importKind = i === "type" || i === "typeof" ?
      i : "value";
    }
    parseImport(r) {
      if (this.match(133))
        return r.importKind = "value", super.parseImport(r);
      let n;
      if (tt(this.state.type) && this.lookaheadCharCode() === 61)
        return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
      if (this.isContextual(130)) {
        let i = this.parseMaybeImportPhase(r, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(r, i);
        n = super.parseImportSpecifiersAndAfter(r, i);
      } else
        n = super.parseImport(r);
      return n.importKind === "type" && n.specifiers.length > 1 && n.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(me.TypeImportCannotSpecifyDefaultAndNamed,
      n), n;
    }
    parseExport(r, n) {
      if (this.match(83)) {
        this.next();
        let i = r, a = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? a = this.parseMaybeImportPhase(i, !1) : i.importKind = "value", this.
        tsParseImportEqualsDeclaration(i, a, !0);
      } else if (this.eat(29)) {
        let i = r;
        return i.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(i, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let i = r;
        return this.expectContextual(128), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(r, n);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let r = this.startNode();
        return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
      }
      if (this.match(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(r, n, i = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(r, n, i || a);
      if (!a) return o;
      for (let {
        id: l,
        init: u
      } of o.declarations)
        u && (n !== "const" || l.typeAnnotation ? this.raise(me.InitializerNotAllowedInAmbientContext, u) : NG(u, this.hasPlugin("estree")) ||
        this.raise(me.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
      return o;
    }
    parseStatementContent(r, n) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let i = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(i, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let i = this.tsParseInterfaceDeclaration(this.startNode());
        if (i) return i;
      }
      return super.parseStatementContent(r, n);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(r, n) {
      return n.some((i) => Qv(i) ? r.accessibility === i : !!r[i]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(r, n, i) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: me.InvalidModifierOnTypeParameterPositions
      }, n);
      let o = /* @__PURE__ */ s(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(n, a) && this.raise(me.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(r, n)) : this.parseClassMemberWithIsStatic(r, n, i, !!n.static);
      }, "callParseClassMemberWithIsStatic");
      n.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(r, n, i, a) {
      let o = this.tsTryParseIndexSignature(n);
      if (o) {
        r.body.push(o), n.abstract && this.raise(me.IndexSignatureHasAbstract, n), n.accessibility && this.raise(me.IndexSignatureHasAccessibility,
        n, {
          modifier: n.accessibility
        }), n.declare && this.raise(me.IndexSignatureHasDeclare, n), n.override && this.raise(me.IndexSignatureHasOverride, n);
        return;
      }
      !this.state.inAbstractClass && n.abstract && this.raise(me.NonAbstractClassHasAbstractMethod, n), n.override && (i.hadSuperClass || this.
      raise(me.OverrideNotInSubClass, n)), super.parseClassMemberWithIsStatic(r, n, i, a);
    }
    parsePostMemberNameModifiers(r) {
      this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(me.ClassMethodHasReadonly, r), r.declare && this.match(10) &&
      this.raise(me.ClassMethodHasDeclare, r);
    }
    parseExpressionStatement(r, n, i) {
      return (n.type === "Identifier" ? this.tsParseExpressionStatement(r, n, i) : void 0) || super.parseExpressionStatement(r, n, i);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(r, n, i) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(r, n, i);
      let a = this.tryParse(() => super.parseConditional(r, n));
      return a.node ? (a.error && (this.state = a.failState), a.node) : (a.error && super.setOptionalParametersError(i, a.error), r);
    }
    parseParenItem(r, n) {
      let i = super.parseParenItem(r, n);
      if (this.eat(17) && (i.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(n);
        return a.expression = r, a.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(a, "TSTypeCastExpression");
      }
      return r;
    }
    parseExportDeclaration(r) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
      let n = this.state.startLoc, i = this.eatContextual(125);
      if (i && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(me.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = tt(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || i) && (r.exportKind = "type"), i && (this.resetStartLocation(
      o, n), o.declare = !0), o) : null;
    }
    parseClassId(r, n, i, a) {
      if ((!n || i) && this.isContextual(113))
        return;
      super.parseClassId(r, n, i, r.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (r.typeParameters = o);
    }
    parseClassPropertyAnnotation(r) {
      r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
      let n = this.tsTryParseTypeAnnotation();
      n && (r.typeAnnotation = n);
    }
    parseClassProperty(r) {
      if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.
      raise(me.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
        let {
          key: n
        } = r;
        this.raise(me.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: n.type === "Identifier" && !r.computed ? n.name : `[${this.input.slice(n.start, n.end)}]`
        });
      }
      return super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return r.abstract && this.raise(me.PrivateElementHasAbstract, r), r.accessibility && this.raise(me.PrivateElementHasAccessibility, r, {
        modifier: r.accessibility
      }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
    }
    parseClassAccessorProperty(r) {
      return this.parseClassPropertyAnnotation(r), r.optional && this.raise(me.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(
      r);
    }
    pushClassMethod(r, n, i, a, o, l) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && o && this.raise(me.ConstructorHasTypeParameters, u);
      let {
        declare: c = !1,
        kind: f
      } = n;
      c && (f === "get" || f === "set") && this.raise(me.DeclareAccessor, n, {
        kind: f
      }), u && (n.typeParameters = u), super.pushClassMethod(r, n, i, a, o, l);
    }
    pushClassPrivateMethod(r, n, i, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (n.typeParameters = o), super.pushClassPrivateMethod(r, n, i, a);
    }
    declareClassPrivateMethodInScope(r, n) {
      r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !hasOwnProperty.call(r.value, "body") || super.declareClassPrivateMethodInScope(
      r, n));
    }
    parseClassSuper(r) {
      super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(r, n, i, a, o, l, u) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (r.typeParameters = c), super.parseObjPropValue(r, n, i, a, o, l, u);
    }
    parseFunctionParams(r, n) {
      let i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      i && (r.typeParameters = i), super.parseFunctionParams(r, n);
    }
    parseVarId(r, n) {
      super.parseVarId(r, n), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
      let i = this.tsTryParseTypeAnnotation();
      i && (r.id.typeAnnotation = i, this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, n) {
      return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, n);
    }
    parseMaybeAssign(r, n) {
      var i, a, o, l, u;
      let c, f, p;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (c = this.state.clone(), f = this.tryParse(() => super.parseMaybeAssign(r, n), c), !f.error) return f.node;
        let {
          context: v
        } = this.state, d = v[v.length - 1];
        (d === at.j_oTag || d === at.j_expr) && v.pop();
      }
      if (!((i = f) != null && i.error) && !this.match(47))
        return super.parseMaybeAssign(r, n);
      (!c || c === this.state) && (c = this.state.clone());
      let h, y = this.tryParse((v) => {
        var d, b;
        h = this.tsParseTypeParameters(this.tsParseConstModifier);
        let E = super.parseMaybeAssign(r, n);
        return (E.type !== "ArrowFunctionExpression" || (d = E.extra) != null && d.parenthesized) && v(), ((b = h) == null ? void 0 : b.params.
        length) !== 0 && this.resetStartLocationFromNode(E, h), E.typeParameters = h, E;
      }, c);
      if (!y.error && !y.aborted)
        return h && this.reportReservedArrowTypeParam(h), y.node;
      if (!f && (Xv(!this.hasPlugin("jsx")), p = this.tryParse(() => super.parseMaybeAssign(r, n), c), !p.error))
        return p.node;
      if ((a = f) != null && a.node)
        return this.state = f.failState, f.node;
      if (y.node)
        return this.state = y.failState, h && this.reportReservedArrowTypeParam(h), y.node;
      if ((o = p) != null && o.node)
        return this.state = p.failState, p.node;
      throw ((l = f) == null ? void 0 : l.error) || y.error || ((u = p) == null ? void 0 : u.error);
    }
    reportReservedArrowTypeParam(r) {
      var n;
      r.params.length === 1 && !r.params[0].constraint && !((n = r.extra) != null && n.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(me.ReservedArrowTypeParam, r);
    }
    parseMaybeUnary(r, n) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, n);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let n = this.tryParse((i) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && i(), a;
        });
        if (n.aborted) return;
        n.thrown || (n.error && (this.state = n.failState), r.returnType = n.node);
      }
      return super.parseArrow(r);
    }
    parseAssignableListItemTypes(r, n) {
      if (!(n & 2)) return r;
      this.eat(17) && (r.optional = !0);
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.resetEndLocation(r), r;
    }
    isAssignable(r, n) {
      switch (r.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(r.expression, n);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(r, n);
      }
    }
    toAssignable(r, n = !1) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(r, n);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          n ? this.expressionScope.recordArrowParameterBindingError(me.UnexpectedTypeCastInParameter, r) : this.raise(me.UnexpectedTypeCastInParameter,
          r), this.toAssignable(r.expression, n);
          break;
        case "AssignmentExpression":
          !n && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
        default:
          super.toAssignable(r, n);
      }
    }
    toAssignableParenthesizedExpression(r, n) {
      switch (r.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(r.expression, n);
          break;
        default:
          super.toAssignable(r, n);
      }
    }
    checkToRestConversion(r, n) {
      switch (r.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(r.expression, !1);
          break;
        default:
          super.checkToRestConversion(r, n);
      }
    }
    isValidLVal(r, n, i) {
      switch (r) {
        case "TSTypeCastExpression":
          return !0;
        case "TSParameterProperty":
          return "parameter";
        case "TSNonNullExpression":
        case "TSInstantiationExpression":
          return "expression";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
          return (i !== 64 || !n) && ["expression", !0];
        default:
          return super.isValidLVal(r, n, i);
      }
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(r) {
      if (this.match(47) || this.match(51)) {
        let n = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let i = super.parseMaybeDecoratorArguments(r);
          return i.typeParameters = n, i;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(r);
    }
    checkCommaAfterRest(r) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(
      r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(r, n) {
      let i = super.parseMaybeDefault(r, n);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(me.TypeAnnotationAfterAssign,
      i.typeAnnotation), i;
    }
    getTokenFromCode(r) {
      if (this.state.inType) {
        if (r === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (r === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(r);
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    toAssignableList(r, n, i) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TSTypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, n, i);
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    shouldParseArrow(r) {
      return this.match(14) ? r.every((n) => this.isAssignable(n, !0)) : super.shouldParseArrow(r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(r) {
      if (this.match(47) || this.match(51)) {
        let n = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        n && (r.typeParameters = n);
      }
      return super.jsxParseOpeningElementAfterName(r);
    }
    getGetterSetterExpectedParamCount(r) {
      let n = super.getGetterSetterExpectedParamCount(r), a = this.getObjectOrClassMethodParams(r)[0];
      return a && this.isThisParam(a) ? n + 1 : n;
    }
    parseCatchClauseParam() {
      let r = super.parseCatchClauseParam(), n = this.tsTryParseTypeAnnotation();
      return n && (r.typeAnnotation = n, this.resetEndLocation(r)), r;
    }
    tsInAmbientContext(r) {
      let {
        isAmbientContext: n,
        strict: i
      } = this.state;
      this.state.isAmbientContext = !0, this.state.strict = !1;
      try {
        return r();
      } finally {
        this.state.isAmbientContext = n, this.state.strict = i;
      }
    }
    parseClass(r, n, i) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!r.abstract;
      try {
        return super.parseClass(r, n, i);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(r, n) {
      if (this.match(80))
        return r.abstract = !0, this.maybeTakeDecorators(n, this.parseClass(r, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return r.abstract = !0, this.raise(me.NonClassMethodPropertyHasAbstractModifer, r), this.tsParseInterfaceDeclaration(r);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(r, n, i, a, o, l, u) {
      let c = super.parseMethod(r, n, i, a, o, l, u);
      if (c.abstract && (this.hasPlugin("estree") ? !!c.value.body : !!c.body)) {
        let {
          key: p
        } = c;
        this.raise(me.AbstractMethodHasImplementation, c, {
          methodName: p.type === "Identifier" && !c.computed ? p.name : `[${this.input.slice(p.start, p.end)}]`
        });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(r, n, i, a) {
      return !n && a ? (this.parseTypeOnlyImportExportSpecifier(r, !1, i), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value",
      super.parseExportSpecifier(r, n, i, a));
    }
    parseImportSpecifier(r, n, i, a, o) {
      return !n && a ? (this.parseTypeOnlyImportExportSpecifier(r, !0, i), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value",
      super.parseImportSpecifier(r, n, i, a, i ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(r, n, i) {
      let a = n ? "imported" : "local", o = n ? "local" : "exported", l = r[a], u, c = !1, f = !0, p = l.loc.start;
      if (this.isContextual(93)) {
        let y = this.parseIdentifier();
        if (this.isContextual(93)) {
          let v = this.parseIdentifier();
          Wr(this.state.type) ? (c = !0, l = y, u = n ? this.parseIdentifier() : this.parseModuleExportName(), f = !1) : (u = v, f = !1);
        } else Wr(this.state.type) ? (f = !1, u = n ? this.parseIdentifier() : this.parseModuleExportName()) : (c = !0, l = y);
      } else Wr(this.state.type) && (c = !0, n ? (l = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(l.name, l.loc.
      start, !0, !0)) : l = this.parseModuleExportName());
      c && i && this.raise(n ? me.TypeModifierIsUsedInTypeImports : me.TypeModifierIsUsedInTypeExports, p), r[a] = l, r[o] = u;
      let h = n ? "importKind" : "exportKind";
      r[h] = c ? "type" : "value", f && this.eatContextual(93) && (r[o] = n ? this.parseIdentifier() : this.parseModuleExportName()), r[o] ||
      (r[o] = In(r[a])), n && this.checkIdentifier(r[o], c ? 4098 : 4096);
    }
  }, "typescript");
  function OG(e) {
    if (e.type !== "MemberExpression") return !1;
    let {
      computed: t,
      property: r
    } = e;
    return t && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : yT(e.object);
  }
  s(OG, "isPossiblyLiteralEnum");
  function NG(e, t) {
    var r;
    let {
      type: n
    } = e;
    if ((r = e.extra) != null && r.parenthesized)
      return !1;
    if (t) {
      if (n === "Literal") {
        let {
          value: i
        } = e;
        if (typeof i == "string" || typeof i == "boolean")
          return !0;
      }
    } else if (n === "StringLiteral" || n === "BooleanLiteral")
      return !0;
    return !!(mT(e, t) || BG(e, t) || n === "TemplateLiteral" && e.expressions.length === 0 || OG(e));
  }
  s(NG, "isValidAmbientConstInitializer");
  function mT(e, t) {
    return t ? e.type === "Literal" && (typeof e.value == "number" || "bigint" in e) : e.type === "NumericLiteral" || e.type === "BigIntLite\
ral";
  }
  s(mT, "isNumber");
  function BG(e, t) {
    if (e.type === "UnaryExpression") {
      let {
        operator: r,
        argument: n
      } = e;
      if (r === "-" && mT(n, t))
        return !0;
    }
    return !1;
  }
  s(BG, "isNegativeNumber");
  function yT(e) {
    return e.type === "Identifier" ? !0 : e.type !== "MemberExpression" || e.computed ? !1 : yT(e.object);
  }
  s(yT, "isUncomputedMemberExpressionChain");
  var Zv = Dn`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), kG = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(r) {
      if (this.match(144)) {
        let n = this.startNode();
        return this.next(), this.assertNoSpace(), n.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(
        n, r);
      }
    }
    finishPlaceholder(r, n) {
      let i = r;
      return (!i.expectedNode || !i.type) && (i = this.finishNode(i, "Placeholder")), i.expectedNode = n, i;
    }
    getTokenFromCode(r) {
      r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(r);
    }
    parseExprAtom(r) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
    }
    parseIdentifier(r) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
    }
    checkReservedWord(r, n, i, a) {
      r !== void 0 && super.checkReservedWord(r, n, i, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(r, n, i) {
      return r === "Placeholder" || super.isValidLVal(r, n, i);
    }
    toAssignable(r, n) {
      r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, n);
    }
    chStartsBindingIdentifier(r, n) {
      return !!(super.chStartsBindingIdentifier(r, n) || this.lookahead().type === 144);
    }
    verifyBreakContinue(r, n) {
      r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, n);
    }
    parseExpressionStatement(r, n) {
      var i;
      if (n.type !== "Placeholder" || (i = n.extra) != null && i.parenthesized)
        return super.parseExpressionStatement(r, n);
      if (this.match(14)) {
        let o = r;
        return o.label = this.finishPlaceholder(n, "Identifier"), this.next(), o.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(o, "LabeledStatement");
      }
      this.semicolon();
      let a = r;
      return a.name = n.name, this.finishPlaceholder(a, "Statement");
    }
    parseBlock(r, n, i) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, n, i);
    }
    parseFunctionId(r) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
    }
    parseClass(r, n, i) {
      let a = n ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, l = this.parsePlaceholder("Identifier");
      if (l)
        if (this.match(81) || this.match(144) || this.match(5))
          r.id = l;
        else {
          if (i || !n)
            return r.id = null, r.body = this.finishPlaceholder(l, "ClassBody"), this.finishNode(r, a);
          throw this.raise(Zv.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(r, n, i);
      return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, o), this.finishNode(
      r, a);
    }
    parseExport(r, n) {
      let i = this.parsePlaceholder("Identifier");
      if (!i) return super.parseExport(r, n);
      let a = r;
      if (!this.isContextual(98) && !this.match(12))
        return a.specifiers = [], a.source = null, a.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(a, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let o = this.startNode();
      return o.exported = i, a.specifiers = [this.finishNode(o, "ExportDefaultSpecifier")], super.parseExport(a, n);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let r = this.nextTokenStart();
        if (this.isUnparsedContextual(r, "from") && this.input.startsWith(ns(144), this.nextTokenStartSince(r + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(r, n) {
      var i;
      return (i = r.specifiers) != null && i.length ? !0 : super.maybeParseExportDefaultSpecifier(r, n);
    }
    checkExport(r) {
      let {
        specifiers: n
      } = r;
      n != null && n.length && (r.specifiers = n.filter((i) => i.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = n;
    }
    parseImport(r) {
      let n = this.parsePlaceholder("Identifier");
      if (!n) return super.parseImport(r);
      if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
        return r.source = this.finishPlaceholder(n, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
      let i = this.startNodeAtNode(n);
      return i.local = n, r.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(Zv.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), FG = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let r = this.state.startLoc, n = this.startNode();
        if (this.next(), tt(this.state.type)) {
          let i = this.parseIdentifierName(), a = this.createIdentifier(n, i);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(r);
      }
    }
    parseExprAtom(r) {
      return this.parseV8Intrinsic() || super.parseExprAtom(r);
    }
  }, "v8intrinsic"), eT = ["minimal", "fsharp", "hack", "smart"], tT = ["^^", "@@", "^", "%", "#"];
  function jG(e) {
    if (e.has("decorators")) {
      if (e.has("decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let r = e.get("decorators").decoratorsBeforeExport;
      if (r != null && typeof r != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let n = e.get("decorators").allowCallParenthesized;
      if (n != null && typeof n != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (e.has("flow") && e.has("typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (e.has("placeholders") && e.has("v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (e.has("pipelineOperator")) {
      var t;
      let r = e.get("pipelineOperator").proposal;
      if (!eT.includes(r)) {
        let i = eT.map((a) => `"${a}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i}.`);
      }
      let n = ((t = e.get("recordAndTuple")) == null ? void 0 : t.syntaxType) === "hash";
      if (r === "hack") {
        if (e.has("placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (e.has("v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let i = e.get("pipelineOperator").topicToken;
        if (!tT.includes(i)) {
          let a = tT.map((o) => `"${o}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${a}\
.`);
        }
        if (i === "#" && n)
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["\
recordAndTuple", e.get("recordAndTuple")])}\`.`);
      } else if (r === "smart" && n)
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", e.
        get("recordAndTuple")])}\`.`);
    }
    if (e.has("moduleAttributes")) {
      if (e.has("importAttributes") || e.has("importAssertions"))
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      if (e.get("moduleAttributes").version !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (e.has("importAttributes") && e.has("importAssertions"))
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (e.has("recordAndTuple")) {
      let r = e.get("recordAndTuple").syntaxType;
      if (r != null) {
        let n = ["hash", "bar"];
        if (!n.includes(r))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + n.map((i) => `'${i}'`).join(", "));
      }
    }
    if (e.has("asyncDoExpressions") && !e.has("doExpressions")) {
      let r = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw r.missingPlugins = "doExpressions", r;
    }
    if (e.has("optionalChainingAssign") && e.get("optionalChainingAssign").version !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
  }
  s(jG, "validatePlugins");
  var gT = {
    estree: MK,
    jsx: CG,
    flow: PG,
    typescript: _G,
    v8intrinsic: FG,
    placeholders: kG
  }, LG = Object.keys(gT), ah = {
    sourceType: "script",
    sourceFilename: void 0,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: !1,
    allowReturnOutsideFunction: !1,
    allowNewTargetOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowSuperOutsideMethod: !1,
    allowUndeclaredExports: !1,
    plugins: [],
    strictMode: null,
    ranges: !1,
    tokens: !1,
    createImportExpressions: !1,
    createParenthesizedExpressions: !1,
    errorRecovery: !1,
    attachComment: !0,
    annexB: !0
  };
  function MG(e) {
    if (e == null)
      return Object.assign({}, ah);
    if (e.annexB != null && e.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    let t = {};
    for (let n of Object.keys(ah)) {
      var r;
      t[n] = (r = e[n]) != null ? r : ah[n];
    }
    return t;
  }
  s(MG, "getOptions");
  var wh = class extends Ch {
    static {
      s(this, "ExpressionParser");
    }
    checkProto(t, r, n, i) {
      if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand)
        return;
      let a = t.key;
      if ((a.type === "Identifier" ? a.name : a.value) === "__proto__") {
        if (r) {
          this.raise(_.RecordNoProto, a);
          return;
        }
        n.used && (i ? i.doubleProtoLoc === null && (i.doubleProtoLoc = a.loc.start) : this.raise(_.DuplicateProto, a)), n.used = !0;
      }
    }
    shouldExitDescending(t, r) {
      return t.type === "ArrowFunctionExpression" && t.start === r;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let t = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.comments, t.errors = this.state.errors,
      this.options.tokens && (t.tokens = this.tokens), t;
    }
    parseExpression(t, r) {
      return t ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
    }
    parseExpressionBase(t) {
      let r = this.state.startLoc, n = this.parseMaybeAssign(t);
      if (this.match(12)) {
        let i = this.startNodeAt(r);
        for (i.expressions = [n]; this.eat(12); )
          i.expressions.push(this.parseMaybeAssign(t));
        return this.toReferencedList(i.expressions), this.finishNode(i, "SequenceExpression");
      }
      return n;
    }
    parseMaybeAssignDisallowIn(t, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(t, r));
    }
    parseMaybeAssignAllowIn(t, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(t, r));
    }
    setOptionalParametersError(t, r) {
      var n;
      t.optionalParametersLoc = (n = r?.loc) != null ? n : this.state.startLoc;
    }
    parseMaybeAssign(t, r) {
      let n = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let l = this.parseYield();
        return r && (l = r.call(this, l, n)), l;
      }
      let i;
      t ? i = !1 : (t = new Pi(), i = !0);
      let {
        type: a
      } = this.state;
      (a === 10 || tt(a)) && (this.state.potentialArrowAt = this.state.start);
      let o = this.parseMaybeConditional(t);
      if (r && (o = r.call(this, o, n)), $K(this.state.type)) {
        let l = this.startNodeAt(n), u = this.state.value;
        if (l.operator = u, this.match(29)) {
          this.toAssignable(o, !0), l.left = o;
          let c = n.index;
          t.doubleProtoLoc != null && t.doubleProtoLoc.index >= c && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.
          index >= c && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= c && (this.checkDestructuringPrivate(
          t), t.privateKeyLoc = null);
        } else
          l.left = o;
        return this.next(), l.right = this.parseMaybeAssign(), this.checkLVal(o, this.finishNode(l, "AssignmentExpression")), l;
      } else i && this.checkExpressionErrors(t, !0);
      return o;
    }
    parseMaybeConditional(t) {
      let r = this.state.startLoc, n = this.state.potentialArrowAt, i = this.parseExprOps(t);
      return this.shouldExitDescending(i, n) ? i : this.parseConditional(i, r, t);
    }
    parseConditional(t, r, n) {
      if (this.eat(17)) {
        let i = this.startNodeAt(r);
        return i.test = t, i.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i.alternate = this.parseMaybeAssign(), this.finishNode(
        i, "ConditionalExpression");
      }
      return t;
    }
    parseMaybeUnaryOrPrivate(t) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(t);
    }
    parseExprOps(t) {
      let r = this.state.startLoc, n = this.state.potentialArrowAt, i = this.parseMaybeUnaryOrPrivate(t);
      return this.shouldExitDescending(i, n) ? i : this.parseExprOp(i, r, -1);
    }
    parseExprOp(t, r, n) {
      if (this.isPrivateName(t)) {
        let a = this.getPrivateNameSV(t);
        (n >= Rl(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(_.PrivateInExpectedIn, t, {
          identifierName: a
        }), this.classScope.usePrivateName(a, t.loc.start);
      }
      let i = this.state.type;
      if (KK(i) && (this.prodParam.hasIn || !this.match(58))) {
        let a = Rl(i);
        if (a > n) {
          if (i === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return t;
            this.checkPipelineAtInfixOperator(t, r);
          }
          let o = this.startNodeAt(r);
          o.left = t, o.operator = this.state.value;
          let l = i === 41 || i === 42, u = i === 40;
          if (u && (a = Rl(42)), this.next(), i === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(_.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(i, a);
          let c = this.finishNode(o, l || u ? "LogicalExpression" : "BinaryExpression"), f = this.state.type;
          if (u && (f === 41 || f === 42) || l && f === 40)
            throw this.raise(_.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(c, r, n);
        }
      }
      return t;
    }
    parseExprOpRightExpr(t, r) {
      let n = this.state.startLoc;
      switch (t) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(_.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, r), n);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
          }
        default:
          return this.parseExprOpBaseRightExpr(t, r);
      }
    }
    parseExprOpBaseRightExpr(t, r) {
      let n = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), n, JK(t) ? r - 1 : r);
    }
    parseHackPipeBody() {
      var t;
      let {
        startLoc: r
      } = this.state, n = this.parseMaybeAssign();
      return BK.has(n.type) && !((t = n.extra) != null && t.parenthesized) && this.raise(_.PipeUnparenthesizedBody, r, {
        type: n.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(_.PipeTopicUnused, r), n;
    }
    checkExponentialAfterUnary(t) {
      this.match(57) && this.raise(_.UnexpectedTokenUnaryExponentiation, t.argument);
    }
    parseMaybeUnary(t, r) {
      let n = this.state.startLoc, i = this.isContextual(96);
      if (i && this.recordAwaitIfAllowed()) {
        this.next();
        let u = this.parseAwait(n);
        return r || this.checkExponentialAfterUnary(u), u;
      }
      let a = this.match(34), o = this.startNode();
      if (HK(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let u = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), this.state.strict && u) {
          let c = o.argument;
          c.type === "Identifier" ? this.raise(_.StrictDelete, o) : this.hasPropertyAsPrivateName(c) && this.raise(_.DeletePrivateField, o);
        }
        if (!a)
          return r || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let l = this.parseUpdate(o, a, t);
      if (i) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? uh(u) : uh(u) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(_.AwaitNotInAsyncContext, n), this.parseAwait(n);
      }
      return l;
    }
    parseUpdate(t, r, n) {
      if (r) {
        let o = t;
        return this.checkLVal(o.argument, this.finishNode(o, "UpdateExpression")), t;
      }
      let i = this.state.startLoc, a = this.parseExprSubscripts(n);
      if (this.checkExpressionErrors(n, !1)) return a;
      for (; GK(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(i);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, a = this.finishNode(o, "UpdateExpressio\
n"));
      }
      return a;
    }
    parseExprSubscripts(t) {
      let r = this.state.startLoc, n = this.state.potentialArrowAt, i = this.parseExprAtom(t);
      return this.shouldExitDescending(i, n) ? i : this.parseSubscripts(i, r);
    }
    parseSubscripts(t, r, n) {
      let i = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(t),
        stop: !1
      };
      do
        t = this.parseSubscript(t, r, n, i), i.maybeAsyncArrow = !1;
      while (!i.stop);
      return t;
    }
    parseSubscript(t, r, n, i) {
      let {
        type: a
      } = this.state;
      if (!n && a === 15)
        return this.parseBind(t, r, n, i);
      if (Vl(a))
        return this.parseTaggedTemplateExpression(t, r, i);
      let o = !1;
      if (a === 18) {
        if (n && (this.raise(_.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return i.stop = !0, t;
        i.optionalChainMember = o = !0, this.next();
      }
      if (!n && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(t, r, i, o);
      {
        let l = this.eat(0);
        return l || o || this.eat(16) ? this.parseMember(t, r, i, l, o) : (i.stop = !0, t);
      }
    }
    parseMember(t, r, n, i, a) {
      let o = this.startNodeAt(r);
      return o.object = t, o.computed = i, i ? (o.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (t.type === "Super" &&
      this.raise(_.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), n.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(t, r, n, i) {
      let a = this.startNodeAt(r);
      return a.object = t, this.next(), a.callee = this.parseNoCallExpr(), i.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), r, n);
    }
    parseCoverCallAndAsyncArrowHead(t, r, n, i) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let l = this.startNodeAt(r);
      l.callee = t;
      let {
        maybeAsyncArrow: u,
        optionalChainMember: c
      } = n;
      u && (this.expressionScope.enter(yG()), o = new Pi()), c && (l.optional = i), i ? l.arguments = this.parseCallExpressionArguments(11) :
      l.arguments = this.parseCallExpressionArguments(11, t.type === "Import", t.type !== "Super", l, o);
      let f = this.finishCallExpression(l, c);
      return u && this.shouldParseAsyncArrow() && !i ? (n.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), f = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), f)) : (u && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(f)), this.state.maybeInArrowParameters = a, f;
    }
    toReferencedArguments(t, r) {
      this.toReferencedListDeep(t.arguments, r);
    }
    parseTaggedTemplateExpression(t, r, n) {
      let i = this.startNodeAt(r);
      return i.tag = t, i.quasi = this.parseTemplate(!0), n.optionalChainMember && this.raise(_.OptionalChainingNoTemplate, r), this.finishNode(
      i, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(t) {
      return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end -
      t.start === 5 && t.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(t, r) {
      if (t.callee.type === "Import")
        if (t.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), t.arguments.length === 0 ||
        t.arguments.length > 2)
          this.raise(_.ImportCallArity, t, {
            maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ?
            2 : 1
          });
        else
          for (let n of t.arguments)
            n.type === "SpreadElement" && this.raise(_.ImportCallSpreadArgument, n);
      return this.finishNode(t, r ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(t, r, n, i, a) {
      let o = [], l = !0, u = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(t); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(t)) {
          r && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(
          _.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        o.push(this.parseExprListItem(!1, a, n));
      }
      return this.state.inFSharpPipelineDirectBody = u, o;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(t, r) {
      var n;
      return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(t, r.arguments, !0, (n = r.extra) == null ?
      void 0 : n.trailingCommaLoc), r.innerComments && Ja(t, r.innerComments), r.callee.trailingComments && Ja(t, r.callee.trailingComments),
      t;
    }
    parseNoCallExpr() {
      let t = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), t, !0);
    }
    parseExprAtom(t) {
      let r, n = null, {
        type: i
      } = this.state;
      switch (i) {
        case 79:
          return this.parseSuper();
        case 83:
          return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : this.match(10) ? this.options.createImportExpressions ?
          this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(_.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(
          r, "Import"));
        case 78:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, t);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, t);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          n = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(n, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          r = this.startNode(), this.next(), r.object = null;
          let a = r.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(r, "BindExpression");
          throw this.raise(_.UnsupportedBind, a);
        }
        case 138:
          return this.raise(_.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          this.unexpected();
          break;
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          wn(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (tt(i)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, l = this.parseIdentifier();
            if (!o && l.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(l), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(l));
              if (tt(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(l)) : l;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(l), this.parseDo(this.startNodeAtNode(l), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(l), [l],
            !1)) : l;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(t, r) {
      let n = this.getPluginOption("pipelineOperator", "proposal");
      if (n)
        return this.state.type = t, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = ar(this.state.endLoc, -1),
        this.parseTopicReference(n);
      this.unexpected();
    }
    parseTopicReference(t) {
      let r = this.startNode(), n = this.state.startLoc, i = this.state.type;
      return this.next(), this.finishTopicReference(r, n, t, i);
    }
    finishTopicReference(t, r, n, i) {
      if (this.testTopicReferenceConfiguration(n, r, i)) {
        let a = n === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(n === "smart" ? _.PrimaryTopicNotAllowed : _.PipeTopicUnbound, r),
        this.registerTopicReference(), this.finishNode(t, a);
      } else
        throw this.raise(_.PipeTopicUnconfiguredToken, r, {
          token: ns(i)
        });
    }
    testTopicReferenceConfiguration(t, r, n) {
      switch (t) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: ns(n)
          }]);
        case "smart":
          return n === 27;
        default:
          throw this.raise(_.PipeTopicRequiresHackPipes, r);
      }
    }
    parseAsyncArrowUnaryFunction(t) {
      this.prodParam.enter(ql(!0, this.prodParam.hasYield));
      let r = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(_.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(t, r, !0);
    }
    parseDo(t, r) {
      this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), t.async = r, this.next();
      let n = this.state.labels;
      return this.state.labels = [], r ? (this.prodParam.enter(2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(),
      this.state.labels = n, this.finishNode(t, "DoExpression");
    }
    parseSuper() {
      let t = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(_.SuperNotAllowed,
      t) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(_.UnexpectedSuper, t), !this.match(10) && !this.match(
      0) && !this.match(16) && this.raise(_.UnsupportedSuper, t), this.finishNode(t, "Super");
    }
    parsePrivateName() {
      let t = this.startNode(), r = this.startNodeAt(ar(this.state.startLoc, 1)), n = this.state.value;
      return this.next(), t.id = this.createIdentifier(r, n), this.finishNode(t, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let t = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(t), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(t, r, "sent");
      }
      return this.parseFunction(t);
    }
    parseMetaProperty(t, r, n) {
      t.meta = r;
      let i = this.state.containsEsc;
      return t.property = this.parseIdentifier(!0), (t.property.name !== n || i) && this.raise(_.UnsupportedMetaProperty, t.property, {
        target: r.name,
        onlyValidPropertyName: n
      }), this.finishNode(t, "MetaProperty");
    }
    parseImportMetaProperty(t) {
      let r = this.createIdentifier(this.startNodeAtNode(t), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(_.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let n = this.isContextual(105);
        if (n || this.unexpected(), this.expectPlugin(n ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(_.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), t.phase = n ? "source" : "defer", this.parseImportCall(t);
      }
      return this.parseMetaProperty(t, r, "meta");
    }
    parseLiteralAtNode(t, r, n) {
      return this.addExtra(n, "rawValue", t), this.addExtra(n, "raw", this.input.slice(n.start, this.state.end)), n.value = t, this.next(), this.
      finishNode(n, r);
    }
    parseLiteral(t, r) {
      let n = this.startNode();
      return this.parseLiteralAtNode(t, r, n);
    }
    parseStringLiteral(t) {
      return this.parseLiteral(t, "StringLiteral");
    }
    parseNumericLiteral(t) {
      return this.parseLiteral(t, "NumericLiteral");
    }
    parseBigIntLiteral(t) {
      return this.parseLiteral(t, "BigIntLiteral");
    }
    parseDecimalLiteral(t) {
      return this.parseLiteral(t, "DecimalLiteral");
    }
    parseRegExpLiteral(t) {
      let r = this.startNode();
      return this.addExtra(r, "raw", this.input.slice(r.start, this.state.end)), r.pattern = t.pattern, r.flags = t.flags, this.next(), this.
      finishNode(r, "RegExpLiteral");
    }
    parseBooleanLiteral(t) {
      let r = this.startNode();
      return r.value = t, this.next(), this.finishNode(r, "BooleanLiteral");
    }
    parseNullLiteral() {
      let t = this.startNode();
      return this.next(), this.finishNode(t, "NullLiteral");
    }
    parseParenAndDistinguishExpression(t) {
      let r = this.state.startLoc, n;
      this.next(), this.expressionScope.enter(mG());
      let i = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, l = [], u = new Pi(), c = !0, f, p;
      for (; !this.match(11); ) {
        if (c)
          c = !1;
        else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
          p = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let v = this.state.startLoc;
          if (f = this.state.startLoc, l.push(this.parseParenItem(this.parseRestBinding(), v)), !this.checkCommaAfterRest(41))
            break;
        } else
          l.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
      }
      let h = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = i, this.state.inFSharpPipelineDirectBody = a;
      let y = this.startNodeAt(r);
      return t && this.shouldParseArrow(l) && (y = this.parseArrow(y)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(y, l, !1), y) : (this.expressionScope.exit(), l.length || this.unexpected(this.
      state.lastTokStartLoc), p && this.unexpected(p), f && this.unexpected(f), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(
      l, !0), l.length > 1 ? (n = this.startNodeAt(o), n.expressions = l, this.finishNode(n, "SequenceExpression"), this.resetEndLocation(n,
      h)) : n = l[0], this.wrapParenthesis(r, n));
    }
    wrapParenthesis(t, r) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", t.index), this.takeSurroundingComments(r, t.index, this.
        state.lastTokEndLoc.index), r;
      let n = this.startNodeAt(t);
      return n.expression = r, this.finishNode(n, "ParenthesizedExpression");
    }
    shouldParseArrow(t) {
      return !this.canInsertSemicolon();
    }
    parseArrow(t) {
      if (this.eat(19))
        return t;
    }
    parseParenItem(t, r) {
      return t;
    }
    parseNewOrNewTarget() {
      let t = this.startNode();
      if (this.next(), this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(t), "new");
        this.next();
        let n = this.parseMetaProperty(t, r, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(_.UnexpectedNewTarget,
        n), n;
      }
      return this.parseNew(t);
    }
    parseNew(t) {
      if (this.parseNewCallee(t), this.eat(10)) {
        let r = this.parseExprList(11);
        this.toReferencedList(r), t.arguments = r;
      } else
        t.arguments = [];
      return this.finishNode(t, "NewExpression");
    }
    parseNewCallee(t) {
      let r = this.match(83), n = this.parseNoCallExpr();
      t.callee = n, r && (n.type === "Import" || n.type === "ImportExpression") && this.raise(_.ImportCallNotNewExpression, n);
    }
    parseTemplateElement(t) {
      let {
        start: r,
        startLoc: n,
        end: i,
        value: a
      } = this.state, o = r + 1, l = this.startNodeAt(ar(n, 1));
      a === null && (t || this.raise(_.InvalidEscapeSequenceTemplate, ar(this.state.firstInvalidTemplateEscapePos, 1)));
      let u = this.match(24), c = u ? -1 : -2, f = i + c;
      l.value = {
        raw: this.input.slice(o, f).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, c)
      }, l.tail = u, this.next();
      let p = this.finishNode(l, "TemplateElement");
      return this.resetEndLocation(p, ar(this.state.lastTokEndLoc, c)), p;
    }
    parseTemplate(t) {
      let r = this.startNode(), n = this.parseTemplateElement(t), i = [n], a = [];
      for (; !n.tail; )
        a.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), i.push(n = this.parseTemplateElement(t));
      return r.expressions = a, r.quasis = i, this.finishNode(r, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(t, r, n, i) {
      n && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = /* @__PURE__ */ Object.create(null), l = !0, u = this.startNode();
      for (u.properties = [], this.next(); !this.match(t); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(t)) {
          this.addTrailingCommaExtraToNode(u);
          break;
        }
        let f;
        r ? f = this.parseBindingProperty() : (f = this.parsePropertyDefinition(i), this.checkProto(f, n, o, i)), n && !this.isObjectProperty(
        f) && f.type !== "SpreadElement" && this.raise(_.InvalidRecordProperty, f), f.shorthand && this.addExtra(f, "shorthand", !0), u.properties.
        push(f);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let c = "ObjectExpression";
      return r ? c = "ObjectPattern" : n && (c = "RecordExpression"), this.finishNode(u, c);
    }
    addTrailingCommaExtraToNode(t) {
      this.addExtra(t, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(t) {
      return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(t) {
      let r = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(_.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          r.push(this.parseDecorator());
      let n = this.startNode(), i = !1, a = !1, o;
      if (this.match(21))
        return r.length && this.unexpected(), this.parseSpread();
      r.length && (n.decorators = r, r = []), n.method = !1, t && (o = this.state.startLoc);
      let l = this.eat(55);
      this.parsePropertyNamePrefixOperator(n);
      let u = this.state.containsEsc;
      if (this.parsePropertyName(n, t), !l && !u && this.maybeAsyncOrAccessorProp(n)) {
        let {
          key: c
        } = n, f = c.name;
        f === "async" && !this.hasPrecedingLineBreak() && (i = !0, this.resetPreviousNodeTrailingComments(c), l = this.eat(55), this.parsePropertyName(
        n)), (f === "get" || f === "set") && (a = !0, this.resetPreviousNodeTrailingComments(c), n.kind = f, this.match(55) && (l = !0, this.
        raise(_.AccessorIsGenerator, this.state.curPosition(), {
          kind: f
        }), this.next()), this.parsePropertyName(n));
      }
      return this.parseObjPropValue(n, o, l, i, !1, a, t);
    }
    getGetterSetterExpectedParamCount(t) {
      return t.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(t) {
      return t.params;
    }
    checkGetterSetterParams(t) {
      var r;
      let n = this.getGetterSetterExpectedParamCount(t), i = this.getObjectOrClassMethodParams(t);
      i.length !== n && this.raise(t.kind === "get" ? _.BadGetterArity : _.BadSetterArity, t), t.kind === "set" && ((r = i[i.length - 1]) ==
      null ? void 0 : r.type) === "RestElement" && this.raise(_.BadSetterRestParameter, t);
    }
    parseObjectMethod(t, r, n, i, a) {
      if (a) {
        let o = this.parseMethod(t, r, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (n || r || this.match(10))
        return i && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, r, n, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(t, r, n, i) {
      if (t.shorthand = !1, this.eat(14))
        return t.value = n ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(i), this.finishNode(t, "ObjectProper\
ty");
      if (!t.computed && t.key.type === "Identifier") {
        if (this.checkReservedWord(t.key.name, t.key.loc.start, !0, !1), n)
          t.value = this.parseMaybeDefault(r, In(t.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          i != null ? i.shorthandAssignLoc === null && (i.shorthandAssignLoc = a) : this.raise(_.InvalidCoverInitializedName, a), t.value = this.
          parseMaybeDefault(r, In(t.key));
        } else
          t.value = In(t.key);
        return t.shorthand = !0, this.finishNode(t, "ObjectProperty");
      }
    }
    parseObjPropValue(t, r, n, i, a, o, l) {
      let u = this.parseObjectMethod(t, n, i, a, o) || this.parseObjectProperty(t, r, a, l);
      return u || this.unexpected(), u;
    }
    parsePropertyName(t, r) {
      if (this.eat(0))
        t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: n,
          value: i
        } = this.state, a;
        if (Wr(n))
          a = this.parseIdentifier(!0);
        else
          switch (n) {
            case 134:
              a = this.parseNumericLiteral(i);
              break;
            case 133:
              a = this.parseStringLiteral(i);
              break;
            case 135:
              a = this.parseBigIntLiteral(i);
              break;
            case 136:
              a = this.parseDecimalLiteral(i);
              break;
            case 138: {
              let o = this.state.startLoc;
              r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = o) : this.raise(_.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        t.key = a, n !== 138 && (t.computed = !1);
      }
    }
    initFunction(t, r) {
      t.id = null, t.generator = !1, t.async = r;
    }
    parseMethod(t, r, n, i, a, o, l = !1) {
      this.initFunction(t, n), t.generator = r, this.scope.enter(18 | (l ? 64 : 0) | (a ? 32 : 0)), this.prodParam.enter(ql(n, t.generator)),
      this.parseFunctionParams(t, i);
      let u = this.parseFunctionBodyAndFinish(t, o, !0);
      return this.prodParam.exit(), this.scope.exit(), u;
    }
    parseArrayLike(t, r, n, i) {
      n && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = this.startNode();
      return this.next(), o.elements = this.parseExprList(t, !n, i, o), this.state.inFSharpPipelineDirectBody = a, this.finishNode(o, n ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(t, r, n, i) {
      this.scope.enter(6);
      let a = ql(n, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(t, n);
      let o = this.state.maybeInArrowParameters;
      return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, r, i)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(t, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(t, r, n) {
      this.toAssignableList(r, n, !1), t.params = r;
    }
    parseFunctionBodyAndFinish(t, r, n = !1) {
      return this.parseFunctionBody(t, !1, n), this.finishNode(t, r);
    }
    parseFunctionBody(t, r, n = !1) {
      let i = r && !this.match(5);
      if (this.expressionScope.enter(dT()), i)
        t.body = this.parseMaybeAssign(), this.checkParams(t, !1, r, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t.body = this.parseBlock(!0, !1, (l) => {
          let u = !this.isSimpleParamList(t.params);
          l && u && this.raise(_.IllegalLanguageModeDirective, (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t);
          let c = !a && this.state.strict;
          this.checkParams(t, !this.state.strict && !r && !n && !u, r, c), this.state.strict && t.id && this.checkIdentifier(t.id, 65, c);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(t) {
      return t.type === "Identifier";
    }
    isSimpleParamList(t) {
      for (let r = 0, n = t.length; r < n; r++)
        if (!this.isSimpleParameter(t[r])) return !1;
      return !0;
    }
    checkParams(t, r, n, i = !0) {
      let a = !r && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let l of t.params)
        this.checkLVal(l, o, 5, a, i);
    }
    parseExprList(t, r, n, i) {
      let a = [], o = !0;
      for (; !this.eat(t); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(t)) {
          i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        a.push(this.parseExprListItem(r, n));
      }
      return a;
    }
    parseExprListItem(t, r, n) {
      let i;
      if (this.match(12))
        t || this.raise(_.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), i = null;
      else if (this.match(21)) {
        let a = this.state.startLoc;
        i = this.parseParenItem(this.parseSpread(r), a);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), n || this.raise(_.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let a = this.startNode();
        this.next(), i = this.finishNode(a, "ArgumentPlaceholder");
      } else
        i = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
      return i;
    }
    parseIdentifier(t) {
      let r = this.startNode(), n = this.parseIdentifierName(t);
      return this.createIdentifier(r, n);
    }
    createIdentifier(t, r) {
      return t.name = r, t.loc.identifierName = r, this.finishNode(t, "Identifier");
    }
    parseIdentifierName(t) {
      let r, {
        startLoc: n,
        type: i
      } = this.state;
      Wr(i) ? r = this.state.value : this.unexpected();
      let a = UK(i);
      return t ? a && this.replaceToken(132) : this.checkReservedWord(r, n, a, !1), this.next(), r;
    }
    checkReservedWord(t, r, n, i) {
      if (t.length > 10 || !aG(t))
        return;
      if (n && nG(t)) {
        this.raise(_.UnexpectedKeyword, r, {
          keyword: t
        });
        return;
      }
      if ((this.state.strict ? i ? uT : oT : aT)(t, this.inModule)) {
        this.raise(_.UnexpectedReservedWord, r, {
          reservedWord: t
        });
        return;
      } else if (t === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(_.YieldBindingIdentifier, r);
          return;
        }
      } else if (t === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(_.AwaitBindingIdentifier, r);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(_.AwaitBindingIdentifierInStaticBlock, r);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(r);
      } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(_.ArgumentsInClass, r);
        return;
      }
    }
    recordAwaitIfAllowed() {
      let t = this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction;
      return t && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), t;
    }
    parseAwait(t) {
      let r = this.startNodeAt(t);
      return this.expressionScope.recordParameterInitializerError(_.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(_.ObsoleteAwaitStar,
      r), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst =
      !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExp\
ression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: t
      } = this.state;
      return t === 53 || t === 10 || t === 0 || Vl(t) || t === 102 && !this.state.containsEsc || t === 137 || t === 56 || this.hasPlugin("v8\
intrinsic") && t === 54;
    }
    parseYield() {
      let t = this.startNode();
      this.expressionScope.recordParameterInitializerError(_.YieldInParameter, t), this.next();
      let r = !1, n = null;
      if (!this.hasPrecedingLineBreak())
        switch (r = this.eat(55), this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!r) break;
          default:
            n = this.parseMaybeAssign();
        }
      return t.delegate = r, t.argument = n, this.finishNode(t, "YieldExpression");
    }
    parseImportCall(t) {
      return this.next(), t.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) &&
      (t.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (t.options = this.parseMaybeAssignAllowIn(),
      this.eat(12))), this.expect(11), this.finishNode(t, "ImportExpression");
    }
    checkPipelineAtInfixOperator(t, r) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && t.type === "SequenceExpression" && this.raise(_.PipelineHeadSequenceExpression, r);
    }
    parseSmartPipelineBodyInStyle(t, r) {
      if (this.isSimpleReference(t)) {
        let n = this.startNodeAt(r);
        return n.callee = t, this.finishNode(n, "PipelineBareFunction");
      } else {
        let n = this.startNodeAt(r);
        return this.checkSmartPipeTopicBodyEarlyErrors(r), n.expression = t, this.finishNode(n, "PipelineTopicExpression");
      }
    }
    isSimpleReference(t) {
      switch (t.type) {
        case "MemberExpression":
          return !t.computed && this.isSimpleReference(t.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(t) {
      if (this.match(19))
        throw this.raise(_.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(_.PipelineTopicUnused, t);
    }
    withTopicBindingContext(t) {
      let r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return t();
      } finally {
        this.state.topicContext = r;
      }
    }
    withSmartMixTopicForbiddingContext(t) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let r = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return t();
        } finally {
          this.state.topicContext = r;
        }
      } else
        return t();
    }
    withSoloAwaitPermittingContext(t) {
      let r = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return t();
      } finally {
        this.state.soloAwait = r;
      }
    }
    allowInAnd(t) {
      let r = this.prodParam.currentFlags();
      if (8 & ~r) {
        this.prodParam.enter(r | 8);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    disallowInAnd(t) {
      let r = this.prodParam.currentFlags();
      if (8 & r) {
        this.prodParam.enter(r & -9);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(t) {
      let r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let n = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let i = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, t);
      return this.state.inFSharpPipelineDirectBody = n, i;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let t = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let r = this.startNodeAt(this.state.endLoc);
      this.next();
      let n = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        t.body = this.parseProgram(r, 8, "module");
      } finally {
        n();
      }
      return this.finishNode(t, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(t) {
    }
  }, oh = {
    kind: 1
  }, RG = {
    kind: 2
  }, qG = /[\uD800-\uDFFF]/u, lh = /in(?:stanceof)?/y;
  function UG(e, t) {
    for (let r = 0; r < e.length; r++) {
      let n = e[r], {
        type: i
      } = n;
      if (typeof i == "number") {
        {
          if (i === 138) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = n, c = o + 1, f = ar(a.start, 1);
            e.splice(r, 1, new un({
              type: An(27),
              value: "#",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: f
            }), new un({
              type: An(132),
              value: l,
              start: c,
              end: u,
              startLoc: f,
              endLoc: a.end
            })), r++;
            continue;
          }
          if (Vl(i)) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = n, c = o + 1, f = ar(a.start, 1), p;
            t.charCodeAt(o) === 96 ? p = new un({
              type: An(22),
              value: "`",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: f
            }) : p = new un({
              type: An(8),
              value: "}",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: f
            });
            let h, y, v, d;
            i === 24 ? (y = u - 1, v = ar(a.end, -1), h = l === null ? null : l.slice(1, -1), d = new un({
              type: An(22),
              value: "`",
              start: y,
              end: u,
              startLoc: v,
              endLoc: a.end
            })) : (y = u - 2, v = ar(a.end, -2), h = l === null ? null : l.slice(1, -2), d = new un({
              type: An(23),
              value: "${",
              start: y,
              end: u,
              startLoc: v,
              endLoc: a.end
            })), e.splice(r, 1, p, new un({
              type: An(20),
              value: h,
              start: c,
              end: y,
              startLoc: f,
              endLoc: v
            }), d), r += 2;
            continue;
          }
        }
        n.type = An(i);
      }
    }
    return e;
  }
  s(UG, "babel7CompatTokens");
  var Dh = class extends wh {
    static {
      s(this, "StatementParser");
    }
    parseTopLevel(t, r) {
      return t.program = this.parseProgram(r), t.comments = this.comments, this.options.tokens && (t.tokens = UG(this.tokens, this.input)), this.
      finishNode(t, "File");
    }
    parseProgram(t, r = 139, n = this.options.sourceType) {
      if (t.sourceType = n, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, !0, !0, r), this.inModule) {
        if (!this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
          for (let [a, o] of Array.from(this.scope.undefinedExports))
            this.raise(_.ModuleExportUndefined, o, {
              localName: a
            });
        this.addExtra(t, "topLevelAwait", this.state.hasTopLevelAwait);
      }
      let i;
      return r === 139 ? i = this.finishNode(t, "Program") : i = this.finishNodeAt(t, "Program", ar(this.state.startLoc, -1)), i;
    }
    stmtToDirective(t) {
      let r = t;
      r.type = "Directive", r.value = r.expression, delete r.expression;
      let n = r.value, i = n.value, a = this.input.slice(n.start, n.end), o = n.value = a.slice(1, -1);
      return this.addExtra(n, "raw", a), this.addExtra(n, "rawValue", o), this.addExtra(n, "expressionValue", i), n.type = "DirectiveLiteral",
      r;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let t = this.startNode();
      return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(t, r) {
      if (wn(t)) {
        if (lh.lastIndex = r, lh.test(this.input)) {
          let n = this.codePointAtPos(lh.lastIndex);
          if (!xi(n) && n !== 92)
            return !1;
        }
        return !0;
      } else return t === 92;
    }
    chStartsBindingPattern(t) {
      return t === 91 || t === 123;
    }
    hasFollowingBindingAtom() {
      let t = this.nextTokenStart(), r = this.codePointAtPos(t);
      return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, t);
    }
    hasInLineFollowingBindingIdentifierOrBrace() {
      let t = this.nextTokenInLineStart(), r = this.codePointAtPos(t);
      return r === 123 || this.chStartsBindingIdentifier(r, t);
    }
    startsUsingForOf() {
      let {
        type: t,
        containsEsc: r
      } = this.lookahead();
      if (t === 102 && !r)
        return !1;
      if (tt(t) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let t = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(t, "using")) {
        t = this.nextTokenInLineStartSince(t + 5);
        let r = this.codePointAtPos(t);
        if (this.chStartsBindingIdentifier(r, t))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(t = !1) {
      let r = 0;
      return this.options.annexB && !this.state.strict && (r |= 4, t && (r |= 8)), this.parseStatementLike(r);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(t) {
      let r = null;
      return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(t, r);
    }
    parseStatementContent(t, r) {
      let n = this.state.type, i = this.startNode(), a = !!(t & 2), o = !!(t & 4), l = t & 1;
      switch (n) {
        case 60:
          return this.parseBreakContinueStatement(i, !0);
        case 63:
          return this.parseBreakContinueStatement(i, !1);
        case 64:
          return this.parseDebuggerStatement(i);
        case 90:
          return this.parseDoWhileStatement(i);
        case 91:
          return this.parseForStatement(i);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? _.StrictFunction : this.options.annexB ? _.SloppyFunctionAnnexB : _.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(i, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, i), !0);
        case 69:
          return this.parseIfStatement(i);
        case 70:
          return this.parseReturnStatement(i);
        case 71:
          return this.parseSwitchStatement(i);
        case 72:
          return this.parseThrowStatement(i);
        case 73:
          return this.parseTryStatement(i);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.recordAwaitIfAllowed() ? a || this.raise(_.UnexpectedLexicalDeclaration, i) : this.raise(_.AwaitUsingNotInAsyncContext,
            i), this.next(), this.parseVarStatement(i, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(_.UnexpectedUsingDeclaration,
          this.state.startLoc) : a || this.raise(_.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(i, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let f = this.nextTokenStart(), p = this.codePointAtPos(f);
          if (p !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(p, f) && p !== 123))
            break;
        }
        case 75:
          a || this.raise(_.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let f = this.state.value;
          return this.parseVarStatement(i, f);
        }
        case 92:
          return this.parseWhileStatement(i);
        case 76:
          return this.parseWithStatement(i);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(i);
        case 83: {
          let f = this.lookaheadCharCode();
          if (f === 40 || f === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !l && this.raise(_.UnexpectedImportExport, this.state.startLoc), this.next();
          let f;
          return n === 83 ? (f = this.parseImport(i), f.type === "ImportDeclaration" && (!f.importKind || f.importKind === "value") && (this.
          sawUnambiguousESM = !0)) : (f = this.parseExport(i, r), (f.type === "ExportNamedDeclaration" && (!f.exportKind || f.exportKind ===
          "value") || f.type === "ExportAllDeclaration" && (!f.exportKind || f.exportKind === "value") || f.type === "ExportDefaultDeclarati\
on") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(f), f;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(_.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(i,
            !0, !a && o);
      }
      let u = this.state.value, c = this.parseExpression();
      return tt(n) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i, u, c, t) : this.parseExpressionStatement(i, c,
      r);
    }
    assertModuleNodeAllowed(t) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(_.ImportOutsideModule, t);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(t, r, n) {
      return t && (r.decorators && r.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolea\
n" && this.raise(_.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...t)) : r.decorators = t, this.resetStartLocationFromNode(
      r, t[0]), n && this.resetStartLocationFromNode(n, r)), r;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(t) {
      let r = [];
      do
        r.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(_.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(_.UnexpectedLeadingDecorator, this.state.startLoc);
      return r;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let t = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let r = this.state.startLoc, n;
        if (this.match(10)) {
          let i = this.state.startLoc;
          this.next(), n = this.parseExpression(), this.expect(11), n = this.wrapParenthesis(i, n);
          let a = this.state.startLoc;
          t.expression = this.parseMaybeDecoratorArguments(n), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && t.expression !==
          n && this.raise(_.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (n = this.parseIdentifier(!1); this.eat(16); ) {
            let i = this.startNodeAt(r);
            i.object = n, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), i.property = this.parsePrivateName()) :
            i.property = this.parseIdentifier(!0), i.computed = !1, n = this.finishNode(i, "MemberExpression");
          }
          t.expression = this.parseMaybeDecoratorArguments(n);
        }
      } else
        t.expression = this.parseExprSubscripts();
      return this.finishNode(t, "Decorator");
    }
    parseMaybeDecoratorArguments(t) {
      if (this.eat(10)) {
        let r = this.startNodeAtNode(t);
        return r.callee = t, r.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(r.arguments), this.finishNode(r,
        "CallExpression");
      }
      return t;
    }
    parseBreakContinueStatement(t, r) {
      return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      t, r), this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(t, r) {
      let n;
      for (n = 0; n < this.state.labels.length; ++n) {
        let i = this.state.labels[n];
        if ((t.label == null || i.name === t.label.name) && (i.kind != null && (r || i.kind === 1) || t.label && r))
          break;
      }
      if (n === this.state.labels.length) {
        let i = r ? "BreakStatement" : "ContinueStatement";
        this.raise(_.IllegalBreakContinue, t, {
          type: i
        });
      }
    }
    parseDebuggerStatement(t) {
      return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let t = this.parseExpression();
      return this.expect(11), t;
    }
    parseDoWhileStatement(t) {
      return this.next(), this.state.labels.push(oh), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
    }
    parseForStatement(t) {
      this.next(), this.state.labels.push(oh);
      let r = null;
      if (this.isContextual(96) && this.recordAwaitIfAllowed() && (r = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10),
      this.match(13))
        return r !== null && this.unexpected(r), this.parseFor(t, null);
      let n = this.isContextual(100);
      {
        let u = this.isContextual(96) && this.startsAwaitUsing(), c = u || this.isContextual(107) && this.startsUsingForOf(), f = n && this.
        hasFollowingBindingAtom() || c;
        if (this.match(74) || this.match(75) || f) {
          let p = this.startNode(), h;
          u ? (h = "await using", this.recordAwaitIfAllowed() || this.raise(_.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) :
          h = this.state.value, this.next(), this.parseVar(p, !0, h);
          let y = this.finishNode(p, "VariableDeclaration"), v = this.match(58);
          return v && c && this.raise(_.ForInUsing, y), (v || this.isContextual(102)) && y.declarations.length === 1 ? this.parseForIn(t, y,
          r) : (r !== null && this.unexpected(r), this.parseFor(t, y));
        }
      }
      let i = this.isContextual(95), a = new Pi(), o = this.parseExpression(!0, a), l = this.isContextual(102);
      if (l && (n && this.raise(_.ForOfLet, o), r === null && i && o.type === "Identifier" && this.raise(_.ForOfAsync, o)), l || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let u = l ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          type: u
        }), this.parseForIn(t, o, r);
      } else
        this.checkExpressionErrors(a, !0);
      return r !== null && this.unexpected(r), this.parseFor(t, o);
    }
    parseFunctionStatement(t, r, n) {
      return this.next(), this.parseFunction(t, 1 | (n ? 2 : 0) | (r ? 8 : 0));
    }
    parseIfStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
    }
    parseReturnStatement(t) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(_.IllegalReturn, this.state.startLoc), this.
      next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "Ret\
urnStatement");
    }
    parseSwitchStatement(t) {
      this.next(), t.discriminant = this.parseHeaderExpression();
      let r = t.cases = [];
      this.expect(5), this.state.labels.push(RG), this.scope.enter(0);
      let n;
      for (let i; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          n && this.finishNode(n, "SwitchCase"), r.push(n = this.startNode()), n.consequent = [], this.next(), a ? n.test = this.parseExpression() :
          (i && this.raise(_.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), i = !0, n.test = null), this.expect(14);
        } else
          n ? n.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), n && this.finishNode(n, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchState\
ment");
    }
    parseThrowStatement(t) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(_.NewlineAfterThrow, this.state.lastTokEndLoc), t.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(t, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let t = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && t.type === "Identifier" ? 8 : 0), this.checkLVal(t, {
        type: "CatchClause"
      }, 9), t;
    }
    parseTryStatement(t) {
      if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
        let r = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.
        enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), t.handler = this.finishNode(
        r, "CatchClause");
      }
      return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(_.NoCatchOrFinally, t), this.finishNode(
      t, "TryStatement");
    }
    parseVarStatement(t, r, n = !1) {
      return this.next(), this.parseVar(t, !1, r, n), this.semicolon(), this.finishNode(t, "VariableDeclaration");
    }
    parseWhileStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(oh), t.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
    }
    parseWithStatement(t) {
      return this.state.strict && this.raise(_.StrictWith, this.state.startLoc), this.next(), t.object = this.parseHeaderExpression(), t.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
    }
    parseEmptyStatement(t) {
      return this.next(), this.finishNode(t, "EmptyStatement");
    }
    parseLabeledStatement(t, r, n, i) {
      for (let o of this.state.labels)
        o.name === r && this.raise(_.LabelRedeclaration, n, {
          labelName: r
        });
      let a = WK(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let l = this.state.labels[o];
        if (l.statementStart === t.start)
          l.statementStart = this.state.start, l.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: r,
        kind: a,
        statementStart: this.state.start
      }), t.body = i & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), t.label =
      n, this.finishNode(t, "LabeledStatement");
    }
    parseExpressionStatement(t, r, n) {
      return t.expression = r, this.semicolon(), this.finishNode(t, "ExpressionStatement");
    }
    parseBlock(t = !1, r = !0, n) {
      let i = this.startNode();
      return t && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(i, t, !1, 8, n), r && this.
      scope.exit(), this.finishNode(i, "BlockStatement");
    }
    isValidDirective(t) {
      return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
    }
    parseBlockBody(t, r, n, i, a) {
      let o = t.body = [], l = t.directives = [];
      this.parseBlockOrModuleBlockBody(o, r ? l : void 0, n, i, a);
    }
    parseBlockOrModuleBlockBody(t, r, n, i, a) {
      let o = this.state.strict, l = !1, u = !1;
      for (; !this.match(i); ) {
        let c = n ? this.parseModuleItem() : this.parseStatementListItem();
        if (r && !u) {
          if (this.isValidDirective(c)) {
            let f = this.stmtToDirective(c);
            r.push(f), !l && f.value.value === "use strict" && (l = !0, this.setStrict(!0));
            continue;
          }
          u = !0, this.state.strictErrors.clear();
        }
        t.push(c);
      }
      a?.call(this, l), o || this.setStrict(!1), this.next();
    }
    parseFor(t, r) {
      return t.init = r, this.semicolon(!1), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), t.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
    }
    parseForIn(t, r, n) {
      let i = this.match(58);
      return this.next(), i ? n !== null && this.unexpected(n) : t.await = n !== null, r.type === "VariableDeclaration" && r.declarations[0].
      init != null && (!i || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") &&
      this.raise(_.ForInOfLoopInitializer, r, {
        type: i ? "ForInStatement" : "ForOfStatement"
      }), r.type === "AssignmentPattern" && this.raise(_.InvalidLhs, r, {
        ancestor: {
          type: "ForStatement"
        }
      }), t.left = r, t.right = i ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, i ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(t, r, n, i = !1) {
      let a = t.declarations = [];
      for (t.kind = n; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, n), o.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !i && (o.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(_.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (n === "const" || n === "using" || n === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(_.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: n
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return t;
    }
    parseVarId(t, r) {
      let n = this.parseBindingAtom();
      (r === "using" || r === "await using") && (n.type === "ArrayPattern" || n.type === "ObjectPattern") && this.raise(_.UsingDeclarationHasBindingPattern,
      n.loc.start), this.checkLVal(n, {
        type: "VariableDeclarator"
      }, r === "var" ? 5 : 8201), t.id = n;
    }
    parseAsyncFunctionExpression(t) {
      return this.parseFunction(t, 8);
    }
    parseFunction(t, r = 0) {
      let n = r & 2, i = !!(r & 1), a = i && !(r & 4), o = !!(r & 8);
      this.initFunction(t, o), this.match(55) && (n && this.raise(_.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t.
      generator = !0), i && (t.id = this.parseFunctionId(a));
      let l = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(ql(o, t.generator)), i || (t.id = this.parseFunctionId()),
      this.parseFunctionParams(t, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(t, i ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), i && !n && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = l, t;
    }
    parseFunctionId(t) {
      return t || tt(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(t, r) {
      this.expect(10), this.expressionScope.enter(hG()), t.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(t) {
      t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, t.id.loc.start);
    }
    parseClass(t, r, n) {
      this.next();
      let i = this.state.strict;
      return this.state.strict = !0, this.parseClassId(t, r, n), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, i), this.
      finishNode(t, r ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(t) {
      return t.type === "Identifier" && t.name === "constructor" || t.type === "StringLiteral" && t.value === "constructor";
    }
    isNonstaticConstructor(t) {
      return !t.computed && !t.static && this.nameIsConstructor(t.key);
    }
    parseClassBody(t, r) {
      this.classScope.enter();
      let n = {
        hadConstructor: !1,
        hadSuperClass: t
      }, i = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (i.length > 0)
              throw this.raise(_.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            i.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          i.length && (o.decorators = i, this.resetStartLocationFromNode(o, i[0]), i = []), this.parseClassMember(a, o, n), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(_.DecoratorConstructor, o);
        }
      }), this.state.strict = r, this.next(), i.length)
        throw this.raise(_.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(t, r) {
      let n = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let i = r;
        return i.kind = "method", i.computed = !1, i.key = n, i.static = !1, this.pushClassMethod(t, i, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let i = r;
        return i.computed = !1, i.key = n, i.static = !1, t.body.push(this.parseClassProperty(i)), !0;
      }
      return this.resetPreviousNodeTrailingComments(n), !1;
    }
    parseClassMember(t, r, n) {
      let i = this.isContextual(106);
      if (i) {
        if (this.parseClassMemberFromModifier(t, r))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(t, r);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(t, r, n, i);
    }
    parseClassMemberWithIsStatic(t, r, n, i) {
      let a = r, o = r, l = r, u = r, c = r, f = a, p = a;
      if (r.static = i, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
        f.kind = "method";
        let E = this.match(138);
        if (this.parseClassElementName(f), E) {
          this.pushClassPrivateMethod(t, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(_.ConstructorIsGenerator, a.key), this.pushClassMethod(t, a, !0, !1, !1, !1);
        return;
      }
      let h = !this.state.containsEsc && tt(this.state.type), y = this.parseClassElementName(r), v = h ? y.name : null, d = this.isPrivateName(
      y), b = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(p), this.isClassMethod()) {
        if (f.kind = "method", d) {
          this.pushClassPrivateMethod(t, o, !1, !1);
          return;
        }
        let E = this.isNonstaticConstructor(a), I = !1;
        E && (a.kind = "constructor", n.hadConstructor && !this.hasPlugin("typescript") && this.raise(_.DuplicateConstructor, y), E && this.
        hasPlugin("typescript") && r.override && this.raise(_.OverrideOnConstructor, y), n.hadConstructor = !0, I = n.hadSuperClass), this.pushClassMethod(
        t, a, !1, !1, E, I);
      } else if (this.isClassProperty())
        d ? this.pushClassPrivateProperty(t, u) : this.pushClassProperty(t, l);
      else if (v === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(y);
        let E = this.eat(55);
        p.optional && this.unexpected(b), f.kind = "method";
        let I = this.match(138);
        this.parseClassElementName(f), this.parsePostMemberNameModifiers(p), I ? this.pushClassPrivateMethod(t, o, E, !0) : (this.isNonstaticConstructor(
        a) && this.raise(_.ConstructorIsAsync, a.key), this.pushClassMethod(t, a, E, !0, !1, !1));
      } else if ((v === "get" || v === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(y), f.kind = v;
        let E = this.match(138);
        this.parseClassElementName(a), E ? this.pushClassPrivateMethod(t, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(_.ConstructorIsAccessor,
        a.key), this.pushClassMethod(t, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (v === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(y);
        let E = this.match(138);
        this.parseClassElementName(l), this.pushClassAccessorProperty(t, c, E);
      } else this.isLineTerminator() ? d ? this.pushClassPrivateProperty(t, u) : this.pushClassProperty(t, l) : this.unexpected();
    }
    parseClassElementName(t) {
      let {
        type: r,
        value: n
      } = this.state;
      if ((r === 132 || r === 133) && t.static && n === "prototype" && this.raise(_.StaticPrototype, this.state.startLoc), r === 138) {
        n === "constructor" && this.raise(_.ConstructorClassPrivateField, this.state.startLoc);
        let i = this.parsePrivateName();
        return t.key = i, i;
      }
      return this.parsePropertyName(t), t.key;
    }
    parseClassStaticBlock(t, r) {
      var n;
      this.scope.enter(208);
      let i = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = r.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = i, t.body.push(this.
      finishNode(r, "StaticBlock")), (n = r.decorators) != null && n.length && this.raise(_.DecoratorStaticBlock, r);
    }
    pushClassProperty(t, r) {
      !r.computed && this.nameIsConstructor(r.key) && this.raise(_.ConstructorClassField, r.key), t.body.push(this.parseClassProperty(r));
    }
    pushClassPrivateProperty(t, r) {
      let n = this.parseClassPrivateProperty(r);
      t.body.push(n), this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), 0, n.key.loc.start);
    }
    pushClassAccessorProperty(t, r, n) {
      !n && !r.computed && this.nameIsConstructor(r.key) && this.raise(_.ConstructorClassField, r.key);
      let i = this.parseClassAccessorProperty(r);
      t.body.push(i), n && this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
    }
    pushClassMethod(t, r, n, i, a, o) {
      t.body.push(this.parseMethod(r, n, i, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(t, r, n, i) {
      let a = this.parseMethod(r, n, i, !1, !1, "ClassPrivateMethod", !0);
      t.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(t, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), r, t.key.loc.start);
    }
    parsePostMemberNameModifiers(t) {
    }
    parseClassPrivateProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
    }
    parseClassProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
    }
    parseClassAccessorProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
    }
    parseInitializer(t) {
      this.scope.enter(80), this.expressionScope.enter(dT()), this.prodParam.enter(0), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(t, r, n, i = 8331) {
      if (tt(this.state.type))
        t.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(t.id, i);
      else if (n || !r)
        t.id = null;
      else
        throw this.raise(_.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(t) {
      t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(t, r) {
      let n = this.parseMaybeImportPhase(t, !0), i = this.maybeParseExportDefaultSpecifier(t, n), a = !i || this.eat(12), o = a && this.eatExportStar(
      t), l = o && this.maybeParseExportNamespaceSpecifier(t), u = a && (!l || this.eat(12)), c = i || o;
      if (o && !l) {
        if (i && this.unexpected(), r)
          throw this.raise(_.UnsupportedDecoratorExport, t);
        return this.parseExportFrom(t, !0), this.finishNode(t, "ExportAllDeclaration");
      }
      let f = this.maybeParseExportNamedSpecifiers(t);
      i && a && !o && !f && this.unexpected(null, 5), l && u && this.unexpected(null, 98);
      let p;
      if (c || f) {
        if (p = !1, r)
          throw this.raise(_.UnsupportedDecoratorExport, t);
        this.parseExportFrom(t, c);
      } else
        p = this.maybeParseExportDeclaration(t);
      if (c || f || p) {
        var h;
        let y = t;
        if (this.checkExport(y, !0, !1, !!y.source), ((h = y.declaration) == null ? void 0 : h.type) === "ClassDeclaration")
          this.maybeTakeDecorators(r, y.declaration, y);
        else if (r)
          throw this.raise(_.UnsupportedDecoratorExport, t);
        return this.finishNode(y, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let y = t, v = this.parseExportDefaultExpression();
        if (y.declaration = v, v.type === "ClassDeclaration")
          this.maybeTakeDecorators(r, v, y);
        else if (r)
          throw this.raise(_.UnsupportedDecoratorExport, t);
        return this.checkExport(y, !0, !0), this.finishNode(y, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(t) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(t, r) {
      if (r || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", r?.loc.start);
        let n = r || this.parseIdentifier(!0), i = this.startNodeAtNode(n);
        return i.exported = n, t.specifiers = [this.finishNode(i, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(t) {
      if (this.isContextual(93)) {
        var r, n;
        (n = (r = t).specifiers) != null || (r.specifiers = []);
        let i = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), i.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(i, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(t) {
      if (this.match(5)) {
        let r = t;
        r.specifiers || (r.specifiers = []);
        let n = r.exportKind === "type";
        return r.specifiers.push(...this.parseExportSpecifiers(n)), r.source = null, r.declaration = null, this.hasPlugin("importAssertions") &&
        (r.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(t) {
      return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions =
      []), t.declaration = this.parseExportDeclaration(t), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let t = this.nextTokenInLineStart();
      return this.isUnparsedContextual(t, "function");
    }
    parseExportDefaultExpression() {
      let t = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(t, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(t, 13);
      if (this.match(80))
        return this.parseClass(t, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(_.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(_.UnsupportedDefaultExport, this.state.startLoc);
      let r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(t) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: t
      } = this.state;
      if (tt(t)) {
        if (t === 95 && !this.state.containsEsc || t === 100)
          return !1;
        if ((t === 130 || t === 129) && !this.state.containsEsc) {
          let {
            type: i
          } = this.lookahead();
          if (tt(i) && i !== 98 || i === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let r = this.nextTokenStart(), n = this.isUnparsedContextual(r, "from");
      if (this.input.charCodeAt(r) === 44 || tt(this.state.type) && n)
        return !0;
      if (this.match(65) && n) {
        let i = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
        return i === 34 || i === 39;
      }
      return !1;
    }
    parseExportFrom(t, r) {
      this.eatContextual(98) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(
      t)) : r && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: t
      } = this.state;
      return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(_.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.
      raise(_.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(_.UsingDeclarationExport,
      this.state.startLoc), !0) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(t, r, n, i) {
      if (r) {
        var a;
        if (n) {
          if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let l = t.declaration;
            l.type === "Identifier" && l.name === "from" && l.end - l.start === 4 && !((o = l.extra) != null && o.parenthesized) && this.raise(
            _.ExportDefaultFromAsIdentifier, l);
          }
        } else if ((a = t.specifiers) != null && a.length)
          for (let l of t.specifiers) {
            let {
              exported: u
            } = l, c = u.type === "Identifier" ? u.name : u.value;
            if (this.checkDuplicateExports(l, c), !i && l.local) {
              let {
                local: f
              } = l;
              f.type !== "Identifier" ? this.raise(_.ExportBindingIsString, l, {
                localName: f.value,
                exportName: c
              }) : (this.checkReservedWord(f.name, f.loc.start, !0, !1), this.scope.checkLocalExport(f));
            }
          }
        else if (t.declaration) {
          let l = t.declaration;
          if (l.type === "FunctionDeclaration" || l.type === "ClassDeclaration") {
            let {
              id: u
            } = l;
            if (!u) throw new Error("Assertion failure");
            this.checkDuplicateExports(t, u.name);
          } else if (l.type === "VariableDeclaration")
            for (let u of l.declarations)
              this.checkDeclaration(u.id);
        }
      }
    }
    checkDeclaration(t) {
      if (t.type === "Identifier")
        this.checkDuplicateExports(t, t.name);
      else if (t.type === "ObjectPattern")
        for (let r of t.properties)
          this.checkDeclaration(r);
      else if (t.type === "ArrayPattern")
        for (let r of t.elements)
          r && this.checkDeclaration(r);
      else t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type ===
      "AssignmentPattern" && this.checkDeclaration(t.left);
    }
    checkDuplicateExports(t, r) {
      this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(_.DuplicateDefaultExport, t) : this.raise(_.DuplicateExport, t, {
        exportName: r
      })), this.exportedIdentifiers.add(r);
    }
    parseExportSpecifiers(t) {
      let r = [], n = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (n)
          n = !1;
        else if (this.expect(12), this.eat(8)) break;
        let i = this.isContextual(130), a = this.match(133), o = this.startNode();
        o.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(o, a, t, i));
      }
      return r;
    }
    parseExportSpecifier(t, r, n, i) {
      return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : r ? t.exported = bG(t.local) : t.exported || (t.exported =
      In(t.local)), this.finishNode(t, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        let t = this.parseStringLiteral(this.state.value), r = qG.exec(t.value);
        return r && this.raise(_.ModuleExportNameHasLoneSurrogate, t, {
          surrogateCharCode: r[0].charCodeAt(0)
        }), t;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(t) {
      return t.assertions != null ? t.assertions.some(({
        key: r,
        value: n
      }) => n.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
    }
    checkImportReflection(t) {
      let {
        specifiers: r
      } = t, n = r.length === 1 ? r[0].type : null;
      if (t.phase === "source")
        n !== "ImportDefaultSpecifier" && this.raise(_.SourcePhaseImportRequiresDefault, r[0].loc.start);
      else if (t.phase === "defer")
        n !== "ImportNamespaceSpecifier" && this.raise(_.DeferImportRequiresNamespace, r[0].loc.start);
      else if (t.module) {
        var i;
        n !== "ImportDefaultSpecifier" && this.raise(_.ImportReflectionNotBinding, r[0].loc.start), ((i = t.assertions) == null ? void 0 : i.
        length) > 0 && this.raise(_.ImportReflectionHasAssertion, r[0].loc.start);
      }
    }
    checkJSONModuleImport(t) {
      if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
        let {
          specifiers: r
        } = t;
        if (r != null) {
          let n = r.find((i) => {
            let a;
            if (i.type === "ExportSpecifier" ? a = i.local : i.type === "ImportSpecifier" && (a = i.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          n !== void 0 && this.raise(_.ImportJSONBindingNotDefault, n.loc.start);
        }
      }
    }
    isPotentialImportPhase(t) {
      return t ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(t, r, n, i) {
      r || (n === "module" ? (this.expectPlugin("importReflection", i), t.module = !0) : this.hasPlugin("importReflection") && (t.module = !1),
      n === "source" ? (this.expectPlugin("sourcePhaseImports", i), t.phase = "source") : n === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", i), t.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t.phase = null));
    }
    parseMaybeImportPhase(t, r) {
      if (!this.isPotentialImportPhase(r))
        return this.applyImportPhase(t, r, null), null;
      let n = this.parseIdentifier(!0), {
        type: i
      } = this.state;
      return (Wr(i) ? i !== 98 || this.lookaheadCharCode() === 102 : i !== 12) ? (this.resetPreviousIdentifierLeadingComments(n), this.applyImportPhase(
      t, r, n.name, n.loc.start), null) : (this.applyImportPhase(t, r, null), n);
    }
    isPrecedingIdImportPhase(t) {
      let {
        type: r
      } = this.state;
      return tt(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
    }
    parseImport(t) {
      return this.match(133) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, !1));
    }
    parseImportSpecifiersAndAfter(t, r) {
      t.specifiers = [];
      let i = !this.maybeParseDefaultImportSpecifier(t, r) || this.eat(12), a = i && this.maybeParseStarImportSpecifier(t);
      return i && !a && this.parseNamedImportSpecifiers(t), this.expectContextual(98), this.parseImportSourceAndAttributes(t);
    }
    parseImportSourceAndAttributes(t) {
      var r;
      return (r = t.specifiers) != null || (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.
      checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.finishNode(t, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(t, r, n) {
      r.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(r, n));
    }
    finishImportSpecifier(t, r, n = 8201) {
      return this.checkLVal(t.local, {
        type: r
      }, n), this.finishNode(t, r);
    }
    parseImportAttributes() {
      this.expect(5);
      let t = [], r = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let n = this.startNode(), i = this.state.value;
        if (r.has(i) && this.raise(_.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: i
        }), r.add(i), this.match(133) ? n.key = this.parseStringLiteral(i) : n.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        133))
          throw this.raise(_.ModuleAttributeInvalidValue, this.state.startLoc);
        n.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(n, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), t;
    }
    parseModuleAttributes() {
      let t = [], r = /* @__PURE__ */ new Set();
      do {
        let n = this.startNode();
        if (n.key = this.parseIdentifier(!0), n.key.name !== "type" && this.raise(_.ModuleAttributeDifferentFromType, n.key), r.has(n.key.name) &&
        this.raise(_.ModuleAttributesWithDuplicateKeys, n.key, {
          key: n.key.name
        }), r.add(n.key.name), this.expect(14), !this.match(133))
          throw this.raise(_.ModuleAttributeInvalidValue, this.state.startLoc);
        n.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(n, "ImportAttribute"));
      } while (this.eat(12));
      return t;
    }
    maybeParseImportAttributes(t) {
      let r, n = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? r = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), r = this.
        parseImportAttributes()), n = !0;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(_.ImportAttributesUseAssert,
        this.state.startLoc), this.addExtra(t, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]),
        this.next(), r = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        r = [];
      else if (this.hasPlugin("moduleAttributes"))
        r = [];
      else return;
      !n && this.hasPlugin("importAssertions") ? t.assertions = r : t.attributes = r;
    }
    maybeParseDefaultImportSpecifier(t, r) {
      if (r) {
        let n = this.startNodeAtNode(r);
        return n.local = r, t.specifiers.push(this.finishImportSpecifier(n, "ImportDefaultSpecifier")), !0;
      } else if (Wr(this.state.type))
        return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(t) {
      if (this.match(55)) {
        let r = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, r, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(t) {
      let r = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = !1;
        else {
          if (this.eat(14))
            throw this.raise(_.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let n = this.startNode(), i = this.match(133), a = this.isContextual(130);
        n.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(n, i, t.importKind === "type" || t.importKind === "typeof", a, void 0);
        t.specifiers.push(o);
      }
    }
    parseImportSpecifier(t, r, n, i, a) {
      if (this.eatContextual(93))
        t.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = t;
        if (r)
          throw this.raise(_.ImportBindingIsString, t, {
            importName: o.value
          });
        this.checkReservedWord(o.name, t.loc.start, !0, !0), t.local || (t.local = In(o));
      }
      return this.finishImportSpecifier(t, "ImportSpecifier", a);
    }
    isThisParam(t) {
      return t.type === "Identifier" && t.name === "this";
    }
  }, Wl = class extends Dh {
    static {
      s(this, "Parser");
    }
    constructor(t, r, n) {
      t = MG(t), super(t, r), this.options = t, this.initializeScopes(), this.plugins = n, this.filename = t.sourceFilename;
    }
    getScopeHandler() {
      return za;
    }
    parse() {
      this.enterInitialScopes();
      let t = this.startNode(), r = this.startNode();
      return this.nextToken(), t.errors = null, this.parseTopLevel(t, r), t.errors = this.state.errors, t.comments.length = this.state.commentsLen,
      t;
    }
  };
  function VG(e, t) {
    var r;
    if (((r = t) == null ? void 0 : r.sourceType) === "unambiguous") {
      t = Object.assign({}, t);
      try {
        t.sourceType = "module";
        let n = Ga(t, e), i = n.parse();
        if (n.sawUnambiguousESM)
          return i;
        if (n.ambiguousScriptDifferentAst)
          try {
            return t.sourceType = "script", Ga(t, e).parse();
          } catch {
          }
        else
          i.program.sourceType = "script";
        return i;
      } catch (n) {
        try {
          return t.sourceType = "script", Ga(t, e).parse();
        } catch {
        }
        throw n;
      }
    } else
      return Ga(t, e).parse();
  }
  s(VG, "parse");
  function $G(e, t) {
    let r = Ga(t, e);
    return r.options.strictMode && (r.state.strict = !0), r.getExpression();
  }
  s($G, "parseExpression");
  function WG(e) {
    let t = {};
    for (let r of Object.keys(e))
      t[r] = An(e[r]);
    return t;
  }
  s(WG, "generateExportedTokenTypes");
  var KG = WG(qK);
  function Ga(e, t) {
    let r = Wl, n = /* @__PURE__ */ new Map();
    if (e != null && e.plugins) {
      for (let i of e.plugins) {
        let a, o;
        typeof i == "string" ? a = i : [a, o] = i, n.has(a) || n.set(a, o || {});
      }
      jG(n), r = GG(n);
    }
    return new r(e, t, n);
  }
  s(Ga, "getParser");
  var rT = /* @__PURE__ */ new Map();
  function GG(e) {
    let t = [];
    for (let i of LG)
      e.has(i) && t.push(i);
    let r = t.join("|"), n = rT.get(r);
    if (!n) {
      n = Wl;
      for (let i of t)
        n = gT[i](n);
      rT.set(r, n);
    }
    return n;
  }
  s(GG, "getParserClass");
  Xa.parse = VG;
  Xa.parseExpression = $G;
  Xa.tokTypes = KG;
});

// ../node_modules/js-tokens/index.js
var bT = T((Kl) => {
  Object.defineProperty(Kl, "__esModule", {
    value: !0
  });
  Kl.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  Kl.matchToToken = function(e) {
    var t = { type: "invalid", value: e[0], closed: void 0 };
    return e[1] ? (t.type = "string", t.closed = !!(e[3] || e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) :
    e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "white\
space"), t;
  };
});

// ../node_modules/picocolors/picocolors.js
var qh = T((jSe, Rh) => {
  var ET = process.argv || [], Gl = process.env, HG = !("NO_COLOR" in Gl || ET.includes("--no-color")) && ("FORCE_COLOR" in Gl || ET.includes(
  "--color") || process.platform === "win32" || ie != null && ie("tty").isatty(1) && Gl.TERM !== "dumb" || "CI" in Gl), YG = /* @__PURE__ */ s(
  (e, t, r = e) => (n) => {
    let i = "" + n, a = i.indexOf(t, e.length);
    return ~a ? e + zG(i, t, r, a) + t : e + i + t;
  }, "formatter"), zG = /* @__PURE__ */ s((e, t, r, n) => {
    let i = "", a = 0;
    do
      i += e.substring(a, n) + r, a = n + t.length, n = e.indexOf(t, a);
    while (~n);
    return i + e.substring(a);
  }, "replaceClose"), vT = /* @__PURE__ */ s((e = HG) => {
    let t = e ? YG : () => String;
    return {
      isColorSupported: e,
      reset: t("\x1B[0m", "\x1B[0m"),
      bold: t("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: t("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: t("\x1B[3m", "\x1B[23m"),
      underline: t("\x1B[4m", "\x1B[24m"),
      inverse: t("\x1B[7m", "\x1B[27m"),
      hidden: t("\x1B[8m", "\x1B[28m"),
      strikethrough: t("\x1B[9m", "\x1B[29m"),
      black: t("\x1B[30m", "\x1B[39m"),
      red: t("\x1B[31m", "\x1B[39m"),
      green: t("\x1B[32m", "\x1B[39m"),
      yellow: t("\x1B[33m", "\x1B[39m"),
      blue: t("\x1B[34m", "\x1B[39m"),
      magenta: t("\x1B[35m", "\x1B[39m"),
      cyan: t("\x1B[36m", "\x1B[39m"),
      white: t("\x1B[37m", "\x1B[39m"),
      gray: t("\x1B[90m", "\x1B[39m"),
      bgBlack: t("\x1B[40m", "\x1B[49m"),
      bgRed: t("\x1B[41m", "\x1B[49m"),
      bgGreen: t("\x1B[42m", "\x1B[49m"),
      bgYellow: t("\x1B[43m", "\x1B[49m"),
      bgBlue: t("\x1B[44m", "\x1B[49m"),
      bgMagenta: t("\x1B[45m", "\x1B[49m"),
      bgCyan: t("\x1B[46m", "\x1B[49m"),
      bgWhite: t("\x1B[47m", "\x1B[49m"),
      blackBright: t("\x1B[90m", "\x1B[39m"),
      redBright: t("\x1B[91m", "\x1B[39m"),
      greenBright: t("\x1B[92m", "\x1B[39m"),
      yellowBright: t("\x1B[93m", "\x1B[39m"),
      blueBright: t("\x1B[94m", "\x1B[39m"),
      magentaBright: t("\x1B[95m", "\x1B[39m"),
      cyanBright: t("\x1B[96m", "\x1B[39m"),
      whiteBright: t("\x1B[97m", "\x1B[39m"),
      bgBlackBright: t("\x1B[100m", "\x1B[49m"),
      bgRedBright: t("\x1B[101m", "\x1B[49m"),
      bgGreenBright: t("\x1B[102m", "\x1B[49m"),
      bgYellowBright: t("\x1B[103m", "\x1B[49m"),
      bgBlueBright: t("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: t("\x1B[105m", "\x1B[49m"),
      bgCyanBright: t("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: t("\x1B[107m", "\x1B[49m")
    };
  }, "createColors");
  Rh.exports = vT();
  Rh.exports.createColors = vT;
});

// ../node_modules/escape-string-regexp/index.js
var xT = T((MSe, TT) => {
  "use strict";
  var JG = /[|\\{}()[\]^$+*?.]/g;
  TT.exports = function(e) {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    return e.replace(JG, "\\$&");
  };
});

// ../node_modules/@babel/highlight/node_modules/color-name/index.js
var PT = T((RSe, ST) => {
  "use strict";
  ST.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/conversions.js
var Uh = T((qSe, DT) => {
  var Ms = PT(), wT = {};
  for (Hl in Ms)
    Ms.hasOwnProperty(Hl) && (wT[Ms[Hl]] = Hl);
  var Hl, Ee = DT.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (or in Ee)
    if (Ee.hasOwnProperty(or)) {
      if (!("channels" in Ee[or]))
        throw new Error("missing channels property: " + or);
      if (!("labels" in Ee[or]))
        throw new Error("missing channel labels property: " + or);
      if (Ee[or].labels.length !== Ee[or].channels)
        throw new Error("channel and label counts mismatch: " + or);
      AT = Ee[or].channels, CT = Ee[or].labels, delete Ee[or].channels, delete Ee[or].labels, Object.defineProperty(Ee[or], "channels", { value: AT }),
      Object.defineProperty(Ee[or], "labels", { value: CT });
    }
  var AT, CT, or;
  Ee.rgb.hsl = function(e) {
    var t = e[0] / 255, r = e[1] / 255, n = e[2] / 255, i = Math.min(t, r, n), a = Math.max(t, r, n), o = a - i, l, u, c;
    return a === i ? l = 0 : t === a ? l = (r - n) / o : r === a ? l = 2 + (n - t) / o : n === a && (l = 4 + (t - r) / o), l = Math.min(l * 60,
    360), l < 0 && (l += 360), c = (i + a) / 2, a === i ? u = 0 : c <= 0.5 ? u = o / (a + i) : u = o / (2 - a - i), [l, u * 100, c * 100];
  };
  Ee.rgb.hsv = function(e) {
    var t, r, n, i, a, o = e[0] / 255, l = e[1] / 255, u = e[2] / 255, c = Math.max(o, l, u), f = c - Math.min(o, l, u), p = /* @__PURE__ */ s(
    function(h) {
      return (c - h) / 6 / f + 1 / 2;
    }, "diffc");
    return f === 0 ? i = a = 0 : (a = f / c, t = p(o), r = p(l), n = p(u), o === c ? i = n - r : l === c ? i = 1 / 3 + t - n : u === c && (i =
    2 / 3 + r - t), i < 0 ? i += 1 : i > 1 && (i -= 1)), [
      i * 360,
      a * 100,
      c * 100
    ];
  };
  Ee.rgb.hwb = function(e) {
    var t = e[0], r = e[1], n = e[2], i = Ee.rgb.hsl(e)[0], a = 1 / 255 * Math.min(t, Math.min(r, n));
    return n = 1 - 1 / 255 * Math.max(t, Math.max(r, n)), [i, a * 100, n * 100];
  };
  Ee.rgb.cmyk = function(e) {
    var t = e[0] / 255, r = e[1] / 255, n = e[2] / 255, i, a, o, l;
    return l = Math.min(1 - t, 1 - r, 1 - n), i = (1 - t - l) / (1 - l) || 0, a = (1 - r - l) / (1 - l) || 0, o = (1 - n - l) / (1 - l) || 0,
    [i * 100, a * 100, o * 100, l * 100];
  };
  function XG(e, t) {
    return Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2) + Math.pow(e[2] - t[2], 2);
  }
  s(XG, "comparativeDistance");
  Ee.rgb.keyword = function(e) {
    var t = wT[e];
    if (t)
      return t;
    var r = 1 / 0, n;
    for (var i in Ms)
      if (Ms.hasOwnProperty(i)) {
        var a = Ms[i], o = XG(e, a);
        o < r && (r = o, n = i);
      }
    return n;
  };
  Ee.keyword.rgb = function(e) {
    return Ms[e];
  };
  Ee.rgb.xyz = function(e) {
    var t = e[0] / 255, r = e[1] / 255, n = e[2] / 255;
    t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92, r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, n = n >
    0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92;
    var i = t * 0.4124 + r * 0.3576 + n * 0.1805, a = t * 0.2126 + r * 0.7152 + n * 0.0722, o = t * 0.0193 + r * 0.1192 + n * 0.9505;
    return [i * 100, a * 100, o * 100];
  };
  Ee.rgb.lab = function(e) {
    var t = Ee.rgb.xyz(e), r = t[0], n = t[1], i = t[2], a, o, l;
    return r /= 95.047, n /= 100, i /= 108.883, r = r > 8856e-6 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, n = n > 8856e-6 ? Math.pow(n, 1 /
    3) : 7.787 * n + 16 / 116, i = i > 8856e-6 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, a = 116 * n - 16, o = 500 * (r - n), l = 200 * (n -
    i), [a, o, l];
  };
  Ee.hsl.rgb = function(e) {
    var t = e[0] / 360, r = e[1] / 100, n = e[2] / 100, i, a, o, l, u;
    if (r === 0)
      return u = n * 255, [u, u, u];
    n < 0.5 ? a = n * (1 + r) : a = n + r - n * r, i = 2 * n - a, l = [0, 0, 0];
    for (var c = 0; c < 3; c++)
      o = t + 1 / 3 * -(c - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? u = i + (a - i) * 6 * o : 2 * o < 1 ? u = a : 3 * o < 2 ? u = i + (a -
      i) * (2 / 3 - o) * 6 : u = i, l[c] = u * 255;
    return l;
  };
  Ee.hsl.hsv = function(e) {
    var t = e[0], r = e[1] / 100, n = e[2] / 100, i = r, a = Math.max(n, 0.01), o, l;
    return n *= 2, r *= n <= 1 ? n : 2 - n, i *= a <= 1 ? a : 2 - a, l = (n + r) / 2, o = n === 0 ? 2 * i / (a + i) : 2 * r / (n + r), [t, o *
    100, l * 100];
  };
  Ee.hsv.rgb = function(e) {
    var t = e[0] / 60, r = e[1] / 100, n = e[2] / 100, i = Math.floor(t) % 6, a = t - Math.floor(t), o = 255 * n * (1 - r), l = 255 * n * (1 -
    r * a), u = 255 * n * (1 - r * (1 - a));
    switch (n *= 255, i) {
      case 0:
        return [n, u, o];
      case 1:
        return [l, n, o];
      case 2:
        return [o, n, u];
      case 3:
        return [o, l, n];
      case 4:
        return [u, o, n];
      case 5:
        return [n, o, l];
    }
  };
  Ee.hsv.hsl = function(e) {
    var t = e[0], r = e[1] / 100, n = e[2] / 100, i = Math.max(n, 0.01), a, o, l;
    return l = (2 - r) * n, a = (2 - r) * i, o = r * i, o /= a <= 1 ? a : 2 - a, o = o || 0, l /= 2, [t, o * 100, l * 100];
  };
  Ee.hwb.rgb = function(e) {
    var t = e[0] / 360, r = e[1] / 100, n = e[2] / 100, i = r + n, a, o, l, u;
    i > 1 && (r /= i, n /= i), a = Math.floor(6 * t), o = 1 - n, l = 6 * t - a, a & 1 && (l = 1 - l), u = r + l * (o - r);
    var c, f, p;
    switch (a) {
      default:
      case 6:
      case 0:
        c = o, f = u, p = r;
        break;
      case 1:
        c = u, f = o, p = r;
        break;
      case 2:
        c = r, f = o, p = u;
        break;
      case 3:
        c = r, f = u, p = o;
        break;
      case 4:
        c = u, f = r, p = o;
        break;
      case 5:
        c = o, f = r, p = u;
        break;
    }
    return [c * 255, f * 255, p * 255];
  };
  Ee.cmyk.rgb = function(e) {
    var t = e[0] / 100, r = e[1] / 100, n = e[2] / 100, i = e[3] / 100, a, o, l;
    return a = 1 - Math.min(1, t * (1 - i) + i), o = 1 - Math.min(1, r * (1 - i) + i), l = 1 - Math.min(1, n * (1 - i) + i), [a * 255, o * 255,
    l * 255];
  };
  Ee.xyz.rgb = function(e) {
    var t = e[0] / 100, r = e[1] / 100, n = e[2] / 100, i, a, o;
    return i = t * 3.2406 + r * -1.5372 + n * -0.4986, a = t * -0.9689 + r * 1.8758 + n * 0.0415, o = t * 0.0557 + r * -0.204 + n * 1.057, i =
    i > 31308e-7 ? 1.055 * Math.pow(i, 1 / 2.4) - 0.055 : i * 12.92, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a * 12.92, o =
    o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o * 12.92, i = Math.min(Math.max(0, i), 1), a = Math.min(Math.max(0, a), 1), o = Math.
    min(Math.max(0, o), 1), [i * 255, a * 255, o * 255];
  };
  Ee.xyz.lab = function(e) {
    var t = e[0], r = e[1], n = e[2], i, a, o;
    return t /= 95.047, r /= 100, n /= 108.883, t = t > 8856e-6 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116, r = r > 8856e-6 ? Math.pow(r, 1 /
    3) : 7.787 * r + 16 / 116, n = n > 8856e-6 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, i = 116 * r - 16, a = 500 * (t - r), o = 200 * (r -
    n), [i, a, o];
  };
  Ee.lab.xyz = function(e) {
    var t = e[0], r = e[1], n = e[2], i, a, o;
    a = (t + 16) / 116, i = r / 500 + a, o = a - n / 200;
    var l = Math.pow(a, 3), u = Math.pow(i, 3), c = Math.pow(o, 3);
    return a = l > 8856e-6 ? l : (a - 16 / 116) / 7.787, i = u > 8856e-6 ? u : (i - 16 / 116) / 7.787, o = c > 8856e-6 ? c : (o - 16 / 116) /
    7.787, i *= 95.047, a *= 100, o *= 108.883, [i, a, o];
  };
  Ee.lab.lch = function(e) {
    var t = e[0], r = e[1], n = e[2], i, a, o;
    return i = Math.atan2(n, r), a = i * 360 / 2 / Math.PI, a < 0 && (a += 360), o = Math.sqrt(r * r + n * n), [t, o, a];
  };
  Ee.lch.lab = function(e) {
    var t = e[0], r = e[1], n = e[2], i, a, o;
    return o = n / 360 * 2 * Math.PI, i = r * Math.cos(o), a = r * Math.sin(o), [t, i, a];
  };
  Ee.rgb.ansi16 = function(e) {
    var t = e[0], r = e[1], n = e[2], i = 1 in arguments ? arguments[1] : Ee.rgb.hsv(e)[2];
    if (i = Math.round(i / 50), i === 0)
      return 30;
    var a = 30 + (Math.round(n / 255) << 2 | Math.round(r / 255) << 1 | Math.round(t / 255));
    return i === 2 && (a += 60), a;
  };
  Ee.hsv.ansi16 = function(e) {
    return Ee.rgb.ansi16(Ee.hsv.rgb(e), e[2]);
  };
  Ee.rgb.ansi256 = function(e) {
    var t = e[0], r = e[1], n = e[2];
    if (t === r && r === n)
      return t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232;
    var i = 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(n / 255 * 5);
    return i;
  };
  Ee.ansi16.rgb = function(e) {
    var t = e % 10;
    if (t === 0 || t === 7)
      return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
    var r = (~~(e > 50) + 1) * 0.5, n = (t & 1) * r * 255, i = (t >> 1 & 1) * r * 255, a = (t >> 2 & 1) * r * 255;
    return [n, i, a];
  };
  Ee.ansi256.rgb = function(e) {
    if (e >= 232) {
      var t = (e - 232) * 10 + 8;
      return [t, t, t];
    }
    e -= 16;
    var r, n = Math.floor(e / 36) / 5 * 255, i = Math.floor((r = e % 36) / 6) / 5 * 255, a = r % 6 / 5 * 255;
    return [n, i, a];
  };
  Ee.rgb.hex = function(e) {
    var t = ((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255), r = t.toString(16).toUpperCase();
    return "000000".substring(r.length) + r;
  };
  Ee.hex.rgb = function(e) {
    var t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!t)
      return [0, 0, 0];
    var r = t[0];
    t[0].length === 3 && (r = r.split("").map(function(l) {
      return l + l;
    }).join(""));
    var n = parseInt(r, 16), i = n >> 16 & 255, a = n >> 8 & 255, o = n & 255;
    return [i, a, o];
  };
  Ee.rgb.hcg = function(e) {
    var t = e[0] / 255, r = e[1] / 255, n = e[2] / 255, i = Math.max(Math.max(t, r), n), a = Math.min(Math.min(t, r), n), o = i - a, l, u;
    return o < 1 ? l = a / (1 - o) : l = 0, o <= 0 ? u = 0 : i === t ? u = (r - n) / o % 6 : i === r ? u = 2 + (n - t) / o : u = 4 + (t - r) /
    o + 4, u /= 6, u %= 1, [u * 360, o * 100, l * 100];
  };
  Ee.hsl.hcg = function(e) {
    var t = e[1] / 100, r = e[2] / 100, n = 1, i = 0;
    return r < 0.5 ? n = 2 * t * r : n = 2 * t * (1 - r), n < 1 && (i = (r - 0.5 * n) / (1 - n)), [e[0], n * 100, i * 100];
  };
  Ee.hsv.hcg = function(e) {
    var t = e[1] / 100, r = e[2] / 100, n = t * r, i = 0;
    return n < 1 && (i = (r - n) / (1 - n)), [e[0], n * 100, i * 100];
  };
  Ee.hcg.rgb = function(e) {
    var t = e[0] / 360, r = e[1] / 100, n = e[2] / 100;
    if (r === 0)
      return [n * 255, n * 255, n * 255];
    var i = [0, 0, 0], a = t % 1 * 6, o = a % 1, l = 1 - o, u = 0;
    switch (Math.floor(a)) {
      case 0:
        i[0] = 1, i[1] = o, i[2] = 0;
        break;
      case 1:
        i[0] = l, i[1] = 1, i[2] = 0;
        break;
      case 2:
        i[0] = 0, i[1] = 1, i[2] = o;
        break;
      case 3:
        i[0] = 0, i[1] = l, i[2] = 1;
        break;
      case 4:
        i[0] = o, i[1] = 0, i[2] = 1;
        break;
      default:
        i[0] = 1, i[1] = 0, i[2] = l;
    }
    return u = (1 - r) * n, [
      (r * i[0] + u) * 255,
      (r * i[1] + u) * 255,
      (r * i[2] + u) * 255
    ];
  };
  Ee.hcg.hsv = function(e) {
    var t = e[1] / 100, r = e[2] / 100, n = t + r * (1 - t), i = 0;
    return n > 0 && (i = t / n), [e[0], i * 100, n * 100];
  };
  Ee.hcg.hsl = function(e) {
    var t = e[1] / 100, r = e[2] / 100, n = r * (1 - t) + 0.5 * t, i = 0;
    return n > 0 && n < 0.5 ? i = t / (2 * n) : n >= 0.5 && n < 1 && (i = t / (2 * (1 - n))), [e[0], i * 100, n * 100];
  };
  Ee.hcg.hwb = function(e) {
    var t = e[1] / 100, r = e[2] / 100, n = t + r * (1 - t);
    return [e[0], (n - t) * 100, (1 - n) * 100];
  };
  Ee.hwb.hcg = function(e) {
    var t = e[1] / 100, r = e[2] / 100, n = 1 - r, i = n - t, a = 0;
    return i < 1 && (a = (n - i) / (1 - i)), [e[0], i * 100, a * 100];
  };
  Ee.apple.rgb = function(e) {
    return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
  };
  Ee.rgb.apple = function(e) {
    return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
  };
  Ee.gray.rgb = function(e) {
    return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
  };
  Ee.gray.hsl = Ee.gray.hsv = function(e) {
    return [0, 0, e[0]];
  };
  Ee.gray.hwb = function(e) {
    return [0, 100, e[0]];
  };
  Ee.gray.cmyk = function(e) {
    return [0, 0, 0, e[0]];
  };
  Ee.gray.lab = function(e) {
    return [e[0], 0, 0];
  };
  Ee.gray.hex = function(e) {
    var t = Math.round(e[0] / 100 * 255) & 255, r = (t << 16) + (t << 8) + t, n = r.toString(16).toUpperCase();
    return "000000".substring(n.length) + n;
  };
  Ee.rgb.gray = function(e) {
    var t = (e[0] + e[1] + e[2]) / 3;
    return [t / 255 * 100];
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/route.js
var _T = T((VSe, IT) => {
  var Yl = Uh();
  function QG() {
    for (var e = {}, t = Object.keys(Yl), r = t.length, n = 0; n < r; n++)
      e[t[n]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return e;
  }
  s(QG, "buildGraph");
  function ZG(e) {
    var t = QG(), r = [e];
    for (t[e].distance = 0; r.length; )
      for (var n = r.pop(), i = Object.keys(Yl[n]), a = i.length, o = 0; o < a; o++) {
        var l = i[o], u = t[l];
        u.distance === -1 && (u.distance = t[n].distance + 1, u.parent = n, r.unshift(l));
      }
    return t;
  }
  s(ZG, "deriveBFS");
  function eH(e, t) {
    return function(r) {
      return t(e(r));
    };
  }
  s(eH, "link");
  function tH(e, t) {
    for (var r = [t[e].parent, e], n = Yl[t[e].parent][e], i = t[e].parent; t[i].parent; )
      r.unshift(t[i].parent), n = eH(Yl[t[i].parent][i], n), i = t[i].parent;
    return n.conversion = r, n;
  }
  s(tH, "wrapConversion");
  IT.exports = function(e) {
    for (var t = ZG(e), r = {}, n = Object.keys(t), i = n.length, a = 0; a < i; a++) {
      var o = n[a], l = t[o];
      l.parent !== null && (r[o] = tH(o, t));
    }
    return r;
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/index.js
var NT = T((WSe, OT) => {
  var Vh = Uh(), rH = _T(), Di = {}, nH = Object.keys(Vh);
  function sH(e) {
    var t = /* @__PURE__ */ s(function(r) {
      return r == null ? r : (arguments.length > 1 && (r = Array.prototype.slice.call(arguments)), e(r));
    }, "wrappedFn");
    return "conversion" in e && (t.conversion = e.conversion), t;
  }
  s(sH, "wrapRaw");
  function iH(e) {
    var t = /* @__PURE__ */ s(function(r) {
      if (r == null)
        return r;
      arguments.length > 1 && (r = Array.prototype.slice.call(arguments));
      var n = e(r);
      if (typeof n == "object")
        for (var i = n.length, a = 0; a < i; a++)
          n[a] = Math.round(n[a]);
      return n;
    }, "wrappedFn");
    return "conversion" in e && (t.conversion = e.conversion), t;
  }
  s(iH, "wrapRounded");
  nH.forEach(function(e) {
    Di[e] = {}, Object.defineProperty(Di[e], "channels", { value: Vh[e].channels }), Object.defineProperty(Di[e], "labels", { value: Vh[e].labels });
    var t = rH(e), r = Object.keys(t);
    r.forEach(function(n) {
      var i = t[n];
      Di[e][n] = iH(i), Di[e][n].raw = sH(i);
    });
  });
  OT.exports = Di;
});

// ../node_modules/@babel/highlight/node_modules/ansi-styles/index.js
var kT = T((GSe, BT) => {
  "use strict";
  var Ii = NT(), zl = /* @__PURE__ */ s((e, t) => function() {
    return `\x1B[${e.apply(Ii, arguments) + t}m`;
  }, "wrapAnsi16"), Jl = /* @__PURE__ */ s((e, t) => function() {
    let r = e.apply(Ii, arguments);
    return `\x1B[${38 + t};5;${r}m`;
  }, "wrapAnsi256"), Xl = /* @__PURE__ */ s((e, t) => function() {
    let r = e.apply(Ii, arguments);
    return `\x1B[${38 + t};2;${r[0]};${r[1]};${r[2]}m`;
  }, "wrapAnsi16m");
  function aH() {
    let e = /* @__PURE__ */ new Map(), t = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        // Bright color
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    t.color.grey = t.color.gray;
    for (let i of Object.keys(t)) {
      let a = t[i];
      for (let o of Object.keys(a)) {
        let l = a[o];
        t[o] = {
          open: `\x1B[${l[0]}m`,
          close: `\x1B[${l[1]}m`
        }, a[o] = t[o], e.set(l[0], l[1]);
      }
      Object.defineProperty(t, i, {
        value: a,
        enumerable: !1
      }), Object.defineProperty(t, "codes", {
        value: e,
        enumerable: !1
      });
    }
    let r = /* @__PURE__ */ s((i) => i, "ansi2ansi"), n = /* @__PURE__ */ s((i, a, o) => [i, a, o], "rgb2rgb");
    t.color.close = "\x1B[39m", t.bgColor.close = "\x1B[49m", t.color.ansi = {
      ansi: zl(r, 0)
    }, t.color.ansi256 = {
      ansi256: Jl(r, 0)
    }, t.color.ansi16m = {
      rgb: Xl(n, 0)
    }, t.bgColor.ansi = {
      ansi: zl(r, 10)
    }, t.bgColor.ansi256 = {
      ansi256: Jl(r, 10)
    }, t.bgColor.ansi16m = {
      rgb: Xl(n, 10)
    };
    for (let i of Object.keys(Ii)) {
      if (typeof Ii[i] != "object")
        continue;
      let a = Ii[i];
      i === "ansi16" && (i = "ansi"), "ansi16" in a && (t.color.ansi[i] = zl(a.ansi16, 0), t.bgColor.ansi[i] = zl(a.ansi16, 10)), "ansi256" in
      a && (t.color.ansi256[i] = Jl(a.ansi256, 0), t.bgColor.ansi256[i] = Jl(a.ansi256, 10)), "rgb" in a && (t.color.ansi16m[i] = Xl(a.rgb, 0),
      t.bgColor.ansi16m[i] = Xl(a.rgb, 10));
    }
    return t;
  }
  s(aH, "assembleStyles");
  Object.defineProperty(BT, "exports", {
    enumerable: !0,
    get: aH
  });
});

// ../node_modules/@babel/highlight/node_modules/has-flag/index.js
var jT = T((YSe, FT) => {
  "use strict";
  FT.exports = (e, t) => {
    t = t || process.argv;
    let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t.indexOf(r + e), i = t.indexOf("--");
    return n !== -1 && (i === -1 ? !0 : n < i);
  };
});

// ../node_modules/@babel/highlight/node_modules/supports-color/index.js
var MT = T((zSe, LT) => {
  "use strict";
  var oH = ie("os"), Kr = jT(), Yt = process.env, _i;
  Kr("no-color") || Kr("no-colors") || Kr("color=false") ? _i = !1 : (Kr("color") || Kr("colors") || Kr("color=true") || Kr("color=always")) &&
  (_i = !0);
  "FORCE_COLOR" in Yt && (_i = Yt.FORCE_COLOR.length === 0 || parseInt(Yt.FORCE_COLOR, 10) !== 0);
  function lH(e) {
    return e === 0 ? !1 : {
      level: e,
      hasBasic: !0,
      has256: e >= 2,
      has16m: e >= 3
    };
  }
  s(lH, "translateLevel");
  function uH(e) {
    if (_i === !1)
      return 0;
    if (Kr("color=16m") || Kr("color=full") || Kr("color=truecolor"))
      return 3;
    if (Kr("color=256"))
      return 2;
    if (e && !e.isTTY && _i !== !0)
      return 0;
    let t = _i ? 1 : 0;
    if (process.platform === "win32") {
      let r = oH.release().split(".");
      return Number(process.versions.node.split(".")[0]) >= 8 && Number(r[0]) >= 10 && Number(r[2]) >= 10586 ? Number(r[2]) >= 14931 ? 3 : 2 :
      1;
    }
    if ("CI" in Yt)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((r) => r in Yt) || Yt.CI_NAME === "codeship" ? 1 : t;
    if ("TEAMCITY_VERSION" in Yt)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Yt.TEAMCITY_VERSION) ? 1 : 0;
    if (Yt.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in Yt) {
      let r = parseInt((Yt.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (Yt.TERM_PROGRAM) {
        case "iTerm.app":
          return r >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(Yt.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Yt.TERM) || "COLORTERM" in
    Yt ? 1 : (Yt.TERM === "dumb", t);
  }
  s(uH, "supportsColor");
  function $h(e) {
    let t = uH(e);
    return lH(t);
  }
  s($h, "getSupportLevel");
  LT.exports = {
    supportsColor: $h,
    stdout: $h(process.stdout),
    stderr: $h(process.stderr)
  };
});

// ../node_modules/@babel/highlight/node_modules/chalk/templates.js
var $T = T((XSe, VT) => {
  "use strict";
  var cH = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,
  RT = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, fH = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, pH = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, dH = /* @__PURE__ */ new Map(
  [
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function UT(e) {
    return e[0] === "u" && e.length === 5 || e[0] === "x" && e.length === 3 ? String.fromCharCode(parseInt(e.slice(1), 16)) : dH.get(e) || e;
  }
  s(UT, "unescape");
  function hH(e, t) {
    let r = [], n = t.trim().split(/\s*,\s*/g), i;
    for (let a of n)
      if (!isNaN(a))
        r.push(Number(a));
      else if (i = a.match(fH))
        r.push(i[2].replace(pH, (o, l, u) => l ? UT(l) : u));
      else
        throw new Error(`Invalid Chalk template style argument: ${a} (in style '${e}')`);
    return r;
  }
  s(hH, "parseArguments");
  function mH(e) {
    RT.lastIndex = 0;
    let t = [], r;
    for (; (r = RT.exec(e)) !== null; ) {
      let n = r[1];
      if (r[2]) {
        let i = hH(n, r[2]);
        t.push([n].concat(i));
      } else
        t.push([n]);
    }
    return t;
  }
  s(mH, "parseStyle");
  function qT(e, t) {
    let r = {};
    for (let i of t)
      for (let a of i.styles)
        r[a[0]] = i.inverse ? null : a.slice(1);
    let n = e;
    for (let i of Object.keys(r))
      if (Array.isArray(r[i])) {
        if (!(i in n))
          throw new Error(`Unknown Chalk style: ${i}`);
        r[i].length > 0 ? n = n[i].apply(n, r[i]) : n = n[i];
      }
    return n;
  }
  s(qT, "buildStyle");
  VT.exports = (e, t) => {
    let r = [], n = [], i = [];
    if (t.replace(cH, (a, o, l, u, c, f) => {
      if (o)
        i.push(UT(o));
      else if (u) {
        let p = i.join("");
        i = [], n.push(r.length === 0 ? p : qT(e, r)(p)), r.push({ inverse: l, styles: mH(u) });
      } else if (c) {
        if (r.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        n.push(qT(e, r)(i.join(""))), i = [], r.pop();
      } else
        i.push(f);
    }), n.push(i.join("")), r.length > 0) {
      let a = `Chalk template literal is missing ${r.length} closing bracket${r.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(a);
    }
    return n.join("");
  };
});

// ../node_modules/@babel/highlight/node_modules/chalk/index.js
var YT = T((ZSe, Za) => {
  "use strict";
  var Kh = xT(), It = kT(), Wh = MT().stdout, yH = $T(), KT = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith(
  "xterm"), GT = ["ansi", "ansi", "ansi256", "ansi16m"], HT = /* @__PURE__ */ new Set(["gray"]), Oi = /* @__PURE__ */ Object.create(null);
  function WT(e, t) {
    t = t || {};
    let r = Wh ? Wh.level : 0;
    e.level = t.level === void 0 ? r : t.level, e.enabled = "enabled" in t ? t.enabled : e.level > 0;
  }
  s(WT, "applyOptions");
  function Qa(e) {
    if (!this || !(this instanceof Qa) || this.template) {
      let t = {};
      return WT(t, e), t.template = function() {
        let r = [].slice.call(arguments);
        return EH.apply(null, [t.template].concat(r));
      }, Object.setPrototypeOf(t, Qa.prototype), Object.setPrototypeOf(t.template, t), t.template.constructor = Qa, t.template;
    }
    WT(this, e);
  }
  s(Qa, "Chalk");
  KT && (It.blue.open = "\x1B[94m");
  for (let e of Object.keys(It))
    It[e].closeRe = new RegExp(Kh(It[e].close), "g"), Oi[e] = {
      get() {
        let t = It[e];
        return Ql.call(this, this._styles ? this._styles.concat(t) : [t], this._empty, e);
      }
    };
  Oi.visible = {
    get() {
      return Ql.call(this, this._styles || [], !0, "visible");
    }
  };
  It.color.closeRe = new RegExp(Kh(It.color.close), "g");
  for (let e of Object.keys(It.color.ansi))
    HT.has(e) || (Oi[e] = {
      get() {
        let t = this.level;
        return function() {
          let n = {
            open: It.color[GT[t]][e].apply(null, arguments),
            close: It.color.close,
            closeRe: It.color.closeRe
          };
          return Ql.call(this, this._styles ? this._styles.concat(n) : [n], this._empty, e);
        };
      }
    });
  It.bgColor.closeRe = new RegExp(Kh(It.bgColor.close), "g");
  for (let e of Object.keys(It.bgColor.ansi)) {
    if (HT.has(e))
      continue;
    let t = "bg" + e[0].toUpperCase() + e.slice(1);
    Oi[t] = {
      get() {
        let r = this.level;
        return function() {
          let i = {
            open: It.bgColor[GT[r]][e].apply(null, arguments),
            close: It.bgColor.close,
            closeRe: It.bgColor.closeRe
          };
          return Ql.call(this, this._styles ? this._styles.concat(i) : [i], this._empty, e);
        };
      }
    };
  }
  var gH = Object.defineProperties(() => {
  }, Oi);
  function Ql(e, t, r) {
    let n = /* @__PURE__ */ s(function() {
      return bH.apply(n, arguments);
    }, "builder");
    n._styles = e, n._empty = t;
    let i = this;
    return Object.defineProperty(n, "level", {
      enumerable: !0,
      get() {
        return i.level;
      },
      set(a) {
        i.level = a;
      }
    }), Object.defineProperty(n, "enabled", {
      enumerable: !0,
      get() {
        return i.enabled;
      },
      set(a) {
        i.enabled = a;
      }
    }), n.hasGrey = this.hasGrey || r === "gray" || r === "grey", n.__proto__ = gH, n;
  }
  s(Ql, "build");
  function bH() {
    let e = arguments, t = e.length, r = String(arguments[0]);
    if (t === 0)
      return "";
    if (t > 1)
      for (let i = 1; i < t; i++)
        r += " " + e[i];
    if (!this.enabled || this.level <= 0 || !r)
      return this._empty ? "" : r;
    let n = It.dim.open;
    KT && this.hasGrey && (It.dim.open = "");
    for (let i of this._styles.slice().reverse())
      r = i.open + r.replace(i.closeRe, i.open) + i.close, r = r.replace(/\r?\n/g, `${i.close}$&${i.open}`);
    return It.dim.open = n, r;
  }
  s(bH, "applyStyle");
  function EH(e, t) {
    if (!Array.isArray(t))
      return [].slice.call(arguments, 1).join(" ");
    let r = [].slice.call(arguments, 2), n = [t.raw[0]];
    for (let i = 1; i < t.length; i++)
      n.push(String(r[i - 1]).replace(/[{}\\]/g, "\\$&")), n.push(String(t.raw[i]));
    return yH(e, n.join(""));
  }
  s(EH, "chalkTag");
  Object.defineProperties(Qa.prototype, Oi);
  Za.exports = Qa();
  Za.exports.supportsColor = Wh;
  Za.exports.default = Za.exports;
});

// ../node_modules/@babel/highlight/lib/index.js
var rx = T((eo) => {
  "use strict";
  Object.defineProperty(eo, "__esModule", {
    value: !0
  });
  eo.default = wH;
  eo.shouldHighlight = tx;
  var zT = bT(), JT = gi(), Hh = vH(qh(), !0);
  function QT(e) {
    if (typeof WeakMap != "function") return null;
    var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (QT = /* @__PURE__ */ s(function(n) {
      return n ? r : t;
    }, "_getRequireWildcardCache"))(e);
  }
  s(QT, "_getRequireWildcardCache");
  function vH(e, t) {
    if (!t && e && e.__esModule) return e;
    if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
    var r = QT(t);
    if (r && r.has(e)) return r.get(e);
    var n = { __proto__: null }, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in e) if (a !== "default" && {}.hasOwnProperty.call(e, a)) {
      var o = i ? Object.getOwnPropertyDescriptor(e, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(n, a, o) : n[a] = e[a];
    }
    return n.default = e, r && r.set(e, n), n;
  }
  s(vH, "_interopRequireWildcard");
  var ZT = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, Hh.createColors)(!1) :
  Hh.default, XT = /* @__PURE__ */ s((e, t) => (r) => e(t(r)), "compose"), TH = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of",
  "set"]);
  function xH(e) {
    return {
      keyword: e.cyan,
      capitalized: e.yellow,
      jsxIdentifier: e.yellow,
      punctuator: e.yellow,
      number: e.magenta,
      string: e.green,
      regex: e.magenta,
      comment: e.gray,
      invalid: XT(XT(e.white, e.bgRed), e.bold)
    };
  }
  s(xH, "getDefs");
  var SH = /\r\n|[\n\r\u2028\u2029]/, PH = /^[()[\]{}]$/, ex;
  {
    let e = /^[a-z][\w-]*$/i, t = /* @__PURE__ */ s(function(r, n, i) {
      if (r.type === "name") {
        if ((0, JT.isKeyword)(r.value) || (0, JT.isStrictReservedWord)(r.value, !0) || TH.has(r.value))
          return "keyword";
        if (e.test(r.value) && (i[n - 1] === "<" || i.slice(n - 2, n) === "</"))
          return "jsxIdentifier";
        if (r.value[0] !== r.value[0].toLowerCase())
          return "capitalized";
      }
      return r.type === "punctuator" && PH.test(r.value) ? "bracket" : r.type === "invalid" && (r.value === "@" || r.value === "#") ? "punct\
uator" : r.type;
    }, "getTokenType");
    ex = /* @__PURE__ */ s(function* (r) {
      let n;
      for (; n = zT.default.exec(r); ) {
        let i = zT.matchToToken(n);
        yield {
          type: t(i, n.index, r),
          value: i.value
        };
      }
    }, "tokenize");
  }
  function AH(e, t) {
    let r = "";
    for (let {
      type: n,
      value: i
    } of ex(t)) {
      let a = e[n];
      a ? r += i.split(SH).map((o) => a(o)).join(`
`) : r += i;
    }
    return r;
  }
  s(AH, "highlightTokens");
  function tx(e) {
    return ZT.isColorSupported || e.forceColor;
  }
  s(tx, "shouldHighlight");
  var Gh;
  function CH(e) {
    if (e) {
      var t;
      return (t = Gh) != null || (Gh = (0, Hh.createColors)(!0)), Gh;
    }
    return ZT;
  }
  s(CH, "getColors");
  function wH(e, t = {}) {
    if (e !== "" && tx(t)) {
      let r = xH(CH(t.forceColor));
      return AH(r, e);
    } else
      return e;
  }
  s(wH, "highlight");
  {
    let e, t;
    eo.getChalk = ({
      forceColor: r
    }) => {
      var n;
      if ((n = e) != null || (e = YT()), r) {
        var i;
        return (i = t) != null || (t = new e.constructor({
          enabled: !0,
          level: 1
        })), t;
      }
      return e;
    };
  }
});

// ../node_modules/@babel/code-frame/lib/index.js
var to = T((Zl) => {
  "use strict";
  Object.defineProperty(Zl, "__esModule", {
    value: !0
  });
  Zl.codeFrameColumns = lx;
  Zl.default = BH;
  var nx = rx(), zh = DH(qh(), !0);
  function ox(e) {
    if (typeof WeakMap != "function") return null;
    var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (ox = /* @__PURE__ */ s(function(n) {
      return n ? r : t;
    }, "_getRequireWildcardCache"))(e);
  }
  s(ox, "_getRequireWildcardCache");
  function DH(e, t) {
    if (!t && e && e.__esModule) return e;
    if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
    var r = ox(t);
    if (r && r.has(e)) return r.get(e);
    var n = { __proto__: null }, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in e) if (a !== "default" && {}.hasOwnProperty.call(e, a)) {
      var o = i ? Object.getOwnPropertyDescriptor(e, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(n, a, o) : n[a] = e[a];
    }
    return n.default = e, r && r.set(e, n), n;
  }
  s(DH, "_interopRequireWildcard");
  var IH = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, zh.createColors)(!1) :
  zh.default, sx = /* @__PURE__ */ s((e, t) => (r) => e(t(r)), "compose"), Yh;
  function _H(e) {
    if (e) {
      var t;
      return (t = Yh) != null || (Yh = (0, zh.createColors)(!0)), Yh;
    }
    return IH;
  }
  s(_H, "getColors");
  var ix = !1;
  function OH(e) {
    return {
      gutter: e.gray,
      marker: sx(e.red, e.bold),
      message: sx(e.red, e.bold)
    };
  }
  s(OH, "getDefs");
  var ax = /\r\n|[\n\r\u2028\u2029]/;
  function NH(e, t, r) {
    let n = Object.assign({
      column: 0,
      line: -1
    }, e.start), i = Object.assign({}, n, e.end), {
      linesAbove: a = 2,
      linesBelow: o = 3
    } = r || {}, l = n.line, u = n.column, c = i.line, f = i.column, p = Math.max(l - (a + 1), 0), h = Math.min(t.length, c + o);
    l === -1 && (p = 0), c === -1 && (h = t.length);
    let y = c - l, v = {};
    if (y)
      for (let d = 0; d <= y; d++) {
        let b = d + l;
        if (!u)
          v[b] = !0;
        else if (d === 0) {
          let E = t[b - 1].length;
          v[b] = [u, E - u + 1];
        } else if (d === y)
          v[b] = [0, f];
        else {
          let E = t[b - d].length;
          v[b] = [0, E];
        }
      }
    else
      u === f ? u ? v[l] = [u, 0] : v[l] = !0 : v[l] = [u, f - u];
    return {
      start: p,
      end: h,
      markerLines: v
    };
  }
  s(NH, "getMarkerLines");
  function lx(e, t, r = {}) {
    let n = (r.highlightCode || r.forceColor) && (0, nx.shouldHighlight)(r), i = _H(r.forceColor), a = OH(i), o = /* @__PURE__ */ s((d, b) => n ?
    d(b) : b, "maybeHighlight"), l = e.split(ax), {
      start: u,
      end: c,
      markerLines: f
    } = NH(t, l, r), p = t.start && typeof t.start.column == "number", h = String(c).length, v = (n ? (0, nx.default)(e, r) : e).split(ax, c).
    slice(u, c).map((d, b) => {
      let E = u + 1 + b, O = ` ${` ${E}`.slice(-h)} |`, k = f[E], j = !f[E + 1];
      if (k) {
        let R = "";
        if (Array.isArray(k)) {
          let U = d.slice(0, Math.max(k[0] - 1, 0)).replace(/[^\t]/g, " "), Q = k[1] || 1;
          R = [`
 `, o(a.gutter, O.replace(/\d/g, " ")), " ", U, o(a.marker, "^").repeat(Q)].join(""), j && r.message && (R += " " + o(a.message, r.message));
        }
        return [o(a.marker, ">"), o(a.gutter, O), d.length > 0 ? ` ${d}` : "", R].join("");
      } else
        return ` ${o(a.gutter, O)}${d.length > 0 ? ` ${d}` : ""}`;
    }).join(`
`);
    return r.message && !p && (v = `${" ".repeat(h + 1)}${r.message}
${v}`), n ? i.reset(v) : v;
  }
  s(lx, "codeFrameColumns");
  function BH(e, t, r, n = {}) {
    if (!ix) {
      ix = !0;
      let a = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning)
        process.emitWarning(a, "DeprecationWarning");
      else {
        let o = new Error(a);
        o.name = "DeprecationWarning", console.warn(new Error(a));
      }
    }
    return r = Math.max(r, 0), lx(e, {
      start: {
        column: r,
        line: t
      }
    }, n);
  }
  s(BH, "_default");
});

// ../node_modules/@babel/template/lib/parse.js
var Xh = T((Jh) => {
  "use strict";
  Object.defineProperty(Jh, "__esModule", {
    value: !0
  });
  Jh.default = HH;
  var kH = Pe(), FH = Ls(), jH = to(), {
    isCallExpression: LH,
    isExpressionStatement: MH,
    isFunction: RH,
    isIdentifier: qH,
    isJSXIdentifier: UH,
    isNewExpression: VH,
    isPlaceholder: eu,
    isStatement: $H,
    isStringLiteral: ux,
    removePropertiesDeep: WH,
    traverse: KH
  } = kH, GH = /^[_$A-Z0-9]+$/;
  function HH(e, t, r) {
    let {
      placeholderWhitelist: n,
      placeholderPattern: i,
      preserveComments: a,
      syntacticPlaceholders: o
    } = r, l = JH(t, r.parser, o);
    WH(l, {
      preserveComments: a
    }), e.validate(l);
    let u = {
      syntactic: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      legacy: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      placeholderWhitelist: n,
      placeholderPattern: i,
      syntacticPlaceholders: o
    };
    return KH(l, YH, u), Object.assign({
      ast: l
    }, u.syntactic.placeholders.length ? u.syntactic : u.legacy);
  }
  s(HH, "parseAndBuildMetadata");
  function YH(e, t, r) {
    var n;
    let i, a = r.syntactic.placeholders.length > 0;
    if (eu(e)) {
      if (r.syntacticPlaceholders === !1)
        throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      i = e.name.name, a = !0;
    } else {
      if (a || r.syntacticPlaceholders)
        return;
      if (qH(e) || UH(e))
        i = e.name;
      else if (ux(e))
        i = e.value;
      else
        return;
    }
    if (a && (r.placeholderPattern != null || r.placeholderWhitelist != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    if (!a && (r.placeholderPattern === !1 || !(r.placeholderPattern || GH).test(i)) && !((n = r.placeholderWhitelist) != null && n.has(i)))
      return;
    t = t.slice();
    let {
      node: o,
      key: l
    } = t[t.length - 1], u;
    ux(e) || eu(e, {
      expectedNode: "StringLiteral"
    }) ? u = "string" : VH(o) && l === "arguments" || LH(o) && l === "arguments" || RH(o) && l === "params" ? u = "param" : MH(o) && !eu(e) ?
    (u = "statement", t = t.slice(0, -1)) : $H(e) && eu(e) ? u = "statement" : u = "other";
    let {
      placeholders: c,
      placeholderNames: f
    } = a ? r.syntactic : r.legacy;
    c.push({
      name: i,
      type: u,
      resolve: /* @__PURE__ */ s((p) => zH(p, t), "resolve"),
      isDuplicate: f.has(i)
    }), f.add(i);
  }
  s(YH, "placeholderVisitorHandler");
  function zH(e, t) {
    let r = e;
    for (let a = 0; a < t.length - 1; a++) {
      let {
        key: o,
        index: l
      } = t[a];
      l === void 0 ? r = r[o] : r = r[o][l];
    }
    let {
      key: n,
      index: i
    } = t[t.length - 1];
    return {
      parent: r,
      key: n,
      index: i
    };
  }
  s(zH, "resolveAncestors");
  function JH(e, t, r) {
    let n = (t.plugins || []).slice();
    r !== !1 && n.push("placeholders"), t = Object.assign({
      allowReturnOutsideFunction: !0,
      allowSuperOutsideMethod: !0,
      sourceType: "module"
    }, t, {
      plugins: n
    });
    try {
      return (0, FH.parse)(e, t);
    } catch (i) {
      let a = i.loc;
      throw a && (i.message += `
` + (0, jH.codeFrameColumns)(e, {
        start: a
      }), i.code = "BABEL_TEMPLATE_PARSE_ERROR"), i;
    }
  }
  s(JH, "parseWithCodeFrame");
});

// ../node_modules/@babel/template/lib/populate.js
var tm = T((em) => {
  "use strict";
  Object.defineProperty(em, "__esModule", {
    value: !0
  });
  em.default = rY;
  var XH = Pe(), {
    blockStatement: QH,
    cloneNode: Zh,
    emptyStatement: ZH,
    expressionStatement: Qh,
    identifier: tu,
    isStatement: cx,
    isStringLiteral: eY,
    stringLiteral: tY,
    validate: fx
  } = XH;
  function rY(e, t) {
    let r = Zh(e.ast);
    return t && (e.placeholders.forEach((n) => {
      if (!hasOwnProperty.call(t, n.name)) {
        let i = n.name;
        throw new Error(`Error: No substitution given for "${i}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${i}'])}
            - { placeholderPattern: /^${i}$/ }`);
      }
    }), Object.keys(t).forEach((n) => {
      if (!e.placeholderNames.has(n))
        throw new Error(`Unknown substitution "${n}" given`);
    })), e.placeholders.slice().reverse().forEach((n) => {
      try {
        nY(n, r, t && t[n.name] || null);
      } catch (i) {
        throw i.message = `@babel/template placeholder "${n.name}": ${i.message}`, i;
      }
    }), r;
  }
  s(rY, "populatePlaceholders");
  function nY(e, t, r) {
    e.isDuplicate && (Array.isArray(r) ? r = r.map((l) => Zh(l)) : typeof r == "object" && (r = Zh(r)));
    let {
      parent: n,
      key: i,
      index: a
    } = e.resolve(t);
    if (e.type === "string") {
      if (typeof r == "string" && (r = tY(r)), !r || !eY(r))
        throw new Error("Expected string substitution");
    } else if (e.type === "statement")
      a === void 0 ? r ? Array.isArray(r) ? r = QH(r) : typeof r == "string" ? r = Qh(tu(r)) : cx(r) || (r = Qh(r)) : r = ZH() : r && !Array.
      isArray(r) && (typeof r == "string" && (r = tu(r)), cx(r) || (r = Qh(r)));
    else if (e.type === "param") {
      if (typeof r == "string" && (r = tu(r)), a === void 0) throw new Error("Assertion failure.");
    } else if (typeof r == "string" && (r = tu(r)), Array.isArray(r))
      throw new Error("Cannot replace single expression with an array.");
    function o(l, u, c) {
      let f = l[u];
      l[u] = c, f.type === "Identifier" && (f.typeAnnotation && (c.typeAnnotation = f.typeAnnotation), f.optional && (c.optional = f.optional),
      f.decorators && (c.decorators = f.decorators));
    }
    if (s(o, "set"), a === void 0)
      fx(n, i, r), o(n, i, r);
    else {
      let l = n[i].slice();
      e.type === "statement" || e.type === "param" ? r == null ? l.splice(a, 1) : Array.isArray(r) ? l.splice(a, 1, ...r) : o(l, a, r) : o(l,
      a, r), fx(n, i, l), n[i] = l;
    }
  }
  s(nY, "applyReplacement");
});

// ../node_modules/@babel/template/lib/string.js
var px = T((rm) => {
  "use strict";
  Object.defineProperty(rm, "__esModule", {
    value: !0
  });
  rm.default = oY;
  var sY = Fl(), iY = Xh(), aY = tm();
  function oY(e, t, r) {
    t = e.code(t);
    let n;
    return (i) => {
      let a = (0, sY.normalizeReplacements)(i);
      return n || (n = (0, iY.default)(e, t, r)), e.unwrap((0, aY.default)(n, a));
    };
  }
  s(oY, "stringTemplate");
});

// ../node_modules/@babel/template/lib/literal.js
var dx = T((nm) => {
  "use strict";
  Object.defineProperty(nm, "__esModule", {
    value: !0
  });
  nm.default = fY;
  var lY = Fl(), uY = Xh(), cY = tm();
  function fY(e, t, r) {
    let {
      metadata: n,
      names: i
    } = pY(e, t, r);
    return (a) => {
      let o = {};
      return a.forEach((l, u) => {
        o[i[u]] = l;
      }), (l) => {
        let u = (0, lY.normalizeReplacements)(l);
        return u && Object.keys(u).forEach((c) => {
          if (hasOwnProperty.call(o, c))
            throw new Error("Unexpected replacement overlap.");
        }), e.unwrap((0, cY.default)(n, u ? Object.assign(u, o) : o));
      };
    };
  }
  s(fY, "literalTemplate");
  function pY(e, t, r) {
    let n = "BABEL_TPL$", i = t.join("");
    do
      n = "$$" + n;
    while (i.includes(n));
    let {
      names: a,
      code: o
    } = dY(t, n);
    return {
      metadata: (0, uY.default)(e, e.code(o), {
        parser: r.parser,
        placeholderWhitelist: new Set(a.concat(r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [])),
        placeholderPattern: r.placeholderPattern,
        preserveComments: r.preserveComments,
        syntacticPlaceholders: r.syntacticPlaceholders
      }),
      names: a
    };
  }
  s(pY, "buildLiteralData");
  function dY(e, t) {
    let r = [], n = e[0];
    for (let i = 1; i < e.length; i++) {
      let a = `${t}${i - 1}`;
      r.push(a), n += a + e[i];
    }
    return {
      names: r,
      code: n
    };
  }
  s(dY, "buildTemplateCode");
});

// ../node_modules/@babel/template/lib/builder.js
var Ex = T((sm) => {
  "use strict";
  Object.defineProperty(sm, "__esModule", {
    value: !0
  });
  sm.default = bx;
  var fn = Fl(), hx = px(), mx = dx(), yx = (0, fn.validate)({
    placeholderPattern: !1
  });
  function bx(e, t) {
    let r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap(), i = t || (0, fn.validate)(null);
    return Object.assign((a, ...o) => {
      if (typeof a == "string") {
        if (o.length > 1) throw new Error("Unexpected extra params.");
        return gx((0, hx.default)(e, a, (0, fn.merge)(i, (0, fn.validate)(o[0]))));
      } else if (Array.isArray(a)) {
        let l = r.get(a);
        return l || (l = (0, mx.default)(e, a, i), r.set(a, l)), gx(l(o));
      } else if (typeof a == "object" && a) {
        if (o.length > 0) throw new Error("Unexpected extra params.");
        return bx(e, (0, fn.merge)(i, (0, fn.validate)(a)));
      }
      throw new Error(`Unexpected template param ${typeof a}`);
    }, {
      ast: /* @__PURE__ */ s((a, ...o) => {
        if (typeof a == "string") {
          if (o.length > 1) throw new Error("Unexpected extra params.");
          return (0, hx.default)(e, a, (0, fn.merge)((0, fn.merge)(i, (0, fn.validate)(o[0])), yx))();
        } else if (Array.isArray(a)) {
          let l = n.get(a);
          return l || (l = (0, mx.default)(e, a, (0, fn.merge)(i, yx)), n.set(a, l)), l(o)();
        }
        throw new Error(`Unexpected template param ${typeof a}`);
      }, "ast")
    });
  }
  s(bx, "createTemplateBuilder");
  function gx(e) {
    let t = "";
    try {
      throw new Error();
    } catch (r) {
      r.stack && (t = r.stack.split(`
`).slice(3).join(`
`));
    }
    return (r) => {
      try {
        return e(r);
      } catch (n) {
        throw n.stack += `
    =============
${t}`, n;
      }
    };
  }
  s(gx, "extendedTrace");
});

// ../node_modules/@babel/template/lib/index.js
var Ni = T((mr) => {
  "use strict";
  Object.defineProperty(mr, "__esModule", {
    value: !0
  });
  mr.statements = mr.statement = mr.smart = mr.program = mr.expression = mr.default = void 0;
  var ro = Uv(), no = Ex(), im = mr.smart = (0, no.default)(ro.smart), hY = mr.statement = (0, no.default)(ro.statement), mY = mr.statements =
  (0, no.default)(ro.statements), yY = mr.expression = (0, no.default)(ro.expression), gY = mr.program = (0, no.default)(ro.program), mPe = mr.
  default = Object.assign(im.bind(void 0), {
    smart: im,
    statement: hY,
    statements: mY,
    expression: yY,
    program: gY,
    ast: im.ast
  });
});

// ../node_modules/@babel/helpers/lib/helpers-generated.js
var vx = T((ru) => {
  "use strict";
  Object.defineProperty(ru, "__esModule", {
    value: !0
  });
  ru.default = void 0;
  var bY = Ni();
  function G(e, t, r) {
    return Object.freeze({
      minVersion: e,
      ast: /* @__PURE__ */ s(() => bY.default.program.ast(t, {
        preserveComments: !0
      }), "ast"),
      metadata: r
    });
  }
  s(G, "helper");
  var EY = ru.default = {
    __proto__: null,
    OverloadYield: G("7.18.14", "function _OverloadYield(e,d){this.v=e,this.k=d}", {
      globals: [],
      locals: {
        _OverloadYield: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_OverloadYield",
      dependencies: {}
    }),
    applyDecoratedDescriptor: G("7.0.0-beta.0", 'function _applyDecoratedDescriptor(i,e,r,n,l){var a={};return Object.keys(n).forEach((funct\
ion(i){a[i]=n[i]})),a.enumerable=!!a.enumerable,a.configurable=!!a.configurable,("value"in a||a.initializer)&&(a.writable=!0),a=r.slice().re\
verse().reduce((function(r,n){return n(i,e,r)||r}),a),l&&void 0!==a.initializer&&(a.value=a.initializer?a.initializer.call(l):void 0,a.initi\
alizer=void 0),void 0===a.initializer?(Object.defineProperty(i,e,a),null):a}', {
      globals: ["Object"],
      locals: {
        _applyDecoratedDescriptor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_applyDecoratedDescriptor",
      dependencies: {}
    }),
    applyDecs2311: G("7.24.0", 'function applyDecs2311(e,t,n,r,o,i){var a,c,u,s,f,l,p,d=Symbol.metadata||Symbol.for("Symbol.metadata"),m=Obj\
ect.defineProperty,h=Object.create,y=[h(null),h(null)],v=t.length;function g(t,n,r){return function(o,i){n&&(i=o,o=e);for(var a=0;a<t.length\
;a++)i=t[a].apply(o,r?[i]:[]);return r?i:o}}function b(e,t,n,r){if("function"!=typeof e&&(r||void 0!==e))throw new TypeError(t+" must "+(n||\
"be")+" a function"+(r?"":" or undefined"));return e}function applyDec(e,t,n,r,o,i,u,s,f,l,p){function d(e){if(!p(e))throw new TypeError("At\
tempted to access private element on non-instance")}var h=[].concat(t[0]),v=t[3],w=!u,D=1===o,S=3===o,j=4===o,E=2===o;function I(t,n,r){retu\
rn function(o,i){return n&&(i=o,o=e),r&&r(o),P[t].call(o,i)}}if(!w){var P={},k=[],F=S?"get":j||D?"set":"value";if(f?(l||D?P={get:setFunction\
Name((function(){return v(this)}),r,"get"),set:function(e){t[4](this,e)}}:P[F]=v,l||setFunctionName(P[F],r,E?"":F)):l||(P=Object.getOwnPrope\
rtyDescriptor(e,r)),!l&&!f){if((c=y[+s][r])&&7!=(c^o))throw Error("Decorating two elements with the same name ("+P[F].name+") is not support\
ed yet");y[+s][r]=o<3?1:o}}for(var N=e,O=h.length-1;O>=0;O-=n?2:1){var T=b(h[O],"A decorator","be",!0),z=n?h[O-1]:void 0,A={},H={kind:["fiel\
d","accessor","method","getter","setter","class"][o],name:r,metadata:a,addInitializer:function(e,t){if(e.v)throw new TypeError("attempted to\
 call addInitializer after decoration was finished");b(t,"An initializer","be",!0),i.push(t)}.bind(null,A)};if(w)c=T.call(z,N,H),A.v=1,b(c,"\
class decorators","return")&&(N=c);else if(H.static=s,H.private=f,c=H.access={has:f?p.bind():function(e){return r in e}},j||(c.get=f?E?funct\
ion(e){return d(e),P.value}:I("get",0,d):function(e){return e[r]}),E||S||(c.set=f?I("set",0,d):function(e,t){e[r]=t}),N=T.call(z,D?{get:P.ge\
t,set:P.set}:P[F],H),A.v=1,D){if("object"==typeof N&&N)(c=b(N.get,"accessor.get"))&&(P.get=c),(c=b(N.set,"accessor.set"))&&(P.set=c),(c=b(N.\
init,"accessor.init"))&&k.unshift(c);else if(void 0!==N)throw new TypeError("accessor decorators must return an object with get, set, or ini\
t properties or undefined")}else b(N,(l?"field":"method")+" decorators","return")&&(l?k.unshift(N):P[F]=N)}return o<2&&u.push(g(k,s,1),g(i,s\
,0)),l||w||(f?D?u.splice(-1,0,I("get",s),I("set",s)):u.push(E?P[F]:b.call.bind(P[F])):m(e,r,P)),N}function w(e){return m(e,d,{configurable:!\
0,enumerable:!0,value:a})}return void 0!==i&&(a=i[d]),a=h(null==a?null:a),f=[],l=function(e){e&&f.push(g(e))},p=function(t,r){for(var i=0;i<\
n.length;i++){var a=n[i],c=a[1],l=7&c;if((8&c)==t&&!l==r){var p=a[2],d=!!a[3],m=16&c;applyDec(t?e:e.prototype,a,m,d?"#"+p:toPropertyKey(p),l\
,l<2?[]:t?s=s||[]:u=u||[],f,!!t,d,r,t&&d?function(t){return checkInRHS(t)===e}:o)}}},p(8,0),p(0,0),p(8,1),p(0,1),l(u),l(s),c=f,v||w(e),{e:c,\
get c(){var n=[];return v&&[w(e=applyDec(e,[t],r,e.name,5,n)),g(n,1)]}}}', {
      globals: ["Symbol", "Object", "TypeError", "Error"],
      locals: {
        applyDecs2311: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs2311",
      dependencies: {
        checkInRHS: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.10.cons\
equent.body.body.0.argument.left.callee"],
        setFunctionName: ["body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.0.consequent.right.pro\
perties.0.value.callee", "body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.1.right.callee"],
        toPropertyKey: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.3.al\
ternate.callee"]
      }
    }),
    arrayLikeToArray: G("7.9.0", "function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[\
e];return n}", {
      globals: ["Array"],
      locals: {
        _arrayLikeToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_arrayLikeToArray",
      dependencies: {}
    }),
    arrayWithHoles: G("7.0.0-beta.0", "function _arrayWithHoles(r){if(Array.isArray(r))return r}", {
      globals: ["Array"],
      locals: {
        _arrayWithHoles: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_arrayWithHoles",
      dependencies: {}
    }),
    arrayWithoutHoles: G("7.0.0-beta.0", "function _arrayWithoutHoles(r){if(Array.isArray(r))return arrayLikeToArray(r)}", {
      globals: ["Array"],
      locals: {
        _arrayWithoutHoles: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_arrayWithoutHoles",
      dependencies: {
        arrayLikeToArray: ["body.0.body.body.0.consequent.argument.callee"]
      }
    }),
    assertClassBrand: G("7.24.0", 'function _assertClassBrand(e,t,n){if("function"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;th\
row new TypeError("Private element is not present on this object")}', {
      globals: ["TypeError"],
      locals: {
        _assertClassBrand: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_assertClassBrand",
      dependencies: {}
    }),
    assertThisInitialized: G("7.0.0-beta.0", `function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been in\
itialised - super() hasn't been called");return e}`, {
      globals: ["ReferenceError"],
      locals: {
        _assertThisInitialized: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_assertThisInitialized",
      dependencies: {}
    }),
    asyncGeneratorDelegate: G("7.0.0-beta.0", 'function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promis\
e((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=func\
tion(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;\
return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}', {
      globals: ["Promise", "Symbol"],
      locals: {
        _asyncGeneratorDelegate: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_asyncGeneratorDelegate",
      dependencies: {
        OverloadYield: ["body.0.body.body.1.body.body.0.argument.expressions.2.properties.1.value.callee"]
      }
    }),
    asyncIterator: G("7.15.9", 'function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.it\
erator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="\
@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation\
(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then((functio\
n(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:nu\
ll,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return v\
oid 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.re\
turn;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}', {
      globals: ["Symbol", "TypeError", "Object", "Promise"],
      locals: {
        _asyncIterator: ["body.0.id"],
        AsyncFromSyncIterator: ["body.1.id", "body.0.body.body.1.body.body.1.consequent.argument.callee", "body.1.body.body.1.argument.expre\
ssions.1.left.object", "body.1.body.body.1.argument.expressions.2.callee", "body.1.body.body.1.argument.expressions.0.left"]
      },
      exportBindingAssignments: [],
      exportName: "_asyncIterator",
      dependencies: {}
    }),
    asyncToGenerator: G("7.0.0-beta.0", 'function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i.\
done?t(u):Promise.resolve(u).then(r,o)}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise((function(r\
,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,_\
throw,"throw",n)}_next(void 0)}))}}', {
      globals: ["Promise"],
      locals: {
        asyncGeneratorStep: ["body.0.id", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.1.body.body.0.expression.c\
allee", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.2.body.body.0.expression.callee"],
        _asyncToGenerator: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_asyncToGenerator",
      dependencies: {}
    }),
    awaitAsyncGenerator: G("7.0.0-beta.0", "function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}", {
      globals: [],
      locals: {
        _awaitAsyncGenerator: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_awaitAsyncGenerator",
      dependencies: {
        OverloadYield: ["body.0.body.body.0.argument.callee"]
      }
    }),
    callSuper: G("7.23.8", "function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleConstructorReturn(t,isNativeReflectConstruct()?Ref\
lect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}", {
      globals: ["Reflect"],
      locals: {
        _callSuper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_callSuper",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.0.argument.expressions.0.right.callee", "body.0.body.body.0.argument.expressions.1.arguments.1.co\
nsequent.arguments.2.object.callee"],
        isNativeReflectConstruct: ["body.0.body.body.0.argument.expressions.1.arguments.1.test.callee"],
        possibleConstructorReturn: ["body.0.body.body.0.argument.expressions.1.callee"]
      }
    }),
    checkInRHS: G("7.20.5", `function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of 'in' should be an object, got "+(n\
ull!==e?typeof e:"null"));return e}`, {
      globals: ["Object", "TypeError"],
      locals: {
        _checkInRHS: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_checkInRHS",
      dependencies: {}
    }),
    checkPrivateRedeclaration: G("7.14.1", 'function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError("Cannot initialize the \
same private elements twice on an object")}', {
      globals: ["TypeError"],
      locals: {
        _checkPrivateRedeclaration: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_checkPrivateRedeclaration",
      dependencies: {}
    }),
    classCallCheck: G("7.0.0-beta.0", 'function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a func\
tion")}', {
      globals: ["TypeError"],
      locals: {
        _classCallCheck: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classCallCheck",
      dependencies: {}
    }),
    classNameTDZError: G("7.0.0-beta.0", `function _classNameTDZError(e){throw new ReferenceError('Class "'+e+'" cannot be referenced in com\
puted property keys.')}`, {
      globals: ["ReferenceError"],
      locals: {
        _classNameTDZError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classNameTDZError",
      dependencies: {}
    }),
    classPrivateFieldGet2: G("7.24.0", "function _classPrivateFieldGet2(s,a){return s.get(assertClassBrand(s,a))}", {
      globals: [],
      locals: {
        _classPrivateFieldGet2: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldGet2",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"]
      }
    }),
    classPrivateFieldInitSpec: G("7.14.1", "function _classPrivateFieldInitSpec(e,t,a){checkPrivateRedeclaration(e,t),t.set(e,a)}", {
      globals: [],
      locals: {
        _classPrivateFieldInitSpec: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldInitSpec",
      dependencies: {
        checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"]
      }
    }),
    classPrivateFieldLooseBase: G("7.0.0-beta.0", 'function _classPrivateFieldBase(e,t){if(!{}.hasOwnProperty.call(e,t))throw new TypeError(\
"attempted to use private field on non-instance");return e}', {
      globals: ["TypeError"],
      locals: {
        _classPrivateFieldBase: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldBase",
      dependencies: {}
    }),
    classPrivateFieldLooseKey: G("7.0.0-beta.0", 'var id=0;function _classPrivateFieldKey(e){return"__private_"+id+++"_"+e}', {
      globals: [],
      locals: {
        id: ["body.0.declarations.0.id", "body.1.body.body.0.argument.left.left.right.argument", "body.1.body.body.0.argument.left.left.righ\
t.argument"],
        _classPrivateFieldKey: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldKey",
      dependencies: {}
    }),
    classPrivateFieldSet2: G("7.24.0", "function _classPrivateFieldSet2(s,a,r){return s.set(assertClassBrand(s,a),r),r}", {
      globals: [],
      locals: {
        _classPrivateFieldSet2: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldSet2",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]
      }
    }),
    classPrivateGetter: G("7.24.0", "function _classPrivateGetter(s,r,a){return a(assertClassBrand(s,r))}", {
      globals: [],
      locals: {
        _classPrivateGetter: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateGetter",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"]
      }
    }),
    classPrivateMethodInitSpec: G("7.14.1", "function _classPrivateMethodInitSpec(e,a){checkPrivateRedeclaration(e,a),a.add(e)}", {
      globals: [],
      locals: {
        _classPrivateMethodInitSpec: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateMethodInitSpec",
      dependencies: {
        checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"]
      }
    }),
    classPrivateSetter: G("7.24.0", "function _classPrivateSetter(s,r,a,t){return r(assertClassBrand(s,a),t),t}", {
      globals: [],
      locals: {
        _classPrivateSetter: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateSetter",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]
      }
    }),
    classStaticPrivateMethodGet: G("7.3.2", "function _classStaticPrivateMethodGet(s,a,t){return assertClassBrand(a,s),t}", {
      globals: [],
      locals: {
        _classStaticPrivateMethodGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateMethodGet",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"]
      }
    }),
    construct: G("7.0.0-beta.0", "function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);va\
r o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}", {
      globals: ["Reflect"],
      locals: {
        _construct: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_construct",
      dependencies: {
        isNativeReflectConstruct: ["body.0.body.body.0.test.callee"],
        setPrototypeOf: ["body.0.body.body.4.argument.expressions.0.right.callee"]
      }
    }),
    createClass: G("7.0.0-beta.0", 'function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.c\
onfigurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_defineP\
roperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}', {
      globals: ["Object"],
      locals: {
        _defineProperties: ["body.0.id", "body.1.body.body.0.argument.expressions.0.right.callee", "body.1.body.body.0.argument.expressions.\
1.right.callee"],
        _createClass: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createClass",
      dependencies: {
        toPropertyKey: ["body.0.body.body.0.body.body.1.expression.expressions.3.arguments.1.callee"]
      }
    }),
    createForOfIteratorHelper: G("7.9.0", 'function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r[\
"@@iterator"];if(!t){if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var n=0,F=function(){\
};return{s:F,n:function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]}},e:function(r){throw r},f:F}}throw new TypeError("Invalid atte\
mpt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;\
return{s:function(){t=t.call(r)},n:function(){var r=t.next();return a=r.done,r},e:function(r){u=!0,o=r},f:function(){try{a||null==t.return||\
t.return()}finally{if(u)throw o}}}}', {
      globals: ["Symbol", "Array", "TypeError"],
      locals: {
        _createForOfIteratorHelper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createForOfIteratorHelper",
      dependencies: {
        unsupportedIterableToArray: ["body.0.body.body.1.consequent.body.0.test.left.right.right.callee"]
      }
    }),
    createForOfIteratorHelperLoose: G("7.9.0", 'function _createForOfIteratorHelperLoose(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.ite\
rator]||r["@@iterator"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof\
 r.length){t&&(r=t);var o=0;return function(){return o>=r.length?{done:!0}:{done:!1,value:r[o++]}}}throw new TypeError("Invalid attempt to i\
terate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
      globals: ["Symbol", "Array", "TypeError"],
      locals: {
        _createForOfIteratorHelperLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createForOfIteratorHelperLoose",
      dependencies: {
        unsupportedIterableToArray: ["body.0.body.body.2.test.left.right.right.callee"]
      }
    }),
    createSuper: G("7.9.0", "function _createSuper(t){var r=isNativeReflectConstruct();return function(){var e,o=getPrototypeOf(t);if(r){var\
 s=getPrototypeOf(this).constructor;e=Reflect.construct(o,arguments,s)}else e=o.apply(this,arguments);return possibleConstructorReturn(this,\
e)}}", {
      globals: ["Reflect"],
      locals: {
        _createSuper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createSuper",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.1.argument.body.body.0.declarations.1.init.callee", "body.0.body.body.1.argument.body.body.1.cons\
equent.body.0.declarations.0.init.object.callee"],
        isNativeReflectConstruct: ["body.0.body.body.0.declarations.0.init.callee"],
        possibleConstructorReturn: ["body.0.body.body.1.argument.body.body.2.argument.callee"]
      }
    }),
    decorate: G("7.1.5", `function _decorate(e,r,t,i){var o=_getDecoratorsApi();if(i)for(var n=0;n<i.length;n++)o=i[n](o);var s=r((function(\
e){o.initializeInstanceElements(e,a.elements)}),t),a=o.decorateClass(_coalesceClassElements(s.d.map(_createElementDescriptor)),e);return o.i\
nitializeClassElements(s.F,a.elements),o.runClassFinishers(s.F,a.finishers)}function _getDecoratorsApi(){_getDecoratorsApi=function(){return\
 e};var e={elementsDefinitionOrder:[["method"],["field"]],initializeInstanceElements:function(e,r){["method","field"].forEach((function(t){r\
.forEach((function(r){r.kind===t&&"own"===r.placement&&this.defineClassElement(e,r)}),this)}),this)},initializeClassElements:function(e,r){v\
ar t=e.prototype;["method","field"].forEach((function(i){r.forEach((function(r){var o=r.placement;if(r.kind===i&&("static"===o||"prototype"=\
==o)){var n="static"===o?e:t;this.defineClassElement(n,r)}}),this)}),this)},defineClassElement:function(e,r){var t=r.descriptor;if("field"==\
=r.kind){var i=r.initializer;t={enumerable:t.enumerable,writable:t.writable,configurable:t.configurable,value:void 0===i?void 0:i.call(e)}}O\
bject.defineProperty(e,r.key,t)},decorateClass:function(e,r){var t=[],i=[],o={static:[],prototype:[],own:[]};if(e.forEach((function(e){this.\
addElementPlacement(e,o)}),this),e.forEach((function(e){if(!_hasDecorators(e))return t.push(e);var r=this.decorateElement(e,o);t.push(r.elem\
ent),t.push.apply(t,r.extras),i.push.apply(i,r.finishers)}),this),!r)return{elements:t,finishers:i};var n=this.decorateConstructor(t,r);retu\
rn i.push.apply(i,n.finishers),n.finishers=i,n},addElementPlacement:function(e,r,t){var i=r[e.placement];if(!t&&-1!==i.indexOf(e.key))throw \
new TypeError("Duplicated element ("+e.key+")");i.push(e.key)},decorateElement:function(e,r){for(var t=[],i=[],o=e.decorators,n=o.length-1;n\
>=0;n--){var s=r[e.placement];s.splice(s.indexOf(e.key),1);var a=this.fromElementDescriptor(e),l=this.toElementFinisherExtras((0,o[n])(a)||a\
);e=l.element,this.addElementPlacement(e,r),l.finisher&&i.push(l.finisher);var c=l.extras;if(c){for(var p=0;p<c.length;p++)this.addElementPl\
acement(c[p],r);t.push.apply(t,c)}}return{element:e,finishers:i,extras:t}},decorateConstructor:function(e,r){for(var t=[],i=r.length-1;i>=0;\
i--){var o=this.fromClassDescriptor(e),n=this.toClassDescriptor((0,r[i])(o)||o);if(void 0!==n.finisher&&t.push(n.finisher),void 0!==n.elemen\
ts){e=n.elements;for(var s=0;s<e.length-1;s++)for(var a=s+1;a<e.length;a++)if(e[s].key===e[a].key&&e[s].placement===e[a].placement)throw new\
 TypeError("Duplicated element ("+e[s].key+")")}}return{elements:e,finishers:t}},fromElementDescriptor:function(e){var r={kind:e.kind,key:e.\
key,placement:e.placement,descriptor:e.descriptor};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),"\
field"===e.kind&&(r.initializer=e.initializer),r},toElementDescriptors:function(e){if(void 0!==e)return toArray(e).map((function(e){var r=th\
is.toElementDescriptor(e);return this.disallowProperty(e,"finisher","An element descriptor"),this.disallowProperty(e,"extras","An element de\
scriptor"),r}),this)},toElementDescriptor:function(e){var r=e.kind+"";if("method"!==r&&"field"!==r)throw new TypeError('An element descripto\
r\\'s .kind property must be either "method" or "field", but a decorator created an element descriptor with .kind "'+r+'"');var t=toPropertyK\
ey(e.key),i=e.placement+"";if("static"!==i&&"prototype"!==i&&"own"!==i)throw new TypeError('An element descriptor\\'s .placement property mus\
t be one of "static", "prototype" or "own", but a decorator created an element descriptor with .placement "'+i+'"');var o=e.descriptor;this.\
disallowProperty(e,"elements","An element descriptor");var n={kind:r,key:t,placement:i,descriptor:Object.assign({},o)};return"field"!==r?thi\
s.disallowProperty(e,"initializer","A method descriptor"):(this.disallowProperty(o,"get","The property descriptor of a field descriptor"),th\
is.disallowProperty(o,"set","The property descriptor of a field descriptor"),this.disallowProperty(o,"value","The property descriptor of a f\
ield descriptor"),n.initializer=e.initializer),n},toElementFinisherExtras:function(e){return{element:this.toElementDescriptor(e),finisher:_o\
ptionalCallableProperty(e,"finisher"),extras:this.toElementDescriptors(e.extras)}},fromClassDescriptor:function(e){var r={kind:"class",eleme\
nts:e.map(this.fromElementDescriptor,this)};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),r},toCla\
ssDescriptor:function(e){var r=e.kind+"";if("class"!==r)throw new TypeError('A class descriptor\\'s .kind property must be "class", but a dec\
orator created a class descriptor with .kind "'+r+'"');this.disallowProperty(e,"key","A class descriptor"),this.disallowProperty(e,"placemen\
t","A class descriptor"),this.disallowProperty(e,"descriptor","A class descriptor"),this.disallowProperty(e,"initializer","A class descripto\
r"),this.disallowProperty(e,"extras","A class descriptor");var t=_optionalCallableProperty(e,"finisher");return{elements:this.toElementDescr\
iptors(e.elements),finisher:t}},runClassFinishers:function(e,r){for(var t=0;t<r.length;t++){var i=(0,r[t])(e);if(void 0!==i){if("function"!=\
typeof i)throw new TypeError("Finishers must return a constructor.");e=i}}return e},disallowProperty:function(e,r,t){if(void 0!==e[r])throw \
new TypeError(t+" can't have a ."+r+" property.")}};return e}function _createElementDescriptor(e){var r,t=toPropertyKey(e.key);"method"===e.\
kind?r={value:e.value,writable:!0,configurable:!0,enumerable:!1}:"get"===e.kind?r={get:e.value,configurable:!0,enumerable:!1}:"set"===e.kind\
?r={set:e.value,configurable:!0,enumerable:!1}:"field"===e.kind&&(r={configurable:!0,writable:!0,enumerable:!0});var i={kind:"field"===e.kin\
d?"field":"method",key:t,placement:e.static?"static":"field"===e.kind?"own":"prototype",descriptor:r};return e.decorators&&(i.decorators=e.d\
ecorators),"field"===e.kind&&(i.initializer=e.value),i}function _coalesceGetterSetter(e,r){void 0!==e.descriptor.get?r.descriptor.get=e.desc\
riptor.get:r.descriptor.set=e.descriptor.set}function _coalesceClassElements(e){for(var r=[],isSameElement=function(e){return"method"===e.ki\
nd&&e.key===o.key&&e.placement===o.placement},t=0;t<e.length;t++){var i,o=e[t];if("method"===o.kind&&(i=r.find(isSameElement)))if(_isDataDes\
criptor(o.descriptor)||_isDataDescriptor(i.descriptor)){if(_hasDecorators(o)||_hasDecorators(i))throw new ReferenceError("Duplicated methods\
 ("+o.key+") can't be decorated.");i.descriptor=o.descriptor}else{if(_hasDecorators(o)){if(_hasDecorators(i))throw new ReferenceError("Decor\
ators can't be placed on different accessors with for the same property ("+o.key+").");i.decorators=o.decorators}_coalesceGetterSetter(o,i)}\
else r.push(o)}return r}function _hasDecorators(e){return e.decorators&&e.decorators.length}function _isDataDescriptor(e){return void 0!==e&\
&!(void 0===e.value&&void 0===e.writable)}function _optionalCallableProperty(e,r){var t=e[r];if(void 0!==t&&"function"!=typeof t)throw new T\
ypeError("Expected '"+r+"' to be a function");return t}`, {
      globals: ["Object", "TypeError", "Symbol", "ReferenceError"],
      locals: {
        _decorate: ["body.0.id"],
        _getDecoratorsApi: ["body.1.id", "body.0.body.body.0.declarations.0.init.callee", "body.1.body.body.0.expression.left"],
        _createElementDescriptor: ["body.2.id", "body.0.body.body.2.declarations.1.init.arguments.0.arguments.0.arguments.0"],
        _coalesceGetterSetter: ["body.3.id", "body.4.body.body.0.body.body.1.consequent.alternate.body.1.expression.callee"],
        _coalesceClassElements: ["body.4.id", "body.0.body.body.2.declarations.1.init.arguments.0.callee"],
        _hasDecorators: ["body.5.id", "body.1.body.body.1.declarations.0.init.properties.4.value.body.body.1.test.expressions.1.arguments.0.\
body.body.0.test.argument.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.left.callee", "body.4.body.body.0.body.\
body.1.consequent.consequent.body.0.test.right.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.test.callee", "body.4.bo\
dy.body.0.body.body.1.consequent.alternate.body.0.consequent.body.0.test.callee"],
        _isDataDescriptor: ["body.6.id", "body.4.body.body.0.body.body.1.consequent.test.left.callee", "body.4.body.body.0.body.body.1.conse\
quent.test.right.callee"],
        _optionalCallableProperty: ["body.7.id", "body.1.body.body.1.declarations.0.init.properties.11.value.body.body.0.argument.properties\
.1.value.callee", "body.1.body.body.1.declarations.0.init.properties.13.value.body.body.3.declarations.0.init.callee"]
      },
      exportBindingAssignments: [],
      exportName: "_decorate",
      dependencies: {
        toArray: ["body.1.body.body.1.declarations.0.init.properties.9.value.body.body.0.consequent.argument.callee.object.callee"],
        toPropertyKey: ["body.1.body.body.1.declarations.0.init.properties.10.value.body.body.2.declarations.0.init.callee", "body.2.body.bo\
dy.0.declarations.1.init.callee"]
      }
    }),
    defaults: G("7.0.0-beta.0", "function _defaults(e,r){for(var t=Object.getOwnPropertyNames(r),o=0;o<t.length;o++){var n=t[o],a=Object.get\
OwnPropertyDescriptor(r,n);a&&a.configurable&&void 0===e[n]&&Object.defineProperty(e,n,a)}return e}", {
      globals: ["Object"],
      locals: {
        _defaults: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defaults",
      dependencies: {}
    }),
    defineAccessor: G("7.20.7", "function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty\
(r,n,c)}", {
      globals: ["Object"],
      locals: {
        _defineAccessor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defineAccessor",
      dependencies: {}
    }),
    defineProperty: G("7.0.0-beta.0", "function _defineProperty(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enu\
merable:!0,configurable:!0,writable:!0}):e[r]=t,e}", {
      globals: ["Object"],
      locals: {
        _defineProperty: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defineProperty",
      dependencies: {
        toPropertyKey: ["body.0.body.body.0.argument.expressions.0.test.left.right.callee"]
      }
    }),
    extends: G("7.0.0-beta.0", "function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.l\
ength;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}", {
      globals: ["Object"],
      locals: {
        _extends: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_extends",
      dependencies: {}
    }),
    get: G("7.0.0-beta.0", 'function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var p=su\
perPropBase(e,t);if(p){var n=Object.getOwnPropertyDescriptor(p,t);return n.get?n.get.call(arguments.length<3?e:r):n.value}},_get.apply(null,\
arguments)}', {
      globals: ["Reflect", "Object"],
      locals: {
        _get: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_get",
      dependencies: {
        superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.0.init.callee"]
      }
    }),
    getPrototypeOf: G("7.0.0-beta.0", "function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind()\
:function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}", {
      globals: ["Object"],
      locals: {
        _getPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_getPrototypeOf",
      dependencies: {}
    }),
    identity: G("7.17.0", "function _identity(t){return t}", {
      globals: [],
      locals: {
        _identity: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_identity",
      dependencies: {}
    }),
    importDeferProxy: G("7.23.0", "function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=functi\
on(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValu\
e(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:c\
onstValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:const\
Value(!1)})}", {
      globals: ["Proxy", "Reflect"],
      locals: {
        _importDeferProxy: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_importDeferProxy",
      dependencies: {}
    }),
    inherits: G("7.0.0-beta.0", 'function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either\
 be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty\
(t,"prototype",{writable:!1}),e&&setPrototypeOf(t,e)}', {
      globals: ["TypeError", "Object"],
      locals: {
        _inherits: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_inherits",
      dependencies: {
        setPrototypeOf: ["body.0.body.body.1.expression.expressions.2.right.callee"]
      }
    }),
    inheritsLoose: G("7.0.0-beta.0", "function _inheritsLoose(t,o){t.prototype=Object.create(o.prototype),t.prototype.constructor=t,setProto\
typeOf(t,o)}", {
      globals: ["Object"],
      locals: {
        _inheritsLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_inheritsLoose",
      dependencies: {
        setPrototypeOf: ["body.0.body.body.0.expression.expressions.2.callee"]
      }
    }),
    initializerDefineProperty: G("7.0.0-beta.0", "function _initializerDefineProperty(e,i,r,l){r&&Object.defineProperty(e,i,{enumerable:r.en\
umerable,configurable:r.configurable,writable:r.writable,value:r.initializer?r.initializer.call(l):void 0})}", {
      globals: ["Object"],
      locals: {
        _initializerDefineProperty: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_initializerDefineProperty",
      dependencies: {}
    }),
    initializerWarningHelper: G("7.0.0-beta.0", 'function _initializerWarningHelper(r,e){throw Error("Decorating class property failed. Plea\
se ensure that transform-class-properties is enabled and runs after the decorators transform.")}', {
      globals: ["Error"],
      locals: {
        _initializerWarningHelper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_initializerWarningHelper",
      dependencies: {}
    }),
    instanceof: G("7.0.0-beta.0", 'function _instanceof(n,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.ha\
sInstance](n):n instanceof e}', {
      globals: ["Symbol"],
      locals: {
        _instanceof: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_instanceof",
      dependencies: {}
    }),
    interopRequireDefault: G("7.0.0-beta.0", "function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}", {
      globals: [],
      locals: {
        _interopRequireDefault: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_interopRequireDefault",
      dependencies: {}
    }),
    interopRequireWildcard: G("7.14.0", 'function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=\
new WeakMap;return(_getRequireWildcardCache=function(e){return e?t:r})(e)}function _interopRequireWildcard(e,r){if(!r&&e&&e.__esModule)retur\
n e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e)\
;var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&{}.hasOwnProperty.call(e,u\
)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u]}return n.default=e,t&&t.set(e,\
n),n}', {
      globals: ["WeakMap", "Object"],
      locals: {
        _getRequireWildcardCache: ["body.0.id", "body.1.body.body.2.declarations.0.init.callee", "body.0.body.body.2.argument.callee.left"],
        _interopRequireWildcard: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_interopRequireWildcard",
      dependencies: {}
    }),
    isNativeFunction: G("7.0.0-beta.0", 'function _isNativeFunction(t){try{return-1!==Function.toString.call(t).indexOf("[native code]")}cat\
ch(n){return"function"==typeof t}}', {
      globals: ["Function"],
      locals: {
        _isNativeFunction: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_isNativeFunction",
      dependencies: {}
    }),
    isNativeReflectConstruct: G("7.9.0", "function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(B\
oolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}", {
      globals: ["Boolean", "Reflect"],
      locals: {
        _isNativeReflectConstruct: ["body.0.id", "body.0.body.body.1.argument.callee.left"]
      },
      exportBindingAssignments: ["body.0.body.body.1.argument.callee"],
      exportName: "_isNativeReflectConstruct",
      dependencies: {}
    }),
    iterableToArray: G("7.0.0-beta.0", 'function _iterableToArray(r){if("undefined"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r["@@ite\
rator"])return Array.from(r)}', {
      globals: ["Symbol", "Array"],
      locals: {
        _iterableToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_iterableToArray",
      dependencies: {}
    }),
    iterableToArrayLimit: G("7.0.0-beta.0", 'function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.ite\
rator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f\
=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u\
))return}finally{if(o)throw n}}return a}}', {
      globals: ["Symbol", "Object"],
      locals: {
        _iterableToArrayLimit: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_iterableToArrayLimit",
      dependencies: {}
    }),
    jsx: G("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="functio\
n"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:vo\
id 0}),1===n)r.children=l;else if(n>1){for(var t=Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&\
&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}', {
      globals: ["Symbol", "Array"],
      locals: {
        REACT_ELEMENT_TYPE: ["body.0.declarations.0.id", "body.1.body.body.0.expression.left", "body.1.body.body.4.argument.properties.0.val\
ue", "body.1.body.body.0.expression.right.left"],
        _createRawReactElement: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createRawReactElement",
      dependencies: {}
    }),
    maybeArrayLike: G("7.9.0", 'function _maybeArrayLike(r,a,e){if(a&&!Array.isArray(a)&&"number"==typeof a.length){var y=a.length;return ar\
rayLikeToArray(a,void 0!==e&&e<y?e:y)}return r(a,e)}', {
      globals: ["Array"],
      locals: {
        _maybeArrayLike: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_maybeArrayLike",
      dependencies: {
        arrayLikeToArray: ["body.0.body.body.0.consequent.body.1.argument.callee"]
      }
    }),
    newArrowCheck: G("7.0.0-beta.0", 'function _newArrowCheck(n,r){if(n!==r)throw new TypeError("Cannot instantiate an arrow function")}', {
      globals: ["TypeError"],
      locals: {
        _newArrowCheck: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_newArrowCheck",
      dependencies: {}
    }),
    nonIterableRest: G("7.0.0-beta.0", 'function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instanc\
e.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
      globals: ["TypeError"],
      locals: {
        _nonIterableRest: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_nonIterableRest",
      dependencies: {}
    }),
    nonIterableSpread: G("7.0.0-beta.0", 'function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance\
.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
      globals: ["TypeError"],
      locals: {
        _nonIterableSpread: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_nonIterableSpread",
      dependencies: {}
    }),
    nullishReceiverError: G("7.22.6", 'function _nullishReceiverError(r){throw new TypeError("Cannot set property of null or undefined.")}',
    {
      globals: ["TypeError"],
      locals: {
        _nullishReceiverError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_nullishReceiverError",
      dependencies: {}
    }),
    objectDestructuringEmpty: G("7.0.0-beta.0", 'function _objectDestructuringEmpty(t){if(null==t)throw new TypeError("Cannot destructure "+\
t)}', {
      globals: ["TypeError"],
      locals: {
        _objectDestructuringEmpty: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectDestructuringEmpty",
      dependencies: {}
    }),
    objectSpread2: G("7.5.0", "function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbol\
s(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}function _objectSprea\
d2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){defineProp\
erty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach\
((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}", {
      globals: ["Object"],
      locals: {
        ownKeys: ["body.0.id", "body.1.body.body.0.body.body.1.expression.consequent.callee.object.callee", "body.1.body.body.0.body.body.1.\
expression.alternate.alternate.callee.object.callee"],
        _objectSpread2: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectSpread2",
      dependencies: {
        defineProperty: ["body.1.body.body.0.body.body.1.expression.consequent.arguments.0.body.body.0.expression.callee"]
      }
    }),
    objectWithoutProperties: G("7.0.0-beta.0", "function _objectWithoutProperties(e,t){if(null==e)return{};var o,r,i=objectWithoutProperties\
Loose(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)o=s[r],t.includes(o)||{}.propertyIs\
Enumerable.call(e,o)&&(i[o]=e[o])}return i}", {
      globals: ["Object"],
      locals: {
        _objectWithoutProperties: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectWithoutProperties",
      dependencies: {
        objectWithoutPropertiesLoose: ["body.0.body.body.1.declarations.2.init.callee"]
      }
    }),
    objectWithoutPropertiesLoose: G("7.0.0-beta.0", "function _objectWithoutPropertiesLoose(r,e){if(null==r)return{};var t={};for(var n in r\
)if({}.hasOwnProperty.call(r,n)){if(e.includes(n))continue;t[n]=r[n]}return t}", {
      globals: [],
      locals: {
        _objectWithoutPropertiesLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectWithoutPropertiesLoose",
      dependencies: {}
    }),
    possibleConstructorReturn: G("7.0.0-beta.0", 'function _possibleConstructorReturn(t,e){if(e&&("object"==typeof e||"function"==typeof e))\
return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return assertThisInitialized(t)}', {
      globals: ["TypeError"],
      locals: {
        _possibleConstructorReturn: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_possibleConstructorReturn",
      dependencies: {
        assertThisInitialized: ["body.0.body.body.2.argument.callee"]
      }
    }),
    readOnlyError: G("7.0.0-beta.0", `function _readOnlyError(r){throw new TypeError('"'+r+'" is read-only')}`, {
      globals: ["TypeError"],
      locals: {
        _readOnlyError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_readOnlyError",
      dependencies: {}
    }),
    regeneratorRuntime: G("7.18.0", `function _regeneratorRuntime(){"use strict";
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LI\
CENSE */_regeneratorRuntime=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t\
[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStr\
ingTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}\
catch(t){define=function(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(\
i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",\
arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={}\
;function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,(function(){return this}));v\
ar d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype\
=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invo\
ke(e,t)}))}))}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;retur\
n h&&"object"==typeof h&&n.call(h,"__await")?e.resolve(h.__await).then((function(t){invoke("next",t,i,a)}),(function(t){invoke("throw",t,i,a\
)})):e.resolve(h).then((function(t){u.value=t,i(u)}),(function(t){return invoke("throw",t,i,a)}))}a(c.arg)}var r;o(this,"_invoke",{value:fun\
ction(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,r){invoke(t,n,e,r)}))}return r=r?r.then(callInvokeWithMethodAndArg\
,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw Er\
ror("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c\
){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(\
o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p\
.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function ma\
ybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.a\
rg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n\
+"' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;ret\
urn a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw"\
,r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc\
=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",\
delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function value\
s(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){fo\
r(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new T\
ypeError(typeof e+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFuncti\
onPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displa\
yName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;r\
eturn!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.set\
PrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create\
(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){re\
turn this})),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);retu\
rn e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(g),define(g,u,"Generator")\
,define(g,a,(function(){return this})),define(g,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[]\
;for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}r\
eturn next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function(e){if(this.prev=0,this.next=0,this.sent=this\
._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.c\
harAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.\
type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",\
a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("r\
oot"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.cat\
chLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.\
catchLoc,!0)}else{if(!u)throw Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abru\
pt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.\
prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.\
type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;retu\
rn"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"n\
ormal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLo\
c===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var \
r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw Error("illegal ca\
tch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.ar\
g=t),y}},e}`, {
      globals: ["Object", "Symbol", "Error", "TypeError", "isNaN", "Promise"],
      locals: {
        _regeneratorRuntime: ["body.0.id", "body.0.body.body.0.expression.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.expression"],
      exportName: "_regeneratorRuntime",
      dependencies: {}
    }),
    set: G("7.0.0-beta.0", 'function set(e,r,t,o){return set="undefined"!=typeof Reflect&&Reflect.set?Reflect.set:function(e,r,t,o){var f,i=\
superPropBase(e,r);if(i){if((f=Object.getOwnPropertyDescriptor(i,r)).set)return f.set.call(o,t),!0;if(!f.writable)return!1}if(f=Object.getOw\
nPropertyDescriptor(o,r)){if(!f.writable)return!1;f.value=t,Object.defineProperty(o,r,f)}else defineProperty(o,r,t);return!0},set(e,r,t,o)}f\
unction _set(e,r,t,o,f){if(!set(e,r,t,o||e)&&f)throw new TypeError("failed to set property");return t}', {
      globals: ["Reflect", "Object", "TypeError"],
      locals: {
        set: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.0.test.left.argument.callee", "body.0.body.\
body.0.argument.expressions.0.left"],
        _set: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_set",
      dependencies: {
        superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.1.init.callee"],
        defineProperty: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.2.alternate.expression.callee"]
      }
    }),
    setFunctionName: G("7.23.6", 'function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try{Object.definePr\
operty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}', {
      globals: ["Object"],
      locals: {
        setFunctionName: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "setFunctionName",
      dependencies: {}
    }),
    setPrototypeOf: G("7.0.0-beta.0", "function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind\
():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}", {
      globals: ["Object"],
      locals: {
        _setPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_setPrototypeOf",
      dependencies: {}
    }),
    skipFirstGeneratorNext: G("7.0.0-beta.0", "function _skipFirstGeneratorNext(t){return function(){var r=t.apply(this,arguments);return r.\
next(),r}}", {
      globals: [],
      locals: {
        _skipFirstGeneratorNext: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_skipFirstGeneratorNext",
      dependencies: {}
    }),
    slicedToArray: G("7.0.0-beta.0", "function _slicedToArray(r,e){return arrayWithHoles(r)||iterableToArrayLimit(r,e)||unsupportedIterableT\
oArray(r,e)||nonIterableRest()}", {
      globals: [],
      locals: {
        _slicedToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_slicedToArray",
      dependencies: {
        arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
        iterableToArrayLimit: ["body.0.body.body.0.argument.left.left.right.callee"],
        unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
        nonIterableRest: ["body.0.body.body.0.argument.right.callee"]
      }
    }),
    superPropBase: G("7.0.0-beta.0", "function _superPropBase(t,o){for(;!{}.hasOwnProperty.call(t,o)&&null!==(t=getPrototypeOf(t)););return \
t}", {
      globals: [],
      locals: {
        _superPropBase: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_superPropBase",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.0.test.right.right.right.callee"]
      }
    }),
    superPropGet: G("7.25.0", "function _superPropertyGet(t,e,r,o){var p=get(getPrototypeOf(1&o?t.prototype:t),e,r);return 2&o?function(t){r\
eturn p.apply(r,t)}:p}", {
      globals: [],
      locals: {
        _superPropertyGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_superPropertyGet",
      dependencies: {
        get: ["body.0.body.body.0.declarations.0.init.callee"],
        getPrototypeOf: ["body.0.body.body.0.declarations.0.init.arguments.0.callee"]
      }
    }),
    superPropSet: G("7.25.0", "function _superPropertySet(t,e,o,r,p,f){return set(getPrototypeOf(f?t.prototype:t),e,o,r,p)}", {
      globals: [],
      locals: {
        _superPropertySet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_superPropertySet",
      dependencies: {
        set: ["body.0.body.body.0.argument.callee"],
        getPrototypeOf: ["body.0.body.body.0.argument.arguments.0.callee"]
      }
    }),
    taggedTemplateLiteral: G("7.0.0-beta.0", "function _taggedTemplateLiteral(e,t){return t||(t=e.slice(0)),Object.freeze(Object.definePrope\
rties(e,{raw:{value:Object.freeze(t)}}))}", {
      globals: ["Object"],
      locals: {
        _taggedTemplateLiteral: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_taggedTemplateLiteral",
      dependencies: {}
    }),
    taggedTemplateLiteralLoose: G("7.0.0-beta.0", "function _taggedTemplateLiteralLoose(e,t){return t||(t=e.slice(0)),e.raw=t,e}", {
      globals: [],
      locals: {
        _taggedTemplateLiteralLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_taggedTemplateLiteralLoose",
      dependencies: {}
    }),
    tdz: G("7.5.5", 'function _tdzError(e){throw new ReferenceError(e+" is not defined - temporal dead zone")}', {
      globals: ["ReferenceError"],
      locals: {
        _tdzError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_tdzError",
      dependencies: {}
    }),
    temporalRef: G("7.0.0-beta.0", "function _temporalRef(r,e){return r===undef?err(e):r}", {
      globals: [],
      locals: {
        _temporalRef: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_temporalRef",
      dependencies: {
        temporalUndefined: ["body.0.body.body.0.argument.test.right"],
        tdz: ["body.0.body.body.0.argument.consequent.callee"]
      }
    }),
    temporalUndefined: G("7.0.0-beta.0", "function _temporalUndefined(){}", {
      globals: [],
      locals: {
        _temporalUndefined: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_temporalUndefined",
      dependencies: {}
    }),
    toArray: G("7.0.0-beta.0", "function _toArray(r){return arrayWithHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterabl\
eRest()}", {
      globals: [],
      locals: {
        _toArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_toArray",
      dependencies: {
        arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
        iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"],
        unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
        nonIterableRest: ["body.0.body.body.0.argument.right.callee"]
      }
    }),
    toConsumableArray: G("7.0.0-beta.0", "function _toConsumableArray(r){return arrayWithoutHoles(r)||iterableToArray(r)||unsupportedIterabl\
eToArray(r)||nonIterableSpread()}", {
      globals: [],
      locals: {
        _toConsumableArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_toConsumableArray",
      dependencies: {
        arrayWithoutHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
        iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"],
        unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
        nonIterableSpread: ["body.0.body.body.0.argument.right.callee"]
      }
    }),
    toPrimitive: G("7.1.5", 'function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e\
.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r\
?String:Number)(t)}', {
      globals: ["Symbol", "TypeError", "String", "Number"],
      locals: {
        toPrimitive: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "toPrimitive",
      dependencies: {}
    }),
    toPropertyKey: G("7.1.5", 'function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==typeof i?i:i+""}', {
      globals: [],
      locals: {
        toPropertyKey: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "toPropertyKey",
      dependencies: {
        toPrimitive: ["body.0.body.body.0.declarations.0.init.callee"]
      }
    }),
    toSetter: G("7.24.0", 'function _toSetter(t,e,n){e||(e=[]);var r=e.length++;return Object.defineProperty({},"_",{set:function(o){e[r]=o,\
t.apply(n,e)}})}', {
      globals: ["Object"],
      locals: {
        _toSetter: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_toSetter",
      dependencies: {}
    }),
    typeof: G("7.0.0-beta.0", 'function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symb\
ol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symb\
ol":typeof o},_typeof(o)}', {
      globals: ["Symbol"],
      locals: {
        _typeof: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_typeof",
      dependencies: {}
    }),
    unsupportedIterableToArray: G("7.9.0", 'function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return arrayLikeToArray(r,\
a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Argum\
ents"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}}', {
      globals: ["Array"],
      locals: {
        _unsupportedIterableToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_unsupportedIterableToArray",
      dependencies: {
        arrayLikeToArray: ["body.0.body.body.0.consequent.body.0.consequent.argument.callee", "body.0.body.body.0.consequent.body.2.argument\
.expressions.1.alternate.consequent.callee"]
      }
    }),
    usingCtx: G("7.23.9", 'function _usingCtx(){var r="function"==typeof SuppressedError?SuppressedError:function(r,e){var n=Error();return \
n.name="SuppressedError",n.error=r,n.suppressed=e,n},e={},n=[];function using(r,e){if(null!=e){if(Object(e)!==e)throw new TypeError("using d\
eclarations can only be used with objects, functions, null, or undefined.");if(r)var o=e[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispos\
e")];if(void 0===o&&(o=e[Symbol.dispose||Symbol.for("Symbol.dispose")],r))var t=o;if("function"!=typeof o)throw new TypeError("Object is not\
 disposable.");t&&(o=function(){try{t.call(e)}catch(r){return Promise.reject(r)}}),n.push({v:e,d:o,a:r})}else r&&n.push({d:e,a:r});return e}\
return{e:e,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o,t=this.e,s=0;function next(){for(;o=n.pop();)try{if(!o.a&&1===s)re\
turn s=0,n.push(o),Promise.resolve().then(next);if(o.d){var r=o.d.call(o.v);if(o.a)return s|=2,Promise.resolve(r).then(next,err)}else s|=1}c\
atch(r){return err(r)}if(1===s)return t!==e?Promise.reject(t):Promise.resolve();if(t!==e)throw t}function err(n){return t=t!==e?new r(n,t):n\
,next()}return next()}}}', {
      globals: ["SuppressedError", "Error", "Object", "TypeError", "Symbol", "Promise"],
      locals: {
        _usingCtx: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_usingCtx",
      dependencies: {}
    }),
    wrapAsyncGenerator: G("7.0.0-beta.0", 'function _wrapAsyncGenerator(e){return function(){return new AsyncGenerator(e.apply(this,argument\
s))}}function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:\
o).then((function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"nor\
mal",t)}),(function(e){resume("throw",e)}))}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:\
!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,\
n){return new Promise((function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},"function"!=typeo\
f e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){ret\
urn this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._i\
nvoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};', {
      globals: ["Promise", "Symbol"],
      locals: {
        _wrapAsyncGenerator: ["body.0.id"],
        AsyncGenerator: ["body.1.id", "body.0.body.body.0.argument.body.body.0.argument.callee", "body.2.expression.expressions.0.left.objec\
t.object", "body.2.expression.expressions.1.left.object.object", "body.2.expression.expressions.2.left.object.object", "body.2.expression.ex\
pressions.3.left.object.object"]
      },
      exportBindingAssignments: [],
      exportName: "_wrapAsyncGenerator",
      dependencies: {
        OverloadYield: ["body.1.body.body.1.body.body.0.block.body.0.declarations.2.init.right"]
      }
    }),
    wrapNativeSuper: G("7.0.0-beta.0", 'function _wrapNativeSuper(t){var r="function"==typeof Map?new Map:void 0;return _wrapNativeSuper=fun\
ction(t){if(null===t||!isNativeFunction(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a f\
unction");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,Wrapper)}function Wrapper(){return construct(t,arguments,getPrototypeOf(this).c\
onstructor)}return Wrapper.prototype=Object.create(t.prototype,{constructor:{value:Wrapper,enumerable:!1,writable:!0,configurable:!0}}),setP\
rototypeOf(Wrapper,t)},_wrapNativeSuper(t)}', {
      globals: ["Map", "TypeError", "Object"],
      locals: {
        _wrapNativeSuper: ["body.0.id", "body.0.body.body.1.argument.expressions.1.callee", "body.0.body.body.1.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.1.argument.expressions.0"],
      exportName: "_wrapNativeSuper",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.arguments.2.object.callee"],
        setPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.4.argument.expressions.1.callee"],
        isNativeFunction: ["body.0.body.body.1.argument.expressions.0.right.body.body.0.test.right.argument.callee"],
        construct: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.callee"]
      }
    }),
    wrapRegExp: G("7.19.0", 'function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=n\
ew WeakMap;function BabelRegExp(e,t,p){var o=RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildG\
roups(e,t){var p=r.get(t);return Object.keys(p).reduce((function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e\
[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=functi\
on(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.p\
rototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)>/\
g,(function(e,r){var t=o[r];return"$"+(Array.isArray(t)?t.join("$"):t)})))}if("function"==typeof p){var i=this;return e[Symbol.replace].call\
(this,t,(function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)}))}ret\
urn e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}', {
      globals: ["RegExp", "WeakMap", "Object", "Symbol", "Array"],
      locals: {
        _wrapRegExp: ["body.0.id", "body.0.body.body.4.argument.expressions.3.callee.object", "body.0.body.body.0.expression.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.expression"],
      exportName: "_wrapRegExp",
      dependencies: {
        setPrototypeOf: ["body.0.body.body.2.body.body.1.argument.expressions.1.callee"],
        inherits: ["body.0.body.body.4.argument.expressions.0.callee"]
      }
    }),
    writeOnlyError: G("7.12.13", `function _writeOnlyError(r){throw new TypeError('"'+r+'" is write-only')}`, {
      globals: ["TypeError"],
      locals: {
        _writeOnlyError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_writeOnlyError",
      dependencies: {}
    })
  };
  Object.assign(EY, {
    AwaitValue: G("7.0.0-beta.0", "function _AwaitValue(t){this.wrapped=t}", {
      globals: [],
      locals: {
        _AwaitValue: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_AwaitValue",
      dependencies: {}
    }),
    applyDecs: G("7.17.8", 'function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"g\
etMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.pri\
vate;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_a\
ssertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.publ\
ic={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMa\
pToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.len\
gth;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.fro\
m(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadat\
a||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer\
"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;cas\
e 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isSta\
tic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,\
v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function\
(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v\
=!0}}function old_assertNotFinished(e,t){if(e.v)throw Error("attempted to call "+t+" after decoration was finished")}function old_assertMeta\
dataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("fun\
ction"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!\
==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&o\
ld_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,\
"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeError\
((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.ini\
t)&&(t=e.initializer)&&void 0!==console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberD\
ec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={set\
:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnPrope\
rtyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_member\
Dec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f\
=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1\
===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b)\
))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length\
;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.v\
alue=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}\
))):2===o?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(va\
r i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(\
v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw \
Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not c\
urrently supported by the decorators plugin. Property name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}o\
ld_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a]\
.call(e);return e}))}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{v\
ar c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d\
=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)}))\
}}function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyC\
lassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}', {
      globals: ["Object", "Map", "Symbol", "Array", "Error", "TypeError", "console"],
      locals: {
        old_createMetadataMethodsForProperty: ["body.0.id", "body.3.body.body.4.block.body.0.argument.arguments.1.arguments.1.callee", "body\
.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.1.callee"],
        old_convertMetadataMapToFinal: ["body.1.id", "body.13.body.body.1.argument.expressions.1.callee", "body.13.body.body.1.argument.expr\
essions.3.callee"],
        old_createAddInitializerMethod: ["body.2.id", "body.3.body.body.3.test.expressions.0.right.right.callee", "body.12.body.body.0.conse\
quent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.0.properties.2.value.callee"],
        old_memberDec: ["body.3.id", "body.9.body.body.1.consequent.expression.left.right.right.callee", "body.9.body.body.1.alternate.body.\
body.1.expression.left.right.right.callee"],
        old_assertNotFinished: ["body.4.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.0.callee", "\
body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.0.callee", "body.2.body.body.0.argument.body.body.0.expres\
sion.expressions.0.callee"],
        old_assertMetadataKey: ["body.5.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.1.callee", "\
body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.1.callee"],
        old_assertCallable: ["body.6.id", "body.2.body.body.0.argument.body.body.0.expression.expressions.1.callee", "body.7.body.body.1.con\
sequent.body.1.expression.expressions.0.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.1.right.callee", "body.7\
.body.body.1.consequent.body.1.expression.expressions.2.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.3.right.\
callee"],
        old_assertValidReturnValue: ["body.7.id", "body.9.body.body.1.consequent.expression.right.expressions.0.callee", "body.9.body.body.1\
.alternate.body.body.1.expression.right.expressions.0.callee", "body.12.body.body.0.consequent.body.0.body.body.2.expression.right.expressio\
ns.0.callee"],
        old_getInit: ["body.8.id", "body.9.body.body.1.consequent.expression.right.expressions.1.alternate.consequent.expressions.0.right.ca\
llee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee"],
        old_applyMemberDec: ["body.9.id", "body.10.body.body.0.body.body.1.consequent.body.2.expression.callee"],
        old_applyMemberDecs: ["body.10.id", "body.13.body.body.1.argument.expressions.0.callee"],
        old_pushInitializers: ["body.11.id", "body.10.body.body.1.expression.expressions.0.callee", "body.10.body.body.1.expression.expressi\
ons.1.callee"],
        old_applyClassDecs: ["body.12.id", "body.13.body.body.1.argument.expressions.2.callee"],
        applyDecs: ["body.13.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs",
      dependencies: {
        setFunctionName: ["body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.9.body.bo\
dy.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
        toPropertyKey: ["body.3.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
      }
    }),
    applyDecs2203: G("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){i\
f(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}functi\
on memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";br\
eak;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)\
),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=fun\
ction(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{retur\
n e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertVa\
lidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with g\
et, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.\
set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"meth\
od")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{ge\
t:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set\
}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),\
0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberDe\
c(h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g\
&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=type\
of l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.p\
ush(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.ca\
ll(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.definePropert\
y(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){v\
ar a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c\
.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&\
&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public met\
hod/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDe\
c(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-\
1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(\
assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;function\
 applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}', {
      globals: ["Error", "TypeError", "Object", "Map", "Array"],
      locals: {
        applyDecs2203Factory: ["body.0.id", "body.2.body.body.0.argument.callee.right.right.callee"],
        applyDecs2203Impl: ["body.1.declarations.0.id", "body.2.body.body.0.argument.callee.right.left", "body.2.body.body.0.argument.callee\
.left"],
        applyDecs2203: ["body.2.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs2203",
      dependencies: {}
    }),
    applyDecs2203R: G("7.20.0", 'function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t)\
{if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}func\
tion memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";\
break;default:c="field"}var l,u,f={kind:c,name:o?"#"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddIniti\
alizerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!=\
=a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:\
{set:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}\
function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return\
 an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable\
(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10=\
==e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o\
?(0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setFu\
nctionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2\
===a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"function"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0==\
=a?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v\
[g],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(\
void 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof \
l){var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push\
(l)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push((function(e,t){return f.get.call(\
e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t\
,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1]\
,p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0=\
==g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated\
 public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}ap\
plyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){fo\
r(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.len\
gth>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializ\
erMethod(r,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}\
}(e,r)}}}}function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}', {
      globals: ["Error", "TypeError", "Object", "Map", "Array"],
      locals: {
        applyDecs2203RFactory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"],
        applyDecs2203R: ["body.1.id", "body.1.body.body.0.argument.callee.left"]
      },
      exportBindingAssignments: ["body.1.body.body.0.argument.callee"],
      exportName: "applyDecs2203R",
      dependencies: {
        setFunctionName: ["body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "bo\
dy.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
        toPropertyKey: ["body.0.body.body.1.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
      }
    }),
    applyDecs2301: G("7.21.0", 'function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){i\
f(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}functi\
on assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r\
,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="f\
ield"}var l,f,p={kind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,\
d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e)\
{return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivat\
e(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():fu\
nction(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCa\
llable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===\
e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");vo\
id 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.in\
it,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function o\
r void 0")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(\
0===a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f="\
set"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnPrope\
rtyDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec(\
g,n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var\
 m=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||\
p.get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===\
l)l=function(e,t){return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}\
else{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.s\
et=p),s?1===a?(e.push((function(e,t){return p.get.call(e,t)})),e.push((function(e,t){return p.set.call(e,t)}))):2===a?e.push(p):e.push((func\
tion(e,t){return p.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t\
.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=functi\
on(t){return checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b\
&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor.\
 This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y\
,v,p,g)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r\
++)t[r].call(e);return e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[\
],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}fi\
nally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function\
 applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}', {
      globals: ["Error", "TypeError", "Object", "Map", "Array"],
      locals: {
        applyDecs2301Factory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"],
        applyDecs2301: ["body.1.id", "body.1.body.body.0.argument.callee.left"]
      },
      exportBindingAssignments: ["body.1.body.body.0.argument.callee"],
      exportName: "applyDecs2301",
      dependencies: {
        checkInRHS: ["body.0.body.body.7.body.body.0.body.body.1.consequent.body.1.test.expressions.0.consequent.expressions.2.right.right.b\
ody.body.0.argument.left.callee"],
        setFunctionName: ["body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "bo\
dy.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
        toPropertyKey: ["body.0.body.body.2.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
      }
    }),
    applyDecs2305: G("7.21.0", 'function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}fu\
nction c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeEr\
ror(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))\
throw new TypeError("Attempted to access private element on non-instance")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var \
w={},S=[],A=3===o?"get":4===o||d?"set":"value";f?(p||d?w={get:setFunctionName((function(){return g(this)}),n,"get"),set:function(e){t[4](thi\
s,e)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?"":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){var\
 D=v[j],E=r?v[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function(\
e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(null\
,I)};try{if(b)(y=s(D.call(E,P,O),"class decorators","return"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e),\
w.value}:(o<4&&(k=i(w,"get",m)),3!==o&&(F=i(w,"set",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.access\
={has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if("object"==typeof \
P&&P)(y=s(P.get,"accessor.get"))&&(w.get=y),(y=s(P.set,"accessor.set"))&&(w.set=y),(y=s(P.init,"accessor.init"))&&S.push(y);else if(void 0!=\
=P)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(P,(p?"field":"method"\
)+" decorators","return")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push((function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].ca\
ll(e,t);return t})),p||b||(f?d?u.push(i(w,"get"),i(w,"set")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function u\
(e,t){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.le\
ngth>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=funct\
ion(t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p\
)){var d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)thr\
ow Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is no\
t currently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyKe\
y(h),d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.leng\
th&&[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}', {
      globals: ["TypeError", "Array", "Object", "Error", "Symbol", "Map"],
      locals: {
        applyDecs2305: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs2305",
      dependencies: {
        checkInRHS: ["body.0.body.body.6.declarations.1.init.callee.body.body.0.declarations.3.init.body.body.0.argument.left.callee"],
        setFunctionName: ["body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.0.consequent.right.properties.\
0.value.callee", "body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.1.right.callee"],
        toPropertyKey: ["body.0.body.body.6.declarations.1.init.callee.body.body.2.body.body.1.consequent.body.2.expression.arguments.3.alte\
rnate.callee"]
      }
    }),
    classApplyDescriptorDestructureSet: G("7.13.10", 'function _classApplyDescriptorDestructureSet(e,t){if(t.set)return"__destrObj"in t||(t.\
__destrObj={set value(r){t.set.call(e,r)}}),t.__destrObj;if(!t.writable)throw new TypeError("attempted to set read only private field");retu\
rn t}', {
      globals: ["TypeError"],
      locals: {
        _classApplyDescriptorDestructureSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classApplyDescriptorDestructureSet",
      dependencies: {}
    }),
    classApplyDescriptorGet: G("7.13.10", "function _classApplyDescriptorGet(e,t){return t.get?t.get.call(e):t.value}", {
      globals: [],
      locals: {
        _classApplyDescriptorGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classApplyDescriptorGet",
      dependencies: {}
    }),
    classApplyDescriptorSet: G("7.13.10", 'function _classApplyDescriptorSet(e,t,l){if(t.set)t.set.call(e,l);else{if(!t.writable)throw new T\
ypeError("attempted to set read only private field");t.value=l}}', {
      globals: ["TypeError"],
      locals: {
        _classApplyDescriptorSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classApplyDescriptorSet",
      dependencies: {}
    }),
    classCheckPrivateStaticAccess: G("7.13.10", "function _classCheckPrivateStaticAccess(s,a,r){return assertClassBrand(a,s,r)}", {
      globals: [],
      locals: {
        _classCheckPrivateStaticAccess: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classCheckPrivateStaticAccess",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.callee"]
      }
    }),
    classCheckPrivateStaticFieldDescriptor: G("7.13.10", 'function _classCheckPrivateStaticFieldDescriptor(t,e){if(void 0===t)throw new Type\
Error("attempted to "+e+" private static field before its declaration")}', {
      globals: ["TypeError"],
      locals: {
        _classCheckPrivateStaticFieldDescriptor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classCheckPrivateStaticFieldDescriptor",
      dependencies: {}
    }),
    classExtractFieldDescriptor: G("7.13.10", "function _classExtractFieldDescriptor(e,t){return classPrivateFieldGet2(t,e)}", {
      globals: [],
      locals: {
        _classExtractFieldDescriptor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classExtractFieldDescriptor",
      dependencies: {
        classPrivateFieldGet2: ["body.0.body.body.0.argument.callee"]
      }
    }),
    classPrivateFieldDestructureSet: G("7.4.4", "function _classPrivateFieldDestructureSet(e,t){var r=classPrivateFieldGet2(t,e);return clas\
sApplyDescriptorDestructureSet(e,r)}", {
      globals: [],
      locals: {
        _classPrivateFieldDestructureSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldDestructureSet",
      dependencies: {
        classApplyDescriptorDestructureSet: ["body.0.body.body.1.argument.callee"],
        classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
      }
    }),
    classPrivateFieldGet: G("7.0.0-beta.0", "function _classPrivateFieldGet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescripto\
rGet(e,r)}", {
      globals: [],
      locals: {
        _classPrivateFieldGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldGet",
      dependencies: {
        classApplyDescriptorGet: ["body.0.body.body.1.argument.callee"],
        classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
      }
    }),
    classPrivateFieldSet: G("7.0.0-beta.0", "function _classPrivateFieldSet(e,t,r){var s=classPrivateFieldGet2(t,e);return classApplyDescrip\
torSet(e,s,r),r}", {
      globals: [],
      locals: {
        _classPrivateFieldSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldSet",
      dependencies: {
        classApplyDescriptorSet: ["body.0.body.body.1.argument.expressions.0.callee"],
        classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
      }
    }),
    classPrivateMethodGet: G("7.1.6", "function _classPrivateMethodGet(s,a,r){return assertClassBrand(a,s),r}", {
      globals: [],
      locals: {
        _classPrivateMethodGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateMethodGet",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"]
      }
    }),
    classPrivateMethodSet: G("7.1.6", 'function _classPrivateMethodSet(){throw new TypeError("attempted to reassign private method")}', {
      globals: ["TypeError"],
      locals: {
        _classPrivateMethodSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateMethodSet",
      dependencies: {}
    }),
    classStaticPrivateFieldDestructureSet: G("7.13.10", 'function _classStaticPrivateFieldDestructureSet(t,r,s){return assertClassBrand(r,t)\
,classCheckPrivateStaticFieldDescriptor(s,"set"),classApplyDescriptorDestructureSet(t,s)}', {
      globals: [],
      locals: {
        _classStaticPrivateFieldDestructureSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateFieldDestructureSet",
      dependencies: {
        classApplyDescriptorDestructureSet: ["body.0.body.body.0.argument.expressions.2.callee"],
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
        classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
      }
    }),
    classStaticPrivateFieldSpecGet: G("7.0.2", 'function _classStaticPrivateFieldSpecGet(t,s,r){return assertClassBrand(s,t),classCheckPriva\
teStaticFieldDescriptor(r,"get"),classApplyDescriptorGet(t,r)}', {
      globals: [],
      locals: {
        _classStaticPrivateFieldSpecGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateFieldSpecGet",
      dependencies: {
        classApplyDescriptorGet: ["body.0.body.body.0.argument.expressions.2.callee"],
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
        classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
      }
    }),
    classStaticPrivateFieldSpecSet: G("7.0.2", 'function _classStaticPrivateFieldSpecSet(s,t,r,e){return assertClassBrand(t,s),classCheckPri\
vateStaticFieldDescriptor(r,"set"),classApplyDescriptorSet(s,r,e),e}', {
      globals: [],
      locals: {
        _classStaticPrivateFieldSpecSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateFieldSpecSet",
      dependencies: {
        classApplyDescriptorSet: ["body.0.body.body.0.argument.expressions.2.callee"],
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
        classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
      }
    }),
    classStaticPrivateMethodSet: G("7.3.2", 'function _classStaticPrivateMethodSet(){throw new TypeError("attempted to set read only static \
private field")}', {
      globals: ["TypeError"],
      locals: {
        _classStaticPrivateMethodSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateMethodSet",
      dependencies: {}
    }),
    defineEnumerableProperties: G("7.0.0-beta.0", 'function _defineEnumerableProperties(e,r){for(var t in r){var n=r[t];n.configurable=n.enu\
merable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,t,n)}if(Object.getOwnPropertySymbols)for(var a=Object.getOwnPropertySymbols(\
r),b=0;b<a.length;b++){var i=a[b];(n=r[i]).configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,i,n)}return e}',
    {
      globals: ["Object"],
      locals: {
        _defineEnumerableProperties: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defineEnumerableProperties",
      dependencies: {}
    }),
    dispose: G("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=Suppressed\
Error:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=Error().stack},dispose_SuppressedError.prototype=Obje\
ct.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}funct\
ion _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch\
(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}', {
      globals: ["SuppressedError", "Error", "Object", "Promise"],
      locals: {
        dispose_SuppressedError: ["body.0.id", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.left.object", "body.0.body\
.body.0.argument.expressions.0.alternate.expressions.1.right.arguments.1.properties.0.value.properties.0.value", "body.0.body.body.0.argumen\
t.expressions.1.callee", "body.1.body.body.1.body.body.0.argument.expressions.0.right.consequent.callee", "body.0.body.body.0.argument.expre\
ssions.0.consequent.left", "body.0.body.body.0.argument.expressions.0.alternate.expressions.0.left"],
        _dispose: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_dispose",
      dependencies: {}
    }),
    objectSpread: G("7.0.0-beta.0", 'function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?Object(arguments\
[r]):{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&o.push.apply(o,Object.getOwnPropertySymbols(t).filter((function(e)\
{return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.forEach((function(r){defineProperty(e,r,t[r])}))}return e}', {
      globals: ["Object"],
      locals: {
        _objectSpread: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectSpread",
      dependencies: {
        defineProperty: ["body.0.body.body.0.body.body.1.expression.expressions.1.arguments.0.body.body.0.expression.callee"]
      }
    }),
    using: G("7.22.0", 'function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations can only be used\
 with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=n[Symbol\
.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.p\
ush({v:n,d:r,a:e}),n}', {
      globals: ["Object", "TypeError", "Symbol"],
      locals: {
        _using: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_using",
      dependencies: {}
    })
  });
});

// ../node_modules/@babel/helpers/lib/index.js
var om = T((pn) => {
  "use strict";
  Object.defineProperty(pn, "__esModule", {
    value: !0
  });
  pn.default = void 0;
  pn.get = Sx;
  pn.getDependencies = PY;
  pn.list = void 0;
  pn.minVersion = SY;
  var vY = Pe(), xx = vx(), {
    cloneNode: TY,
    identifier: Tx
  } = vY;
  function nu(e, t, r) {
    try {
      let n = t.split("."), i = n.shift();
      for (; n.length > 0; )
        e = e[i], i = n.shift();
      if (arguments.length > 2)
        e[i] = r;
      else
        return e[i];
    } catch (n) {
      throw n.message += ` (when accessing ${t})`, n;
    }
  }
  s(nu, "deep");
  function xY(e, t, r, n, i, a) {
    let {
      locals: o,
      dependencies: l,
      exportBindingAssignments: u,
      exportName: c
    } = t, f = new Set(n || []);
    r && f.add(r);
    for (let [p, h] of (Object.entries || ((y) => Object.keys(y).map((v) => [v, y[v]])))(o)) {
      let y = p;
      if (r && p === c)
        y = r;
      else
        for (; f.has(y); ) y = "_" + y;
      if (y !== p)
        for (let v of h)
          nu(e, v, Tx(y));
    }
    for (let [p, h] of (Object.entries || ((y) => Object.keys(y).map((v) => [v, y[v]])))(l)) {
      let y = typeof i == "function" && i(p) || Tx(p);
      for (let v of h)
        nu(e, v, TY(y));
    }
    a?.(e, c, (p) => {
      u.forEach((h) => nu(e, h, p(nu(e, h))));
    });
  }
  s(xY, "permuteHelperAST");
  var am = /* @__PURE__ */ Object.create(null);
  function su(e) {
    if (!am[e]) {
      let t = xx.default[e];
      if (!t)
        throw Object.assign(new ReferenceError(`Unknown helper ${e}`), {
          code: "BABEL_HELPER_UNKNOWN",
          helper: e
        });
      am[e] = {
        minVersion: t.minVersion,
        build(r, n, i, a) {
          let o = t.ast();
          return xY(o, t.metadata, n, i, r, a), {
            nodes: o.body,
            globals: t.metadata.globals
          };
        },
        getDependencies() {
          return Object.keys(t.metadata.dependencies);
        }
      };
    }
    return am[e];
  }
  s(su, "loadHelper");
  function Sx(e, t, r, n, i) {
    if (typeof r == "object") {
      let a = r;
      a?.type === "Identifier" ? r = a.name : r = void 0;
    }
    return su(e).build(t, r, n, i);
  }
  s(Sx, "get");
  function SY(e) {
    return su(e).minVersion;
  }
  s(SY, "minVersion");
  function PY(e) {
    return su(e).getDependencies();
  }
  s(PY, "getDependencies");
  pn.ensure = (e) => {
    su(e);
  };
  var EPe = pn.list = Object.keys(xx.default).map((e) => e.replace(/^_/, "")), vPe = pn.default = Sx;
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var lm = T((We) => {
  "use strict";
  Object.defineProperty(We, "__esModule", {
    value: !0
  });
  We.Var = We.User = We.Statement = We.SpreadProperty = We.Scope = We.RestProperty = We.ReferencedMemberExpression = We.ReferencedIdentifier =
  We.Referenced = We.Pure = We.NumericLiteralTypeAnnotation = We.Generated = We.ForAwaitStatement = We.Flow = We.Expression = We.ExistentialTypeParam =
  We.BlockScoped = We.BindingIdentifier = void 0;
  var SPe = We.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], PPe = We.ReferencedMemberExpression = ["MemberExpression"], APe = We.
  BindingIdentifier = ["Identifier"], CPe = We.Statement = ["Statement"], wPe = We.Expression = ["Expression"], DPe = We.Scope = ["Scopable",
  "Pattern"], IPe = We.Referenced = null, _Pe = We.BlockScoped = null, OPe = We.Var = ["VariableDeclaration"], NPe = We.User = null, BPe = We.
  Generated = null, kPe = We.Pure = null, FPe = We.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], jPe = We.RestProperty =
  ["RestElement"], LPe = We.SpreadProperty = ["RestElement"], MPe = We.ExistentialTypeParam = ["ExistsTypeAnnotation"], RPe = We.NumericLiteralTypeAnnotation =
  ["NumberLiteralTypeAnnotation"], qPe = We.ForAwaitStatement = ["ForOfStatement"];
});

// ../node_modules/debug/node_modules/ms/index.js
var Ax = T((VPe, Px) => {
  var Bi = 1e3, ki = Bi * 60, Fi = ki * 60, Rs = Fi * 24, AY = Rs * 7, CY = Rs * 365.25;
  Px.exports = function(e, t) {
    t = t || {};
    var r = typeof e;
    if (r === "string" && e.length > 0)
      return wY(e);
    if (r === "number" && isFinite(e))
      return t.long ? IY(e) : DY(e);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(e)
    );
  };
  function wY(e) {
    if (e = String(e), !(e.length > 100)) {
      var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.
      exec(
        e
      );
      if (t) {
        var r = parseFloat(t[1]), n = (t[2] || "ms").toLowerCase();
        switch (n) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return r * CY;
          case "weeks":
          case "week":
          case "w":
            return r * AY;
          case "days":
          case "day":
          case "d":
            return r * Rs;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return r * Fi;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return r * ki;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return r * Bi;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return r;
          default:
            return;
        }
      }
    }
  }
  s(wY, "parse");
  function DY(e) {
    var t = Math.abs(e);
    return t >= Rs ? Math.round(e / Rs) + "d" : t >= Fi ? Math.round(e / Fi) + "h" : t >= ki ? Math.round(e / ki) + "m" : t >= Bi ? Math.round(
    e / Bi) + "s" : e + "ms";
  }
  s(DY, "fmtShort");
  function IY(e) {
    var t = Math.abs(e);
    return t >= Rs ? iu(e, t, Rs, "day") : t >= Fi ? iu(e, t, Fi, "hour") : t >= ki ? iu(e, t, ki, "minute") : t >= Bi ? iu(e, t, Bi, "secon\
d") : e + " ms";
  }
  s(IY, "fmtLong");
  function iu(e, t, r, n) {
    var i = t >= r * 1.5;
    return Math.round(e / r) + " " + n + (i ? "s" : "");
  }
  s(iu, "plural");
});

// ../node_modules/debug/src/common.js
var um = T((WPe, Cx) => {
  function _Y(e) {
    r.debug = r, r.default = r, r.coerce = u, r.disable = a, r.enable = i, r.enabled = o, r.humanize = Ax(), r.destroy = c, Object.keys(e).forEach(
    (f) => {
      r[f] = e[f];
    }), r.names = [], r.skips = [], r.formatters = {};
    function t(f) {
      let p = 0;
      for (let h = 0; h < f.length; h++)
        p = (p << 5) - p + f.charCodeAt(h), p |= 0;
      return r.colors[Math.abs(p) % r.colors.length];
    }
    s(t, "selectColor"), r.selectColor = t;
    function r(f) {
      let p, h = null, y, v;
      function d(...b) {
        if (!d.enabled)
          return;
        let E = d, I = Number(/* @__PURE__ */ new Date()), O = I - (p || I);
        E.diff = O, E.prev = p, E.curr = I, p = I, b[0] = r.coerce(b[0]), typeof b[0] != "string" && b.unshift("%O");
        let k = 0;
        b[0] = b[0].replace(/%([a-zA-Z%])/g, (R, U) => {
          if (R === "%%")
            return "%";
          k++;
          let Q = r.formatters[U];
          if (typeof Q == "function") {
            let W = b[k];
            R = Q.call(E, W), b.splice(k, 1), k--;
          }
          return R;
        }), r.formatArgs.call(E, b), (E.log || r.log).apply(E, b);
      }
      return s(d, "debug"), d.namespace = f, d.useColors = r.useColors(), d.color = r.selectColor(f), d.extend = n, d.destroy = r.destroy, Object.
      defineProperty(d, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: /* @__PURE__ */ s(() => h !== null ? h : (y !== r.namespaces && (y = r.namespaces, v = r.enabled(f)), v), "get"),
        set: /* @__PURE__ */ s((b) => {
          h = b;
        }, "set")
      }), typeof r.init == "function" && r.init(d), d;
    }
    s(r, "createDebug");
    function n(f, p) {
      let h = r(this.namespace + (typeof p > "u" ? ":" : p) + f);
      return h.log = this.log, h;
    }
    s(n, "extend");
    function i(f) {
      r.save(f), r.namespaces = f, r.names = [], r.skips = [];
      let p, h = (typeof f == "string" ? f : "").split(/[\s,]+/), y = h.length;
      for (p = 0; p < y; p++)
        h[p] && (f = h[p].replace(/\*/g, ".*?"), f[0] === "-" ? r.skips.push(new RegExp("^" + f.slice(1) + "$")) : r.names.push(new RegExp("\
^" + f + "$")));
    }
    s(i, "enable");
    function a() {
      let f = [
        ...r.names.map(l),
        ...r.skips.map(l).map((p) => "-" + p)
      ].join(",");
      return r.enable(""), f;
    }
    s(a, "disable");
    function o(f) {
      if (f[f.length - 1] === "*")
        return !0;
      let p, h;
      for (p = 0, h = r.skips.length; p < h; p++)
        if (r.skips[p].test(f))
          return !1;
      for (p = 0, h = r.names.length; p < h; p++)
        if (r.names[p].test(f))
          return !0;
      return !1;
    }
    s(o, "enabled");
    function l(f) {
      return f.toString().substring(2, f.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    s(l, "toNamespace");
    function u(f) {
      return f instanceof Error ? f.stack || f.message : f;
    }
    s(u, "coerce");
    function c() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major versio\
n of `debug`.");
    }
    return s(c, "destroy"), r.enable(r.load()), r;
  }
  s(_Y, "setup");
  Cx.exports = _Y;
});

// ../node_modules/debug/src/browser.js
var wx = T((gr, au) => {
  gr.formatArgs = NY;
  gr.save = BY;
  gr.load = kY;
  gr.useColors = OY;
  gr.storage = FY();
  gr.destroy = /* @__PURE__ */ (() => {
    let e = !1;
    return () => {
      e || (e = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the nex\
t major version of `debug`."));
    };
  })();
  gr.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function OY() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let e;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
    // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (e = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(e[1], 10) >=
    31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  s(OY, "useColors");
  function NY(e) {
    if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" +
    au.exports.humanize(this.diff), !this.useColors)
      return;
    let t = "color: " + this.color;
    e.splice(1, 0, t, "color: inherit");
    let r = 0, n = 0;
    e[0].replace(/%[a-zA-Z%]/g, (i) => {
      i !== "%%" && (r++, i === "%c" && (n = r));
    }), e.splice(n, 0, t);
  }
  s(NY, "formatArgs");
  gr.log = console.debug || console.log || (() => {
  });
  function BY(e) {
    try {
      e ? gr.storage.setItem("debug", e) : gr.storage.removeItem("debug");
    } catch {
    }
  }
  s(BY, "save");
  function kY() {
    let e;
    try {
      e = gr.storage.getItem("debug");
    } catch {
    }
    return !e && typeof process < "u" && "env" in process && (e = process.env.DEBUG), e;
  }
  s(kY, "load");
  function FY() {
    try {
      return localStorage;
    } catch {
    }
  }
  s(FY, "localstorage");
  au.exports = um()(gr);
  var { formatters: jY } = au.exports;
  jY.j = function(e) {
    try {
      return JSON.stringify(e);
    } catch (t) {
      return "[UnexpectedJSONParseError]: " + t.message;
    }
  };
});

// ../node_modules/has-flag/index.js
var Ix = T((HPe, Dx) => {
  "use strict";
  Dx.exports = (e, t = process.argv) => {
    let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t.indexOf(r + e), i = t.indexOf("--");
    return n !== -1 && (i === -1 || n < i);
  };
});

// ../node_modules/supports-color/index.js
var Nx = T((YPe, Ox) => {
  "use strict";
  var LY = ie("os"), _x = ie("tty"), Ir = Ix(), { env: jt } = process, ss;
  Ir("no-color") || Ir("no-colors") || Ir("color=false") || Ir("color=never") ? ss = 0 : (Ir("color") || Ir("colors") || Ir("color=true") ||
  Ir("color=always")) && (ss = 1);
  "FORCE_COLOR" in jt && (jt.FORCE_COLOR === "true" ? ss = 1 : jt.FORCE_COLOR === "false" ? ss = 0 : ss = jt.FORCE_COLOR.length === 0 ? 1 : Math.
  min(parseInt(jt.FORCE_COLOR, 10), 3));
  function cm(e) {
    return e === 0 ? !1 : {
      level: e,
      hasBasic: !0,
      has256: e >= 2,
      has16m: e >= 3
    };
  }
  s(cm, "translateLevel");
  function fm(e, t) {
    if (ss === 0)
      return 0;
    if (Ir("color=16m") || Ir("color=full") || Ir("color=truecolor"))
      return 3;
    if (Ir("color=256"))
      return 2;
    if (e && !t && ss === void 0)
      return 0;
    let r = ss || 0;
    if (jt.TERM === "dumb")
      return r;
    if (process.platform === "win32") {
      let n = LY.release().split(".");
      return Number(n[0]) >= 10 && Number(n[2]) >= 10586 ? Number(n[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in jt)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n) => n in jt) || jt.CI_NAME === "codeship" ?
      1 : r;
    if ("TEAMCITY_VERSION" in jt)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(jt.TEAMCITY_VERSION) ? 1 : 0;
    if (jt.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in jt) {
      let n = parseInt((jt.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (jt.TERM_PROGRAM) {
        case "iTerm.app":
          return n >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(jt.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(jt.TERM) || "COLORTERM" in
    jt ? 1 : r;
  }
  s(fm, "supportsColor");
  function MY(e) {
    let t = fm(e, e && e.isTTY);
    return cm(t);
  }
  s(MY, "getSupportLevel");
  Ox.exports = {
    supportsColor: MY,
    stdout: cm(fm(!0, _x.isatty(1))),
    stderr: cm(fm(!0, _x.isatty(2)))
  };
});

// ../node_modules/debug/src/node.js
var kx = T((Lt, lu) => {
  var RY = ie("tty"), ou = ie("util");
  Lt.init = GY;
  Lt.log = $Y;
  Lt.formatArgs = UY;
  Lt.save = WY;
  Lt.load = KY;
  Lt.useColors = qY;
  Lt.destroy = ou.deprecate(
    () => {
    },
    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
  );
  Lt.colors = [6, 2, 3, 4, 5, 1];
  try {
    let e = Nx();
    e && (e.stderr || e).level >= 2 && (Lt.colors = [
      20,
      21,
      26,
      27,
      32,
      33,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      56,
      57,
      62,
      63,
      68,
      69,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      92,
      93,
      98,
      99,
      112,
      113,
      128,
      129,
      134,
      135,
      148,
      149,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      178,
      179,
      184,
      185,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      214,
      215,
      220,
      221
    ]);
  } catch {
  }
  Lt.inspectOpts = Object.keys(process.env).filter((e) => /^debug_/i.test(e)).reduce((e, t) => {
    let r = t.substring(6).toLowerCase().replace(/_([a-z])/g, (i, a) => a.toUpperCase()), n = process.env[t];
    return /^(yes|on|true|enabled)$/i.test(n) ? n = !0 : /^(no|off|false|disabled)$/i.test(n) ? n = !1 : n === "null" ? n = null : n = Number(
    n), e[r] = n, e;
  }, {});
  function qY() {
    return "colors" in Lt.inspectOpts ? !!Lt.inspectOpts.colors : RY.isatty(process.stderr.fd);
  }
  s(qY, "useColors");
  function UY(e) {
    let { namespace: t, useColors: r } = this;
    if (r) {
      let n = this.color, i = "\x1B[3" + (n < 8 ? n : "8;5;" + n), a = `  ${i};1m${t} \x1B[0m`;
      e[0] = a + e[0].split(`
`).join(`
` + a), e.push(i + "m+" + lu.exports.humanize(this.diff) + "\x1B[0m");
    } else
      e[0] = VY() + t + " " + e[0];
  }
  s(UY, "formatArgs");
  function VY() {
    return Lt.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
  }
  s(VY, "getDate");
  function $Y(...e) {
    return process.stderr.write(ou.formatWithOptions(Lt.inspectOpts, ...e) + `
`);
  }
  s($Y, "log");
  function WY(e) {
    e ? process.env.DEBUG = e : delete process.env.DEBUG;
  }
  s(WY, "save");
  function KY() {
    return process.env.DEBUG;
  }
  s(KY, "load");
  function GY(e) {
    e.inspectOpts = {};
    let t = Object.keys(Lt.inspectOpts);
    for (let r = 0; r < t.length; r++)
      e.inspectOpts[t[r]] = Lt.inspectOpts[t[r]];
  }
  s(GY, "init");
  lu.exports = um()(Lt);
  var { formatters: Bx } = lu.exports;
  Bx.o = function(e) {
    return this.inspectOpts.colors = this.useColors, ou.inspect(e, this.inspectOpts).split(`
`).map((t) => t.trim()).join(" ");
  };
  Bx.O = function(e) {
    return this.inspectOpts.colors = this.useColors, ou.inspect(e, this.inspectOpts);
  };
});

// ../node_modules/debug/src/index.js
var qs = T((XPe, pm) => {
  typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? pm.exports = wx() : pm.exports = kx();
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var hm = T((_t) => {
  "use strict";
  Object.defineProperty(_t, "__esModule", {
    value: !0
  });
  _t.isBindingIdentifier = mz;
  _t.isBlockScoped = vz;
  _t.isExpression = gz;
  _t.isFlow = Az;
  _t.isForAwaitStatement = Dz;
  _t.isGenerated = Sz;
  _t.isPure = Pz;
  _t.isReferenced = Ez;
  _t.isReferencedIdentifier = dz;
  _t.isReferencedMemberExpression = hz;
  _t.isRestProperty = Cz;
  _t.isScope = bz;
  _t.isSpreadProperty = wz;
  _t.isStatement = yz;
  _t.isUser = xz;
  _t.isVar = Tz;
  var HY = Pe(), {
    isBinding: YY,
    isBlockScoped: zY,
    isExportDeclaration: JY,
    isExpression: XY,
    isFlow: QY,
    isForStatement: ZY,
    isForXStatement: ez,
    isIdentifier: Fx,
    isImportDeclaration: tz,
    isImportSpecifier: rz,
    isJSXIdentifier: nz,
    isJSXMemberExpression: sz,
    isMemberExpression: iz,
    isRestElement: jx,
    isReferenced: dm,
    isScope: az,
    isStatement: oz,
    isVar: lz,
    isVariableDeclaration: uz,
    react: cz,
    isForOfStatement: fz
  } = HY, {
    isCompatTag: pz
  } = cz;
  function dz(e) {
    let {
      node: t,
      parent: r
    } = this;
    if (!Fx(t, e) && !sz(r, e))
      if (nz(t, e)) {
        if (pz(t.name)) return !1;
      } else
        return !1;
    return dm(t, r, this.parentPath.parent);
  }
  s(dz, "isReferencedIdentifier");
  function hz() {
    let {
      node: e,
      parent: t
    } = this;
    return iz(e) && dm(e, t);
  }
  s(hz, "isReferencedMemberExpression");
  function mz() {
    let {
      node: e,
      parent: t
    } = this, r = this.parentPath.parent;
    return Fx(e) && YY(e, t, r);
  }
  s(mz, "isBindingIdentifier");
  function yz() {
    let {
      node: e,
      parent: t
    } = this;
    return oz(e) ? !(uz(e) && (ez(t, {
      left: e
    }) || ZY(t, {
      init: e
    }))) : !1;
  }
  s(yz, "isStatement");
  function gz() {
    return this.isIdentifier() ? this.isReferencedIdentifier() : XY(this.node);
  }
  s(gz, "isExpression");
  function bz() {
    return az(this.node, this.parent);
  }
  s(bz, "isScope");
  function Ez() {
    return dm(this.node, this.parent);
  }
  s(Ez, "isReferenced");
  function vz() {
    return zY(this.node);
  }
  s(vz, "isBlockScoped");
  function Tz() {
    return lz(this.node);
  }
  s(Tz, "isVar");
  function xz() {
    return this.node && !!this.node.loc;
  }
  s(xz, "isUser");
  function Sz() {
    return !this.isUser();
  }
  s(Sz, "isGenerated");
  function Pz(e) {
    return this.scope.isPure(this.node, e);
  }
  s(Pz, "isPure");
  function Az() {
    let {
      node: e
    } = this;
    return QY(e) ? !0 : tz(e) ? e.importKind === "type" || e.importKind === "typeof" : JY(e) ? e.exportKind === "type" : rz(e) ? e.importKind ===
    "type" || e.importKind === "typeof" : !1;
  }
  s(Az, "isFlow");
  function Cz() {
    var e;
    return jx(this.node) && ((e = this.parentPath) == null ? void 0 : e.isObjectPattern());
  }
  s(Cz, "isRestProperty");
  function wz() {
    var e;
    return jx(this.node) && ((e = this.parentPath) == null ? void 0 : e.isObjectExpression());
  }
  s(wz, "isSpreadProperty");
  function Dz() {
    return fz(this.node, {
      await: !0
    });
  }
  s(Dz, "isForAwaitStatement");
  _t.isExistentialTypeParam = /* @__PURE__ */ s(function() {
    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
  }, "isExistentialTypeParam"), _t.isNumericLiteralTypeAnnotation = /* @__PURE__ */ s(function() {
    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
  }, "isNumericLiteralTypeAnnotation");
});

// ../node_modules/@babel/traverse/lib/visitors.js
var io = T((Vs) => {
  "use strict";
  Object.defineProperty(Vs, "__esModule", {
    value: !0
  });
  Vs.environmentVisitor = jz;
  Vs.explode = Hx;
  Vs.isExplodedVisitor = Gx;
  Vs.merge = zx;
  Vs.verify = Yx;
  var Kx = lm(), Iz = hm(), _z = Pe(), Lx = ji(), {
    DEPRECATED_KEYS: Mx,
    DEPRECATED_ALIASES: Rx,
    FLIPPED_ALIAS_KEYS: qx,
    TYPES: Oz,
    __internal__deprecationWarning: Ux
  } = _z;
  function Nz(e) {
    return e in Kx;
  }
  s(Nz, "isVirtualType");
  function Gx(e) {
    return e?._exploded;
  }
  s(Gx, "isExplodedVisitor");
  function Hx(e) {
    if (Gx(e)) return e;
    e._exploded = !0;
    for (let t of Object.keys(e)) {
      if (Us(t)) continue;
      let r = t.split("|");
      if (r.length === 1) continue;
      let n = e[t];
      delete e[t];
      for (let i of r)
        e[i] = n;
    }
    Yx(e), delete e.__esModule, Bz(e), Wx(e);
    for (let t of Object.keys(e)) {
      if (Us(t) || !Nz(t)) continue;
      let r = e[t];
      for (let i of Object.keys(r))
        r[i] = kz(t, r[i]);
      delete e[t];
      let n = Kx[t];
      if (n !== null)
        for (let i of n)
          e[i] ? so(e[i], r) : e[i] = r;
      else
        so(e, r);
    }
    for (let t of Object.keys(e)) {
      if (Us(t)) continue;
      let r = qx[t];
      if (t in Mx) {
        let i = Mx[t];
        Ux(t, i, "Visitor "), r = [i];
      } else if (t in Rx) {
        let i = Rx[t];
        Ux(t, i, "Visitor "), r = qx[i];
      }
      if (!r) continue;
      let n = e[t];
      delete e[t];
      for (let i of r) {
        let a = e[i];
        a ? so(a, n) : e[i] = Object.assign({}, n);
      }
    }
    for (let t of Object.keys(e))
      Us(t) || Wx(e[t]);
    return e;
  }
  s(Hx, "explode$1");
  function Yx(e) {
    if (!e._verified) {
      if (typeof e == "function")
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Functi\
on }`?");
      for (let t of Object.keys(e)) {
        if ((t === "enter" || t === "exit") && Vx(t, e[t]), Us(t)) continue;
        if (!Oz.includes(t))
          throw new Error(`You gave us a visitor for the node type ${t} but it's not a valid type in @babel/traverse 7.25.3`);
        let r = e[t];
        if (typeof r == "object")
          for (let n of Object.keys(r))
            if (n === "enter" || n === "exit")
              Vx(`${t}.${n}`, r[n]);
            else
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${t} that has the invalid property ${n}`);
      }
      e._verified = !0;
    }
  }
  s(Yx, "verify$1");
  function Vx(e, t) {
    let r = [].concat(t);
    for (let n of r)
      if (typeof n != "function")
        throw new TypeError(`Non-function found defined in ${e} with type ${typeof n}`);
  }
  s(Vx, "validateVisitorMethods");
  function zx(e, t = [], r) {
    let n = {
      _verified: !0,
      _exploded: !0
    };
    Object.defineProperty(n, "_exploded", {
      enumerable: !1
    }), Object.defineProperty(n, "_verified", {
      enumerable: !1
    });
    for (let i = 0; i < e.length; i++) {
      let a = Hx(e[i]), o = t[i], l = a;
      (o || r) && (l = $x(l, o, r)), so(n, l);
      for (let u of Object.keys(a)) {
        if (Us(u)) continue;
        let c = a[u];
        (o || r) && (c = $x(c, o, r));
        let f = n[u] || (n[u] = {});
        so(f, c);
      }
    }
    return n;
  }
  s(zx, "merge");
  function $x(e, t, r) {
    let n = {};
    for (let i of ["enter", "exit"]) {
      let a = e[i];
      Array.isArray(a) && (a = a.map(function(o) {
        let l = o;
        return t && (l = /* @__PURE__ */ s(function(u) {
          o.call(t, u, t);
        }, "newFn")), r && (l = r(t?.key, i, l)), l !== o && (l.toString = () => o.toString()), l;
      }), n[i] = a);
    }
    return n;
  }
  s($x, "wrapWithStateOrWrapper");
  function Bz(e) {
    for (let t of Object.keys(e)) {
      if (Us(t)) continue;
      let r = e[t];
      typeof r == "function" && (e[t] = {
        enter: r
      });
    }
  }
  s(Bz, "ensureEntranceObjects");
  function Wx(e) {
    e.enter && !Array.isArray(e.enter) && (e.enter = [e.enter]), e.exit && !Array.isArray(e.exit) && (e.exit = [e.exit]);
  }
  s(Wx, "ensureCallbackArrays");
  function kz(e, t) {
    let r = `is${e}`, n = Iz[r], i = /* @__PURE__ */ s(function(a) {
      if (n.call(a))
        return t.apply(this, arguments);
    }, "newFn");
    return i.toString = () => t.toString(), i;
  }
  s(kz, "wrapCheck");
  function Us(e) {
    return e[0] === "_" || e === "enter" || e === "exit" || e === "shouldSkip" || e === "denylist" || e === "noScope" || e === "skipKeys" ||
    e === "blacklist";
  }
  s(Us, "shouldIgnoreKey");
  function so(e, t) {
    for (let r of ["enter", "exit"])
      t[r] && (e[r] = [].concat(e[r] || [], t[r]));
  }
  s(so, "mergePair");
  var Fz = {
    FunctionParent(e) {
      e.isArrowFunctionExpression() || (e.skip(), e.isMethod() && (e.requeueComputedKeyAndDecorators ? e.requeueComputedKeyAndDecorators() :
      Lx.requeueComputedKeyAndDecorators.call(e)));
    },
    Property(e) {
      e.isObjectProperty() || (e.skip(), e.requeueComputedKeyAndDecorators ? e.requeueComputedKeyAndDecorators() : Lx.requeueComputedKeyAndDecorators.
      call(e));
    }
  };
  function jz(e) {
    return zx([Fz, e]);
  }
  s(jz, "environmentVisitor");
});

// ../node_modules/@babel/traverse/lib/scope/lib/renamer.js
var Jx = T((uu) => {
  "use strict";
  Object.defineProperty(uu, "__esModule", {
    value: !0
  });
  uu.default = void 0;
  var Lz = Pe(), Mz = cu(), Rz = io(), qz = ji(), Uz = {
    ReferencedIdentifier({
      node: e
    }, t) {
      e.name === t.oldName && (e.name = t.newName);
    },
    Scope(e, t) {
      e.scope.bindingIdentifierEquals(t.oldName, t.binding.identifier) || (e.skip(), e.isMethod() && (e.requeueComputedKeyAndDecorators ? e.
      requeueComputedKeyAndDecorators() : qz.requeueComputedKeyAndDecorators.call(e)));
    },
    ObjectProperty({
      node: e,
      scope: t
    }, r) {
      let {
        name: n
      } = e.key;
      if (e.shorthand && (n === r.oldName || n === r.newName) && t.getBindingIdentifier(n) === r.binding.identifier) {
        e.shorthand = !1;
        {
          var i;
          (i = e.extra) != null && i.shorthand && (e.extra.shorthand = !1);
        }
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(e, t) {
      if (e.isVariableDeclaration()) return;
      let r = e.isAssignmentExpression() ? e.getAssignmentIdentifiers() : e.getOuterBindingIdentifiers();
      for (let n in r)
        n === t.oldName && (r[n].name = t.newName);
    }
  }, mm = class {
    static {
      s(this, "Renamer");
    }
    constructor(t, r, n) {
      this.newName = n, this.oldName = r, this.binding = t;
    }
    maybeConvertFromExportDeclaration(t) {
      let r = t.parentPath;
      if (r.isExportDeclaration()) {
        if (r.isExportDefaultDeclaration()) {
          let {
            declaration: n
          } = r.node;
          if (Lz.isDeclaration(n) && !n.id)
            return;
        }
        r.isExportAllDeclaration() || r.splitExportDeclaration();
      }
    }
    maybeConvertFromClassFunctionDeclaration(t) {
      return t;
    }
    maybeConvertFromClassFunctionExpression(t) {
      return t;
    }
    rename() {
      let {
        binding: t,
        oldName: r,
        newName: n
      } = this, {
        scope: i,
        path: a
      } = t, o = a.find((u) => u.isDeclaration() || u.isFunctionExpression() || u.isClassExpression());
      o && o.getOuterBindingIdentifiers()[r] === t.identifier && this.maybeConvertFromExportDeclaration(o);
      let l = arguments[0] || i.block;
      (0, Mz.traverseNode)(l, (0, Rz.explode)(Uz), i, this, i.path, {
        discriminant: !0
      }), arguments[0] || (i.removeOwnBinding(r), i.bindings[n] = t, this.binding.identifier.name = n), o && (this.maybeConvertFromClassFunctionDeclaration(
      a), this.maybeConvertFromClassFunctionExpression(a));
    }
  };
  uu.default = mm;
});

// ../node_modules/@babel/traverse/lib/scope/binding.js
var Xx = T((fu) => {
  "use strict";
  Object.defineProperty(fu, "__esModule", {
    value: !0
  });
  fu.default = void 0;
  var ym = class {
    static {
      s(this, "Binding");
    }
    constructor({
      identifier: t,
      scope: r,
      path: n,
      kind: i
    }) {
      this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0,
      this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = t, this.scope = r, this.path = n, this.kind = i,
      (i === "var" || i === "hoisted") && Vz(n) && this.reassign(n), this.clearValue();
    }
    deoptValue() {
      this.clearValue(), this.hasDeoptedValue = !0;
    }
    setValue(t) {
      this.hasDeoptedValue || (this.hasValue = !0, this.value = t);
    }
    clearValue() {
      this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
    }
    reassign(t) {
      this.constant = !1, !this.constantViolations.includes(t) && this.constantViolations.push(t);
    }
    reference(t) {
      this.referencePaths.includes(t) || (this.referenced = !0, this.references++, this.referencePaths.push(t));
    }
    dereference() {
      this.references--, this.referenced = !!this.references;
    }
  };
  fu.default = ym;
  function Vz(e) {
    for (let {
      parentPath: t,
      key: r
    } = e; t; {
      parentPath: t,
      key: r
    } = t) {
      if (t.isFunctionParent()) return !1;
      if (t.isWhile() || t.isForXStatement() || t.isForStatement() && r === "body")
        return !0;
    }
    return !1;
  }
  s(Vz, "isDeclaredInLoop");
});

// ../node_modules/@babel/traverse/node_modules/globals/globals.json
var Qx = T((aAe, $z) => {
  $z.exports = {
    builtin: {
      Array: !1,
      ArrayBuffer: !1,
      Atomics: !1,
      BigInt: !1,
      BigInt64Array: !1,
      BigUint64Array: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      globalThis: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      SharedArrayBuffer: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    es5: {
      Array: !1,
      Boolean: !1,
      constructor: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      propertyIsEnumerable: !1,
      RangeError: !1,
      ReferenceError: !1,
      RegExp: !1,
      String: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1
    },
    es2015: {
      Array: !1,
      ArrayBuffer: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    es2017: {
      Array: !1,
      ArrayBuffer: !1,
      Atomics: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      SharedArrayBuffer: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    browser: {
      AbortController: !1,
      AbortSignal: !1,
      addEventListener: !1,
      alert: !1,
      AnalyserNode: !1,
      Animation: !1,
      AnimationEffectReadOnly: !1,
      AnimationEffectTiming: !1,
      AnimationEffectTimingReadOnly: !1,
      AnimationEvent: !1,
      AnimationPlaybackEvent: !1,
      AnimationTimeline: !1,
      applicationCache: !1,
      ApplicationCache: !1,
      ApplicationCacheErrorEvent: !1,
      atob: !1,
      Attr: !1,
      Audio: !1,
      AudioBuffer: !1,
      AudioBufferSourceNode: !1,
      AudioContext: !1,
      AudioDestinationNode: !1,
      AudioListener: !1,
      AudioNode: !1,
      AudioParam: !1,
      AudioProcessingEvent: !1,
      AudioScheduledSourceNode: !1,
      "AudioWorkletGlobalScope ": !1,
      AudioWorkletNode: !1,
      AudioWorkletProcessor: !1,
      BarProp: !1,
      BaseAudioContext: !1,
      BatteryManager: !1,
      BeforeUnloadEvent: !1,
      BiquadFilterNode: !1,
      Blob: !1,
      BlobEvent: !1,
      blur: !1,
      BroadcastChannel: !1,
      btoa: !1,
      BudgetService: !1,
      ByteLengthQueuingStrategy: !1,
      Cache: !1,
      caches: !1,
      CacheStorage: !1,
      cancelAnimationFrame: !1,
      cancelIdleCallback: !1,
      CanvasCaptureMediaStreamTrack: !1,
      CanvasGradient: !1,
      CanvasPattern: !1,
      CanvasRenderingContext2D: !1,
      ChannelMergerNode: !1,
      ChannelSplitterNode: !1,
      CharacterData: !1,
      clearInterval: !1,
      clearTimeout: !1,
      clientInformation: !1,
      ClipboardEvent: !1,
      close: !1,
      closed: !1,
      CloseEvent: !1,
      Comment: !1,
      CompositionEvent: !1,
      confirm: !1,
      console: !1,
      ConstantSourceNode: !1,
      ConvolverNode: !1,
      CountQueuingStrategy: !1,
      createImageBitmap: !1,
      Credential: !1,
      CredentialsContainer: !1,
      crypto: !1,
      Crypto: !1,
      CryptoKey: !1,
      CSS: !1,
      CSSConditionRule: !1,
      CSSFontFaceRule: !1,
      CSSGroupingRule: !1,
      CSSImportRule: !1,
      CSSKeyframeRule: !1,
      CSSKeyframesRule: !1,
      CSSMediaRule: !1,
      CSSNamespaceRule: !1,
      CSSPageRule: !1,
      CSSRule: !1,
      CSSRuleList: !1,
      CSSStyleDeclaration: !1,
      CSSStyleRule: !1,
      CSSStyleSheet: !1,
      CSSSupportsRule: !1,
      CustomElementRegistry: !1,
      customElements: !1,
      CustomEvent: !1,
      DataTransfer: !1,
      DataTransferItem: !1,
      DataTransferItemList: !1,
      defaultstatus: !1,
      defaultStatus: !1,
      DelayNode: !1,
      DeviceMotionEvent: !1,
      DeviceOrientationEvent: !1,
      devicePixelRatio: !1,
      dispatchEvent: !1,
      document: !1,
      Document: !1,
      DocumentFragment: !1,
      DocumentType: !1,
      DOMError: !1,
      DOMException: !1,
      DOMImplementation: !1,
      DOMMatrix: !1,
      DOMMatrixReadOnly: !1,
      DOMParser: !1,
      DOMPoint: !1,
      DOMPointReadOnly: !1,
      DOMQuad: !1,
      DOMRect: !1,
      DOMRectReadOnly: !1,
      DOMStringList: !1,
      DOMStringMap: !1,
      DOMTokenList: !1,
      DragEvent: !1,
      DynamicsCompressorNode: !1,
      Element: !1,
      ErrorEvent: !1,
      event: !1,
      Event: !1,
      EventSource: !1,
      EventTarget: !1,
      external: !1,
      fetch: !1,
      File: !1,
      FileList: !1,
      FileReader: !1,
      find: !1,
      focus: !1,
      FocusEvent: !1,
      FontFace: !1,
      FontFaceSetLoadEvent: !1,
      FormData: !1,
      frameElement: !1,
      frames: !1,
      GainNode: !1,
      Gamepad: !1,
      GamepadButton: !1,
      GamepadEvent: !1,
      getComputedStyle: !1,
      getSelection: !1,
      HashChangeEvent: !1,
      Headers: !1,
      history: !1,
      History: !1,
      HTMLAllCollection: !1,
      HTMLAnchorElement: !1,
      HTMLAreaElement: !1,
      HTMLAudioElement: !1,
      HTMLBaseElement: !1,
      HTMLBodyElement: !1,
      HTMLBRElement: !1,
      HTMLButtonElement: !1,
      HTMLCanvasElement: !1,
      HTMLCollection: !1,
      HTMLContentElement: !1,
      HTMLDataElement: !1,
      HTMLDataListElement: !1,
      HTMLDetailsElement: !1,
      HTMLDialogElement: !1,
      HTMLDirectoryElement: !1,
      HTMLDivElement: !1,
      HTMLDListElement: !1,
      HTMLDocument: !1,
      HTMLElement: !1,
      HTMLEmbedElement: !1,
      HTMLFieldSetElement: !1,
      HTMLFontElement: !1,
      HTMLFormControlsCollection: !1,
      HTMLFormElement: !1,
      HTMLFrameElement: !1,
      HTMLFrameSetElement: !1,
      HTMLHeadElement: !1,
      HTMLHeadingElement: !1,
      HTMLHRElement: !1,
      HTMLHtmlElement: !1,
      HTMLIFrameElement: !1,
      HTMLImageElement: !1,
      HTMLInputElement: !1,
      HTMLLabelElement: !1,
      HTMLLegendElement: !1,
      HTMLLIElement: !1,
      HTMLLinkElement: !1,
      HTMLMapElement: !1,
      HTMLMarqueeElement: !1,
      HTMLMediaElement: !1,
      HTMLMenuElement: !1,
      HTMLMetaElement: !1,
      HTMLMeterElement: !1,
      HTMLModElement: !1,
      HTMLObjectElement: !1,
      HTMLOListElement: !1,
      HTMLOptGroupElement: !1,
      HTMLOptionElement: !1,
      HTMLOptionsCollection: !1,
      HTMLOutputElement: !1,
      HTMLParagraphElement: !1,
      HTMLParamElement: !1,
      HTMLPictureElement: !1,
      HTMLPreElement: !1,
      HTMLProgressElement: !1,
      HTMLQuoteElement: !1,
      HTMLScriptElement: !1,
      HTMLSelectElement: !1,
      HTMLShadowElement: !1,
      HTMLSlotElement: !1,
      HTMLSourceElement: !1,
      HTMLSpanElement: !1,
      HTMLStyleElement: !1,
      HTMLTableCaptionElement: !1,
      HTMLTableCellElement: !1,
      HTMLTableColElement: !1,
      HTMLTableElement: !1,
      HTMLTableRowElement: !1,
      HTMLTableSectionElement: !1,
      HTMLTemplateElement: !1,
      HTMLTextAreaElement: !1,
      HTMLTimeElement: !1,
      HTMLTitleElement: !1,
      HTMLTrackElement: !1,
      HTMLUListElement: !1,
      HTMLUnknownElement: !1,
      HTMLVideoElement: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      IdleDeadline: !1,
      IIRFilterNode: !1,
      Image: !1,
      ImageBitmap: !1,
      ImageBitmapRenderingContext: !1,
      ImageCapture: !1,
      ImageData: !1,
      indexedDB: !1,
      innerHeight: !1,
      innerWidth: !1,
      InputEvent: !1,
      IntersectionObserver: !1,
      IntersectionObserverEntry: !1,
      Intl: !1,
      isSecureContext: !1,
      KeyboardEvent: !1,
      KeyframeEffect: !1,
      KeyframeEffectReadOnly: !1,
      length: !1,
      localStorage: !1,
      location: !0,
      Location: !1,
      locationbar: !1,
      matchMedia: !1,
      MediaDeviceInfo: !1,
      MediaDevices: !1,
      MediaElementAudioSourceNode: !1,
      MediaEncryptedEvent: !1,
      MediaError: !1,
      MediaKeyMessageEvent: !1,
      MediaKeySession: !1,
      MediaKeyStatusMap: !1,
      MediaKeySystemAccess: !1,
      MediaList: !1,
      MediaQueryList: !1,
      MediaQueryListEvent: !1,
      MediaRecorder: !1,
      MediaSettingsRange: !1,
      MediaSource: !1,
      MediaStream: !1,
      MediaStreamAudioDestinationNode: !1,
      MediaStreamAudioSourceNode: !1,
      MediaStreamEvent: !1,
      MediaStreamTrack: !1,
      MediaStreamTrackEvent: !1,
      menubar: !1,
      MessageChannel: !1,
      MessageEvent: !1,
      MessagePort: !1,
      MIDIAccess: !1,
      MIDIConnectionEvent: !1,
      MIDIInput: !1,
      MIDIInputMap: !1,
      MIDIMessageEvent: !1,
      MIDIOutput: !1,
      MIDIOutputMap: !1,
      MIDIPort: !1,
      MimeType: !1,
      MimeTypeArray: !1,
      MouseEvent: !1,
      moveBy: !1,
      moveTo: !1,
      MutationEvent: !1,
      MutationObserver: !1,
      MutationRecord: !1,
      name: !1,
      NamedNodeMap: !1,
      NavigationPreloadManager: !1,
      navigator: !1,
      Navigator: !1,
      NetworkInformation: !1,
      Node: !1,
      NodeFilter: !1,
      NodeIterator: !1,
      NodeList: !1,
      Notification: !1,
      OfflineAudioCompletionEvent: !1,
      OfflineAudioContext: !1,
      offscreenBuffering: !1,
      OffscreenCanvas: !0,
      onabort: !0,
      onafterprint: !0,
      onanimationend: !0,
      onanimationiteration: !0,
      onanimationstart: !0,
      onappinstalled: !0,
      onauxclick: !0,
      onbeforeinstallprompt: !0,
      onbeforeprint: !0,
      onbeforeunload: !0,
      onblur: !0,
      oncancel: !0,
      oncanplay: !0,
      oncanplaythrough: !0,
      onchange: !0,
      onclick: !0,
      onclose: !0,
      oncontextmenu: !0,
      oncuechange: !0,
      ondblclick: !0,
      ondevicemotion: !0,
      ondeviceorientation: !0,
      ondeviceorientationabsolute: !0,
      ondrag: !0,
      ondragend: !0,
      ondragenter: !0,
      ondragleave: !0,
      ondragover: !0,
      ondragstart: !0,
      ondrop: !0,
      ondurationchange: !0,
      onemptied: !0,
      onended: !0,
      onerror: !0,
      onfocus: !0,
      ongotpointercapture: !0,
      onhashchange: !0,
      oninput: !0,
      oninvalid: !0,
      onkeydown: !0,
      onkeypress: !0,
      onkeyup: !0,
      onlanguagechange: !0,
      onload: !0,
      onloadeddata: !0,
      onloadedmetadata: !0,
      onloadstart: !0,
      onlostpointercapture: !0,
      onmessage: !0,
      onmessageerror: !0,
      onmousedown: !0,
      onmouseenter: !0,
      onmouseleave: !0,
      onmousemove: !0,
      onmouseout: !0,
      onmouseover: !0,
      onmouseup: !0,
      onmousewheel: !0,
      onoffline: !0,
      ononline: !0,
      onpagehide: !0,
      onpageshow: !0,
      onpause: !0,
      onplay: !0,
      onplaying: !0,
      onpointercancel: !0,
      onpointerdown: !0,
      onpointerenter: !0,
      onpointerleave: !0,
      onpointermove: !0,
      onpointerout: !0,
      onpointerover: !0,
      onpointerup: !0,
      onpopstate: !0,
      onprogress: !0,
      onratechange: !0,
      onrejectionhandled: !0,
      onreset: !0,
      onresize: !0,
      onscroll: !0,
      onsearch: !0,
      onseeked: !0,
      onseeking: !0,
      onselect: !0,
      onstalled: !0,
      onstorage: !0,
      onsubmit: !0,
      onsuspend: !0,
      ontimeupdate: !0,
      ontoggle: !0,
      ontransitionend: !0,
      onunhandledrejection: !0,
      onunload: !0,
      onvolumechange: !0,
      onwaiting: !0,
      onwheel: !0,
      open: !1,
      openDatabase: !1,
      opener: !1,
      Option: !1,
      origin: !1,
      OscillatorNode: !1,
      outerHeight: !1,
      outerWidth: !1,
      PageTransitionEvent: !1,
      pageXOffset: !1,
      pageYOffset: !1,
      PannerNode: !1,
      parent: !1,
      Path2D: !1,
      PaymentAddress: !1,
      PaymentRequest: !1,
      PaymentRequestUpdateEvent: !1,
      PaymentResponse: !1,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceLongTaskTiming: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceNavigationTiming: !1,
      PerformanceObserver: !1,
      PerformanceObserverEntryList: !1,
      PerformancePaintTiming: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      PeriodicWave: !1,
      Permissions: !1,
      PermissionStatus: !1,
      personalbar: !1,
      PhotoCapabilities: !1,
      Plugin: !1,
      PluginArray: !1,
      PointerEvent: !1,
      PopStateEvent: !1,
      postMessage: !1,
      Presentation: !1,
      PresentationAvailability: !1,
      PresentationConnection: !1,
      PresentationConnectionAvailableEvent: !1,
      PresentationConnectionCloseEvent: !1,
      PresentationConnectionList: !1,
      PresentationReceiver: !1,
      PresentationRequest: !1,
      print: !1,
      ProcessingInstruction: !1,
      ProgressEvent: !1,
      PromiseRejectionEvent: !1,
      prompt: !1,
      PushManager: !1,
      PushSubscription: !1,
      PushSubscriptionOptions: !1,
      queueMicrotask: !1,
      RadioNodeList: !1,
      Range: !1,
      ReadableStream: !1,
      registerProcessor: !1,
      RemotePlayback: !1,
      removeEventListener: !1,
      Request: !1,
      requestAnimationFrame: !1,
      requestIdleCallback: !1,
      resizeBy: !1,
      ResizeObserver: !1,
      ResizeObserverEntry: !1,
      resizeTo: !1,
      Response: !1,
      RTCCertificate: !1,
      RTCDataChannel: !1,
      RTCDataChannelEvent: !1,
      RTCDtlsTransport: !1,
      RTCIceCandidate: !1,
      RTCIceGatherer: !1,
      RTCIceTransport: !1,
      RTCPeerConnection: !1,
      RTCPeerConnectionIceEvent: !1,
      RTCRtpContributingSource: !1,
      RTCRtpReceiver: !1,
      RTCRtpSender: !1,
      RTCSctpTransport: !1,
      RTCSessionDescription: !1,
      RTCStatsReport: !1,
      RTCTrackEvent: !1,
      screen: !1,
      Screen: !1,
      screenLeft: !1,
      ScreenOrientation: !1,
      screenTop: !1,
      screenX: !1,
      screenY: !1,
      ScriptProcessorNode: !1,
      scroll: !1,
      scrollbars: !1,
      scrollBy: !1,
      scrollTo: !1,
      scrollX: !1,
      scrollY: !1,
      SecurityPolicyViolationEvent: !1,
      Selection: !1,
      self: !1,
      ServiceWorker: !1,
      ServiceWorkerContainer: !1,
      ServiceWorkerRegistration: !1,
      sessionStorage: !1,
      setInterval: !1,
      setTimeout: !1,
      ShadowRoot: !1,
      SharedWorker: !1,
      SourceBuffer: !1,
      SourceBufferList: !1,
      speechSynthesis: !1,
      SpeechSynthesisEvent: !1,
      SpeechSynthesisUtterance: !1,
      StaticRange: !1,
      status: !1,
      statusbar: !1,
      StereoPannerNode: !1,
      stop: !1,
      Storage: !1,
      StorageEvent: !1,
      StorageManager: !1,
      styleMedia: !1,
      StyleSheet: !1,
      StyleSheetList: !1,
      SubtleCrypto: !1,
      SVGAElement: !1,
      SVGAngle: !1,
      SVGAnimatedAngle: !1,
      SVGAnimatedBoolean: !1,
      SVGAnimatedEnumeration: !1,
      SVGAnimatedInteger: !1,
      SVGAnimatedLength: !1,
      SVGAnimatedLengthList: !1,
      SVGAnimatedNumber: !1,
      SVGAnimatedNumberList: !1,
      SVGAnimatedPreserveAspectRatio: !1,
      SVGAnimatedRect: !1,
      SVGAnimatedString: !1,
      SVGAnimatedTransformList: !1,
      SVGAnimateElement: !1,
      SVGAnimateMotionElement: !1,
      SVGAnimateTransformElement: !1,
      SVGAnimationElement: !1,
      SVGCircleElement: !1,
      SVGClipPathElement: !1,
      SVGComponentTransferFunctionElement: !1,
      SVGDefsElement: !1,
      SVGDescElement: !1,
      SVGDiscardElement: !1,
      SVGElement: !1,
      SVGEllipseElement: !1,
      SVGFEBlendElement: !1,
      SVGFEColorMatrixElement: !1,
      SVGFEComponentTransferElement: !1,
      SVGFECompositeElement: !1,
      SVGFEConvolveMatrixElement: !1,
      SVGFEDiffuseLightingElement: !1,
      SVGFEDisplacementMapElement: !1,
      SVGFEDistantLightElement: !1,
      SVGFEDropShadowElement: !1,
      SVGFEFloodElement: !1,
      SVGFEFuncAElement: !1,
      SVGFEFuncBElement: !1,
      SVGFEFuncGElement: !1,
      SVGFEFuncRElement: !1,
      SVGFEGaussianBlurElement: !1,
      SVGFEImageElement: !1,
      SVGFEMergeElement: !1,
      SVGFEMergeNodeElement: !1,
      SVGFEMorphologyElement: !1,
      SVGFEOffsetElement: !1,
      SVGFEPointLightElement: !1,
      SVGFESpecularLightingElement: !1,
      SVGFESpotLightElement: !1,
      SVGFETileElement: !1,
      SVGFETurbulenceElement: !1,
      SVGFilterElement: !1,
      SVGForeignObjectElement: !1,
      SVGGElement: !1,
      SVGGeometryElement: !1,
      SVGGradientElement: !1,
      SVGGraphicsElement: !1,
      SVGImageElement: !1,
      SVGLength: !1,
      SVGLengthList: !1,
      SVGLinearGradientElement: !1,
      SVGLineElement: !1,
      SVGMarkerElement: !1,
      SVGMaskElement: !1,
      SVGMatrix: !1,
      SVGMetadataElement: !1,
      SVGMPathElement: !1,
      SVGNumber: !1,
      SVGNumberList: !1,
      SVGPathElement: !1,
      SVGPatternElement: !1,
      SVGPoint: !1,
      SVGPointList: !1,
      SVGPolygonElement: !1,
      SVGPolylineElement: !1,
      SVGPreserveAspectRatio: !1,
      SVGRadialGradientElement: !1,
      SVGRect: !1,
      SVGRectElement: !1,
      SVGScriptElement: !1,
      SVGSetElement: !1,
      SVGStopElement: !1,
      SVGStringList: !1,
      SVGStyleElement: !1,
      SVGSVGElement: !1,
      SVGSwitchElement: !1,
      SVGSymbolElement: !1,
      SVGTextContentElement: !1,
      SVGTextElement: !1,
      SVGTextPathElement: !1,
      SVGTextPositioningElement: !1,
      SVGTitleElement: !1,
      SVGTransform: !1,
      SVGTransformList: !1,
      SVGTSpanElement: !1,
      SVGUnitTypes: !1,
      SVGUseElement: !1,
      SVGViewElement: !1,
      TaskAttributionTiming: !1,
      Text: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      TextEvent: !1,
      TextMetrics: !1,
      TextTrack: !1,
      TextTrackCue: !1,
      TextTrackCueList: !1,
      TextTrackList: !1,
      TimeRanges: !1,
      toolbar: !1,
      top: !1,
      Touch: !1,
      TouchEvent: !1,
      TouchList: !1,
      TrackEvent: !1,
      TransitionEvent: !1,
      TreeWalker: !1,
      UIEvent: !1,
      URL: !1,
      URLSearchParams: !1,
      ValidityState: !1,
      visualViewport: !1,
      VisualViewport: !1,
      VTTCue: !1,
      WaveShaperNode: !1,
      WebAssembly: !1,
      WebGL2RenderingContext: !1,
      WebGLActiveInfo: !1,
      WebGLBuffer: !1,
      WebGLContextEvent: !1,
      WebGLFramebuffer: !1,
      WebGLProgram: !1,
      WebGLQuery: !1,
      WebGLRenderbuffer: !1,
      WebGLRenderingContext: !1,
      WebGLSampler: !1,
      WebGLShader: !1,
      WebGLShaderPrecisionFormat: !1,
      WebGLSync: !1,
      WebGLTexture: !1,
      WebGLTransformFeedback: !1,
      WebGLUniformLocation: !1,
      WebGLVertexArrayObject: !1,
      WebSocket: !1,
      WheelEvent: !1,
      window: !1,
      Window: !1,
      Worker: !1,
      WritableStream: !1,
      XMLDocument: !1,
      XMLHttpRequest: !1,
      XMLHttpRequestEventTarget: !1,
      XMLHttpRequestUpload: !1,
      XMLSerializer: !1,
      XPathEvaluator: !1,
      XPathExpression: !1,
      XPathResult: !1,
      XSLTProcessor: !1
    },
    worker: {
      addEventListener: !1,
      applicationCache: !1,
      atob: !1,
      Blob: !1,
      BroadcastChannel: !1,
      btoa: !1,
      Cache: !1,
      caches: !1,
      clearInterval: !1,
      clearTimeout: !1,
      close: !0,
      console: !1,
      fetch: !1,
      FileReaderSync: !1,
      FormData: !1,
      Headers: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      ImageData: !1,
      importScripts: !0,
      indexedDB: !1,
      location: !1,
      MessageChannel: !1,
      MessagePort: !1,
      name: !1,
      navigator: !1,
      Notification: !1,
      onclose: !0,
      onconnect: !0,
      onerror: !0,
      onlanguagechange: !0,
      onmessage: !0,
      onoffline: !0,
      ononline: !0,
      onrejectionhandled: !0,
      onunhandledrejection: !0,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      postMessage: !0,
      Promise: !1,
      queueMicrotask: !1,
      removeEventListener: !1,
      Request: !1,
      Response: !1,
      self: !0,
      ServiceWorkerRegistration: !1,
      setInterval: !1,
      setTimeout: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
      WebSocket: !1,
      Worker: !1,
      WorkerGlobalScope: !1,
      XMLHttpRequest: !1
    },
    node: {
      __dirname: !1,
      __filename: !1,
      Buffer: !1,
      clearImmediate: !1,
      clearInterval: !1,
      clearTimeout: !1,
      console: !1,
      exports: !0,
      global: !1,
      Intl: !1,
      module: !1,
      process: !1,
      queueMicrotask: !1,
      require: !1,
      setImmediate: !1,
      setInterval: !1,
      setTimeout: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1
    },
    commonjs: {
      exports: !0,
      global: !1,
      module: !1,
      require: !1
    },
    amd: {
      define: !1,
      require: !1
    },
    mocha: {
      after: !1,
      afterEach: !1,
      before: !1,
      beforeEach: !1,
      context: !1,
      describe: !1,
      it: !1,
      mocha: !1,
      run: !1,
      setup: !1,
      specify: !1,
      suite: !1,
      suiteSetup: !1,
      suiteTeardown: !1,
      teardown: !1,
      test: !1,
      xcontext: !1,
      xdescribe: !1,
      xit: !1,
      xspecify: !1
    },
    jasmine: {
      afterAll: !1,
      afterEach: !1,
      beforeAll: !1,
      beforeEach: !1,
      describe: !1,
      expect: !1,
      fail: !1,
      fdescribe: !1,
      fit: !1,
      it: !1,
      jasmine: !1,
      pending: !1,
      runs: !1,
      spyOn: !1,
      spyOnProperty: !1,
      waits: !1,
      waitsFor: !1,
      xdescribe: !1,
      xit: !1
    },
    jest: {
      afterAll: !1,
      afterEach: !1,
      beforeAll: !1,
      beforeEach: !1,
      describe: !1,
      expect: !1,
      fdescribe: !1,
      fit: !1,
      it: !1,
      jest: !1,
      pit: !1,
      require: !1,
      test: !1,
      xdescribe: !1,
      xit: !1,
      xtest: !1
    },
    qunit: {
      asyncTest: !1,
      deepEqual: !1,
      equal: !1,
      expect: !1,
      module: !1,
      notDeepEqual: !1,
      notEqual: !1,
      notOk: !1,
      notPropEqual: !1,
      notStrictEqual: !1,
      ok: !1,
      propEqual: !1,
      QUnit: !1,
      raises: !1,
      start: !1,
      stop: !1,
      strictEqual: !1,
      test: !1,
      throws: !1
    },
    phantomjs: {
      console: !0,
      exports: !0,
      phantom: !0,
      require: !0,
      WebPage: !0
    },
    couch: {
      emit: !1,
      exports: !1,
      getRow: !1,
      log: !1,
      module: !1,
      provides: !1,
      require: !1,
      respond: !1,
      send: !1,
      start: !1,
      sum: !1
    },
    rhino: {
      defineClass: !1,
      deserialize: !1,
      gc: !1,
      help: !1,
      importClass: !1,
      importPackage: !1,
      java: !1,
      load: !1,
      loadClass: !1,
      Packages: !1,
      print: !1,
      quit: !1,
      readFile: !1,
      readUrl: !1,
      runCommand: !1,
      seal: !1,
      serialize: !1,
      spawn: !1,
      sync: !1,
      toint32: !1,
      version: !1
    },
    nashorn: {
      __DIR__: !1,
      __FILE__: !1,
      __LINE__: !1,
      com: !1,
      edu: !1,
      exit: !1,
      java: !1,
      Java: !1,
      javafx: !1,
      JavaImporter: !1,
      javax: !1,
      JSAdapter: !1,
      load: !1,
      loadWithNewGlobal: !1,
      org: !1,
      Packages: !1,
      print: !1,
      quit: !1
    },
    wsh: {
      ActiveXObject: !0,
      Enumerator: !0,
      GetObject: !0,
      ScriptEngine: !0,
      ScriptEngineBuildVersion: !0,
      ScriptEngineMajorVersion: !0,
      ScriptEngineMinorVersion: !0,
      VBArray: !0,
      WScript: !0,
      WSH: !0,
      XDomainRequest: !0
    },
    jquery: {
      $: !1,
      jQuery: !1
    },
    yui: {
      YAHOO: !1,
      YAHOO_config: !1,
      YUI: !1,
      YUI_config: !1
    },
    shelljs: {
      cat: !1,
      cd: !1,
      chmod: !1,
      config: !1,
      cp: !1,
      dirs: !1,
      echo: !1,
      env: !1,
      error: !1,
      exec: !1,
      exit: !1,
      find: !1,
      grep: !1,
      ln: !1,
      ls: !1,
      mkdir: !1,
      mv: !1,
      popd: !1,
      pushd: !1,
      pwd: !1,
      rm: !1,
      sed: !1,
      set: !1,
      target: !1,
      tempdir: !1,
      test: !1,
      touch: !1,
      which: !1
    },
    prototypejs: {
      $: !1,
      $$: !1,
      $A: !1,
      $break: !1,
      $continue: !1,
      $F: !1,
      $H: !1,
      $R: !1,
      $w: !1,
      Abstract: !1,
      Ajax: !1,
      Autocompleter: !1,
      Builder: !1,
      Class: !1,
      Control: !1,
      Draggable: !1,
      Draggables: !1,
      Droppables: !1,
      Effect: !1,
      Element: !1,
      Enumerable: !1,
      Event: !1,
      Field: !1,
      Form: !1,
      Hash: !1,
      Insertion: !1,
      ObjectRange: !1,
      PeriodicalExecuter: !1,
      Position: !1,
      Prototype: !1,
      Scriptaculous: !1,
      Selector: !1,
      Sortable: !1,
      SortableObserver: !1,
      Sound: !1,
      Template: !1,
      Toggle: !1,
      Try: !1
    },
    meteor: {
      _: !1,
      $: !1,
      Accounts: !1,
      AccountsClient: !1,
      AccountsCommon: !1,
      AccountsServer: !1,
      App: !1,
      Assets: !1,
      Blaze: !1,
      check: !1,
      Cordova: !1,
      DDP: !1,
      DDPRateLimiter: !1,
      DDPServer: !1,
      Deps: !1,
      EJSON: !1,
      Email: !1,
      HTTP: !1,
      Log: !1,
      Match: !1,
      Meteor: !1,
      Mongo: !1,
      MongoInternals: !1,
      Npm: !1,
      Package: !1,
      Plugin: !1,
      process: !1,
      Random: !1,
      ReactiveDict: !1,
      ReactiveVar: !1,
      Router: !1,
      ServiceConfiguration: !1,
      Session: !1,
      share: !1,
      Spacebars: !1,
      Template: !1,
      Tinytest: !1,
      Tracker: !1,
      UI: !1,
      Utils: !1,
      WebApp: !1,
      WebAppInternals: !1
    },
    mongo: {
      _isWindows: !1,
      _rand: !1,
      BulkWriteResult: !1,
      cat: !1,
      cd: !1,
      connect: !1,
      db: !1,
      getHostName: !1,
      getMemInfo: !1,
      hostname: !1,
      ISODate: !1,
      listFiles: !1,
      load: !1,
      ls: !1,
      md5sumFile: !1,
      mkdir: !1,
      Mongo: !1,
      NumberInt: !1,
      NumberLong: !1,
      ObjectId: !1,
      PlanCache: !1,
      print: !1,
      printjson: !1,
      pwd: !1,
      quit: !1,
      removeFile: !1,
      rs: !1,
      sh: !1,
      UUID: !1,
      version: !1,
      WriteResult: !1
    },
    applescript: {
      $: !1,
      Application: !1,
      Automation: !1,
      console: !1,
      delay: !1,
      Library: !1,
      ObjC: !1,
      ObjectSpecifier: !1,
      Path: !1,
      Progress: !1,
      Ref: !1
    },
    serviceworker: {
      addEventListener: !1,
      applicationCache: !1,
      atob: !1,
      Blob: !1,
      BroadcastChannel: !1,
      btoa: !1,
      Cache: !1,
      caches: !1,
      CacheStorage: !1,
      clearInterval: !1,
      clearTimeout: !1,
      Client: !1,
      clients: !1,
      Clients: !1,
      close: !0,
      console: !1,
      ExtendableEvent: !1,
      ExtendableMessageEvent: !1,
      fetch: !1,
      FetchEvent: !1,
      FileReaderSync: !1,
      FormData: !1,
      Headers: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      ImageData: !1,
      importScripts: !1,
      indexedDB: !1,
      location: !1,
      MessageChannel: !1,
      MessagePort: !1,
      name: !1,
      navigator: !1,
      Notification: !1,
      onclose: !0,
      onconnect: !0,
      onerror: !0,
      onfetch: !0,
      oninstall: !0,
      onlanguagechange: !0,
      onmessage: !0,
      onmessageerror: !0,
      onnotificationclick: !0,
      onnotificationclose: !0,
      onoffline: !0,
      ononline: !0,
      onpush: !0,
      onpushsubscriptionchange: !0,
      onrejectionhandled: !0,
      onsync: !0,
      onunhandledrejection: !0,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      postMessage: !0,
      Promise: !1,
      queueMicrotask: !1,
      registration: !1,
      removeEventListener: !1,
      Request: !1,
      Response: !1,
      self: !1,
      ServiceWorker: !1,
      ServiceWorkerContainer: !1,
      ServiceWorkerGlobalScope: !1,
      ServiceWorkerMessageEvent: !1,
      ServiceWorkerRegistration: !1,
      setInterval: !1,
      setTimeout: !1,
      skipWaiting: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
      WebSocket: !1,
      WindowClient: !1,
      Worker: !1,
      WorkerGlobalScope: !1,
      XMLHttpRequest: !1
    },
    atomtest: {
      advanceClock: !1,
      fakeClearInterval: !1,
      fakeClearTimeout: !1,
      fakeSetInterval: !1,
      fakeSetTimeout: !1,
      resetTimeouts: !1,
      waitsForPromise: !1
    },
    embertest: {
      andThen: !1,
      click: !1,
      currentPath: !1,
      currentRouteName: !1,
      currentURL: !1,
      fillIn: !1,
      find: !1,
      findAll: !1,
      findWithAssert: !1,
      keyEvent: !1,
      pauseTest: !1,
      resumeTest: !1,
      triggerEvent: !1,
      visit: !1,
      wait: !1
    },
    protractor: {
      $: !1,
      $$: !1,
      browser: !1,
      by: !1,
      By: !1,
      DartObject: !1,
      element: !1,
      protractor: !1
    },
    "shared-node-browser": {
      clearInterval: !1,
      clearTimeout: !1,
      console: !1,
      setInterval: !1,
      setTimeout: !1,
      URL: !1,
      URLSearchParams: !1
    },
    webextensions: {
      browser: !1,
      chrome: !1,
      opr: !1
    },
    greasemonkey: {
      cloneInto: !1,
      createObjectIn: !1,
      exportFunction: !1,
      GM: !1,
      GM_addStyle: !1,
      GM_deleteValue: !1,
      GM_getResourceText: !1,
      GM_getResourceURL: !1,
      GM_getValue: !1,
      GM_info: !1,
      GM_listValues: !1,
      GM_log: !1,
      GM_openInTab: !1,
      GM_registerMenuCommand: !1,
      GM_setClipboard: !1,
      GM_setValue: !1,
      GM_xmlhttpRequest: !1,
      unsafeWindow: !1
    },
    devtools: {
      $: !1,
      $_: !1,
      $$: !1,
      $0: !1,
      $1: !1,
      $2: !1,
      $3: !1,
      $4: !1,
      $x: !1,
      chrome: !1,
      clear: !1,
      copy: !1,
      debug: !1,
      dir: !1,
      dirxml: !1,
      getEventListeners: !1,
      inspect: !1,
      keys: !1,
      monitor: !1,
      monitorEvents: !1,
      profile: !1,
      profileEnd: !1,
      queryObjects: !1,
      table: !1,
      undebug: !1,
      unmonitor: !1,
      unmonitorEvents: !1,
      values: !1
    }
  };
});

// ../node_modules/@babel/traverse/node_modules/globals/index.js
var eS = T((oAe, Zx) => {
  "use strict";
  Zx.exports = Qx();
});

// ../node_modules/@babel/traverse/lib/cache.js
var $s = T((br) => {
  "use strict";
  Object.defineProperty(br, "__esModule", {
    value: !0
  });
  br.clear = Kz;
  br.clearPath = tS;
  br.clearScope = rS;
  br.getCachedPaths = Gz;
  br.getOrCreateCachedPaths = Hz;
  br.scope = br.path = void 0;
  var pu = br.path = /* @__PURE__ */ new WeakMap(), Wz = br.scope = /* @__PURE__ */ new WeakMap();
  function Kz() {
    tS(), rS();
  }
  s(Kz, "clear");
  function tS() {
    br.path = pu = /* @__PURE__ */ new WeakMap();
  }
  s(tS, "clearPath");
  function rS() {
    br.scope = Wz = /* @__PURE__ */ new WeakMap();
  }
  s(rS, "clearScope");
  var gm = Object.freeze({});
  function Gz(e, t) {
    var r, n;
    return e = null, (r = pu.get((n = e) != null ? n : gm)) == null ? void 0 : r.get(t);
  }
  s(Gz, "getCachedPaths");
  function Hz(e, t) {
    var r, n;
    e = null;
    let i = pu.get((r = e) != null ? r : gm);
    i || pu.set((n = e) != null ? n : gm, i = /* @__PURE__ */ new WeakMap());
    let a = i.get(t);
    return a || i.set(t, a = /* @__PURE__ */ new Map()), a;
  }
  s(Hz, "getOrCreateCachedPaths");
});

// ../node_modules/@babel/traverse/lib/scope/index.js
var Tm = T((hu) => {
  "use strict";
  Object.defineProperty(hu, "__esModule", {
    value: !0
  });
  hu.default = void 0;
  var Yz = Jx(), zz = _r(), Jz = Xx(), Xz = eS(), pS = Pe(), Qz = pS, nS = $s(), Zz = io(), {
    NOT_LOCAL_BINDING: sS,
    assignmentExpression: eJ,
    callExpression: iS,
    cloneNode: aS,
    getBindingIdentifiers: dS,
    identifier: Ws,
    isArrayExpression: oS,
    isBinary: tJ,
    isCallExpression: lS,
    isClass: rJ,
    isClassBody: nJ,
    isClassDeclaration: sJ,
    isExportAllDeclaration: hS,
    isExportDefaultDeclaration: iJ,
    isExportNamedDeclaration: bm,
    isFunctionDeclaration: aJ,
    isIdentifier: Ks,
    isImportDeclaration: Em,
    isLiteral: oJ,
    isMemberExpression: lJ,
    isMethod: uJ,
    isModuleSpecifier: cJ,
    isNullLiteral: fJ,
    isObjectExpression: pJ,
    isProperty: dJ,
    isPureish: hJ,
    isRegExpLiteral: mJ,
    isSuper: yJ,
    isTaggedTemplateExpression: gJ,
    isTemplateLiteral: mS,
    isThisExpression: uS,
    isUnaryExpression: bJ,
    isVariableDeclaration: EJ,
    expressionStatement: vJ,
    matchesPattern: cS,
    memberExpression: vm,
    numericLiteral: TJ,
    toIdentifier: xJ,
    variableDeclaration: SJ,
    variableDeclarator: PJ,
    isRecordExpression: AJ,
    isTupleExpression: CJ,
    isObjectProperty: wJ,
    isTopicReference: fS,
    isMetaProperty: DJ,
    isPrivateName: IJ,
    isExportDeclaration: _J,
    buildUndefinedNode: OJ,
    sequenceExpression: NJ
  } = pS;
  function ct(e, t) {
    switch (e?.type) {
      default:
        if (Em(e) || _J(e)) {
          var r;
          if ((hS(e) || bm(e) || Em(e)) && e.source)
            ct(e.source, t);
          else if ((bm(e) || Em(e)) && (r = e.specifiers) != null && r.length)
            for (let n of e.specifiers) ct(n, t);
          else (iJ(e) || bm(e)) && e.declaration && ct(e.declaration, t);
        } else cJ(e) ? ct(e.local, t) : oJ(e) && !fJ(e) && !mJ(e) && !mS(e) && t.push(e.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        ct(e.object, t), ct(e.property, t);
        break;
      case "Identifier":
      case "JSXIdentifier":
        t.push(e.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        ct(e.callee, t);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (let n of e.properties)
          ct(n, t);
        break;
      case "SpreadElement":
      case "RestElement":
        ct(e.argument, t);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        ct(e.key, t);
        break;
      case "ThisExpression":
        t.push("this");
        break;
      case "Super":
        t.push("super");
        break;
      case "Import":
        t.push("import");
        break;
      case "DoExpression":
        t.push("do");
        break;
      case "YieldExpression":
        t.push("yield"), ct(e.argument, t);
        break;
      case "AwaitExpression":
        t.push("await"), ct(e.argument, t);
        break;
      case "AssignmentExpression":
        ct(e.left, t);
        break;
      case "VariableDeclarator":
        ct(e.id, t);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        ct(e.id, t);
        break;
      case "PrivateName":
        ct(e.id, t);
        break;
      case "ParenthesizedExpression":
        ct(e.expression, t);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        ct(e.argument, t);
        break;
      case "MetaProperty":
        ct(e.meta, t), ct(e.property, t);
        break;
      case "JSXElement":
        ct(e.openingElement, t);
        break;
      case "JSXOpeningElement":
        ct(e.name, t);
        break;
      case "JSXFragment":
        ct(e.openingFragment, t);
        break;
      case "JSXOpeningFragment":
        t.push("Fragment");
        break;
      case "JSXNamespacedName":
        ct(e.namespace, t), ct(e.name, t);
        break;
    }
  }
  s(ct, "gatherNodeParts");
  var du = {
    ForStatement(e) {
      let t = e.get("init");
      if (t.isVar()) {
        let {
          scope: r
        } = e;
        (r.getFunctionParent() || r.getProgramParent()).registerBinding("var", t);
      }
    },
    Declaration(e) {
      if (e.isBlockScoped() || e.isImportDeclaration() || e.isExportDeclaration()) return;
      (e.scope.getFunctionParent() || e.scope.getProgramParent()).registerDeclaration(e);
    },
    ImportDeclaration(e) {
      e.scope.getBlockParent().registerDeclaration(e);
    },
    ReferencedIdentifier(e, t) {
      t.references.push(e);
    },
    ForXStatement(e, t) {
      let r = e.get("left");
      if (r.isPattern() || r.isIdentifier())
        t.constantViolations.push(e);
      else if (r.isVar()) {
        let {
          scope: n
        } = e;
        (n.getFunctionParent() || n.getProgramParent()).registerBinding("var", r);
      }
    },
    ExportDeclaration: {
      exit(e) {
        let {
          node: t,
          scope: r
        } = e;
        if (hS(t)) return;
        let n = t.declaration;
        if (sJ(n) || aJ(n)) {
          let i = n.id;
          if (!i) return;
          let a = r.getBinding(i.name);
          a?.reference(e);
        } else if (EJ(n))
          for (let i of n.declarations)
            for (let a of Object.keys(dS(i))) {
              let o = r.getBinding(a);
              o?.reference(e);
            }
      }
    },
    LabeledStatement(e) {
      e.scope.getBlockParent().registerDeclaration(e);
    },
    AssignmentExpression(e, t) {
      t.assignments.push(e);
    },
    UpdateExpression(e, t) {
      t.constantViolations.push(e);
    },
    UnaryExpression(e, t) {
      e.node.operator === "delete" && t.constantViolations.push(e);
    },
    BlockScoped(e) {
      let t = e.scope;
      if (t.path === e && (t = t.parent), t.getBlockParent().registerDeclaration(e), e.isClassDeclaration() && e.node.id) {
        let i = e.node.id.name;
        e.scope.bindings[i] = e.scope.parent.getBinding(i);
      }
    },
    CatchClause(e) {
      e.scope.registerBinding("let", e);
    },
    Function(e) {
      let t = e.get("params");
      for (let r of t)
        e.scope.registerBinding("param", r);
      e.isFunctionExpression() && e.has("id") && !e.get("id").node[sS] && e.scope.registerBinding("local", e.get("id"), e);
    },
    ClassExpression(e) {
      e.has("id") && !e.get("id").node[sS] && e.scope.registerBinding("local", e.get("id"), e);
    },
    TSTypeAnnotation(e) {
      e.skip();
    }
  }, BJ = 0, ao = class e {
    static {
      s(this, "Scope");
    }
    constructor(t) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references =
      void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
      let {
        node: r
      } = t, n = nS.scope.get(r);
      if (n?.path === t)
        return n;
      nS.scope.set(r, this), this.uid = BJ++, this.block = r, this.path = t, this.labels = /* @__PURE__ */ new Map(), this.inited = !1;
    }
    get parent() {
      var t;
      let r, n = this.path;
      do {
        var i;
        let a = n.key === "key" || n.listKey === "decorators";
        n = n.parentPath, a && n.isMethod() && (n = n.parentPath), (i = n) != null && i.isScope() && (r = n);
      } while (n && !r);
      return (t = r) == null ? void 0 : t.scope;
    }
    get parentBlock() {
      return this.path.parent;
    }
    get hub() {
      return this.path.hub;
    }
    traverse(t, r, n) {
      (0, zz.default)(t, r, this, n, this.path);
    }
    generateDeclaredUidIdentifier(t) {
      let r = this.generateUidIdentifier(t);
      return this.push({
        id: r
      }), aS(r);
    }
    generateUidIdentifier(t) {
      return Ws(this.generateUid(t));
    }
    generateUid(t = "temp") {
      t = xJ(t).replace(/^_+/, "").replace(/\d+$/g, "");
      let r, n = 1;
      do
        r = this._generateUid(t, n), n++;
      while (this.hasLabel(r) || this.hasBinding(r) || this.hasGlobal(r) || this.hasReference(r));
      let i = this.getProgramParent();
      return i.references[r] = !0, i.uids[r] = !0, r;
    }
    _generateUid(t, r) {
      let n = t;
      return r > 1 && (n += r), `_${n}`;
    }
    generateUidBasedOnNode(t, r) {
      let n = [];
      ct(t, n);
      let i = n.join("$");
      return i = i.replace(/^_/, "") || r || "ref", this.generateUid(i.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(t, r) {
      return Ws(this.generateUidBasedOnNode(t, r));
    }
    isStatic(t) {
      if (uS(t) || yJ(t) || fS(t))
        return !0;
      if (Ks(t)) {
        let r = this.getBinding(t.name);
        return r ? r.constant : this.hasBinding(t.name);
      }
      return !1;
    }
    maybeGenerateMemoised(t, r) {
      if (this.isStatic(t))
        return null;
      {
        let n = this.generateUidIdentifierBasedOnNode(t);
        return r ? n : (this.push({
          id: n
        }), aS(n));
      }
    }
    checkBlockScopedCollisions(t, r, n, i) {
      if (r === "param" || t.kind === "local") return;
      if (r === "let" || t.kind === "let" || t.kind === "const" || t.kind === "module" || t.kind === "param" && r === "const")
        throw this.hub.buildError(i, `Duplicate declaration "${n}"`, TypeError);
    }
    rename(t, r) {
      let n = this.getBinding(t);
      n && (r || (r = this.generateUidIdentifier(t).name), new Yz.default(n, t, r).rename(arguments[2]));
    }
    _renameFromMap(t, r, n, i) {
      t[r] && (t[n] = i, t[r] = null);
    }
    dump() {
      let t = "-".repeat(60);
      console.log(t);
      let r = this;
      do {
        console.log("#", r.block.type);
        for (let n of Object.keys(r.bindings)) {
          let i = r.bindings[n];
          console.log(" -", n, {
            constant: i.constant,
            references: i.references,
            violations: i.constantViolations.length,
            kind: i.kind
          });
        }
      } while (r = r.parent);
      console.log(t);
    }
    toArray(t, r, n) {
      if (Ks(t)) {
        let o = this.getBinding(t.name);
        if (o != null && o.constant && o.path.isGenericType("Array"))
          return t;
      }
      if (oS(t))
        return t;
      if (Ks(t, {
        name: "arguments"
      }))
        return iS(vm(vm(vm(Ws("Array"), Ws("prototype")), Ws("slice")), Ws("call")), [t]);
      let i, a = [t];
      return r === !0 ? i = "toConsumableArray" : typeof r == "number" ? (a.push(TJ(r)), i = "slicedToArray") : i = "toArray", n && (a.unshift(
      this.hub.addHelper(i)), i = "maybeArrayLike"), iS(this.hub.addHelper(i), a);
    }
    hasLabel(t) {
      return !!this.getLabel(t);
    }
    getLabel(t) {
      return this.labels.get(t);
    }
    registerLabel(t) {
      this.labels.set(t.node.label.name, t);
    }
    registerDeclaration(t) {
      if (t.isLabeledStatement())
        this.registerLabel(t);
      else if (t.isFunctionDeclaration())
        this.registerBinding("hoisted", t.get("id"), t);
      else if (t.isVariableDeclaration()) {
        let r = t.get("declarations"), {
          kind: n
        } = t.node;
        for (let i of r)
          this.registerBinding(n === "using" || n === "await using" ? "const" : n, i);
      } else if (t.isClassDeclaration()) {
        if (t.node.declare) return;
        this.registerBinding("let", t);
      } else if (t.isImportDeclaration()) {
        let r = t.node.importKind === "type" || t.node.importKind === "typeof", n = t.get("specifiers");
        for (let i of n) {
          let a = r || i.isImportSpecifier() && (i.node.importKind === "type" || i.node.importKind === "typeof");
          this.registerBinding(a ? "unknown" : "module", i);
        }
      } else if (t.isExportDeclaration()) {
        let r = t.get("declaration");
        (r.isClassDeclaration() || r.isFunctionDeclaration() || r.isVariableDeclaration()) && this.registerDeclaration(r);
      } else
        this.registerBinding("unknown", t);
    }
    buildUndefinedNode() {
      return OJ();
    }
    registerConstantViolation(t) {
      let r = t.getAssignmentIdentifiers();
      for (let i of Object.keys(r)) {
        var n;
        (n = this.getBinding(i)) == null || n.reassign(t);
      }
    }
    registerBinding(t, r, n = r) {
      if (!t) throw new ReferenceError("no `kind`");
      if (r.isVariableDeclaration()) {
        let o = r.get("declarations");
        for (let l of o)
          this.registerBinding(t, l);
        return;
      }
      let i = this.getProgramParent(), a = r.getOuterBindingIdentifiers(!0);
      for (let o of Object.keys(a)) {
        i.references[o] = !0;
        for (let l of a[o]) {
          let u = this.getOwnBinding(o);
          if (u) {
            if (u.identifier === l) continue;
            this.checkBlockScopedCollisions(u, t, o, l);
          }
          u ? u.reassign(n) : this.bindings[o] = new Jz.default({
            identifier: l,
            scope: this,
            path: n,
            kind: t
          });
        }
      }
    }
    addGlobal(t) {
      this.globals[t.name] = t;
    }
    hasUid(t) {
      let r = this;
      do
        if (r.uids[t]) return !0;
      while (r = r.parent);
      return !1;
    }
    hasGlobal(t) {
      let r = this;
      do
        if (r.globals[t]) return !0;
      while (r = r.parent);
      return !1;
    }
    hasReference(t) {
      return !!this.getProgramParent().references[t];
    }
    isPure(t, r) {
      if (Ks(t)) {
        let o = this.getBinding(t.name);
        return o ? r ? o.constant : !0 : !1;
      } else {
        if (uS(t) || DJ(t) || fS(t) || IJ(t))
          return !0;
        if (rJ(t)) {
          var n;
          return t.superClass && !this.isPure(t.superClass, r) || ((n = t.decorators) == null ? void 0 : n.length) > 0 ? !1 : this.isPure(t.
          body, r);
        } else if (nJ(t)) {
          for (let o of t.body)
            if (!this.isPure(o, r)) return !1;
          return !0;
        } else {
          if (tJ(t))
            return this.isPure(t.left, r) && this.isPure(t.right, r);
          if (oS(t) || CJ(t)) {
            for (let o of t.elements)
              if (o !== null && !this.isPure(o, r)) return !1;
            return !0;
          } else if (pJ(t) || AJ(t)) {
            for (let o of t.properties)
              if (!this.isPure(o, r)) return !1;
            return !0;
          } else if (uJ(t)) {
            var i;
            return !(t.computed && !this.isPure(t.key, r) || ((i = t.decorators) == null ? void 0 : i.length) > 0);
          } else if (dJ(t)) {
            var a;
            return !(t.computed && !this.isPure(t.key, r) || ((a = t.decorators) == null ? void 0 : a.length) > 0 || (wJ(t) || t.static) && t.
            value !== null && !this.isPure(t.value, r));
          } else {
            if (bJ(t))
              return this.isPure(t.argument, r);
            if (mS(t)) {
              for (let o of t.expressions)
                if (!this.isPure(o, r)) return !1;
              return !0;
            } else return gJ(t) ? cS(t.tag, "String.raw") && !this.hasBinding("String", {
              noGlobals: !0
            }) && this.isPure(t.quasi, r) : lJ(t) ? !t.computed && Ks(t.object) && t.object.name === "Symbol" && Ks(t.property) && t.property.
            name !== "for" && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) : lS(t) ? cS(t.callee, "Symbol.for") && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) && t.arguments.length === 1 && Qz.isStringLiteral(t.arguments[0]) : hJ(t);
          }
        }
      }
    }
    setData(t, r) {
      return this.data[t] = r;
    }
    getData(t) {
      let r = this;
      do {
        let n = r.data[t];
        if (n != null) return n;
      } while (r = r.parent);
    }
    removeData(t) {
      let r = this;
      do
        r.data[t] != null && (r.data[t] = null);
      while (r = r.parent);
    }
    init() {
      this.inited || (this.inited = !0, this.crawl());
    }
    crawl() {
      let t = this.path;
      this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.
      create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
      let r = this.getProgramParent();
      if (r.crawling) return;
      let n = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      if (this.crawling = !0, t.type !== "Program" && (0, Zz.isExplodedVisitor)(du)) {
        for (let a of du.enter)
          a.call(n, t, n);
        let i = du[t.type];
        if (i)
          for (let a of i.enter)
            a.call(n, t, n);
      }
      t.traverse(du, n), this.crawling = !1;
      for (let i of n.assignments) {
        let a = i.getAssignmentIdentifiers();
        for (let o of Object.keys(a))
          i.scope.getBinding(o) || r.addGlobal(a[o]);
        i.scope.registerConstantViolation(i);
      }
      for (let i of n.references) {
        let a = i.scope.getBinding(i.node.name);
        a ? a.reference(i) : r.addGlobal(i.node);
      }
      for (let i of n.constantViolations)
        i.scope.registerConstantViolation(i);
    }
    push(t) {
      let r = this.path;
      r.isPattern() ? r = this.getPatternParent().path : !r.isBlockStatement() && !r.isProgram() && (r = this.getBlockParent().path), r.isSwitchStatement() &&
      (r = (this.getFunctionParent() || this.getProgramParent()).path);
      let {
        init: n,
        unique: i,
        kind: a = "var",
        id: o
      } = t;
      if (!n && !i && (a === "var" || a === "let") && r.isFunction() && !r.node.name && lS(r.parent, {
        callee: r.node
      }) && r.parent.arguments.length <= r.node.params.length && Ks(o)) {
        r.pushContainer("params", o), r.scope.registerBinding("param", r.get("params")[r.node.params.length - 1]);
        return;
      }
      (r.isLoop() || r.isCatchClause() || r.isFunction()) && (r.ensureBlock(), r = r.get("body"));
      let l = t._blockHoist == null ? 2 : t._blockHoist, u = `declaration:${a}:${l}`, c = !i && r.getData(u);
      if (!c) {
        let h = SJ(a, []);
        h._blockHoist = l, [c] = r.unshiftContainer("body", [h]), i || r.setData(u, c);
      }
      let f = PJ(o, n), p = c.node.declarations.push(f);
      r.scope.registerBinding(a, c.get("declarations")[p - 1]);
    }
    getProgramParent() {
      let t = this;
      do
        if (t.path.isProgram())
          return t;
      while (t = t.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let t = this;
      do
        if (t.path.isFunctionParent())
          return t;
      while (t = t.parent);
      return null;
    }
    getBlockParent() {
      let t = this;
      do
        if (t.path.isBlockParent())
          return t;
      while (t = t.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let t = this;
      do
        if (!t.path.isPattern())
          return t.getBlockParent();
      while (t = t.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      let t = /* @__PURE__ */ Object.create(null), r = this;
      do {
        for (let n of Object.keys(r.bindings))
          n in t || (t[n] = r.bindings[n]);
        r = r.parent;
      } while (r);
      return t;
    }
    getAllBindingsOfKind(...t) {
      let r = /* @__PURE__ */ Object.create(null);
      for (let n of t) {
        let i = this;
        do {
          for (let a of Object.keys(i.bindings)) {
            let o = i.bindings[a];
            o.kind === n && (r[a] = o);
          }
          i = i.parent;
        } while (i);
      }
      return r;
    }
    bindingIdentifierEquals(t, r) {
      return this.getBindingIdentifier(t) === r;
    }
    getBinding(t) {
      let r = this, n;
      do {
        let a = r.getOwnBinding(t);
        if (a) {
          var i;
          if (!((i = n) != null && i.isPattern() && a.kind !== "param" && a.kind !== "local"))
            return a;
        } else if (!a && t === "arguments" && r.path.isFunction() && !r.path.isArrowFunctionExpression())
          break;
        n = r.path;
      } while (r = r.parent);
    }
    getOwnBinding(t) {
      return this.bindings[t];
    }
    getBindingIdentifier(t) {
      var r;
      return (r = this.getBinding(t)) == null ? void 0 : r.identifier;
    }
    getOwnBindingIdentifier(t) {
      let r = this.bindings[t];
      return r?.identifier;
    }
    hasOwnBinding(t) {
      return !!this.getOwnBinding(t);
    }
    hasBinding(t, r) {
      if (!t) return !1;
      let n = this;
      do
        if (n.hasOwnBinding(t))
          return !0;
      while (n = n.parent);
      let i, a;
      return typeof r == "object" ? (i = r.noGlobals, a = r.noUids) : typeof r == "boolean" && (i = r), !!(!a && this.hasUid(t) || !i && e.globals.
      includes(t) || !i && e.contextVariables.includes(t));
    }
    parentHasBinding(t, r) {
      var n;
      return (n = this.parent) == null ? void 0 : n.hasBinding(t, r);
    }
    moveBindingTo(t, r) {
      let n = this.getBinding(t);
      n && (n.scope.removeOwnBinding(t), n.scope = r, r.bindings[t] = n);
    }
    removeOwnBinding(t) {
      delete this.bindings[t];
    }
    removeBinding(t) {
      var r;
      (r = this.getBinding(t)) == null || r.scope.removeOwnBinding(t);
      let n = this;
      do
        n.uids[t] && (n.uids[t] = !1);
      while (n = n.parent);
    }
    hoistVariables(t = (r) => this.push({
      id: r
    })) {
      this.crawl();
      let r = /* @__PURE__ */ new Set();
      for (let i of Object.keys(this.bindings)) {
        let a = this.bindings[i];
        if (!a) continue;
        let {
          path: o
        } = a;
        if (!o.isVariableDeclarator()) continue;
        let {
          parent: l,
          parentPath: u
        } = o;
        if (l.kind !== "var" || r.has(l)) continue;
        r.add(o.parent);
        let c, f = [];
        for (let p of l.declarations) {
          var n;
          (n = c) != null || (c = p.id), p.init && f.push(eJ("=", p.id, p.init));
          let h = Object.keys(dS(p, !1, !0, !0));
          for (let y of h)
            t(Ws(y), p.init != null);
        }
        if (u.parentPath.isFor({
          left: l
        }))
          u.replaceWith(c);
        else if (f.length === 0)
          u.remove();
        else {
          let p = f.length === 1 ? f[0] : NJ(f);
          u.parentPath.isForStatement({
            init: l
          }) ? u.replaceWith(p) : u.replaceWith(vJ(p));
        }
      }
    }
  };
  hu.default = ao;
  ao.globals = Object.keys(Xz.builtin);
  ao.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
});

// ../node_modules/@jridgewell/set-array/dist/set-array.umd.js
var gS = T((mu, yS) => {
  (function(e, t) {
    typeof mu == "object" && typeof yS < "u" ? t(mu) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, t(e.setArray = {}));
  })(mu, function(e) {
    "use strict";
    class t {
      static {
        s(this, "SetArray");
      }
      constructor() {
        this._indexes = { __proto__: null }, this.array = [];
      }
    }
    function r(l) {
      return l;
    }
    s(r, "cast");
    function n(l, u) {
      return l._indexes[u];
    }
    s(n, "get");
    function i(l, u) {
      let c = n(l, u);
      if (c !== void 0)
        return c;
      let { array: f, _indexes: p } = l, h = f.push(u);
      return p[u] = h - 1;
    }
    s(i, "put");
    function a(l) {
      let { array: u, _indexes: c } = l;
      if (u.length === 0)
        return;
      let f = u.pop();
      c[f] = void 0;
    }
    s(a, "pop");
    function o(l, u) {
      let c = n(l, u);
      if (c === void 0)
        return;
      let { array: f, _indexes: p } = l;
      for (let h = c + 1; h < f.length; h++) {
        let y = f[h];
        f[h - 1] = y, p[y]--;
      }
      p[u] = void 0, f.pop();
    }
    s(o, "remove"), e.SetArray = t, e.get = n, e.pop = a, e.put = i, e.remove = o, Object.defineProperty(e, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var xm = T((yu, bS) => {
  (function(e, t) {
    typeof yu == "object" && typeof bS < "u" ? t(yu) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, t(e.sourcemapCodec = {}));
  })(yu, function(e) {
    "use strict";
    let n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = new Uint8Array(64), a = new Uint8Array(128);
    for (let W = 0; W < n.length; W++) {
      let q = n.charCodeAt(W);
      i[W] = q, a[q] = W;
    }
    function o(W, q) {
      let M = 0, K = 0, pe = 0;
      do {
        let X = W.next();
        pe = a[X], M |= (pe & 31) << K, K += 5;
      } while (pe & 32);
      let ae = M & 1;
      return M >>>= 1, ae && (M = -2147483648 | -M), q + M;
    }
    s(o, "decodeInteger");
    function l(W, q, M) {
      let K = q - M;
      K = K < 0 ? -K << 1 | 1 : K << 1;
      do {
        let pe = K & 31;
        K >>>= 5, K > 0 && (pe |= 32), W.write(i[pe]);
      } while (K > 0);
      return q;
    }
    s(l, "encodeInteger");
    function u(W, q) {
      return W.pos >= q ? !1 : W.peek() !== 44;
    }
    s(u, "hasMoreVlq");
    let c = 1024 * 16, f = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
      decode(W) {
        return Buffer.from(W.buffer, W.byteOffset, W.byteLength).toString();
      }
    } : {
      decode(W) {
        let q = "";
        for (let M = 0; M < W.length; M++)
          q += String.fromCharCode(W[M]);
        return q;
      }
    };
    class p {
      static {
        s(this, "StringWriter");
      }
      constructor() {
        this.pos = 0, this.out = "", this.buffer = new Uint8Array(c);
      }
      write(q) {
        let { buffer: M } = this;
        M[this.pos++] = q, this.pos === c && (this.out += f.decode(M), this.pos = 0);
      }
      flush() {
        let { buffer: q, out: M, pos: K } = this;
        return K > 0 ? M + f.decode(q.subarray(0, K)) : M;
      }
    }
    class h {
      static {
        s(this, "StringReader");
      }
      constructor(q) {
        this.pos = 0, this.buffer = q;
      }
      next() {
        return this.buffer.charCodeAt(this.pos++);
      }
      peek() {
        return this.buffer.charCodeAt(this.pos);
      }
      indexOf(q) {
        let { buffer: M, pos: K } = this, pe = M.indexOf(q, K);
        return pe === -1 ? M.length : pe;
      }
    }
    let y = [];
    function v(W) {
      let { length: q } = W, M = new h(W), K = [], pe = [], ae = 0;
      for (; M.pos < q; M.pos++) {
        ae = o(M, ae);
        let X = o(M, 0);
        if (!u(M, q)) {
          let De = pe.pop();
          De[2] = ae, De[3] = X;
          continue;
        }
        let J = o(M, 0), be = o(M, 0) & 1 ? [ae, X, 0, 0, J, o(M, 0)] : [ae, X, 0, 0, J], Se = y;
        if (u(M, q)) {
          Se = [];
          do {
            let De = o(M, 0);
            Se.push(De);
          } while (u(M, q));
        }
        be.vars = Se, K.push(be), pe.push(be);
      }
      return K;
    }
    s(v, "decodeOriginalScopes");
    function d(W) {
      let q = new p();
      for (let M = 0; M < W.length; )
        M = b(W, M, q, [0]);
      return q.flush();
    }
    s(d, "encodeOriginalScopes");
    function b(W, q, M, K) {
      let pe = W[q], { 0: ae, 1: X, 2: J, 3: ne, 4: oe, vars: be } = pe;
      q > 0 && M.write(44), K[0] = l(M, ae, K[0]), l(M, X, 0), l(M, oe, 0);
      let Se = pe.length === 6 ? 1 : 0;
      l(M, Se, 0), pe.length === 6 && l(M, pe[5], 0);
      for (let De of be)
        l(M, De, 0);
      for (q++; q < W.length; ) {
        let De = W[q], { 0: he, 1: Ne } = De;
        if (he > J || he === J && Ne >= ne)
          break;
        q = b(W, q, M, K);
      }
      return M.write(44), K[0] = l(M, J, K[0]), l(M, ne, 0), q;
    }
    s(b, "_encodeOriginalScopes");
    function E(W) {
      let { length: q } = W, M = new h(W), K = [], pe = [], ae = 0, X = 0, J = 0, ne = 0, oe = 0, be = 0, Se = 0, De = 0;
      do {
        let he = M.indexOf(";"), Ne = 0;
        for (; M.pos < he; M.pos++) {
          if (Ne = o(M, Ne), !u(M, he)) {
            let Dt = pe.pop();
            Dt[2] = ae, Dt[3] = Ne;
            continue;
          }
          let mt = o(M, 0), Oe = mt & 1, ke = mt & 2, ft = mt & 4, Nt = null, Zt = y, Bt;
          if (Oe) {
            let Dt = o(M, X);
            J = o(M, X === Dt ? J : 0), X = Dt, Bt = [ae, Ne, 0, 0, Dt, J];
          } else
            Bt = [ae, Ne, 0, 0];
          if (Bt.isScope = !!ft, ke) {
            let Dt = ne, pr = oe;
            ne = o(M, ne);
            let nn = Dt === ne;
            oe = o(M, nn ? oe : 0), be = o(M, nn && pr === oe ? be : 0), Nt = [ne, oe, be];
          }
          if (Bt.callsite = Nt, u(M, he)) {
            Zt = [];
            do {
              Se = ae, De = Ne;
              let Dt = o(M, 0), pr;
              if (Dt < -1) {
                pr = [[o(M, 0)]];
                for (let nn = -1; nn > Dt; nn--) {
                  let vn = Se;
                  Se = o(M, Se), De = o(M, Se === vn ? De : 0);
                  let Vr = o(M, 0);
                  pr.push([Vr, Se, De]);
                }
              } else
                pr = [[Dt]];
              Zt.push(pr);
            } while (u(M, he));
          }
          Bt.bindings = Zt, K.push(Bt), pe.push(Bt);
        }
        ae++, M.pos = he + 1;
      } while (M.pos < q);
      return K;
    }
    s(E, "decodeGeneratedRanges");
    function I(W) {
      if (W.length === 0)
        return "";
      let q = new p();
      for (let M = 0; M < W.length; )
        M = O(W, M, q, [0, 0, 0, 0, 0, 0, 0]);
      return q.flush();
    }
    s(I, "encodeGeneratedRanges");
    function O(W, q, M, K) {
      let pe = W[q], { 0: ae, 1: X, 2: J, 3: ne, isScope: oe, callsite: be, bindings: Se } = pe;
      K[0] < ae ? (k(M, K[0], ae), K[0] = ae, K[1] = 0) : q > 0 && M.write(44), K[1] = l(M, pe[1], K[1]);
      let De = (pe.length === 6 ? 1 : 0) | (be ? 2 : 0) | (oe ? 4 : 0);
      if (l(M, De, 0), pe.length === 6) {
        let { 4: he, 5: Ne } = pe;
        he !== K[2] && (K[3] = 0), K[2] = l(M, he, K[2]), K[3] = l(M, Ne, K[3]);
      }
      if (be) {
        let { 0: he, 1: Ne, 2: mt } = pe.callsite;
        he !== K[4] ? (K[5] = 0, K[6] = 0) : Ne !== K[5] && (K[6] = 0), K[4] = l(M, he, K[4]), K[5] = l(M, Ne, K[5]), K[6] = l(M, mt, K[6]);
      }
      if (Se)
        for (let he of Se) {
          he.length > 1 && l(M, -he.length, 0);
          let Ne = he[0][0];
          l(M, Ne, 0);
          let mt = ae, Oe = X;
          for (let ke = 1; ke < he.length; ke++) {
            let ft = he[ke];
            mt = l(M, ft[1], mt), Oe = l(M, ft[2], Oe), l(M, ft[0], 0);
          }
        }
      for (q++; q < W.length; ) {
        let he = W[q], { 0: Ne, 1: mt } = he;
        if (Ne > J || Ne === J && mt >= ne)
          break;
        q = O(W, q, M, K);
      }
      return K[0] < J ? (k(M, K[0], J), K[0] = J, K[1] = 0) : M.write(44), K[1] = l(M, ne, K[1]), q;
    }
    s(O, "_encodeGeneratedRanges");
    function k(W, q, M) {
      do
        W.write(59);
      while (++q < M);
    }
    s(k, "catchupLine");
    function j(W) {
      let { length: q } = W, M = new h(W), K = [], pe = 0, ae = 0, X = 0, J = 0, ne = 0;
      do {
        let oe = M.indexOf(";"), be = [], Se = !0, De = 0;
        for (pe = 0; M.pos < oe; ) {
          let he;
          pe = o(M, pe), pe < De && (Se = !1), De = pe, u(M, oe) ? (ae = o(M, ae), X = o(M, X), J = o(M, J), u(M, oe) ? (ne = o(M, ne), he =
          [pe, ae, X, J, ne]) : he = [pe, ae, X, J]) : he = [pe], be.push(he), M.pos++;
        }
        Se || R(be), K.push(be), M.pos = oe + 1;
      } while (M.pos <= q);
      return K;
    }
    s(j, "decode");
    function R(W) {
      W.sort(U);
    }
    s(R, "sort");
    function U(W, q) {
      return W[0] - q[0];
    }
    s(U, "sortComparator");
    function Q(W) {
      let q = new p(), M = 0, K = 0, pe = 0, ae = 0;
      for (let X = 0; X < W.length; X++) {
        let J = W[X];
        if (X > 0 && q.write(59), J.length === 0)
          continue;
        let ne = 0;
        for (let oe = 0; oe < J.length; oe++) {
          let be = J[oe];
          oe > 0 && q.write(44), ne = l(q, be[0], ne), be.length !== 1 && (M = l(q, be[1], M), K = l(q, be[2], K), pe = l(q, be[3], pe), be.
          length !== 4 && (ae = l(q, be[4], ae)));
        }
      }
      return q.flush();
    }
    s(Q, "encode"), e.decode = j, e.decodeGeneratedRanges = E, e.decodeOriginalScopes = v, e.encode = Q, e.encodeGeneratedRanges = I, e.encodeOriginalScopes =
    d, Object.defineProperty(e, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var ES = T((Sm, Pm) => {
  (function(e, t) {
    typeof Sm == "object" && typeof Pm < "u" ? Pm.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, e.resolveURI = t());
  })(Sm, function() {
    "use strict";
    let e = /^[\w+.-]+:\/\//, t = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, r = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    var n;
    (function(E) {
      E[E.Empty = 1] = "Empty", E[E.Hash = 2] = "Hash", E[E.Query = 3] = "Query", E[E.RelativePath = 4] = "RelativePath", E[E.AbsolutePath =
      5] = "AbsolutePath", E[E.SchemeRelative = 6] = "SchemeRelative", E[E.Absolute = 7] = "Absolute";
    })(n || (n = {}));
    function i(E) {
      return e.test(E);
    }
    s(i, "isAbsoluteUrl");
    function a(E) {
      return E.startsWith("//");
    }
    s(a, "isSchemeRelativeUrl");
    function o(E) {
      return E.startsWith("/");
    }
    s(o, "isAbsolutePath");
    function l(E) {
      return E.startsWith("file:");
    }
    s(l, "isFileUrl");
    function u(E) {
      return /^[.?#]/.test(E);
    }
    s(u, "isRelative");
    function c(E) {
      let I = t.exec(E);
      return p(I[1], I[2] || "", I[3], I[4] || "", I[5] || "/", I[6] || "", I[7] || "");
    }
    s(c, "parseAbsoluteUrl");
    function f(E) {
      let I = r.exec(E), O = I[2];
      return p("file:", "", I[1] || "", "", o(O) ? O : "/" + O, I[3] || "", I[4] || "");
    }
    s(f, "parseFileUrl");
    function p(E, I, O, k, j, R, U) {
      return {
        scheme: E,
        user: I,
        host: O,
        port: k,
        path: j,
        query: R,
        hash: U,
        type: n.Absolute
      };
    }
    s(p, "makeUrl");
    function h(E) {
      if (a(E)) {
        let O = c("http:" + E);
        return O.scheme = "", O.type = n.SchemeRelative, O;
      }
      if (o(E)) {
        let O = c("http://foo.com" + E);
        return O.scheme = "", O.host = "", O.type = n.AbsolutePath, O;
      }
      if (l(E))
        return f(E);
      if (i(E))
        return c(E);
      let I = c("http://foo.com/" + E);
      return I.scheme = "", I.host = "", I.type = E ? E.startsWith("?") ? n.Query : E.startsWith("#") ? n.Hash : n.RelativePath : n.Empty, I;
    }
    s(h, "parseUrl");
    function y(E) {
      if (E.endsWith("/.."))
        return E;
      let I = E.lastIndexOf("/");
      return E.slice(0, I + 1);
    }
    s(y, "stripPathFilename");
    function v(E, I) {
      d(I, I.type), E.path === "/" ? E.path = I.path : E.path = y(I.path) + E.path;
    }
    s(v, "mergePaths");
    function d(E, I) {
      let O = I <= n.RelativePath, k = E.path.split("/"), j = 1, R = 0, U = !1;
      for (let W = 1; W < k.length; W++) {
        let q = k[W];
        if (!q) {
          U = !0;
          continue;
        }
        if (U = !1, q !== ".") {
          if (q === "..") {
            R ? (U = !0, R--, j--) : O && (k[j++] = q);
            continue;
          }
          k[j++] = q, R++;
        }
      }
      let Q = "";
      for (let W = 1; W < j; W++)
        Q += "/" + k[W];
      (!Q || U && !Q.endsWith("/..")) && (Q += "/"), E.path = Q;
    }
    s(d, "normalizePath");
    function b(E, I) {
      if (!E && !I)
        return "";
      let O = h(E), k = O.type;
      if (I && k !== n.Absolute) {
        let R = h(I), U = R.type;
        switch (k) {
          case n.Empty:
            O.hash = R.hash;
          // fall through
          case n.Hash:
            O.query = R.query;
          // fall through
          case n.Query:
          case n.RelativePath:
            v(O, R);
          // fall through
          case n.AbsolutePath:
            O.user = R.user, O.host = R.host, O.port = R.port;
          // fall through
          case n.SchemeRelative:
            O.scheme = R.scheme;
        }
        U > k && (k = U);
      }
      d(O, k);
      let j = O.query + O.hash;
      switch (k) {
        // This is impossible, because of the empty checks at the start of the function.
        // case UrlType.Empty:
        case n.Hash:
        case n.Query:
          return j;
        case n.RelativePath: {
          let R = O.path.slice(1);
          return R ? u(I || E) && !u(R) ? "./" + R + j : R + j : j || ".";
        }
        case n.AbsolutePath:
          return O.path + j;
        default:
          return O.scheme + "//" + O.user + O.host + O.port + O.path + j;
      }
    }
    return s(b, "resolve"), b;
  });
});

// ../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var bu = T((gu, vS) => {
  (function(e, t) {
    typeof gu == "object" && typeof vS < "u" ? t(gu, xm(), ES()) : typeof define == "function" && define.amd ? define(["exports", "@jridgewe\
ll/sourcemap-codec", "@jridgewell/resolve-uri"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, t(e.traceMapping = {}, e.sourcemapCodec,
    e.resolveURI));
  })(gu, function(e, t, r) {
    "use strict";
    function n(F, V) {
      return V && !V.endsWith("/") && (V += "/"), r(F, V);
    }
    s(n, "resolve");
    function i(F) {
      if (!F)
        return "";
      let V = F.lastIndexOf("/");
      return F.slice(0, V + 1);
    }
    s(i, "stripFilename");
    let a = 0, o = 1, l = 2, u = 3, c = 4, f = 1, p = 2;
    function h(F, V) {
      let H = y(F, 0);
      if (H === F.length)
        return F;
      V || (F = F.slice());
      for (let Z = H; Z < F.length; Z = y(F, Z + 1))
        F[Z] = d(F[Z], V);
      return F;
    }
    s(h, "maybeSort");
    function y(F, V) {
      for (let H = V; H < F.length; H++)
        if (!v(F[H]))
          return H;
      return F.length;
    }
    s(y, "nextUnsortedSegmentLine");
    function v(F) {
      for (let V = 1; V < F.length; V++)
        if (F[V][a] < F[V - 1][a])
          return !1;
      return !0;
    }
    s(v, "isSorted");
    function d(F, V) {
      return V || (F = F.slice()), F.sort(b);
    }
    s(d, "sortSegments");
    function b(F, V) {
      return F[a] - V[a];
    }
    s(b, "sortComparator");
    let E = !1;
    function I(F, V, H, Z) {
      for (; H <= Z; ) {
        let de = H + (Z - H >> 1), ce = F[de][a] - V;
        if (ce === 0)
          return E = !0, de;
        ce < 0 ? H = de + 1 : Z = de - 1;
      }
      return E = !1, H - 1;
    }
    s(I, "binarySearch");
    function O(F, V, H) {
      for (let Z = H + 1; Z < F.length && F[Z][a] === V; H = Z++)
        ;
      return H;
    }
    s(O, "upperBound");
    function k(F, V, H) {
      for (let Z = H - 1; Z >= 0 && F[Z][a] === V; H = Z--)
        ;
      return H;
    }
    s(k, "lowerBound");
    function j() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    s(j, "memoizedState");
    function R(F, V, H, Z) {
      let { lastKey: de, lastNeedle: ce, lastIndex: Ce } = H, Fe = 0, Ie = F.length - 1;
      if (Z === de) {
        if (V === ce)
          return E = Ce !== -1 && F[Ce][a] === V, Ce;
        V >= ce ? Fe = Ce === -1 ? 0 : Ce : Ie = Ce;
      }
      return H.lastKey = Z, H.lastNeedle = V, H.lastIndex = I(F, V, Fe, Ie);
    }
    s(R, "memoizedBinarySearch");
    function U(F, V) {
      let H = V.map(W);
      for (let Z = 0; Z < F.length; Z++) {
        let de = F[Z];
        for (let ce = 0; ce < de.length; ce++) {
          let Ce = de[ce];
          if (Ce.length === 1)
            continue;
          let Fe = Ce[o], Ie = Ce[l], je = Ce[u], Ct = H[Fe], Je = Ct[Ie] || (Ct[Ie] = []), $e = V[Fe], ut = O(Je, je, R(Je, je, $e, Ie));
          $e.lastIndex = ++ut, Q(Je, ut, [je, Z, Ce[a]]);
        }
      }
      return H;
    }
    s(U, "buildBySources");
    function Q(F, V, H) {
      for (let Z = F.length; Z > V; Z--)
        F[Z] = F[Z - 1];
      F[V] = H;
    }
    s(Q, "insert");
    function W() {
      return { __proto__: null };
    }
    s(W, "buildNullArray");
    let q = /* @__PURE__ */ s(function(F, V) {
      let H = M(F);
      if (!("sections" in H))
        return new Se(H, V);
      let Z = [], de = [], ce = [], Ce = [], Fe = [];
      K(H, V, Z, de, ce, Ce, Fe, 0, 0, 1 / 0, 1 / 0);
      let Ie = {
        version: 3,
        file: H.file,
        names: Ce,
        sources: de,
        sourcesContent: ce,
        mappings: Z,
        ignoreList: Fe
      };
      return pr(Ie);
    }, "AnyMap");
    function M(F) {
      return typeof F == "string" ? JSON.parse(F) : F;
    }
    s(M, "parse");
    function K(F, V, H, Z, de, ce, Ce, Fe, Ie, je, Ct) {
      let { sections: Je } = F;
      for (let $e = 0; $e < Je.length; $e++) {
        let { map: ut, offset: vt } = Je[$e], kt = je, an = Ct;
        if ($e + 1 < Je.length) {
          let zn = Je[$e + 1].offset;
          kt = Math.min(je, Fe + zn.line), kt === je ? an = Math.min(Ct, Ie + zn.column) : kt < je && (an = Ie + zn.column);
        }
        pe(ut, V, H, Z, de, ce, Ce, Fe + vt.line, Ie + vt.column, kt, an);
      }
    }
    s(K, "recurse");
    function pe(F, V, H, Z, de, ce, Ce, Fe, Ie, je, Ct) {
      let Je = M(F);
      if ("sections" in Je)
        return K(...arguments);
      let $e = new Se(Je, V), ut = Z.length, vt = ce.length, kt = Ne($e), { resolvedSources: an, sourcesContent: zn, ignoreList: Sa } = $e;
      if (ae(Z, an), ae(ce, $e.names), zn)
        ae(de, zn);
      else
        for (let er = 0; er < an.length; er++)
          de.push(null);
      if (Sa)
        for (let er = 0; er < Sa.length; er++)
          Ce.push(Sa[er] + ut);
      for (let er = 0; er < kt.length; er++) {
        let mi = Fe + er;
        if (mi > je)
          return;
        let Pa = X(H, mi), rN = er === 0 ? Ie : 0, L1 = kt[er];
        for (let Yf = 0; Yf < L1.length; Yf++) {
          let Is = L1[Yf], cl = rN + Is[a];
          if (mi === je && cl >= Ct)
            return;
          if (Is.length === 1) {
            Pa.push([cl]);
            continue;
          }
          let M1 = ut + Is[o], R1 = Is[l], q1 = Is[u];
          Pa.push(Is.length === 4 ? [cl, M1, R1, q1] : [cl, M1, R1, q1, vt + Is[c]]);
        }
      }
    }
    s(pe, "addSection");
    function ae(F, V) {
      for (let H = 0; H < V.length; H++)
        F.push(V[H]);
    }
    s(ae, "append");
    function X(F, V) {
      for (let H = F.length; H <= V; H++)
        F[H] = [];
      return F[V];
    }
    s(X, "getLine");
    let J = "`line` must be greater than 0 (lines start at line 1)", ne = "`column` must be greater than or equal to 0 (columns start at col\
umn 0)", oe = -1, be = 1;
    class Se {
      static {
        s(this, "TraceMap");
      }
      constructor(V, H) {
        let Z = typeof V == "string";
        if (!Z && V._decodedMemo)
          return V;
        let de = Z ? JSON.parse(V) : V, { version: ce, file: Ce, names: Fe, sourceRoot: Ie, sources: je, sourcesContent: Ct } = de;
        this.version = ce, this.file = Ce, this.names = Fe || [], this.sourceRoot = Ie, this.sources = je, this.sourcesContent = Ct, this.ignoreList =
        de.ignoreList || de.x_google_ignoreList || void 0;
        let Je = n(Ie || "", i(H));
        this.resolvedSources = je.map((ut) => n(ut || "", Je));
        let { mappings: $e } = de;
        typeof $e == "string" ? (this._encoded = $e, this._decoded = void 0) : (this._encoded = void 0, this._decoded = h($e, Z)), this._decodedMemo =
        j(), this._bySources = void 0, this._bySourceMemos = void 0;
      }
    }
    function De(F) {
      return F;
    }
    s(De, "cast");
    function he(F) {
      var V, H;
      return (V = (H = F)._encoded) !== null && V !== void 0 ? V : H._encoded = t.encode(F._decoded);
    }
    s(he, "encodedMappings");
    function Ne(F) {
      var V;
      return (V = F)._decoded || (V._decoded = t.decode(F._encoded));
    }
    s(Ne, "decodedMappings");
    function mt(F, V, H) {
      let Z = Ne(F);
      if (V >= Z.length)
        return null;
      let de = Z[V], ce = Tn(de, F._decodedMemo, V, H, be);
      return ce === -1 ? null : de[ce];
    }
    s(mt, "traceSegment");
    function Oe(F, V) {
      let { line: H, column: Z, bias: de } = V;
      if (H--, H < 0)
        throw new Error(J);
      if (Z < 0)
        throw new Error(ne);
      let ce = Ne(F);
      if (H >= ce.length)
        return sn(null, null, null, null);
      let Ce = ce[H], Fe = Tn(Ce, F._decodedMemo, H, Z, de || be);
      if (Fe === -1)
        return sn(null, null, null, null);
      let Ie = Ce[Fe];
      if (Ie.length === 1)
        return sn(null, null, null, null);
      let { names: je, resolvedSources: Ct } = F;
      return sn(Ct[Ie[o]], Ie[l] + 1, Ie[u], Ie.length === 5 ? je[Ie[c]] : null);
    }
    s(Oe, "originalPositionFor");
    function ke(F, V) {
      let { source: H, line: Z, column: de, bias: ce } = V;
      return re(F, H, Z, de, ce || be, !1);
    }
    s(ke, "generatedPositionFor");
    function ft(F, V) {
      let { source: H, line: Z, column: de, bias: ce } = V;
      return re(F, H, Z, de, ce || oe, !0);
    }
    s(ft, "allGeneratedPositionsFor");
    function Nt(F, V) {
      let H = Ne(F), { names: Z, resolvedSources: de } = F;
      for (let ce = 0; ce < H.length; ce++) {
        let Ce = H[ce];
        for (let Fe = 0; Fe < Ce.length; Fe++) {
          let Ie = Ce[Fe], je = ce + 1, Ct = Ie[0], Je = null, $e = null, ut = null, vt = null;
          Ie.length !== 1 && (Je = de[Ie[1]], $e = Ie[2] + 1, ut = Ie[3]), Ie.length === 5 && (vt = Z[Ie[4]]), V({
            generatedLine: je,
            generatedColumn: Ct,
            source: Je,
            originalLine: $e,
            originalColumn: ut,
            name: vt
          });
        }
      }
    }
    s(Nt, "eachMapping");
    function Zt(F, V) {
      let { sources: H, resolvedSources: Z } = F, de = H.indexOf(V);
      return de === -1 && (de = Z.indexOf(V)), de;
    }
    s(Zt, "sourceIndex");
    function Bt(F, V) {
      let { sourcesContent: H } = F;
      if (H == null)
        return null;
      let Z = Zt(F, V);
      return Z === -1 ? null : H[Z];
    }
    s(Bt, "sourceContentFor");
    function Dt(F, V) {
      let { ignoreList: H } = F;
      if (H == null)
        return !1;
      let Z = Zt(F, V);
      return Z === -1 ? !1 : H.includes(Z);
    }
    s(Dt, "isIgnored");
    function pr(F, V) {
      let H = new Se(Vr(F, []), V);
      return H._decoded = F.mappings, H;
    }
    s(pr, "presortedDecodedMap");
    function nn(F) {
      return Vr(F, Ne(F));
    }
    s(nn, "decodedMap");
    function vn(F) {
      return Vr(F, he(F));
    }
    s(vn, "encodedMap");
    function Vr(F, V) {
      return {
        version: F.version,
        file: F.file,
        names: F.names,
        sourceRoot: F.sourceRoot,
        sources: F.sources,
        sourcesContent: F.sourcesContent,
        mappings: V,
        ignoreList: F.ignoreList || F.x_google_ignoreList
      };
    }
    s(Vr, "clone");
    function sn(F, V, H, Z) {
      return { source: F, line: V, column: H, name: Z };
    }
    s(sn, "OMapping");
    function Yn(F, V) {
      return { line: F, column: V };
    }
    s(Yn, "GMapping");
    function Tn(F, V, H, Z, de) {
      let ce = R(F, Z, V, H);
      return E ? ce = (de === oe ? O : k)(F, Z, ce) : de === oe && ce++, ce === -1 || ce === F.length ? -1 : ce;
    }
    s(Tn, "traceSegmentInternal");
    function ue(F, V, H, Z, de) {
      let ce = Tn(F, V, H, Z, be);
      if (!E && de === oe && ce++, ce === -1 || ce === F.length)
        return [];
      let Ce = E ? Z : F[ce][a];
      E || (ce = k(F, Ce, ce));
      let Fe = O(F, Ce, ce), Ie = [];
      for (; ce <= Fe; ce++) {
        let je = F[ce];
        Ie.push(Yn(je[f] + 1, je[p]));
      }
      return Ie;
    }
    s(ue, "sliceGeneratedPositions");
    function re(F, V, H, Z, de, ce) {
      var Ce;
      if (H--, H < 0)
        throw new Error(J);
      if (Z < 0)
        throw new Error(ne);
      let { sources: Fe, resolvedSources: Ie } = F, je = Fe.indexOf(V);
      if (je === -1 && (je = Ie.indexOf(V)), je === -1)
        return ce ? [] : Yn(null, null);
      let Je = ((Ce = F)._bySources || (Ce._bySources = U(Ne(F), F._bySourceMemos = Fe.map(j))))[je][H];
      if (Je == null)
        return ce ? [] : Yn(null, null);
      let $e = F._bySourceMemos[je];
      if (ce)
        return ue(Je, $e, H, Z, de);
      let ut = Tn(Je, $e, H, Z, de);
      if (ut === -1)
        return Yn(null, null);
      let vt = Je[ut];
      return Yn(vt[f] + 1, vt[p]);
    }
    s(re, "generatedPosition"), e.AnyMap = q, e.GREATEST_LOWER_BOUND = be, e.LEAST_UPPER_BOUND = oe, e.TraceMap = Se, e.allGeneratedPositionsFor =
    ft, e.decodedMap = nn, e.decodedMappings = Ne, e.eachMapping = Nt, e.encodedMap = vn, e.encodedMappings = he, e.generatedPositionFor = ke,
    e.isIgnored = Dt, e.originalPositionFor = Oe, e.presortedDecodedMap = pr, e.sourceContentFor = Bt, e.traceSegment = mt;
  });
});

// ../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var Am = T((Eu, TS) => {
  (function(e, t) {
    typeof Eu == "object" && typeof TS < "u" ? t(Eu, gS(), xm(), bu()) : typeof define == "function" && define.amd ? define(["exports", "@jr\
idgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], t) : (e = typeof globalThis < "u" ? globalThis : e || self,
    t(e.genMapping = {}, e.setArray, e.sourcemapCodec, e.traceMapping));
  })(Eu, function(e, t, r, n) {
    "use strict";
    class f {
      static {
        s(this, "GenMapping");
      }
      constructor({ file: J, sourceRoot: ne } = {}) {
        this._names = new t.SetArray(), this._sources = new t.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = J, this.
        sourceRoot = ne, this._ignoreList = new t.SetArray();
      }
    }
    function p(X) {
      return X;
    }
    s(p, "cast");
    function h(X, J, ne, oe, be, Se, De, he) {
      return R(!1, X, J, ne, oe, be, Se, De, he);
    }
    s(h, "addSegment");
    function y(X, J) {
      return ae(!1, X, J);
    }
    s(y, "addMapping");
    let v = /* @__PURE__ */ s((X, J, ne, oe, be, Se, De, he) => R(!0, X, J, ne, oe, be, Se, De, he), "maybeAddSegment"), d = /* @__PURE__ */ s(
    (X, J) => ae(!0, X, J), "maybeAddMapping");
    function b(X, J, ne) {
      let { _sources: oe, _sourcesContent: be } = X, Se = t.put(oe, J);
      be[Se] = ne;
    }
    s(b, "setSourceContent");
    function E(X, J, ne = !0) {
      let { _sources: oe, _sourcesContent: be, _ignoreList: Se } = X, De = t.put(oe, J);
      De === be.length && (be[De] = null), ne ? t.put(Se, De) : t.remove(Se, De);
    }
    s(E, "setIgnore");
    function I(X) {
      let { _mappings: J, _sources: ne, _sourcesContent: oe, _names: be, _ignoreList: Se } = X;
      return q(J), {
        version: 3,
        file: X.file || void 0,
        names: be.array,
        sourceRoot: X.sourceRoot || void 0,
        sources: ne.array,
        sourcesContent: oe,
        mappings: J,
        ignoreList: Se.array
      };
    }
    s(I, "toDecodedMap");
    function O(X) {
      let J = I(X);
      return Object.assign(Object.assign({}, J), { mappings: r.encode(J.mappings) });
    }
    s(O, "toEncodedMap");
    function k(X) {
      let J = new n.TraceMap(X), ne = new f({ file: J.file, sourceRoot: J.sourceRoot });
      return M(ne._names, J.names), M(ne._sources, J.sources), ne._sourcesContent = J.sourcesContent || J.sources.map(() => null), ne._mappings =
      n.decodedMappings(J), J.ignoreList && M(ne._ignoreList, J.ignoreList), ne;
    }
    s(k, "fromMap");
    function j(X) {
      let J = [], { _mappings: ne, _sources: oe, _names: be } = X;
      for (let Se = 0; Se < ne.length; Se++) {
        let De = ne[Se];
        for (let he = 0; he < De.length; he++) {
          let Ne = De[he], mt = { line: Se + 1, column: Ne[0] }, Oe, ke, ft;
          Ne.length !== 1 && (Oe = oe.array[Ne[1]], ke = { line: Ne[2] + 1, column: Ne[3] }, Ne.length === 5 && (ft = be.array[Ne[4]])), J.push(
          { generated: mt, source: Oe, original: ke, name: ft });
        }
      }
      return J;
    }
    s(j, "allMappings");
    function R(X, J, ne, oe, be, Se, De, he, Ne) {
      let { _mappings: mt, _sources: Oe, _sourcesContent: ke, _names: ft } = J, Nt = U(mt, ne), Zt = Q(Nt, oe);
      if (!be)
        return X && K(Nt, Zt) ? void 0 : W(Nt, Zt, [oe]);
      let Bt = t.put(Oe, be), Dt = he ? t.put(ft, he) : -1;
      if (Bt === ke.length && (ke[Bt] = Ne ?? null), !(X && pe(Nt, Zt, Bt, Se, De, Dt)))
        return W(Nt, Zt, he ? [oe, Bt, Se, De, Dt] : [oe, Bt, Se, De]);
    }
    s(R, "addSegmentInternal");
    function U(X, J) {
      for (let ne = X.length; ne <= J; ne++)
        X[ne] = [];
      return X[J];
    }
    s(U, "getLine");
    function Q(X, J) {
      let ne = X.length;
      for (let oe = ne - 1; oe >= 0; ne = oe--) {
        let be = X[oe];
        if (J >= be[0])
          break;
      }
      return ne;
    }
    s(Q, "getColumnIndex");
    function W(X, J, ne) {
      for (let oe = X.length; oe > J; oe--)
        X[oe] = X[oe - 1];
      X[J] = ne;
    }
    s(W, "insert");
    function q(X) {
      let { length: J } = X, ne = J;
      for (let oe = ne - 1; oe >= 0 && !(X[oe].length > 0); ne = oe, oe--)
        ;
      ne < J && (X.length = ne);
    }
    s(q, "removeEmptyFinalLines");
    function M(X, J) {
      for (let ne = 0; ne < J.length; ne++)
        t.put(X, J[ne]);
    }
    s(M, "putAll");
    function K(X, J) {
      return J === 0 ? !0 : X[J - 1].length === 1;
    }
    s(K, "skipSourceless");
    function pe(X, J, ne, oe, be, Se) {
      if (J === 0)
        return !1;
      let De = X[J - 1];
      return De.length === 1 ? !1 : ne === De[1] && oe === De[2] && be === De[3] && Se === (De.length === 5 ? De[4] : -1);
    }
    s(pe, "skipSource");
    function ae(X, J, ne) {
      let { generated: oe, source: be, original: Se, name: De, content: he } = ne;
      return be ? R(X, J, oe.line - 1, oe.column, be, Se.line - 1, Se.column, De, he) : R(X, J, oe.line - 1, oe.column, null, null, null, null,
      null);
    }
    s(ae, "addMappingInternal"), e.GenMapping = f, e.addMapping = y, e.addSegment = h, e.allMappings = j, e.fromMap = k, e.maybeAddMapping =
    d, e.maybeAddSegment = v, e.setIgnore = E, e.setSourceContent = b, e.toDecodedMap = I, e.toEncodedMap = O, Object.defineProperty(e, "__e\
sModule", { value: !0 });
  });
});

// ../node_modules/@babel/generator/lib/source-map.js
var xS = T((vu) => {
  "use strict";
  Object.defineProperty(vu, "__esModule", {
    value: !0
  });
  vu.default = void 0;
  var is = Am(), Cm = bu(), wm = class {
    static {
      s(this, "SourceMap");
    }
    constructor(t, r) {
      var n;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn =
      0, this._inputMap = void 0;
      let i = this._map = new is.GenMapping({
        sourceRoot: t.sourceRoot
      });
      if (this._sourceFileName = (n = t.sourceFileName) == null ? void 0 : n.replace(/\\/g, "/"), this._rawMappings = void 0, t.inputSourceMap) {
        this._inputMap = new Cm.TraceMap(t.inputSourceMap);
        let o = this._inputMap.resolvedSources;
        if (o.length)
          for (let l = 0; l < o.length; l++) {
            var a;
            (0, is.setSourceContent)(i, o[l], (a = this._inputMap.sourcesContent) == null ? void 0 : a[l]);
          }
      }
      if (typeof r == "string" && !t.inputSourceMap)
        (0, is.setSourceContent)(i, this._sourceFileName, r);
      else if (typeof r == "object")
        for (let o of Object.keys(r))
          (0, is.setSourceContent)(i, o.replace(/\\/g, "/"), r[o]);
    }
    get() {
      return (0, is.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, is.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, is.allMappings)(this._map));
    }
    mark(t, r, n, i, a, o) {
      var l;
      this._rawMappings = void 0;
      let u;
      if (r != null)
        if (this._inputMap) {
          if (u = (0, Cm.originalPositionFor)(this._inputMap, {
            line: r,
            column: n
          }), !u.name && a) {
            let c = (0, Cm.originalPositionFor)(this._inputMap, a);
            c.name && (i = c.name);
          }
        } else
          u = {
            source: o?.replace(/\\/g, "/") || this._sourceFileName,
            line: r,
            column: n
          };
      (0, is.maybeAddMapping)(this._map, {
        name: i,
        generated: t,
        source: (l = u) == null ? void 0 : l.source,
        original: u
      });
    }
  };
  vu.default = wm;
});

// ../node_modules/@babel/generator/lib/buffer.js
var SS = T((Tu) => {
  "use strict";
  Object.defineProperty(Tu, "__esModule", {
    value: !0
  });
  Tu.default = void 0;
  var Dm = class {
    static {
      s(this, "Buffer");
    }
    constructor(t, r) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this.
      _canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = t, this._indentChar = r;
      for (let n = 0; n < 64; n++)
        this._fastIndentations.push(r.repeat(n));
      this._allocQueue();
    }
    _allocQueue() {
      let t = this._queue;
      for (let r = 0; r < 16; r++)
        t.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(t, r, n, i, a) {
      let o = this._queueCursor;
      o === this._queue.length && this._allocQueue();
      let l = this._queue[o];
      l.char = t, l.repeat = r, l.line = n, l.column = i, l.filename = a, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      let t = this._map, r = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: t?.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          let n = t ? t.get() : null;
          return r.map = n, n;
        },
        set map(n) {
          Object.defineProperty(r, "map", {
            value: n,
            writable: !0
          });
        },
        get rawMappings() {
          let n = t?.getRawMappings();
          return r.rawMappings = n, n;
        },
        set rawMappings(n) {
          Object.defineProperty(r, "rawMappings", {
            value: n,
            writable: !0
          });
        }
      };
      return r;
    }
    append(t, r) {
      this._flush(), this._append(t, this._sourcePosition, r);
    }
    appendChar(t) {
      this._flush(), this._appendChar(t, 1, this._sourcePosition);
    }
    queue(t) {
      if (t === 10)
        for (; this._queueCursor !== 0; ) {
          let n = this._queue[this._queueCursor - 1].char;
          if (n !== 32 && n !== 9)
            break;
          this._queueCursor--;
        }
      let r = this._sourcePosition;
      this._pushQueue(t, 1, r.line, r.column, r.filename);
    }
    queueIndentation(t) {
      t !== 0 && this._pushQueue(-1, t, void 0, void 0, void 0);
    }
    _flush() {
      let t = this._queueCursor, r = this._queue;
      for (let n = 0; n < t; n++) {
        let i = r[n];
        this._appendChar(i.char, i.repeat, i);
      }
      this._queueCursor = 0;
    }
    _appendChar(t, r, n) {
      if (this._last = t, t === -1) {
        let i = this._fastIndentations[r];
        i !== void 0 ? this._str += i : this._str += r > 1 ? this._indentChar.repeat(r) : this._indentChar;
      } else
        this._str += r > 1 ? String.fromCharCode(t).repeat(r) : String.fromCharCode(t);
      t !== 10 ? (this._mark(n.line, n.column, n.identifierName, n.identifierNamePos, n.filename), this._position.column += r) : (this._position.
      line++, this._position.column = 0), this._canMarkIdName && (n.identifierName = void 0, n.identifierNamePos = void 0);
    }
    _append(t, r, n) {
      let i = t.length, a = this._position;
      if (this._last = t.charCodeAt(i - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = t, this._appendCount =
      0) : this._str += t, !n && !this._map) {
        a.column += i;
        return;
      }
      let {
        column: o,
        identifierName: l,
        identifierNamePos: u,
        filename: c
      } = r, f = r.line;
      (l != null || u != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
      let p = t.indexOf(`
`), h = 0;
      for (p !== 0 && this._mark(f, o, l, u, c); p !== -1; )
        a.line++, a.column = 0, h = p + 1, h < i && f !== void 0 && this._mark(++f, 0, null, null, c), p = t.indexOf(`
`, h);
      a.column += i - h;
    }
    _mark(t, r, n, i, a) {
      var o;
      (o = this._map) == null || o.mark(this._position, t, r, n, i, a);
    }
    removeTrailingNewline() {
      let t = this._queueCursor;
      t !== 0 && this._queue[t - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      let t = this._queueCursor;
      t !== 0 && this._queue[t - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      let t = this._queueCursor;
      return t !== 0 ? this._queue[t - 1].char : this._last;
    }
    getNewlineCount() {
      let t = this._queueCursor, r = 0;
      if (t === 0) return this._last === 10 ? 1 : 0;
      for (let n = t - 1; n >= 0 && this._queue[n].char === 10; n--)
        r++;
      return r === t && this._last === 10 ? r + 1 : r;
    }
    endsWithCharAndNewline() {
      let t = this._queue, r = this._queueCursor;
      if (r !== 0)
        return t[r - 1].char !== 10 ? void 0 : r > 1 ? t[r - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(t, r) {
      if (!this._map) {
        r();
        return;
      }
      this.source("start", t);
      let n = t.identifierName, i = this._sourcePosition;
      n && (this._canMarkIdName = !1, i.identifierName = n), r(), n && (this._canMarkIdName = !0, i.identifierName = void 0, i.identifierNamePos =
      void 0), this.source("end", t);
    }
    source(t, r) {
      this._map && this._normalizePosition(t, r, 0);
    }
    sourceWithOffset(t, r, n) {
      this._map && this._normalizePosition(t, r, n);
    }
    _normalizePosition(t, r, n) {
      let i = r[t], a = this._sourcePosition;
      i && (a.line = i.line, a.column = Math.max(i.column + n, 0), a.filename = r.filename);
    }
    getCurrentColumn() {
      let t = this._queue, r = this._queueCursor, n = -1, i = 0;
      for (let a = 0; a < r; a++) {
        let o = t[a];
        o.char === 10 && (n = i), i += o.repeat;
      }
      return n === -1 ? this._position.column + i : i - 1 - n;
    }
    getCurrentLine() {
      let t = 0, r = this._queue;
      for (let n = 0; n < this._queueCursor; n++)
        r[n].char === 10 && t++;
      return this._position.line + t;
    }
  };
  Tu.default = Dm;
});

// ../node_modules/@babel/generator/lib/node/whitespace.js
var DS = T((Su) => {
  "use strict";
  Object.defineProperty(Su, "__esModule", {
    value: !0
  });
  Su.nodes = void 0;
  var kJ = Pe(), {
    FLIPPED_ALIAS_KEYS: FJ,
    isArrayExpression: jJ,
    isAssignmentExpression: AS,
    isBinary: CS,
    isBlockStatement: LJ,
    isCallExpression: wS,
    isFunction: oo,
    isIdentifier: xu,
    isLiteral: MJ,
    isMemberExpression: Im,
    isObjectExpression: RJ,
    isOptionalCallExpression: qJ,
    isOptionalMemberExpression: UJ,
    isStringLiteral: VJ
  } = kJ;
  function Li(e, t) {
    return e && (Im(e) || UJ(e) ? (Li(e.object, t), e.computed && Li(e.property, t)) : CS(e) || AS(e) ? (Li(e.left, t), Li(e.right, t)) : wS(
    e) || qJ(e) ? (t.hasCall = !0, Li(e.callee, t)) : oo(e) ? t.hasFunction = !0 : xu(e) && (t.hasHelper = t.hasHelper || e.callee && _n(e.callee))),
    t;
  }
  s(Li, "crawlInternal");
  function PS(e) {
    return Li(e, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  s(PS, "crawl");
  function _n(e) {
    return e ? Im(e) ? _n(e.object) || _n(e.property) : xu(e) ? e.name === "require" || e.name.charCodeAt(0) === 95 : wS(e) ? _n(e.callee) :
    CS(e) || AS(e) ? xu(e.left) && _n(e.left) || _n(e.right) : !1 : !1;
  }
  s(_n, "isHelper");
  function $J(e) {
    return MJ(e) || RJ(e) || jJ(e) || xu(e) || Im(e);
  }
  s($J, "isType");
  var Gs = Su.nodes = {
    AssignmentExpression(e) {
      let t = PS(e.right);
      if (t.hasCall && t.hasHelper || t.hasFunction)
        return t.hasFunction ? 3 : 2;
    },
    SwitchCase(e, t) {
      return (e.consequent.length || t.cases[0] === e ? 1 : 0) | (!e.consequent.length && t.cases[t.cases.length - 1] === e ? 2 : 0);
    },
    LogicalExpression(e) {
      if (oo(e.left) || oo(e.right))
        return 2;
    },
    Literal(e) {
      if (VJ(e) && e.value === "use strict")
        return 2;
    },
    CallExpression(e) {
      if (oo(e.callee) || _n(e))
        return 3;
    },
    OptionalCallExpression(e) {
      if (oo(e.callee))
        return 3;
    },
    VariableDeclaration(e) {
      for (let t = 0; t < e.declarations.length; t++) {
        let r = e.declarations[t], n = _n(r.id) && !$J(r.init);
        if (!n && r.init) {
          let i = PS(r.init);
          n = _n(r.init) && i.hasCall || i.hasFunction;
        }
        if (n)
          return 3;
      }
    },
    IfStatement(e) {
      if (LJ(e.consequent))
        return 3;
    }
  };
  Gs.ObjectProperty = Gs.ObjectTypeProperty = Gs.ObjectMethod = function(e, t) {
    if (t.properties[0] === e)
      return 1;
  };
  Gs.ObjectTypeCallProperty = function(e, t) {
    var r;
    if (t.callProperties[0] === e && !((r = t.properties) != null && r.length))
      return 1;
  };
  Gs.ObjectTypeIndexer = function(e, t) {
    var r, n;
    if (t.indexers[0] === e && !((r = t.properties) != null && r.length) && !((n = t.callProperties) != null && n.length))
      return 1;
  };
  Gs.ObjectTypeInternalSlot = function(e, t) {
    var r, n, i;
    if (t.internalSlots[0] === e && !((r = t.properties) != null && r.length) && !((n = t.callProperties) != null && n.length) && !((i = t.indexers) !=
    null && i.length))
      return 1;
  };
  [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([
  e, t]) {
    [e].concat(FJ[e] || []).forEach(function(r) {
      let n = t ? 3 : 0;
      Gs[r] = () => n;
    });
  });
});

// ../node_modules/@babel/generator/lib/node/parentheses.js
var kS = T((rt) => {
  "use strict";
  Object.defineProperty(rt, "__esModule", {
    value: !0
  });
  rt.ArrowFunctionExpression = yX;
  rt.AssignmentExpression = bX;
  rt.Binary = NS;
  rt.BinaryExpression = fX;
  rt.ClassExpression = hX;
  rt.ConditionalExpression = Om;
  rt.DoExpression = sX;
  rt.FunctionExpression = mX;
  rt.FunctionTypeAnnotation = tX;
  rt.Identifier = vX;
  rt.LogicalExpression = EX;
  rt.NullableTypeAnnotation = eX;
  rt.ObjectExpression = nX;
  rt.OptionalIndexedAccessType = aX;
  rt.OptionalCallExpression = rt.OptionalMemberExpression = gX;
  rt.SequenceExpression = pX;
  rt.TSSatisfiesExpression = rt.TSAsExpression = oX;
  rt.TSInferType = uX;
  rt.TSInstantiationExpression = cX;
  rt.UnaryLike = rt.TSTypeAssertion = BS;
  rt.TSIntersectionType = rt.TSUnionType = lX;
  rt.IntersectionTypeAnnotation = rt.UnionTypeAnnotation = iX;
  rt.UpdateExpression = rX;
  rt.AwaitExpression = rt.YieldExpression = dX;
  var WJ = Pe(), Or = as(), {
    isArrayTypeAnnotation: KJ,
    isBinaryExpression: GJ,
    isCallExpression: HJ,
    isExportDeclaration: YJ,
    isForOfStatement: zJ,
    isIndexedAccessType: JJ,
    isMemberExpression: OS,
    isObjectPattern: XJ,
    isOptionalMemberExpression: QJ,
    isYieldExpression: ZJ
  } = WJ, IS = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!\
=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-",
  8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function _S(e, t) {
    if (t === "BinaryExpression" || t === "LogicalExpression")
      return IS.get(e.operator);
    if (t === "TSAsExpression" || t === "TSSatisfiesExpression")
      return IS.get("in");
  }
  s(_S, "getBinaryPrecedence");
  function _m(e) {
    return e === "TSAsExpression" || e === "TSSatisfiesExpression" || e === "TSTypeAssertion";
  }
  s(_m, "isTSTypeExpression");
  var Pu = /* @__PURE__ */ s((e, t) => {
    let r = t.type;
    return (r === "ClassDeclaration" || r === "ClassExpression") && t.superClass === e;
  }, "isClassExtendsClause"), Au = /* @__PURE__ */ s((e, t) => {
    let r = t.type;
    return (r === "MemberExpression" || r === "OptionalMemberExpression") && t.object === e || (r === "CallExpression" || r === "OptionalCal\
lExpression" || r === "NewExpression") && t.callee === e || r === "TaggedTemplateExpression" && t.tag === e || r === "TSNonNullExpression";
  }, "hasPostfixPart");
  function eX(e, t) {
    return KJ(t);
  }
  s(eX, "NullableTypeAnnotation");
  function tX(e, t, r) {
    let n = t.type;
    return n === "UnionTypeAnnotation" || n === "IntersectionTypeAnnotation" || n === "ArrayTypeAnnotation" || !!(r & Or.TokenContext.arrowFlowReturnType);
  }
  s(tX, "FunctionTypeAnnotation");
  function rX(e, t) {
    return Au(e, t) || Pu(e, t);
  }
  s(rX, "UpdateExpression");
  function nX(e, t, r) {
    return !!(r & (Or.TokenContext.expressionStatement | Or.TokenContext.arrowBody));
  }
  s(nX, "ObjectExpression");
  function sX(e, t, r) {
    return !e.async && !!(r & Or.TokenContext.expressionStatement);
  }
  s(sX, "DoExpression");
  function NS(e, t) {
    let r = t.type;
    if (e.type === "BinaryExpression" && e.operator === "**" && r === "BinaryExpression" && t.operator === "**")
      return t.left === e;
    if (Pu(e, t) || Au(e, t) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression")
      return !0;
    let n = _S(t, r);
    if (n != null) {
      let i = _S(e, e.type);
      if (n === i && r === "BinaryExpression" && t.right === e || n > i)
        return !0;
    }
  }
  s(NS, "Binary");
  function iX(e, t) {
    let r = t.type;
    return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
  }
  s(iX, "UnionTypeAnnotation");
  function aX(e, t) {
    return JJ(t) && t.objectType === e;
  }
  s(aX, "OptionalIndexedAccessType");
  function oX(e, t) {
    return (t.type === "AssignmentExpression" || t.type === "AssignmentPattern") && t.left === e || t.type === "BinaryExpression" && (t.operator ===
    "|" || t.operator === "&") && e === t.left ? !0 : NS(e, t);
  }
  s(oX, "TSAsExpression");
  function lX(e, t) {
    let r = t.type;
    return r === "TSArrayType" || r === "TSOptionalType" || r === "TSIntersectionType" || r === "TSUnionType" || r === "TSRestType";
  }
  s(lX, "TSUnionType");
  function uX(e, t) {
    let r = t.type;
    return r === "TSArrayType" || r === "TSOptionalType";
  }
  s(uX, "TSInferType");
  function cX(e, t) {
    let r = t.type;
    return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!t.typeParameters;
  }
  s(cX, "TSInstantiationExpression");
  function fX(e, t, r, n) {
    return e.operator === "in" && n;
  }
  s(fX, "BinaryExpression");
  function pX(e, t) {
    let r = t.type;
    return !(r === "ForStatement" || r === "ThrowStatement" || r === "ReturnStatement" || r === "IfStatement" && t.test === e || r === "Whil\
eStatement" && t.test === e || r === "ForInStatement" && t.right === e || r === "SwitchStatement" && t.discriminant === e || r === "Expressi\
onStatement" && t.expression === e);
  }
  s(pX, "SequenceExpression");
  function dX(e, t) {
    let r = t.type;
    return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || Au(e, t) || r === "A\
waitExpression" && ZJ(e) || r === "ConditionalExpression" && e === t.test || Pu(e, t) || _m(r);
  }
  s(dX, "YieldExpression");
  function hX(e, t, r) {
    return !!(r & (Or.TokenContext.expressionStatement | Or.TokenContext.exportDefault));
  }
  s(hX, "ClassExpression");
  function BS(e, t) {
    return Au(e, t) || GJ(t) && t.operator === "**" && t.left === e || Pu(e, t);
  }
  s(BS, "UnaryLike");
  function mX(e, t, r) {
    return !!(r & (Or.TokenContext.expressionStatement | Or.TokenContext.exportDefault));
  }
  s(mX, "FunctionExpression");
  function yX(e, t) {
    return YJ(t) || Om(e, t);
  }
  s(yX, "ArrowFunctionExpression");
  function Om(e, t) {
    let r = t.type;
    return r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalEx\
pression" && t.test === e || r === "AwaitExpression" || _m(r) ? !0 : BS(e, t);
  }
  s(Om, "ConditionalExpression");
  function gX(e, t) {
    return HJ(t) && t.callee === e || OS(t) && t.object === e;
  }
  s(gX, "OptionalMemberExpression");
  function bX(e, t) {
    return XJ(e.left) ? !0 : Om(e, t);
  }
  s(bX, "AssignmentExpression");
  function EX(e, t) {
    let r = t.type;
    if (_m(r)) return !0;
    if (r !== "LogicalExpression") return !1;
    switch (e.operator) {
      case "||":
        return t.operator === "??" || t.operator === "&&";
      case "&&":
        return t.operator === "??";
      case "??":
        return t.operator !== "??";
    }
  }
  s(EX, "LogicalExpression");
  function vX(e, t, r) {
    var n;
    let i = t.type;
    if ((n = e.extra) != null && n.parenthesized && i === "AssignmentExpression" && t.left === e) {
      let a = t.right.type;
      if ((a === "FunctionExpression" || a === "ClassExpression") && t.right.id == null)
        return !0;
    }
    return e.name === "let" ? (OS(t, {
      object: e,
      computed: !0
    }) || QJ(t, {
      object: e,
      computed: !0,
      optional: !1
    })) && r & (Or.TokenContext.expressionStatement | Or.TokenContext.forHead | Or.TokenContext.forInHead) ? !0 : !!(r & Or.TokenContext.forOfHead) :
    e.name === "async" && zJ(t, {
      left: e,
      await: !1
    });
  }
  s(vX, "Identifier");
});

// ../node_modules/@babel/generator/lib/node/index.js
var as = T((os) => {
  "use strict";
  Object.defineProperty(os, "__esModule", {
    value: !0
  });
  os.TokenContext = void 0;
  os.needsParens = kX;
  os.needsWhitespace = Bm;
  os.needsWhitespaceAfter = BX;
  os.needsWhitespaceBefore = NX;
  var TX = DS(), xX = kS(), SX = Pe(), {
    FLIPPED_ALIAS_KEYS: PX,
    isCallExpression: FS,
    isDecorator: AX,
    isExpressionStatement: CX,
    isMemberExpression: wX,
    isNewExpression: DX,
    isParenthesizedExpression: IX
  } = SX, AAe = os.TokenContext = {
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    forHead: 8,
    forInHead: 16,
    forOfHead: 32,
    arrowFlowReturnType: 64
  };
  function jS(e) {
    let t = /* @__PURE__ */ new Map();
    function r(n, i) {
      let a = t.get(n);
      t.set(n, a ? function(o, l, u, c) {
        var f;
        return (f = a(o, l, u, c)) != null ? f : i(o, l, u, c);
      } : i);
    }
    s(r, "add");
    for (let n of Object.keys(e)) {
      let i = PX[n];
      if (i)
        for (let a of i)
          r(a, e[n]);
      else
        r(n, e[n]);
    }
    return t;
  }
  s(jS, "expandAliases");
  var _X = jS(xX), OX = jS(TX.nodes);
  function LS(e) {
    return FS(e) ? !0 : wX(e) && LS(e.object);
  }
  s(LS, "isOrHasCallExpression");
  function Bm(e, t, r) {
    var n;
    if (!e) return !1;
    CX(e) && (e = e.expression);
    let i = (n = OX.get(e.type)) == null ? void 0 : n(e, t);
    return typeof i == "number" ? (i & r) !== 0 : !1;
  }
  s(Bm, "needsWhitespace");
  function NX(e, t) {
    return Bm(e, t, 1);
  }
  s(NX, "needsWhitespaceBefore");
  function BX(e, t) {
    return Bm(e, t, 2);
  }
  s(BX, "needsWhitespaceAfter");
  function kX(e, t, r, n) {
    var i;
    return t ? DX(t) && t.callee === e && LS(e) ? !0 : AX(t) ? !Nm(e) && !(FS(e) && Nm(e.callee)) && !IX(e) : (i = _X.get(e.type)) == null ?
    void 0 : i(e, t, r, n) : !1;
  }
  s(kX, "needsParens");
  function Nm(e) {
    switch (e.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !e.computed && e.property.type === "Identifier" && Nm(e.object);
      default:
        return !1;
    }
  }
  s(Nm, "isDecoratorMemberExpression");
});

// ../node_modules/@babel/generator/lib/generators/template-literals.js
var MS = T((lo) => {
  "use strict";
  Object.defineProperty(lo, "__esModule", {
    value: !0
  });
  lo.TaggedTemplateExpression = FX;
  lo.TemplateElement = jX;
  lo.TemplateLiteral = LX;
  function FX(e) {
    this.print(e.tag, e), this.print(e.typeParameters, e), this.print(e.quasi, e);
  }
  s(FX, "TaggedTemplateExpression");
  function jX() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  s(jX, "TemplateElement");
  function LX(e) {
    let t = e.quasis, r = "`";
    for (let n = 0; n < t.length; n++)
      r += t[n].value.raw, n + 1 < t.length && (this.token(r + "${", !0), this.print(e.expressions[n], e), r = "}");
    this.token(r + "`", !0);
  }
  s(LX, "TemplateLiteral");
});

// ../node_modules/@babel/generator/lib/generators/expressions.js
var qS = T((it) => {
  "use strict";
  Object.defineProperty(it, "__esModule", {
    value: !0
  });
  it.LogicalExpression = it.BinaryExpression = it.AssignmentExpression = lQ;
  it.AssignmentPattern = oQ;
  it.AwaitExpression = nQ;
  it.BindExpression = uQ;
  it.CallExpression = tQ;
  it.ConditionalExpression = GX;
  it.Decorator = QX;
  it.DoExpression = $X;
  it.EmptyStatement = iQ;
  it.ExpressionStatement = aQ;
  it.Import = rQ;
  it.MemberExpression = cQ;
  it.MetaProperty = fQ;
  it.ModuleExpression = hQ;
  it.NewExpression = HX;
  it.OptionalCallExpression = eQ;
  it.OptionalMemberExpression = ZX;
  it.ParenthesizedExpression = WX;
  it.PrivateName = pQ;
  it.SequenceExpression = YX;
  it.Super = JX;
  it.ThisExpression = zX;
  it.UnaryExpression = VX;
  it.UpdateExpression = KX;
  it.V8IntrinsicIdentifier = dQ;
  it.YieldExpression = sQ;
  it._shouldPrintDecoratorsBeforeExport = XX;
  var MX = Pe(), RX = as(), {
    isCallExpression: qX,
    isLiteral: RS,
    isMemberExpression: km,
    isNewExpression: UX
  } = MX;
  function VX(e) {
    let {
      operator: t
    } = e;
    t === "void" || t === "delete" || t === "typeof" || t === "throw" ? (this.word(t), this.space()) : this.token(t), this.print(e.argument,
    e);
  }
  s(VX, "UnaryExpression");
  function $X(e) {
    e.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(e.body, e);
  }
  s($X, "DoExpression");
  function WX(e) {
    this.tokenChar(40), this.print(e.expression, e), this.rightParens(e);
  }
  s(WX, "ParenthesizedExpression");
  function KX(e) {
    e.prefix ? (this.token(e.operator), this.print(e.argument, e)) : (this.printTerminatorless(e.argument, e, !0), this.token(e.operator));
  }
  s(KX, "UpdateExpression");
  function GX(e) {
    this.print(e.test, e), this.space(), this.tokenChar(63), this.space(), this.print(e.consequent, e), this.space(), this.tokenChar(58), this.
    space(), this.print(e.alternate, e);
  }
  s(GX, "ConditionalExpression");
  function HX(e, t) {
    if (this.word("new"), this.space(), this.print(e.callee, e), this.format.minified && e.arguments.length === 0 && !e.optional && !qX(t, {
      callee: e
    }) && !km(t) && !UX(t))
      return;
    this.print(e.typeArguments, e), this.print(e.typeParameters, e), e.optional && this.token("?."), this.tokenChar(40);
    let r = this.enterForStatementInit(!1);
    this.printList(e.arguments, e), r(), this.rightParens(e);
  }
  s(HX, "NewExpression");
  function YX(e) {
    this.printList(e.expressions, e);
  }
  s(YX, "SequenceExpression");
  function zX() {
    this.word("this");
  }
  s(zX, "ThisExpression");
  function JX() {
    this.word("super");
  }
  s(JX, "Super");
  function XX(e) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof e.start == "number" && e.start ===
    e.declaration.start;
  }
  s(XX, "_shouldPrintDecoratorsBeforeExport");
  function QX(e) {
    this.tokenChar(64), this.print(e.expression, e), this.newline();
  }
  s(QX, "Decorator");
  function ZX(e) {
    let {
      computed: t
    } = e, {
      optional: r,
      property: n
    } = e;
    if (this.print(e.object, e), !t && km(n))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    RS(n) && typeof n.value == "number" && (t = !0), r && this.token("?."), t ? (this.tokenChar(91), this.print(n, e), this.tokenChar(93)) :
    (r || this.tokenChar(46), this.print(n, e));
  }
  s(ZX, "OptionalMemberExpression");
  function eQ(e) {
    this.print(e.callee, e), this.print(e.typeParameters, e), e.optional && this.token("?."), this.print(e.typeArguments, e), this.tokenChar(
    40);
    let t = this.enterForStatementInit(!1);
    this.printList(e.arguments, e), t(), this.rightParens(e);
  }
  s(eQ, "OptionalCallExpression");
  function tQ(e) {
    this.print(e.callee, e), this.print(e.typeArguments, e), this.print(e.typeParameters, e), this.tokenChar(40);
    let t = this.enterForStatementInit(!1);
    this.printList(e.arguments, e), t(), this.rightParens(e);
  }
  s(tQ, "CallExpression");
  function rQ() {
    this.word("import");
  }
  s(rQ, "Import");
  function nQ(e) {
    this.word("await"), e.argument && (this.space(), this.printTerminatorless(e.argument, e, !1));
  }
  s(nQ, "AwaitExpression");
  function sQ(e) {
    this.word("yield", !0), e.delegate ? (this.tokenChar(42), e.argument && (this.space(), this.print(e.argument, e))) : e.argument && (this.
    space(), this.printTerminatorless(e.argument, e, !1));
  }
  s(sQ, "YieldExpression");
  function iQ() {
    this.semicolon(!0);
  }
  s(iQ, "EmptyStatement");
  function aQ(e) {
    this.tokenContext |= RX.TokenContext.expressionStatement, this.print(e.expression, e), this.semicolon();
  }
  s(aQ, "ExpressionStatement");
  function oQ(e) {
    this.print(e.left, e), e.left.type === "Identifier" && (e.left.optional && this.tokenChar(63), this.print(e.left.typeAnnotation, e)), this.
    space(), this.tokenChar(61), this.space(), this.print(e.right, e);
  }
  s(oQ, "AssignmentPattern");
  function lQ(e) {
    this.print(e.left, e), this.space(), e.operator === "in" || e.operator === "instanceof" ? this.word(e.operator) : this.token(e.operator),
    this.space(), this.print(e.right, e);
  }
  s(lQ, "AssignmentExpression");
  function uQ(e) {
    this.print(e.object, e), this.token("::"), this.print(e.callee, e);
  }
  s(uQ, "BindExpression");
  function cQ(e) {
    if (this.print(e.object, e), !e.computed && km(e.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let t = e.computed;
    if (RS(e.property) && typeof e.property.value == "number" && (t = !0), t) {
      let r = this.enterForStatementInit(!1);
      this.tokenChar(91), this.print(e.property, e), this.tokenChar(93), r();
    } else
      this.tokenChar(46), this.print(e.property, e);
  }
  s(cQ, "MemberExpression");
  function fQ(e) {
    this.print(e.meta, e), this.tokenChar(46), this.print(e.property, e);
  }
  s(fQ, "MetaProperty");
  function pQ(e) {
    this.tokenChar(35), this.print(e.id, e);
  }
  s(pQ, "PrivateName");
  function dQ(e) {
    this.tokenChar(37), this.word(e.name);
  }
  s(dQ, "V8IntrinsicIdentifier");
  function hQ(e) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    let {
      body: t
    } = e;
    (t.body.length || t.directives.length) && this.newline(), this.print(t, e), this.dedent(), this.rightBrace(e);
  }
  s(hQ, "ModuleExpression");
});

// ../node_modules/@babel/generator/lib/generators/statements.js
var WS = T((gt) => {
  "use strict";
  Object.defineProperty(gt, "__esModule", {
    value: !0
  });
  gt.BreakStatement = PQ;
  gt.CatchClause = _Q;
  gt.ContinueStatement = AQ;
  gt.DebuggerStatement = BQ;
  gt.DoWhileStatement = SQ;
  gt.ForOfStatement = gt.ForInStatement = void 0;
  gt.ForStatement = TQ;
  gt.IfStatement = vQ;
  gt.LabeledStatement = DQ;
  gt.ReturnStatement = CQ;
  gt.SwitchCase = NQ;
  gt.SwitchStatement = OQ;
  gt.ThrowStatement = wQ;
  gt.TryStatement = IQ;
  gt.VariableDeclaration = kQ;
  gt.VariableDeclarator = FQ;
  gt.WhileStatement = xQ;
  gt.WithStatement = EQ;
  var mQ = Pe(), Fm = as(), {
    isFor: US,
    isForStatement: yQ,
    isIfStatement: gQ,
    isStatement: bQ
  } = mQ;
  function EQ(e) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(e.object, e), this.tokenChar(41), this.printBlock(e);
  }
  s(EQ, "WithStatement");
  function vQ(e) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.space();
    let t = e.alternate && gQ(VS(e.consequent));
    t && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(e.consequent, e), t && (this.dedent(), this.newline(),
    this.tokenChar(125)), e.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(
    e.alternate, e));
  }
  s(vQ, "IfStatement");
  function VS(e) {
    let {
      body: t
    } = e;
    return bQ(t) === !1 ? e : VS(t);
  }
  s(VS, "getLastStatement");
  function TQ(e) {
    this.word("for"), this.space(), this.tokenChar(40);
    {
      let t = this.enterForStatementInit(!0);
      this.tokenContext |= Fm.TokenContext.forHead, this.print(e.init, e), t();
    }
    this.tokenChar(59), e.test && (this.space(), this.print(e.test, e)), this.tokenChar(59), e.update && (this.space(), this.print(e.update,
    e)), this.tokenChar(41), this.printBlock(e);
  }
  s(TQ, "ForStatement");
  function xQ(e) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.printBlock(e);
  }
  s(xQ, "WhileStatement");
  function $S(e) {
    this.word("for"), this.space();
    let t = e.type === "ForOfStatement";
    t && e.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40);
    {
      let r = t ? null : this.enterForStatementInit(!0);
      this.tokenContext |= t ? Fm.TokenContext.forOfHead : Fm.TokenContext.forInHead, this.print(e.left, e), r?.();
    }
    this.space(), this.word(t ? "of" : "in"), this.space(), this.print(e.right, e), this.tokenChar(41), this.printBlock(e);
  }
  s($S, "ForXStatement");
  var NAe = gt.ForInStatement = $S, BAe = gt.ForOfStatement = $S;
  function SQ(e) {
    this.word("do"), this.space(), this.print(e.body, e), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e.test,
    e), this.tokenChar(41), this.semicolon();
  }
  s(SQ, "DoWhileStatement");
  function Cu(e, t, r, n) {
    t && (e.space(), e.printTerminatorless(t, r, n)), e.semicolon();
  }
  s(Cu, "printStatementAfterKeyword");
  function PQ(e) {
    this.word("break"), Cu(this, e.label, e, !0);
  }
  s(PQ, "BreakStatement");
  function AQ(e) {
    this.word("continue"), Cu(this, e.label, e, !0);
  }
  s(AQ, "ContinueStatement");
  function CQ(e) {
    this.word("return"), Cu(this, e.argument, e, !1);
  }
  s(CQ, "ReturnStatement");
  function wQ(e) {
    this.word("throw"), Cu(this, e.argument, e, !1);
  }
  s(wQ, "ThrowStatement");
  function DQ(e) {
    this.print(e.label, e), this.tokenChar(58), this.space(), this.print(e.body, e);
  }
  s(DQ, "LabeledStatement");
  function IQ(e) {
    this.word("try"), this.space(), this.print(e.block, e), this.space(), e.handlers ? this.print(e.handlers[0], e) : this.print(e.handler, e),
    e.finalizer && (this.space(), this.word("finally"), this.space(), this.print(e.finalizer, e));
  }
  s(IQ, "TryStatement");
  function _Q(e) {
    this.word("catch"), this.space(), e.param && (this.tokenChar(40), this.print(e.param, e), this.print(e.param.typeAnnotation, e), this.tokenChar(
    41), this.space()), this.print(e.body, e);
  }
  s(_Q, "CatchClause");
  function OQ(e) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(e.discriminant, e), this.tokenChar(41), this.space(), this.tokenChar(123),
    this.printSequence(e.cases, e, {
      indent: !0,
      addNewlines(t, r) {
        if (!t && e.cases[e.cases.length - 1] === r) return -1;
      }
    }), this.rightBrace(e);
  }
  s(OQ, "SwitchStatement");
  function NQ(e) {
    e.test ? (this.word("case"), this.space(), this.print(e.test, e), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), e.consequent.
    length && (this.newline(), this.printSequence(e.consequent, e, {
      indent: !0
    }));
  }
  s(NQ, "SwitchCase");
  function BQ() {
    this.word("debugger"), this.semicolon();
  }
  s(BQ, "DebuggerStatement");
  function kQ(e, t) {
    e.declare && (this.word("declare"), this.space());
    let {
      kind: r
    } = e;
    r === "await using" ? (this.word("await"), this.space(), this.word("using", !0)) : this.word(r, r === "using"), this.space();
    let n = !1;
    if (!US(t))
      for (let i of e.declarations)
        i.init && (n = !0);
    if (this.printList(e.declarations, e, {
      separator: n ? function() {
        this.tokenChar(44), this.newline();
      } : void 0,
      indent: e.declarations.length > 1
    }), US(t)) {
      if (yQ(t)) {
        if (t.init === e) return;
      } else if (t.left === e) return;
    }
    this.semicolon();
  }
  s(kQ, "VariableDeclaration");
  function FQ(e) {
    this.print(e.id, e), e.definite && this.tokenChar(33), this.print(e.id.typeAnnotation, e), e.init && (this.space(), this.tokenChar(61), this.
    space(), this.print(e.init, e));
  }
  s(FQ, "VariableDeclarator");
});

// ../node_modules/@babel/generator/lib/generators/classes.js
var KS = T((Nr) => {
  "use strict";
  Object.defineProperty(Nr, "__esModule", {
    value: !0
  });
  Nr.ClassAccessorProperty = VQ;
  Nr.ClassBody = qQ;
  Nr.ClassExpression = Nr.ClassDeclaration = RQ;
  Nr.ClassMethod = WQ;
  Nr.ClassPrivateMethod = KQ;
  Nr.ClassPrivateProperty = $Q;
  Nr.ClassProperty = UQ;
  Nr.StaticBlock = HQ;
  Nr._classMethodHead = GQ;
  var jQ = Pe(), {
    isExportDefaultDeclaration: LQ,
    isExportNamedDeclaration: MQ
  } = jQ;
  function RQ(e, t) {
    (!(LQ(t) || MQ(t)) || !this._shouldPrintDecoratorsBeforeExport(t)) && this.printJoin(e.decorators, e), e.declare && (this.word("declare"),
    this.space()), e.abstract && (this.word("abstract"), this.space()), this.word("class"), e.id && (this.space(), this.print(e.id, e)), this.
    print(e.typeParameters, e), e.superClass && (this.space(), this.word("extends"), this.space(), this.print(e.superClass, e), this.print(e.
    superTypeParameters, e)), e.implements && (this.space(), this.word("implements"), this.space(), this.printList(e.implements, e)), this.space(),
    this.print(e.body, e);
  }
  s(RQ, "ClassDeclaration");
  function qQ(e) {
    if (this.tokenChar(123), e.body.length === 0)
      this.tokenChar(125);
    else {
      this.newline();
      let t = this.enterForStatementInit(!1);
      this.printSequence(e.body, e, {
        indent: !0
      }), t(), this.endsWith(10) || this.newline(), this.rightBrace(e);
    }
  }
  s(qQ, "ClassBody");
  function UQ(e) {
    var t;
    this.printJoin(e.decorators, e);
    let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), e.computed ? (this.tokenChar(91), this.print(e.key, e), this.tokenChar(93)) :
    (this._variance(e), this.print(e.key, e)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation,
    e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
  }
  s(UQ, "ClassProperty");
  function VQ(e) {
    var t;
    this.printJoin(e.decorators, e);
    let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), this.word("accessor", !0), this.space(), e.computed ? (this.tokenChar(91), this.
    print(e.key, e), this.tokenChar(93)) : (this._variance(e), this.print(e.key, e)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(
    33), this.print(e.typeAnnotation, e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
  }
  s(VQ, "ClassAccessorProperty");
  function $Q(e) {
    this.printJoin(e.decorators, e), e.static && (this.word("static"), this.space()), this.print(e.key, e), this.print(e.typeAnnotation, e),
    e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
  }
  s($Q, "ClassPrivateProperty");
  function WQ(e) {
    this._classMethodHead(e), this.space(), this.print(e.body, e);
  }
  s(WQ, "ClassMethod");
  function KQ(e) {
    this._classMethodHead(e), this.space(), this.print(e.body, e);
  }
  s(KQ, "ClassPrivateMethod");
  function GQ(e) {
    var t;
    this.printJoin(e.decorators, e);
    let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), this._methodHead(e);
  }
  s(GQ, "_classMethodHead");
  function HQ(e) {
    this.word("static"), this.space(), this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(
    e.body, e, {
      indent: !0
    }), this.rightBrace(e));
  }
  s(HQ, "StaticBlock");
});

// ../node_modules/@babel/generator/lib/generators/methods.js
var GS = T((Gr) => {
  "use strict";
  Object.defineProperty(Gr, "__esModule", {
    value: !0
  });
  Gr.ArrowFunctionExpression = sZ;
  Gr.FunctionDeclaration = Gr.FunctionExpression = nZ;
  Gr._functionHead = rZ;
  Gr._methodHead = eZ;
  Gr._param = ZQ;
  Gr._parameters = QQ;
  Gr._params = XQ;
  Gr._predicate = tZ;
  var YQ = Pe(), zQ = as(), {
    isIdentifier: JQ
  } = YQ;
  function XQ(e, t, r) {
    this.print(e.typeParameters, e);
    let n = aZ.call(this, t, r);
    n && this.sourceIdentifierName(n.name, n.pos), this.tokenChar(40), this._parameters(e.params, e), this.tokenChar(41);
    let i = e.type === "ArrowFunctionExpression";
    this.print(e.returnType, e, i), this._noLineTerminator = i;
  }
  s(XQ, "_params");
  function QQ(e, t) {
    let r = this.enterForStatementInit(!1), n = e.length;
    for (let i = 0; i < n; i++)
      this._param(e[i], t), i < e.length - 1 && (this.tokenChar(44), this.space());
    r();
  }
  s(QQ, "_parameters");
  function ZQ(e, t) {
    this.printJoin(e.decorators, e), this.print(e, t), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
  }
  s(ZQ, "_param");
  function eZ(e) {
    let t = e.kind, r = e.key;
    (t === "get" || t === "set") && (this.word(t), this.space()), e.async && (this.word("async", !0), this.space()), (t === "method" || t ===
    "init") && e.generator && this.tokenChar(42), e.computed ? (this.tokenChar(91), this.print(r, e), this.tokenChar(93)) : this.print(r, e),
    e.optional && this.tokenChar(63), this._params(e, e.computed && e.key.type !== "StringLiteral" ? void 0 : e.key, void 0);
  }
  s(eZ, "_methodHead");
  function tZ(e, t) {
    e.predicate && (e.returnType || this.tokenChar(58), this.space(), this.print(e.predicate, e, t));
  }
  s(tZ, "_predicate");
  function rZ(e, t) {
    e.async && (this.word("async"), this._endsWithInnerRaw = !1, this.space()), this.word("function"), e.generator && (this._endsWithInnerRaw =
    !1, this.tokenChar(42)), this.space(), e.id && this.print(e.id, e), this._params(e, e.id, t), e.type !== "TSDeclareFunction" && this._predicate(
    e);
  }
  s(rZ, "_functionHead");
  function nZ(e, t) {
    this._functionHead(e, t), this.space(), this.print(e.body, e);
  }
  s(nZ, "FunctionExpression");
  function sZ(e, t) {
    e.async && (this.word("async", !0), this.space());
    let r;
    !this.format.retainLines && e.params.length === 1 && JQ(r = e.params[0]) && !iZ(e, r) ? this.print(r, e, !0) : this._params(e, void 0, t),
    this._predicate(e, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.tokenContext |= zQ.TokenContext.arrowBody,
    this.print(e.body, e);
  }
  s(sZ, "ArrowFunctionExpression");
  function iZ(e, t) {
    var r, n;
    return !!(e.typeParameters || e.returnType || e.predicate || t.typeAnnotation || t.optional || (r = t.leadingComments) != null && r.length ||
    (n = t.trailingComments) != null && n.length);
  }
  s(iZ, "hasTypesOrComments");
  function aZ(e, t) {
    let r = e;
    if (!r && t) {
      let u = t.type;
      u === "VariableDeclarator" ? r = t.id : u === "AssignmentExpression" || u === "AssignmentPattern" ? r = t.left : u === "ObjectProperty" ||
      u === "ClassProperty" ? (!t.computed || t.key.type === "StringLiteral") && (r = t.key) : (u === "ClassPrivateProperty" || u === "Class\
AccessorProperty") && (r = t.key);
    }
    if (!r) return;
    let n;
    if (r.type === "Identifier") {
      var i, a;
      n = {
        pos: (i = r.loc) == null ? void 0 : i.start,
        name: ((a = r.loc) == null ? void 0 : a.identifierName) || r.name
      };
    } else if (r.type === "PrivateName") {
      var o;
      n = {
        pos: (o = r.loc) == null ? void 0 : o.start,
        name: "#" + r.id.name
      };
    } else if (r.type === "StringLiteral") {
      var l;
      n = {
        pos: (l = r.loc) == null ? void 0 : l.start,
        name: r.value
      };
    }
    return n;
  }
  s(aZ, "_getFuncIdName");
});

// ../node_modules/@babel/generator/lib/generators/modules.js
var jm = T((lr) => {
  "use strict";
  Object.defineProperty(lr, "__esModule", {
    value: !0
  });
  lr.ExportAllDeclaration = vZ;
  lr.ExportDefaultDeclaration = xZ;
  lr.ExportDefaultSpecifier = yZ;
  lr.ExportNamedDeclaration = TZ;
  lr.ExportNamespaceSpecifier = bZ;
  lr.ExportSpecifier = gZ;
  lr.ImportAttribute = PZ;
  lr.ImportDeclaration = SZ;
  lr.ImportDefaultSpecifier = mZ;
  lr.ImportExpression = CZ;
  lr.ImportNamespaceSpecifier = AZ;
  lr.ImportSpecifier = hZ;
  lr._printAttributes = EZ;
  var oZ = Pe(), lZ = as(), {
    isClassDeclaration: uZ,
    isExportDefaultSpecifier: cZ,
    isExportNamespaceSpecifier: fZ,
    isImportDefaultSpecifier: pZ,
    isImportNamespaceSpecifier: dZ,
    isStatement: YS
  } = oZ;
  function hZ(e) {
    (e.importKind === "type" || e.importKind === "typeof") && (this.word(e.importKind), this.space()), this.print(e.imported, e), e.local &&
    e.local.name !== e.imported.name && (this.space(), this.word("as"), this.space(), this.print(e.local, e));
  }
  s(hZ, "ImportSpecifier");
  function mZ(e) {
    this.print(e.local, e);
  }
  s(mZ, "ImportDefaultSpecifier");
  function yZ(e) {
    this.print(e.exported, e);
  }
  s(yZ, "ExportDefaultSpecifier");
  function gZ(e) {
    e.exportKind === "type" && (this.word("type"), this.space()), this.print(e.local, e), e.exported && e.local.name !== e.exported.name && (this.
    space(), this.word("as"), this.space(), this.print(e.exported, e));
  }
  s(gZ, "ExportSpecifier");
  function bZ(e) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.exported, e);
  }
  s(bZ, "ExportNamespaceSpecifier");
  var HS = !1;
  function EZ(e) {
    let {
      importAttributesKeyword: t
    } = this.format, {
      attributes: r,
      assertions: n
    } = e;
    r && !t && !HS && (HS = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify \
the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\
\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    let i = t === "assert" || !t && n;
    if (this.word(i ? "assert" : "with"), this.space(), !i && t !== "with") {
      this.printList(r || n, e);
      return;
    }
    this.tokenChar(123), this.space(), this.printList(r || n, e), this.space(), this.tokenChar(125);
  }
  s(EZ, "_printAttributes");
  function vZ(e) {
    var t, r;
    this.word("export"), this.space(), e.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.
    word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, e, !0),
    this.space(), this._printAttributes(e)) : this.print(e.source, e), this.semicolon();
  }
  s(vZ, "ExportAllDeclaration");
  function zS(e, t) {
    uZ(t.declaration) && e._shouldPrintDecoratorsBeforeExport(t) && e.printJoin(t.declaration.decorators, t);
  }
  s(zS, "maybePrintDecoratorsBeforeExport");
  function TZ(e) {
    if (zS(this, e), this.word("export"), this.space(), e.declaration) {
      let n = e.declaration;
      this.print(n, e), YS(n) || this.semicolon();
    } else {
      e.exportKind === "type" && (this.word("type"), this.space());
      let n = e.specifiers.slice(0), i = !1;
      for (; ; ) {
        let a = n[0];
        if (cZ(a) || fZ(a))
          i = !0, this.print(n.shift(), e), n.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      if ((n.length || !n.length && !i) && (this.tokenChar(123), n.length && (this.space(), this.printList(n, e), this.space()), this.tokenChar(
      125)), e.source) {
        var t, r;
        this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.
        print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e);
      }
      this.semicolon();
    }
  }
  s(TZ, "ExportNamedDeclaration");
  function xZ(e) {
    zS(this, e), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space(), this.tokenContext |=
    lZ.TokenContext.exportDefault;
    let t = e.declaration;
    this.print(t, e), YS(t) || this.semicolon();
  }
  s(xZ, "ExportDefaultDeclaration");
  function SZ(e) {
    var t, r;
    this.word("import"), this.space();
    let n = e.importKind === "type" || e.importKind === "typeof";
    n ? (this.noIndentInnerCommentsHere(), this.word(e.importKind), this.space()) : e.module ? (this.noIndentInnerCommentsHere(), this.word(
    "module"), this.space()) : e.phase && (this.noIndentInnerCommentsHere(), this.word(e.phase), this.space());
    let i = e.specifiers.slice(0), a = !!i.length;
    for (; a; ) {
      let o = i[0];
      if (pZ(o) || dZ(o))
        this.print(i.shift(), e), i.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    i.length ? (this.tokenChar(123), this.space(), this.printList(i, e), this.space(), this.tokenChar(125)) : n && !a && (this.tokenChar(123),
    this.tokenChar(125)), (a || n) && (this.space(), this.word("from"), this.space()), (t = e.attributes) != null && t.length || (r = e.assertions) !=
    null && r.length ? (this.print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e), this.semicolon();
  }
  s(SZ, "ImportDeclaration");
  function PZ(e) {
    this.print(e.key), this.tokenChar(58), this.space(), this.print(e.value);
  }
  s(PZ, "ImportAttribute");
  function AZ(e) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.local, e);
  }
  s(AZ, "ImportNamespaceSpecifier");
  function CZ(e) {
    this.word("import"), e.phase && (this.tokenChar(46), this.word(e.phase)), this.tokenChar(40), this.print(e.source, e), e.options != null &&
    (this.tokenChar(44), this.space(), this.print(e.options, e)), this.tokenChar(41);
  }
  s(CZ, "ImportExpression");
});

// ../node_modules/jsesc/jsesc.js
var ZS = T((VAe, QS) => {
  "use strict";
  var JS = {}, wZ = JS.hasOwnProperty, XS = /* @__PURE__ */ s((e, t) => {
    for (let r in e)
      wZ.call(e, r) && t(r, e[r]);
  }, "forOwn"), DZ = /* @__PURE__ */ s((e, t) => (t && XS(t, (r, n) => {
    e[r] = n;
  }), e), "extend"), IZ = /* @__PURE__ */ s((e, t) => {
    let r = e.length, n = -1;
    for (; ++n < r; )
      t(e[n]);
  }, "forEach"), uo = JS.toString, _Z = Array.isArray, OZ = Buffer.isBuffer, NZ = /* @__PURE__ */ s((e) => uo.call(e) == "[object Object]", "\
isObject"), BZ = /* @__PURE__ */ s((e) => typeof e == "string" || uo.call(e) == "[object String]", "isString"), kZ = /* @__PURE__ */ s((e) => typeof e ==
  "number" || uo.call(e) == "[object Number]", "isNumber"), FZ = /* @__PURE__ */ s((e) => typeof e == "function", "isFunction"), jZ = /* @__PURE__ */ s(
  (e) => uo.call(e) == "[object Map]", "isMap"), LZ = /* @__PURE__ */ s((e) => uo.call(e) == "[object Set]", "isSet"), MZ = {
    '"': '\\"',
    "'": "\\'",
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  }, RZ = /["'\\\b\f\n\r\t]/, qZ = /[0-9]/, UZ = /[ !#-&\(-\[\]-_a-~]/, ls = /* @__PURE__ */ s((e, t) => {
    let r = /* @__PURE__ */ s(() => {
      c = u, ++t.indentLevel, u = t.indent.repeat(t.indentLevel);
    }, "increaseIndentation"), n = {
      escapeEverything: !1,
      minimal: !1,
      isScriptContext: !1,
      quotes: "single",
      wrap: !1,
      es6: !1,
      json: !1,
      compact: !0,
      lowercaseHex: !1,
      numbers: "decimal",
      indent: "	",
      indentLevel: 0,
      __inline1__: !1,
      __inline2__: !1
    }, i = t && t.json;
    i && (n.quotes = "double", n.wrap = !0), t = DZ(n, t), t.quotes != "single" && t.quotes != "double" && t.quotes != "backtick" && (t.quotes =
    "single");
    let a = t.quotes == "double" ? '"' : t.quotes == "backtick" ? "`" : "'", o = t.compact, l = t.lowercaseHex, u = t.indent.repeat(t.indentLevel),
    c = "", f = t.__inline1__, p = t.__inline2__, h = o ? "" : `
`, y, v = !0, d = t.numbers == "binary", b = t.numbers == "octal", E = t.numbers == "decimal", I = t.numbers == "hexadecimal";
    if (i && e && FZ(e.toJSON) && (e = e.toJSON()), !BZ(e)) {
      if (jZ(e))
        return e.size == 0 ? "new Map()" : (o || (t.__inline1__ = !0, t.__inline2__ = !1), "new Map(" + ls(Array.from(e), t) + ")");
      if (LZ(e))
        return e.size == 0 ? "new Set()" : "new Set(" + ls(Array.from(e), t) + ")";
      if (OZ(e))
        return e.length == 0 ? "Buffer.from([])" : "Buffer.from(" + ls(Array.from(e), t) + ")";
      if (_Z(e))
        return y = [], t.wrap = !0, f && (t.__inline1__ = !1, t.__inline2__ = !0), p || r(), IZ(e, (R) => {
          v = !1, p && (t.__inline2__ = !1), y.push(
            (o || p ? "" : u) + ls(R, t)
          );
        }), v ? "[]" : p ? "[" + y.join(", ") + "]" : "[" + h + y.join("," + h) + h + (o ? "" : c) + "]";
      if (kZ(e)) {
        if (i)
          return JSON.stringify(e);
        if (E)
          return String(e);
        if (I) {
          let R = e.toString(16);
          return l || (R = R.toUpperCase()), "0x" + R;
        }
        if (d)
          return "0b" + e.toString(2);
        if (b)
          return "0o" + e.toString(8);
      } else return NZ(e) ? (y = [], t.wrap = !0, r(), XS(e, (R, U) => {
        v = !1, y.push(
          (o ? "" : u) + ls(R, t) + ":" + (o ? "" : " ") + ls(U, t)
        );
      }), v ? "{}" : "{" + h + y.join("," + h) + h + (o ? "" : c) + "}") : i ? JSON.stringify(e) || "null" : String(e);
    }
    let O = e, k = -1, j = O.length;
    for (y = ""; ++k < j; ) {
      let R = O.charAt(k);
      if (t.es6) {
        let M = O.charCodeAt(k);
        if (
          // check if it’s the start of a surrogate pair
          M >= 55296 && M <= 56319 && // high surrogate
          j > k + 1
        ) {
          let K = O.charCodeAt(k + 1);
          if (K >= 56320 && K <= 57343) {
            let ae = ((M - 55296) * 1024 + K - 56320 + 65536).toString(16);
            l || (ae = ae.toUpperCase()), y += "\\u{" + ae + "}", ++k;
            continue;
          }
        }
      }
      if (!t.escapeEverything) {
        if (UZ.test(R)) {
          y += R;
          continue;
        }
        if (R == '"') {
          y += a == R ? '\\"' : R;
          continue;
        }
        if (R == "`") {
          y += a == R ? "\\`" : R;
          continue;
        }
        if (R == "'") {
          y += a == R ? "\\'" : R;
          continue;
        }
      }
      if (R == "\0" && !i && !qZ.test(O.charAt(k + 1))) {
        y += "\\0";
        continue;
      }
      if (RZ.test(R)) {
        y += MZ[R];
        continue;
      }
      let U = R.charCodeAt(0);
      if (t.minimal && U != 8232 && U != 8233) {
        y += R;
        continue;
      }
      let Q = U.toString(16);
      l || (Q = Q.toUpperCase());
      let W = Q.length > 2 || i, q = "\\" + (W ? "u" : "x") + ("0000" + Q).slice(W ? -4 : -2);
      y += q;
    }
    return t.wrap && (y = a + y + a), a == "`" && (y = y.replace(/\$\{/g, "\\${")), t.isScriptContext ? y.replace(/<\/(script|style)/gi, "<\\\
/$1").replace(/<!--/g, i ? "\\u003C!--" : "\\x3C!--") : y;
  }, "jsesc");
  ls.version = "2.5.2";
  QS.exports = ls;
});

// ../node_modules/@babel/generator/lib/generators/types.js
var Mm = T((pt) => {
  "use strict";
  Object.defineProperty(pt, "__esModule", {
    value: !0
  });
  pt.ArgumentPlaceholder = KZ;
  pt.ArrayPattern = pt.ArrayExpression = JZ;
  pt.BigIntLiteral = see;
  pt.BooleanLiteral = eee;
  pt.DecimalLiteral = iee;
  pt.Identifier = WZ;
  pt.NullLiteral = tee;
  pt.NumericLiteral = ree;
  pt.ObjectPattern = pt.ObjectExpression = HZ;
  pt.ObjectMethod = YZ;
  pt.ObjectProperty = zZ;
  pt.PipelineBareFunction = lee;
  pt.PipelinePrimaryTopicReference = uee;
  pt.PipelineTopicExpression = oee;
  pt.RecordExpression = XZ;
  pt.RegExpLiteral = ZZ;
  pt.SpreadElement = pt.RestElement = GZ;
  pt.StringLiteral = nee;
  pt.TopicReference = aee;
  pt.TupleExpression = QZ;
  var VZ = Pe(), tP = ZS(), {
    isAssignmentPattern: $Z,
    isIdentifier: Lm
  } = VZ;
  function WZ(e) {
    var t;
    this.sourceIdentifierName(((t = e.loc) == null ? void 0 : t.identifierName) || e.name), this.word(e.name);
  }
  s(WZ, "Identifier");
  function KZ() {
    this.tokenChar(63);
  }
  s(KZ, "ArgumentPlaceholder");
  function GZ(e) {
    this.token("..."), this.print(e.argument, e);
  }
  s(GZ, "RestElement");
  function HZ(e) {
    let t = e.properties;
    if (this.tokenChar(123), t.length) {
      let r = this.enterForStatementInit(!1);
      this.space(), this.printList(t, e, {
        indent: !0,
        statement: !0
      }), this.space(), r();
    }
    this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
  }
  s(HZ, "ObjectExpression");
  function YZ(e) {
    this.printJoin(e.decorators, e), this._methodHead(e), this.space(), this.print(e.body, e);
  }
  s(YZ, "ObjectMethod");
  function zZ(e) {
    if (this.printJoin(e.decorators, e), e.computed)
      this.tokenChar(91), this.print(e.key, e), this.tokenChar(93);
    else {
      if ($Z(e.value) && Lm(e.key) && e.key.name === e.value.left.name) {
        this.print(e.value, e);
        return;
      }
      if (this.print(e.key, e), e.shorthand && Lm(e.key) && Lm(e.value) && e.key.name === e.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(e.value, e);
  }
  s(zZ, "ObjectProperty");
  function JZ(e) {
    let t = e.elements, r = t.length;
    this.tokenChar(91);
    let n = this.enterForStatementInit(!1);
    for (let i = 0; i < t.length; i++) {
      let a = t[i];
      a ? (i > 0 && this.space(), this.print(a, e), i < r - 1 && this.tokenChar(44)) : this.tokenChar(44);
    }
    n(), this.tokenChar(93);
  }
  s(JZ, "ArrayExpression");
  function XZ(e) {
    let t = e.properties, r, n;
    if (this.format.recordAndTupleSyntaxType === "bar")
      r = "{|", n = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)}\
 received).`);
      r = "#{", n = "}";
    }
    this.token(r), t.length && (this.space(), this.printList(t, e, {
      indent: !0,
      statement: !0
    }), this.space()), this.token(n);
  }
  s(XZ, "RecordExpression");
  function QZ(e) {
    let t = e.elements, r = t.length, n, i;
    if (this.format.recordAndTupleSyntaxType === "bar")
      n = "[|", i = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      n = "#[", i = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(n);
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      o && (a > 0 && this.space(), this.print(o, e), a < r - 1 && this.tokenChar(44));
    }
    this.token(i);
  }
  s(QZ, "TupleExpression");
  function ZZ(e) {
    this.word(`/${e.pattern}/${e.flags}`);
  }
  s(ZZ, "RegExpLiteral");
  function eee(e) {
    this.word(e.value ? "true" : "false");
  }
  s(eee, "BooleanLiteral");
  function tee() {
    this.word("null");
  }
  s(tee, "NullLiteral");
  function ree(e) {
    let t = this.getPossibleRaw(e), r = this.format.jsescOption, n = e.value, i = n + "";
    r.numbers ? this.number(tP(n, r), n) : t == null ? this.number(i, n) : this.format.minified ? this.number(t.length < i.length ? t : i, n) :
    this.number(t, n);
  }
  s(ree, "NumericLiteral");
  function nee(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.token(t);
      return;
    }
    let r = tP(e.value, this.format.jsescOption);
    this.token(r);
  }
  s(nee, "StringLiteral");
  function see(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.word(t);
      return;
    }
    this.word(e.value + "n");
  }
  s(see, "BigIntLiteral");
  function iee(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.word(t);
      return;
    }
    this.word(e.value + "m");
  }
  s(iee, "DecimalLiteral");
  var eP = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function aee() {
    let {
      topicToken: e
    } = this.format;
    if (eP.has(e))
      this.token(e);
    else {
      let t = JSON.stringify(e), r = Array.from(eP, (n) => JSON.stringify(n));
      throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${t} received instead).`);
    }
  }
  s(aee, "TopicReference");
  function oee(e) {
    this.print(e.expression, e);
  }
  s(oee, "PipelineTopicExpression");
  function lee(e) {
    this.print(e.callee, e);
  }
  s(lee, "PipelineBareFunction");
  function uee() {
    this.tokenChar(35);
  }
  s(uee, "PipelinePrimaryTopicReference");
});

// ../node_modules/@babel/generator/lib/generators/flow.js
var nP = T((fe) => {
  "use strict";
  Object.defineProperty(fe, "__esModule", {
    value: !0
  });
  fe.AnyTypeAnnotation = hee;
  fe.ArrayTypeAnnotation = mee;
  fe.BooleanLiteralTypeAnnotation = gee;
  fe.BooleanTypeAnnotation = yee;
  fe.DeclareClass = Eee;
  fe.DeclareExportAllDeclaration = _ee;
  fe.DeclareExportDeclaration = Iee;
  fe.DeclareFunction = vee;
  fe.DeclareInterface = See;
  fe.DeclareModule = Pee;
  fe.DeclareModuleExports = Aee;
  fe.DeclareOpaqueType = wee;
  fe.DeclareTypeAlias = Cee;
  fe.DeclareVariable = Dee;
  fe.DeclaredPredicate = xee;
  fe.EmptyTypeAnnotation = Qee;
  fe.EnumBooleanBody = Nee;
  fe.EnumBooleanMember = Lee;
  fe.EnumDeclaration = Oee;
  fe.EnumDefaultedMember = jee;
  fe.EnumNumberBody = Bee;
  fe.EnumNumberMember = Mee;
  fe.EnumStringBody = kee;
  fe.EnumStringMember = Ree;
  fe.EnumSymbolBody = Fee;
  fe.ExistsTypeAnnotation = Uee;
  fe.FunctionTypeAnnotation = Vee;
  fe.FunctionTypeParam = $ee;
  fe.IndexedAccessType = Ste;
  fe.InferredPredicate = Tee;
  fe.InterfaceDeclaration = Hee;
  fe.GenericTypeAnnotation = fe.ClassImplements = fe.InterfaceExtends = Wee;
  fe.InterfaceTypeAnnotation = zee;
  fe.IntersectionTypeAnnotation = Jee;
  fe.MixedTypeAnnotation = Xee;
  fe.NullLiteralTypeAnnotation = bee;
  fe.NullableTypeAnnotation = Zee;
  Object.defineProperty(fe, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rP.NumericLiteral;
    }, "get")
  });
  fe.NumberTypeAnnotation = ete;
  fe.ObjectTypeAnnotation = cte;
  fe.ObjectTypeCallProperty = pte;
  fe.ObjectTypeIndexer = dte;
  fe.ObjectTypeInternalSlot = fte;
  fe.ObjectTypeProperty = hte;
  fe.ObjectTypeSpreadProperty = mte;
  fe.OpaqueType = ute;
  fe.OptionalIndexedAccessType = Pte;
  fe.QualifiedTypeIdentifier = yte;
  Object.defineProperty(fe, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rP.StringLiteral;
    }, "get")
  });
  fe.StringTypeAnnotation = tte;
  fe.SymbolTypeAnnotation = gte;
  fe.ThisTypeAnnotation = rte;
  fe.TupleTypeAnnotation = nte;
  fe.TypeAlias = ite;
  fe.TypeAnnotation = ate;
  fe.TypeCastExpression = vte;
  fe.TypeParameter = lte;
  fe.TypeParameterDeclaration = fe.TypeParameterInstantiation = ote;
  fe.TypeofTypeAnnotation = ste;
  fe.UnionTypeAnnotation = Ete;
  fe.Variance = Tte;
  fe.VoidTypeAnnotation = xte;
  fe._interfaceish = Kee;
  fe._variance = Gee;
  var cee = Pe(), fee = jm(), pee = as(), rP = Mm(), {
    isDeclareExportDeclaration: wu,
    isStatement: dee
  } = cee;
  function hee() {
    this.word("any");
  }
  s(hee, "AnyTypeAnnotation");
  function mee(e) {
    this.print(e.elementType, e, !0), this.tokenChar(91), this.tokenChar(93);
  }
  s(mee, "ArrayTypeAnnotation");
  function yee() {
    this.word("boolean");
  }
  s(yee, "BooleanTypeAnnotation");
  function gee(e) {
    this.word(e.value ? "true" : "false");
  }
  s(gee, "BooleanLiteralTypeAnnotation");
  function bee() {
    this.word("null");
  }
  s(bee, "NullLiteralTypeAnnotation");
  function Eee(e, t) {
    wu(t) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(e);
  }
  s(Eee, "DeclareClass");
  function vee(e, t) {
    wu(t) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(e.id, e), this.print(e.id.typeAnnotation.
    typeAnnotation, e), e.predicate && (this.space(), this.print(e.predicate, e)), this.semicolon();
  }
  s(vee, "DeclareFunction");
  function Tee() {
    this.tokenChar(37), this.word("checks");
  }
  s(Tee, "InferredPredicate");
  function xee(e) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(e.value, e), this.tokenChar(41);
  }
  s(xee, "DeclaredPredicate");
  function See(e) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(e);
  }
  s(See, "DeclareInterface");
  function Pee(e) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(e.id, e), this.space(), this.print(e.body, e);
  }
  s(Pee, "DeclareModule");
  function Aee(e) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(e.typeAnnotation, e);
  }
  s(Aee, "DeclareModuleExports");
  function Cee(e) {
    this.word("declare"), this.space(), this.TypeAlias(e);
  }
  s(Cee, "DeclareTypeAlias");
  function wee(e, t) {
    wu(t) || (this.word("declare"), this.space()), this.OpaqueType(e);
  }
  s(wee, "DeclareOpaqueType");
  function Dee(e, t) {
    wu(t) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(e.id, e), this.print(e.id.typeAnnotation, e), this.
    semicolon();
  }
  s(Dee, "DeclareVariable");
  function Iee(e) {
    this.word("declare"), this.space(), this.word("export"), this.space(), e.default && (this.word("default"), this.space()), qee.call(this,
    e);
  }
  s(Iee, "DeclareExportDeclaration");
  function _ee(e) {
    this.word("declare"), this.space(), fee.ExportAllDeclaration.call(this, e);
  }
  s(_ee, "DeclareExportAllDeclaration");
  function Oee(e) {
    let {
      id: t,
      body: r
    } = e;
    this.word("enum"), this.space(), this.print(t, e), this.print(r, e);
  }
  s(Oee, "EnumDeclaration");
  function Du(e, t, r) {
    r && (e.space(), e.word("of"), e.space(), e.word(t)), e.space();
  }
  s(Du, "enumExplicitType");
  function Iu(e, t) {
    let {
      members: r
    } = t;
    e.token("{"), e.indent(), e.newline();
    for (let n of r)
      e.print(n, t), e.newline();
    t.hasUnknownMembers && (e.token("..."), e.newline()), e.dedent(), e.token("}");
  }
  s(Iu, "enumBody");
  function Nee(e) {
    let {
      explicitType: t
    } = e;
    Du(this, "boolean", t), Iu(this, e);
  }
  s(Nee, "EnumBooleanBody");
  function Bee(e) {
    let {
      explicitType: t
    } = e;
    Du(this, "number", t), Iu(this, e);
  }
  s(Bee, "EnumNumberBody");
  function kee(e) {
    let {
      explicitType: t
    } = e;
    Du(this, "string", t), Iu(this, e);
  }
  s(kee, "EnumStringBody");
  function Fee(e) {
    Du(this, "symbol", !0), Iu(this, e);
  }
  s(Fee, "EnumSymbolBody");
  function jee(e) {
    let {
      id: t
    } = e;
    this.print(t, e), this.tokenChar(44);
  }
  s(jee, "EnumDefaultedMember");
  function Rm(e, t) {
    let {
      id: r,
      init: n
    } = t;
    e.print(r, t), e.space(), e.token("="), e.space(), e.print(n, t), e.token(",");
  }
  s(Rm, "enumInitializedMember");
  function Lee(e) {
    Rm(this, e);
  }
  s(Lee, "EnumBooleanMember");
  function Mee(e) {
    Rm(this, e);
  }
  s(Mee, "EnumNumberMember");
  function Ree(e) {
    Rm(this, e);
  }
  s(Ree, "EnumStringMember");
  function qee(e) {
    if (e.declaration) {
      let t = e.declaration;
      this.print(t, e), dee(t) || this.semicolon();
    } else
      this.tokenChar(123), e.specifiers.length && (this.space(), this.printList(e.specifiers, e), this.space()), this.tokenChar(125), e.source &&
      (this.space(), this.word("from"), this.space(), this.print(e.source, e)), this.semicolon();
  }
  s(qee, "FlowExportDeclaration");
  function Uee() {
    this.tokenChar(42);
  }
  s(Uee, "ExistsTypeAnnotation");
  function Vee(e, t) {
    this.print(e.typeParameters, e), this.tokenChar(40), e.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(e.this.typeAnnotation,
    e), (e.params.length || e.rest) && (this.tokenChar(44), this.space())), this.printList(e.params, e), e.rest && (e.params.length && (this.
    tokenChar(44), this.space()), this.token("..."), this.print(e.rest, e)), this.tokenChar(41);
    let r = t?.type;
    r != null && (r === "ObjectTypeCallProperty" || r === "ObjectTypeInternalSlot" || r === "DeclareFunction" || r === "ObjectTypeProperty" &&
    t.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(e.returnType, e);
  }
  s(Vee, "FunctionTypeAnnotation");
  function $ee(e) {
    this.print(e.name, e), e.optional && this.tokenChar(63), e.name && (this.tokenChar(58), this.space()), this.print(e.typeAnnotation, e);
  }
  s($ee, "FunctionTypeParam");
  function Wee(e) {
    this.print(e.id, e), this.print(e.typeParameters, e, !0);
  }
  s(Wee, "InterfaceExtends");
  function Kee(e) {
    var t;
    if (this.print(e.id, e), this.print(e.typeParameters, e), (t = e.extends) != null && t.length && (this.space(), this.word("extends"), this.
    space(), this.printList(e.extends, e)), e.type === "DeclareClass") {
      var r, n;
      (r = e.mixins) != null && r.length && (this.space(), this.word("mixins"), this.space(), this.printList(e.mixins, e)), (n = e.implements) !=
      null && n.length && (this.space(), this.word("implements"), this.space(), this.printList(e.implements, e));
    }
    this.space(), this.print(e.body, e);
  }
  s(Kee, "_interfaceish");
  function Gee(e) {
    var t;
    let r = (t = e.variance) == null ? void 0 : t.kind;
    r != null && (r === "plus" ? this.tokenChar(43) : r === "minus" && this.tokenChar(45));
  }
  s(Gee, "_variance");
  function Hee(e) {
    this.word("interface"), this.space(), this._interfaceish(e);
  }
  s(Hee, "InterfaceDeclaration");
  function Yee() {
    this.space(), this.tokenChar(38), this.space();
  }
  s(Yee, "andSeparator");
  function zee(e) {
    var t;
    this.word("interface"), (t = e.extends) != null && t.length && (this.space(), this.word("extends"), this.space(), this.printList(e.extends,
    e)), this.space(), this.print(e.body, e);
  }
  s(zee, "InterfaceTypeAnnotation");
  function Jee(e) {
    this.printJoin(e.types, e, {
      separator: Yee
    });
  }
  s(Jee, "IntersectionTypeAnnotation");
  function Xee() {
    this.word("mixed");
  }
  s(Xee, "MixedTypeAnnotation");
  function Qee() {
    this.word("empty");
  }
  s(Qee, "EmptyTypeAnnotation");
  function Zee(e) {
    this.tokenChar(63), this.print(e.typeAnnotation, e);
  }
  s(Zee, "NullableTypeAnnotation");
  function ete() {
    this.word("number");
  }
  s(ete, "NumberTypeAnnotation");
  function tte() {
    this.word("string");
  }
  s(tte, "StringTypeAnnotation");
  function rte() {
    this.word("this");
  }
  s(rte, "ThisTypeAnnotation");
  function nte(e) {
    this.tokenChar(91), this.printList(e.types, e), this.tokenChar(93);
  }
  s(nte, "TupleTypeAnnotation");
  function ste(e) {
    this.word("typeof"), this.space(), this.print(e.argument, e);
  }
  s(ste, "TypeofTypeAnnotation");
  function ite(e) {
    this.word("type"), this.space(), this.print(e.id, e), this.print(e.typeParameters, e), this.space(), this.tokenChar(61), this.space(), this.
    print(e.right, e), this.semicolon();
  }
  s(ite, "TypeAlias");
  function ate(e, t) {
    this.tokenChar(58), this.space(), t.type === "ArrowFunctionExpression" ? this.tokenContext |= pee.TokenContext.arrowFlowReturnType : e.optional &&
    this.tokenChar(63), this.print(e.typeAnnotation, e);
  }
  s(ate, "TypeAnnotation");
  function ote(e) {
    this.tokenChar(60), this.printList(e.params, e, {}), this.tokenChar(62);
  }
  s(ote, "TypeParameterInstantiation");
  function lte(e) {
    this._variance(e), this.word(e.name), e.bound && this.print(e.bound, e), e.default && (this.space(), this.tokenChar(61), this.space(), this.
    print(e.default, e));
  }
  s(lte, "TypeParameter");
  function ute(e) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(e.id, e), this.print(e.typeParameters, e), e.supertype &&
    (this.tokenChar(58), this.space(), this.print(e.supertype, e)), e.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(
    e.impltype, e)), this.semicolon();
  }
  s(ute, "OpaqueType");
  function cte(e) {
    e.exact ? this.token("{|") : this.tokenChar(123);
    let t = [...e.properties, ...e.callProperties || [], ...e.indexers || [], ...e.internalSlots || []];
    t.length && (this.newline(), this.space(), this.printJoin(t, e, {
      addNewlines(r) {
        if (r && !t[0]) return 1;
      },
      indent: !0,
      statement: !0,
      iterator: /* @__PURE__ */ s(() => {
        (t.length !== 1 || e.inexact) && (this.tokenChar(44), this.space());
      }, "iterator")
    }), this.space()), e.inexact && (this.indent(), this.token("..."), t.length && this.newline(), this.dedent()), e.exact ? this.token("|}") :
    this.tokenChar(125);
  }
  s(cte, "ObjectTypeAnnotation");
  function fte(e) {
    e.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(e.id, e), this.tokenChar(93), this.tokenChar(
    93), e.optional && this.tokenChar(63), e.method || (this.tokenChar(58), this.space()), this.print(e.value, e);
  }
  s(fte, "ObjectTypeInternalSlot");
  function pte(e) {
    e.static && (this.word("static"), this.space()), this.print(e.value, e);
  }
  s(pte, "ObjectTypeCallProperty");
  function dte(e) {
    e.static && (this.word("static"), this.space()), this._variance(e), this.tokenChar(91), e.id && (this.print(e.id, e), this.tokenChar(58),
    this.space()), this.print(e.key, e), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(e.value, e);
  }
  s(dte, "ObjectTypeIndexer");
  function hte(e) {
    e.proto && (this.word("proto"), this.space()), e.static && (this.word("static"), this.space()), (e.kind === "get" || e.kind === "set") &&
    (this.word(e.kind), this.space()), this._variance(e), this.print(e.key, e), e.optional && this.tokenChar(63), e.method || (this.tokenChar(
    58), this.space()), this.print(e.value, e);
  }
  s(hte, "ObjectTypeProperty");
  function mte(e) {
    this.token("..."), this.print(e.argument, e);
  }
  s(mte, "ObjectTypeSpreadProperty");
  function yte(e) {
    this.print(e.qualification, e), this.tokenChar(46), this.print(e.id, e);
  }
  s(yte, "QualifiedTypeIdentifier");
  function gte() {
    this.word("symbol");
  }
  s(gte, "SymbolTypeAnnotation");
  function bte() {
    this.space(), this.tokenChar(124), this.space();
  }
  s(bte, "orSeparator");
  function Ete(e) {
    this.printJoin(e.types, e, {
      separator: bte
    });
  }
  s(Ete, "UnionTypeAnnotation");
  function vte(e) {
    this.tokenChar(40), this.print(e.expression, e), this.print(e.typeAnnotation, e), this.tokenChar(41);
  }
  s(vte, "TypeCastExpression");
  function Tte(e) {
    e.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  s(Tte, "Variance");
  function xte() {
    this.word("void");
  }
  s(xte, "VoidTypeAnnotation");
  function Ste(e) {
    this.print(e.objectType, e, !0), this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
  }
  s(Ste, "IndexedAccessType");
  function Pte(e) {
    this.print(e.objectType, e), e.optional && this.token("?."), this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
  }
  s(Pte, "OptionalIndexedAccessType");
});

// ../node_modules/@babel/generator/lib/generators/base.js
var sP = T((On) => {
  "use strict";
  Object.defineProperty(On, "__esModule", {
    value: !0
  });
  On.BlockStatement = wte;
  On.Directive = Dte;
  On.DirectiveLiteral = Ote;
  On.File = Ate;
  On.InterpreterDirective = Nte;
  On.Placeholder = Bte;
  On.Program = Cte;
  function Ate(e) {
    e.program && this.print(e.program.interpreter, e), this.print(e.program, e);
  }
  s(Ate, "File");
  function Cte(e) {
    var t;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    let r = (t = e.directives) == null ? void 0 : t.length;
    if (r) {
      var n;
      let i = e.body.length ? 2 : 1;
      this.printSequence(e.directives, e, {
        trailingCommentsLineOffset: i
      }), (n = e.directives[r - 1].trailingComments) != null && n.length || this.newline(i);
    }
    this.printSequence(e.body, e);
  }
  s(Cte, "Program");
  function wte(e) {
    var t;
    this.tokenChar(123);
    let r = (t = e.directives) == null ? void 0 : t.length;
    if (r) {
      var n;
      let a = e.body.length ? 2 : 1;
      this.printSequence(e.directives, e, {
        indent: !0,
        trailingCommentsLineOffset: a
      }), (n = e.directives[r - 1].trailingComments) != null && n.length || this.newline(a);
    }
    let i = this.enterForStatementInit(!1);
    this.printSequence(e.body, e, {
      indent: !0
    }), i(), this.rightBrace(e);
  }
  s(wte, "BlockStatement");
  function Dte(e) {
    this.print(e.value, e), this.semicolon();
  }
  s(Dte, "Directive");
  var Ite = /(?:^|[^\\])(?:\\\\)*'/, _te = /(?:^|[^\\])(?:\\\\)*"/;
  function Ote(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.token(t);
      return;
    }
    let {
      value: r
    } = e;
    if (!_te.test(r))
      this.token(`"${r}"`);
    else if (!Ite.test(r))
      this.token(`'${r}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  s(Ote, "DirectiveLiteral");
  function Nte(e) {
    this.token(`#!${e.value}`), this.newline(1, !0);
  }
  s(Nte, "InterpreterDirective");
  function Bte(e) {
    this.token("%%"), this.print(e.name), this.token("%%"), e.expectedNode === "Statement" && this.semicolon();
  }
  s(Bte, "Placeholder");
});

// ../node_modules/@babel/generator/lib/generators/jsx.js
var iP = T((Vt) => {
  "use strict";
  Object.defineProperty(Vt, "__esModule", {
    value: !0
  });
  Vt.JSXAttribute = kte;
  Vt.JSXClosingElement = Kte;
  Vt.JSXClosingFragment = zte;
  Vt.JSXElement = Vte;
  Vt.JSXEmptyExpression = Gte;
  Vt.JSXExpressionContainer = Rte;
  Vt.JSXFragment = Hte;
  Vt.JSXIdentifier = Fte;
  Vt.JSXMemberExpression = Lte;
  Vt.JSXNamespacedName = jte;
  Vt.JSXOpeningElement = Wte;
  Vt.JSXOpeningFragment = Yte;
  Vt.JSXSpreadAttribute = Mte;
  Vt.JSXSpreadChild = qte;
  Vt.JSXText = Ute;
  function kte(e) {
    this.print(e.name, e), e.value && (this.tokenChar(61), this.print(e.value, e));
  }
  s(kte, "JSXAttribute");
  function Fte(e) {
    this.word(e.name);
  }
  s(Fte, "JSXIdentifier");
  function jte(e) {
    this.print(e.namespace, e), this.tokenChar(58), this.print(e.name, e);
  }
  s(jte, "JSXNamespacedName");
  function Lte(e) {
    this.print(e.object, e), this.tokenChar(46), this.print(e.property, e);
  }
  s(Lte, "JSXMemberExpression");
  function Mte(e) {
    this.tokenChar(123), this.token("..."), this.print(e.argument, e), this.tokenChar(125);
  }
  s(Mte, "JSXSpreadAttribute");
  function Rte(e) {
    this.tokenChar(123), this.print(e.expression, e), this.tokenChar(125);
  }
  s(Rte, "JSXExpressionContainer");
  function qte(e) {
    this.tokenChar(123), this.token("..."), this.print(e.expression, e), this.tokenChar(125);
  }
  s(qte, "JSXSpreadChild");
  function Ute(e) {
    let t = this.getPossibleRaw(e);
    t !== void 0 ? this.token(t, !0) : this.token(e.value, !0);
  }
  s(Ute, "JSXText");
  function Vte(e) {
    let t = e.openingElement;
    if (this.print(t, e), !t.selfClosing) {
      this.indent();
      for (let r of e.children)
        this.print(r, e);
      this.dedent(), this.print(e.closingElement, e);
    }
  }
  s(Vte, "JSXElement");
  function $te() {
    this.space();
  }
  s($te, "spaceSeparator");
  function Wte(e) {
    this.tokenChar(60), this.print(e.name, e), this.print(e.typeParameters, e), e.attributes.length > 0 && (this.space(), this.printJoin(e.attributes,
    e, {
      separator: $te
    })), e.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
  }
  s(Wte, "JSXOpeningElement");
  function Kte(e) {
    this.token("</"), this.print(e.name, e), this.tokenChar(62);
  }
  s(Kte, "JSXClosingElement");
  function Gte() {
    this.printInnerComments();
  }
  s(Gte, "JSXEmptyExpression");
  function Hte(e) {
    this.print(e.openingFragment, e), this.indent();
    for (let t of e.children)
      this.print(t, e);
    this.dedent(), this.print(e.closingFragment, e);
  }
  s(Hte, "JSXFragment");
  function Yte() {
    this.tokenChar(60), this.tokenChar(62);
  }
  s(Yte, "JSXOpeningFragment");
  function zte() {
    this.token("</"), this.tokenChar(62);
  }
  s(zte, "JSXClosingFragment");
});

// ../node_modules/@babel/generator/lib/generators/typescript.js
var lP = T((le) => {
  "use strict";
  Object.defineProperty(le, "__esModule", {
    value: !0
  });
  le.TSAnyKeyword = ure;
  le.TSArrayType = Ore;
  le.TSSatisfiesExpression = le.TSAsExpression = zre;
  le.TSBigIntKeyword = cre;
  le.TSBooleanKeyword = hre;
  le.TSCallSignatureDeclaration = nre;
  le.TSConditionalType = Mre;
  le.TSConstructSignatureDeclaration = sre;
  le.TSConstructorType = Pre;
  le.TSDeclareFunction = ere;
  le.TSDeclareMethod = tre;
  le.TSEnumDeclaration = Qre;
  le.TSEnumMember = Zre;
  le.TSExportAssignment = ane;
  le.TSExpressionWithTypeArguments = Kre;
  le.TSExternalModuleReference = sne;
  le.TSFunctionType = Sre;
  le.TSImportEqualsDeclaration = nne;
  le.TSImportType = rne;
  le.TSIndexSignature = lre;
  le.TSIndexedAccessType = Vre;
  le.TSInferType = Rre;
  le.TSInstantiationExpression = Xre;
  le.TSInterfaceBody = Hre;
  le.TSInterfaceDeclaration = Gre;
  le.TSIntersectionType = Lre;
  le.TSIntrinsicKeyword = Tre;
  le.TSLiteralType = Wre;
  le.TSMappedType = $re;
  le.TSMethodSignature = ore;
  le.TSModuleBlock = tne;
  le.TSModuleDeclaration = ene;
  le.TSNamedTupleMember = Fre;
  le.TSNamespaceExportDeclaration = one;
  le.TSNeverKeyword = vre;
  le.TSNonNullExpression = ine;
  le.TSNullKeyword = Ere;
  le.TSNumberKeyword = pre;
  le.TSObjectKeyword = dre;
  le.TSOptionalType = Bre;
  le.TSParameterProperty = Zte;
  le.TSParenthesizedType = qre;
  le.TSPropertySignature = ire;
  le.TSQualifiedName = rre;
  le.TSRestType = kre;
  le.TSStringKeyword = mre;
  le.TSSymbolKeyword = yre;
  le.TSThisType = xre;
  le.TSTupleType = Nre;
  le.TSTypeAliasDeclaration = Yre;
  le.TSTypeAnnotation = Jte;
  le.TSTypeAssertion = Jre;
  le.TSTypeLiteral = Ire;
  le.TSTypeOperator = Ure;
  le.TSTypeParameter = Qte;
  le.TSTypeParameterDeclaration = le.TSTypeParameterInstantiation = Xte;
  le.TSTypePredicate = wre;
  le.TSTypeQuery = Dre;
  le.TSTypeReference = Cre;
  le.TSUndefinedKeyword = bre;
  le.TSUnionType = jre;
  le.TSUnknownKeyword = fre;
  le.TSVoidKeyword = gre;
  le.tsPrintClassMemberModifiers = une;
  le.tsPrintFunctionOrConstructorType = Are;
  le.tsPrintPropertyOrMethodName = are;
  le.tsPrintSignatureDeclarationBase = lne;
  le.tsPrintTypeLiteralOrInterfaceBody = _re;
  function Jte(e) {
    this.tokenChar(58), this.space(), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
  }
  s(Jte, "TSTypeAnnotation");
  function Xte(e, t) {
    this.tokenChar(60), this.printList(e.params, e, {}), t.type === "ArrowFunctionExpression" && e.params.length === 1 && this.tokenChar(44),
    this.tokenChar(62);
  }
  s(Xte, "TSTypeParameterInstantiation");
  function Qte(e) {
    e.in && (this.word("in"), this.space()), e.out && (this.word("out"), this.space()), this.word(e.name), e.constraint && (this.space(), this.
    word("extends"), this.space(), this.print(e.constraint, e)), e.default && (this.space(), this.tokenChar(61), this.space(), this.print(e.
    default, e));
  }
  s(Qte, "TSTypeParameter");
  function Zte(e) {
    e.accessibility && (this.word(e.accessibility), this.space()), e.readonly && (this.word("readonly"), this.space()), this._param(e.parameter);
  }
  s(Zte, "TSParameterProperty");
  function ere(e, t) {
    e.declare && (this.word("declare"), this.space()), this._functionHead(e, t), this.tokenChar(59);
  }
  s(ere, "TSDeclareFunction");
  function tre(e) {
    this._classMethodHead(e), this.tokenChar(59);
  }
  s(tre, "TSDeclareMethod");
  function rre(e) {
    this.print(e.left, e), this.tokenChar(46), this.print(e.right, e);
  }
  s(rre, "TSQualifiedName");
  function nre(e) {
    this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
  }
  s(nre, "TSCallSignatureDeclaration");
  function sre(e) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
  }
  s(sre, "TSConstructSignatureDeclaration");
  function ire(e) {
    let {
      readonly: t
    } = e;
    t && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e), this.print(e.typeAnnotation, e), this.tokenChar(59);
  }
  s(ire, "TSPropertySignature");
  function are(e) {
    e.computed && this.tokenChar(91), this.print(e.key, e), e.computed && this.tokenChar(93), e.optional && this.tokenChar(63);
  }
  s(are, "tsPrintPropertyOrMethodName");
  function ore(e) {
    let {
      kind: t
    } = e;
    (t === "set" || t === "get") && (this.word(t), this.space()), this.tsPrintPropertyOrMethodName(e), this.tsPrintSignatureDeclarationBase(
    e), this.tokenChar(59);
  }
  s(ore, "TSMethodSignature");
  function lre(e) {
    let {
      readonly: t,
      static: r
    } = e;
    r && (this.word("static"), this.space()), t && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(e.parameters,
    e), this.tokenChar(93), this.print(e.typeAnnotation, e), this.tokenChar(59);
  }
  s(lre, "TSIndexSignature");
  function ure() {
    this.word("any");
  }
  s(ure, "TSAnyKeyword");
  function cre() {
    this.word("bigint");
  }
  s(cre, "TSBigIntKeyword");
  function fre() {
    this.word("unknown");
  }
  s(fre, "TSUnknownKeyword");
  function pre() {
    this.word("number");
  }
  s(pre, "TSNumberKeyword");
  function dre() {
    this.word("object");
  }
  s(dre, "TSObjectKeyword");
  function hre() {
    this.word("boolean");
  }
  s(hre, "TSBooleanKeyword");
  function mre() {
    this.word("string");
  }
  s(mre, "TSStringKeyword");
  function yre() {
    this.word("symbol");
  }
  s(yre, "TSSymbolKeyword");
  function gre() {
    this.word("void");
  }
  s(gre, "TSVoidKeyword");
  function bre() {
    this.word("undefined");
  }
  s(bre, "TSUndefinedKeyword");
  function Ere() {
    this.word("null");
  }
  s(Ere, "TSNullKeyword");
  function vre() {
    this.word("never");
  }
  s(vre, "TSNeverKeyword");
  function Tre() {
    this.word("intrinsic");
  }
  s(Tre, "TSIntrinsicKeyword");
  function xre() {
    this.word("this");
  }
  s(xre, "TSThisType");
  function Sre(e) {
    this.tsPrintFunctionOrConstructorType(e);
  }
  s(Sre, "TSFunctionType");
  function Pre(e) {
    e.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e);
  }
  s(Pre, "TSConstructorType");
  function Are(e) {
    let {
      typeParameters: t
    } = e, r = e.parameters;
    this.print(t, e), this.tokenChar(40), this._parameters(r, e), this.tokenChar(41), this.space(), this.token("=>"), this.space();
    let n = e.typeAnnotation;
    this.print(n.typeAnnotation, e);
  }
  s(Are, "tsPrintFunctionOrConstructorType");
  function Cre(e) {
    this.print(e.typeName, e, !0), this.print(e.typeParameters, e, !0);
  }
  s(Cre, "TSTypeReference");
  function wre(e) {
    e.asserts && (this.word("asserts"), this.space()), this.print(e.parameterName), e.typeAnnotation && (this.space(), this.word("is"), this.
    space(), this.print(e.typeAnnotation.typeAnnotation));
  }
  s(wre, "TSTypePredicate");
  function Dre(e) {
    this.word("typeof"), this.space(), this.print(e.exprName), e.typeParameters && this.print(e.typeParameters, e);
  }
  s(Dre, "TSTypeQuery");
  function Ire(e) {
    this.tsPrintTypeLiteralOrInterfaceBody(e.members, e);
  }
  s(Ire, "TSTypeLiteral");
  function _re(e, t) {
    qm(this, e, t);
  }
  s(_re, "tsPrintTypeLiteralOrInterfaceBody");
  function qm(e, t, r) {
    if (e.token("{"), t.length) {
      e.indent(), e.newline();
      for (let n of t)
        e.print(n, r), e.newline();
      e.dedent();
    }
    e.rightBrace(r);
  }
  s(qm, "tsPrintBraced");
  function Ore(e) {
    this.print(e.elementType, e, !0), this.token("[]");
  }
  s(Ore, "TSArrayType");
  function Nre(e) {
    this.tokenChar(91), this.printList(e.elementTypes, e), this.tokenChar(93);
  }
  s(Nre, "TSTupleType");
  function Bre(e) {
    this.print(e.typeAnnotation, e), this.tokenChar(63);
  }
  s(Bre, "TSOptionalType");
  function kre(e) {
    this.token("..."), this.print(e.typeAnnotation, e);
  }
  s(kre, "TSRestType");
  function Fre(e) {
    this.print(e.label, e), e.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(e.elementType, e);
  }
  s(Fre, "TSNamedTupleMember");
  function jre(e) {
    oP(this, e, "|");
  }
  s(jre, "TSUnionType");
  function Lre(e) {
    oP(this, e, "&");
  }
  s(Lre, "TSIntersectionType");
  function oP(e, t, r) {
    e.printJoin(t.types, t, {
      separator() {
        this.space(), this.token(r), this.space();
      }
    });
  }
  s(oP, "tsPrintUnionOrIntersectionType");
  function Mre(e) {
    this.print(e.checkType), this.space(), this.word("extends"), this.space(), this.print(e.extendsType), this.space(), this.tokenChar(63), this.
    space(), this.print(e.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e.falseType);
  }
  s(Mre, "TSConditionalType");
  function Rre(e) {
    this.token("infer"), this.space(), this.print(e.typeParameter);
  }
  s(Rre, "TSInferType");
  function qre(e) {
    this.tokenChar(40), this.print(e.typeAnnotation, e), this.tokenChar(41);
  }
  s(qre, "TSParenthesizedType");
  function Ure(e) {
    this.word(e.operator), this.space(), this.print(e.typeAnnotation, e);
  }
  s(Ure, "TSTypeOperator");
  function Vre(e) {
    this.print(e.objectType, e, !0), this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
  }
  s(Vre, "TSIndexedAccessType");
  function $re(e) {
    let {
      nameType: t,
      optional: r,
      readonly: n,
      typeParameter: i,
      typeAnnotation: a
    } = e;
    this.tokenChar(123), this.space(), n && (aP(this, n), this.word("readonly"), this.space()), this.tokenChar(91), this.word(i.name), this.
    space(), this.word("in"), this.space(), this.print(i.constraint, i), t && (this.space(), this.word("as"), this.space(), this.print(t, e)),
    this.tokenChar(93), r && (aP(this, r), this.tokenChar(63)), a && (this.tokenChar(58), this.space(), this.print(a, e)), this.space(), this.
    tokenChar(125);
  }
  s($re, "TSMappedType");
  function aP(e, t) {
    t !== !0 && e.token(t);
  }
  s(aP, "tokenIfPlusMinus");
  function Wre(e) {
    this.print(e.literal, e);
  }
  s(Wre, "TSLiteralType");
  function Kre(e) {
    this.print(e.expression, e), this.print(e.typeParameters, e);
  }
  s(Kre, "TSExpressionWithTypeArguments");
  function Gre(e) {
    let {
      declare: t,
      id: r,
      typeParameters: n,
      extends: i,
      body: a
    } = e;
    t && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r, e), this.print(n, e), i != null && i.length &&
    (this.space(), this.word("extends"), this.space(), this.printList(i, e)), this.space(), this.print(a, e);
  }
  s(Gre, "TSInterfaceDeclaration");
  function Hre(e) {
    this.tsPrintTypeLiteralOrInterfaceBody(e.body, e);
  }
  s(Hre, "TSInterfaceBody");
  function Yre(e) {
    let {
      declare: t,
      id: r,
      typeParameters: n,
      typeAnnotation: i
    } = e;
    t && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r, e), this.print(n, e), this.space(), this.tokenChar(
    61), this.space(), this.print(i, e), this.tokenChar(59);
  }
  s(Yre, "TSTypeAliasDeclaration");
  function zre(e) {
    var t;
    let {
      type: r,
      expression: n,
      typeAnnotation: i
    } = e, a = !!((t = n.trailingComments) != null && t.length);
    this.print(n, e, !0, void 0, a), this.space(), this.word(r === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(i, e);
  }
  s(zre, "TSTypeExpression");
  function Jre(e) {
    let {
      typeAnnotation: t,
      expression: r
    } = e;
    this.tokenChar(60), this.print(t, e), this.tokenChar(62), this.space(), this.print(r, e);
  }
  s(Jre, "TSTypeAssertion");
  function Xre(e) {
    this.print(e.expression, e), this.print(e.typeParameters, e);
  }
  s(Xre, "TSInstantiationExpression");
  function Qre(e) {
    let {
      declare: t,
      const: r,
      id: n,
      members: i
    } = e;
    t && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(n, e), this.
    space(), qm(this, i, e);
  }
  s(Qre, "TSEnumDeclaration");
  function Zre(e) {
    let {
      id: t,
      initializer: r
    } = e;
    this.print(t, e), r && (this.space(), this.tokenChar(61), this.space(), this.print(r, e)), this.tokenChar(44);
  }
  s(Zre, "TSEnumMember");
  function ene(e) {
    let {
      declare: t,
      id: r
    } = e;
    if (t && (this.word("declare"), this.space()), e.global || (this.word(r.type === "Identifier" ? "namespace" : "module"), this.space()), this.
    print(r, e), !e.body) {
      this.tokenChar(59);
      return;
    }
    let n = e.body;
    for (; n.type === "TSModuleDeclaration"; )
      this.tokenChar(46), this.print(n.id, n), n = n.body;
    this.space(), this.print(n, e);
  }
  s(ene, "TSModuleDeclaration");
  function tne(e) {
    qm(this, e.body, e);
  }
  s(tne, "TSModuleBlock");
  function rne(e) {
    let {
      argument: t,
      qualifier: r,
      typeParameters: n
    } = e;
    this.word("import"), this.tokenChar(40), this.print(t, e), this.tokenChar(41), r && (this.tokenChar(46), this.print(r, e)), n && this.print(
    n, e);
  }
  s(rne, "TSImportType");
  function nne(e) {
    let {
      isExport: t,
      id: r,
      moduleReference: n
    } = e;
    t && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(r, e), this.space(), this.tokenChar(61), this.space(),
    this.print(n, e), this.tokenChar(59);
  }
  s(nne, "TSImportEqualsDeclaration");
  function sne(e) {
    this.token("require("), this.print(e.expression, e), this.tokenChar(41);
  }
  s(sne, "TSExternalModuleReference");
  function ine(e) {
    this.print(e.expression, e), this.tokenChar(33);
  }
  s(ine, "TSNonNullExpression");
  function ane(e) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e.expression, e), this.tokenChar(59);
  }
  s(ane, "TSExportAssignment");
  function one(e) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e.id, e);
  }
  s(one, "TSNamespaceExportDeclaration");
  function lne(e) {
    let {
      typeParameters: t
    } = e, r = e.parameters;
    this.print(t, e), this.tokenChar(40), this._parameters(r, e), this.tokenChar(41);
    let n = e.typeAnnotation;
    this.print(n, e);
  }
  s(lne, "tsPrintSignatureDeclarationBase");
  function une(e) {
    let t = e.type === "ClassAccessorProperty" || e.type === "ClassProperty";
    t && e.declare && (this.word("declare"), this.space()), e.accessibility && (this.word(e.accessibility), this.space()), e.static && (this.
    word("static"), this.space()), e.override && (this.word("override"), this.space()), e.abstract && (this.word("abstract"), this.space()),
    t && e.readonly && (this.word("readonly"), this.space());
  }
  s(une, "tsPrintClassMemberModifiers");
});

// ../node_modules/@babel/generator/lib/generators/index.js
var uP = T((ze) => {
  "use strict";
  Object.defineProperty(ze, "__esModule", {
    value: !0
  });
  var Um = MS();
  Object.keys(Um).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ze && ze[e] === Um[e] || Object.defineProperty(ze, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Um[e];
      }, "get")
    });
  });
  var Vm = qS();
  Object.keys(Vm).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ze && ze[e] === Vm[e] || Object.defineProperty(ze, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Vm[e];
      }, "get")
    });
  });
  var $m = WS();
  Object.keys($m).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ze && ze[e] === $m[e] || Object.defineProperty(ze, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return $m[e];
      }, "get")
    });
  });
  var Wm = KS();
  Object.keys(Wm).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ze && ze[e] === Wm[e] || Object.defineProperty(ze, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Wm[e];
      }, "get")
    });
  });
  var Km = GS();
  Object.keys(Km).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ze && ze[e] === Km[e] || Object.defineProperty(ze, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Km[e];
      }, "get")
    });
  });
  var Gm = jm();
  Object.keys(Gm).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ze && ze[e] === Gm[e] || Object.defineProperty(ze, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Gm[e];
      }, "get")
    });
  });
  var Hm = Mm();
  Object.keys(Hm).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ze && ze[e] === Hm[e] || Object.defineProperty(ze, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Hm[e];
      }, "get")
    });
  });
  var Ym = nP();
  Object.keys(Ym).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ze && ze[e] === Ym[e] || Object.defineProperty(ze, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ym[e];
      }, "get")
    });
  });
  var zm = sP();
  Object.keys(zm).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ze && ze[e] === zm[e] || Object.defineProperty(ze, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return zm[e];
      }, "get")
    });
  });
  var Jm = iP();
  Object.keys(Jm).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ze && ze[e] === Jm[e] || Object.defineProperty(ze, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Jm[e];
      }, "get")
    });
  });
  var Xm = lP();
  Object.keys(Xm).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ze && ze[e] === Xm[e] || Object.defineProperty(ze, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Xm[e];
      }, "get")
    });
  });
});

// ../node_modules/@babel/generator/lib/printer.js
var fP = T((_u) => {
  "use strict";
  Object.defineProperty(_u, "__esModule", {
    value: !0
  });
  _u.default = void 0;
  var cne = SS(), fne = as(), pne = Pe(), dne = uP(), {
    isFunction: hne,
    isStatement: mne,
    isClassBody: yne,
    isTSInterfaceBody: gne,
    isTSEnumDeclaration: bne
  } = pne, Ene = /e/i, vne = /\.0+$/, cP = /[\n\r\u2028\u2029]/, Tne = /[\n\r\u2028\u2029]|\*\//, {
    needsParens: xne
  } = fne, co = class {
    static {
      s(this, "Printer");
    }
    constructor(t, r) {
      this.inForStatementInit = !1, this.tokenContext = 0, this._currentNode = null, this._indent = 0, this._indentRepeat = 0, this._insideAux =
      !1, this._parenPushNewlineState = null, this._noLineTerminator = !1, this._printAuxAfterOnNextUserNode = !1, this._printedComments = /* @__PURE__ */ new Set(),
      this._endsWithInteger = !1, this._endsWithWord = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments =
      !0, this.format = t, this._indentRepeat = t.indent.style.length, this._inputMap = r?._inputMap, this._buf = new cne.default(r, t.indent.
      style[0]);
    }
    enterForStatementInit(t) {
      let r = this.inForStatementInit;
      return r === t ? () => {
      } : (this.inForStatementInit = t, () => {
        this.inForStatementInit = r;
      });
    }
    generate(t) {
      return this.print(t), this._maybeAddAuxComment(), this._buf.get();
    }
    indent() {
      this.format.compact || this.format.concise || this._indent++;
    }
    dedent() {
      this.format.compact || this.format.concise || this._indent--;
    }
    semicolon(t = !1) {
      this._maybeAddAuxComment(), t ? this._appendChar(59) : this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(t) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
    }
    rightParens(t) {
      this.sourceWithOffset("end", t.loc, -1), this.tokenChar(41);
    }
    space(t = !1) {
      if (!this.format.compact) {
        if (t)
          this._space();
        else if (this._buf.hasContent()) {
          let r = this.getLastChar();
          r !== 32 && r !== 10 && this._space();
        }
      }
    }
    word(t, r = !1) {
      this.tokenContext = 0, this._maybePrintInnerComments(), (this._endsWithWord || t.charCodeAt(0) === 47 && this.endsWith(47)) && this._space(),
      this._maybeAddAuxComment(), this._append(t, !1), this._endsWithWord = !0, this._noLineTerminator = r;
    }
    number(t, r) {
      function n(i) {
        if (i.length > 2 && i.charCodeAt(0) === 48) {
          let a = i.charCodeAt(1);
          return a === 98 || a === 111 || a === 120;
        }
        return !1;
      }
      s(n, "isNonDecimalLiteral"), this.word(t), this._endsWithInteger = Number.isInteger(r) && !n(t) && !Ene.test(t) && !vne.test(t) && t.charCodeAt(
      t.length - 1) !== 46;
    }
    token(t, r = !1) {
      this.tokenContext = 0, this._maybePrintInnerComments();
      let n = this.getLastChar(), i = t.charCodeAt(0);
      (n === 33 && (t === "--" || i === 61) || i === 43 && n === 43 || i === 45 && n === 45 || i === 46 && this._endsWithInteger) && this._space(),
      this._maybeAddAuxComment(), this._append(t, r), this._noLineTerminator = !1;
    }
    tokenChar(t) {
      this.tokenContext = 0, this._maybePrintInnerComments();
      let r = this.getLastChar();
      (t === 43 && r === 43 || t === 45 && r === 45 || t === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this.
      _appendChar(t), this._noLineTerminator = !1;
    }
    newline(t = 1, r) {
      if (!(t <= 0)) {
        if (!r) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        t > 2 && (t = 2), t -= this._buf.getNewlineCount();
        for (let n = 0; n < t; n++)
          this._newline();
      }
    }
    endsWith(t) {
      return this.getLastChar() === t;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(t, r) {
      if (!t) {
        r();
        return;
      }
      this._catchUp("start", t), this._buf.exactSource(t, r);
    }
    source(t, r) {
      r && (this._catchUp(t, r), this._buf.source(t, r));
    }
    sourceWithOffset(t, r, n) {
      r && (this._catchUp(t, r), this._buf.sourceWithOffset(t, r, n));
    }
    sourceIdentifierName(t, r) {
      if (!this._buf._canMarkIdName) return;
      let n = this._buf._sourcePosition;
      n.identifierNamePos = r, n.identifierName = t;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _append(t, r) {
      this._maybeAddParen(t), this._maybeIndent(t.charCodeAt(0)), this._buf.append(t, r), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _appendChar(t) {
      this._maybeAddParenChar(t), this._maybeIndent(t), this._buf.appendChar(t), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _queue(t) {
      this._maybeAddParenChar(t), this._maybeIndent(t), this._buf.queue(t), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(t) {
      this._indent && t !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(t) {
      if (this._indent && t !== 10 && this.endsWith(10))
        return !0;
    }
    _maybeAddParenChar(t) {
      let r = this._parenPushNewlineState;
      if (r && t !== 32) {
        if (t !== 10) {
          this._parenPushNewlineState = null;
          return;
        }
        this.tokenChar(40), this.indent(), r.printed = !0;
      }
    }
    _maybeAddParen(t) {
      let r = this._parenPushNewlineState;
      if (!r) return;
      let n = t.length, i;
      for (i = 0; i < n && t.charCodeAt(i) === 32; i++) ;
      if (i === n)
        return;
      let a = t.charCodeAt(i);
      if (a !== 10) {
        if (a !== 47 || i + 1 === n) {
          this._parenPushNewlineState = null;
          return;
        }
        let o = t.charCodeAt(i + 1);
        if (o === 42)
          return;
        if (o !== 47) {
          this._parenPushNewlineState = null;
          return;
        }
      }
      this.tokenChar(40), this.indent(), r.printed = !0;
    }
    catchUp(t) {
      if (!this.format.retainLines) return;
      let r = t - this._buf.getCurrentLine();
      for (let n = 0; n < r; n++)
        this._newline();
    }
    _catchUp(t, r) {
      var n;
      if (!this.format.retainLines) return;
      let i = r == null || (n = r[t]) == null ? void 0 : n.line;
      if (i != null) {
        let a = i - this._buf.getCurrentLine();
        for (let o = 0; o < a; o++)
          this._newline();
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(t, r, n) {
      if (n)
        this._noLineTerminator = !0, this.print(t, r);
      else {
        let i = {
          printed: !1
        };
        this._parenPushNewlineState = i, this.print(t, r), i.printed && (this.dedent(), this.newline(), this.tokenChar(41));
      }
    }
    print(t, r, n, i, a) {
      var o, l;
      if (!t) return;
      this._endsWithInnerRaw = !1;
      let u = t.type, c = this.format, f = c.concise;
      t._compact && (c.concise = !0);
      let p = this[u];
      if (p === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(u)} with constructor ${JSON.stringify(t.constructor.name)}`);
      let h = this._currentNode;
      this._currentNode = t;
      let y = this._insideAux;
      this._insideAux = t.loc == null, this._maybeAddAuxComment(this._insideAux && !y);
      let v = (o = t.extra) == null ? void 0 : o.parenthesized, d = a || v && c.retainFunctionParens && u === "FunctionExpression" || xne(t,
      r, this.tokenContext, this.inForStatementInit);
      if (!d && v && (l = t.leadingComments) != null && l.length && t.leadingComments[0].type === "CommentBlock")
        switch (r?.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (r.callee !== t) break;
          default:
            d = !0;
        }
      let b;
      d && (this.tokenChar(40), this._endsWithInnerRaw = !1, b = this.enterForStatementInit(!1)), this._lastCommentLine = 0, this._printLeadingComments(
      t, r);
      let E = u === "Program" || u === "File" ? null : t.loc;
      this.exactSource(E, p.bind(this, t, r)), d ? (this._printTrailingComments(t, r), this.tokenChar(41), this._noLineTerminator = n, b()) :
      n && !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(t, r)) : this._printTrailingComments(t, r, i),
      this._currentNode = h, c.concise = f, this._insideAux = y, this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(t) {
      t && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      let t = this.format.auxiliaryCommentBefore;
      t && this._printComment({
        type: "CommentBlock",
        value: t
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      let t = this.format.auxiliaryCommentAfter;
      t && this._printComment({
        type: "CommentBlock",
        value: t
      }, 0);
    }
    getPossibleRaw(t) {
      let r = t.extra;
      if (r?.raw != null && r.rawValue != null && t.value === r.rawValue)
        return r.raw;
    }
    printJoin(t, r, n = {}) {
      if (!(t != null && t.length)) return;
      let {
        indent: i
      } = n;
      if (i == null && this.format.retainLines) {
        var a;
        let p = (a = t[0].loc) == null ? void 0 : a.start.line;
        p != null && p !== this._buf.getCurrentLine() && (i = !0);
      }
      i && this.indent();
      let o = {
        addNewlines: n.addNewlines,
        nextNodeStartLine: 0
      }, l = n.separator ? n.separator.bind(this) : null, u = t.length;
      for (let p = 0; p < u; p++) {
        let h = t[p];
        if (h && (n.statement && this._printNewline(p === 0, o), this.print(h, r, void 0, n.trailingCommentsLineOffset || 0), n.iterator == null ||
        n.iterator(h, p), p < u - 1 && l?.(), n.statement)) {
          var c;
          if ((c = h.trailingComments) != null && c.length || (this._lastCommentLine = 0), p + 1 === u)
            this.newline(1);
          else {
            var f;
            let y = t[p + 1];
            o.nextNodeStartLine = ((f = y.loc) == null ? void 0 : f.start.line) || 0, this._printNewline(!0, o);
          }
        }
      }
      i && this.dedent();
    }
    printAndIndentOnComments(t, r) {
      let n = t.leadingComments && t.leadingComments.length > 0;
      n && this.indent(), this.print(t, r), n && this.dedent();
    }
    printBlock(t) {
      let r = t.body;
      r.type !== "EmptyStatement" && this.space(), this.print(r, t);
    }
    _printTrailingComments(t, r, n) {
      let {
        innerComments: i,
        trailingComments: a
      } = t;
      i != null && i.length && this._printComments(2, i, t, r, n), a != null && a.length && this._printComments(2, a, t, r, n);
    }
    _printLeadingComments(t, r) {
      let n = t.leadingComments;
      n != null && n.length && this._printComments(0, n, t, r);
    }
    _maybePrintInnerComments() {
      this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments() {
      let t = this._currentNode, r = t.innerComments;
      if (!(r != null && r.length)) return;
      let n = this.endsWith(32), i = this._indentInnerComments, a = this._printedComments.size;
      i && this.indent(), this._printComments(1, r, t), n && a !== this._printedComments.size && this.space(), i && this.dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(t, r, n = {}) {
      var i;
      n.statement = !0, (i = n.indent) != null || (n.indent = !1), this.printJoin(t, r, n);
    }
    printList(t, r, n = {}) {
      n.separator == null && (n.separator = Sne), this.printJoin(t, r, n);
    }
    _printNewline(t, r) {
      let n = this.format;
      if (n.retainLines || n.compact) return;
      if (n.concise) {
        this.space();
        return;
      }
      if (!t)
        return;
      let i = r.nextNodeStartLine, a = this._lastCommentLine;
      if (i > 0 && a > 0) {
        let o = i - a;
        if (o >= 0) {
          this.newline(o || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(t) {
      return t.ignore || this._printedComments.has(t) ? 0 : this._noLineTerminator && Tne.test(t.value) ? 2 : (this._printedComments.add(t),
      this.format.shouldPrintComment(t.value) ? 1 : 0);
    }
    _printComment(t, r) {
      let n = this._noLineTerminator, i = t.type === "CommentBlock", a = i && r !== 1 && !this._noLineTerminator;
      a && this._buf.hasContent() && r !== 2 && this.newline(1);
      let o = this.getLastChar();
      o !== 91 && o !== 123 && this.space();
      let l;
      if (i) {
        let {
          _parenPushNewlineState: c
        } = this;
        if (c?.printed === !1 && cP.test(t.value) && (this.tokenChar(40), this.indent(), c.printed = !0), l = `/*${t.value}*/`, this.format.
        indent.adjustMultilineComment) {
          var u;
          let f = (u = t.loc) == null ? void 0 : u.start.column;
          if (f) {
            let p = new RegExp("\\n\\s{1," + f + "}", "g");
            l = l.replace(p, `
`);
          }
          if (this.format.concise)
            l = l.replace(/\n(?!$)/g, `
`);
          else {
            let p = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (p += this._getIndent()), l = l.replace(/\n(?!$)/g, `
${" ".repeat(p)}`);
          }
        }
      } else n ? l = `/*${t.value}*/` : l = `//${t.value}`;
      this.endsWith(47) && this._space(), this.source("start", t.loc), this._append(l, i), !i && !n && this.newline(1, !0), a && r !== 3 && this.
      newline(1);
    }
    _printComments(t, r, n, i, a = 0) {
      let o = n.loc, l = r.length, u = !!o, c = u ? o.start.line : 0, f = u ? o.end.line : 0, p = 0, h = 0, y = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let v = 0; v < l; v++) {
        let d = r[v], b = this._shouldPrintComment(d);
        if (b === 2) {
          u = !1;
          break;
        }
        if (u && d.loc && b === 1) {
          let E = d.loc.start.line, I = d.loc.end.line;
          if (t === 0) {
            let O = 0;
            v === 0 ? this._buf.hasContent() && (d.type === "CommentLine" || E !== I) && (O = h = 1) : O = E - p, p = I, y(O), this._printComment(
            d, 1), v + 1 === l && (y(Math.max(c - p, h)), p = c);
          } else if (t === 1) {
            let O = E - (v === 0 ? c : p);
            p = I, y(O), this._printComment(d, 1), v + 1 === l && (y(Math.min(1, f - p)), p = f);
          } else {
            let O = E - (v === 0 ? f - a : p);
            p = I, y(O), this._printComment(d, 1);
          }
        } else {
          if (u = !1, b !== 1)
            continue;
          if (l === 1) {
            let E = d.loc ? d.loc.start.line === d.loc.end.line : !cP.test(d.value), I = E && !mne(n) && !yne(i) && !gne(i) && !bne(i);
            t === 0 ? this._printComment(d, I && n.type !== "ObjectExpression" || E && hne(i, {
              body: n
            }) ? 1 : 0) : I && t === 2 ? this._printComment(d, 1) : this._printComment(d, 0);
          } else t === 1 && !(n.type === "ObjectExpression" && n.properties.length > 1) && n.type !== "ClassBody" && n.type !== "TSInterface\
Body" ? this._printComment(d, v === 0 ? 2 : v === l - 1 ? 3 : 0) : this._printComment(d, 0);
        }
      }
      t === 2 && u && p && (this._lastCommentLine = p);
    }
  };
  Object.assign(co.prototype, dne);
  co.prototype.Noop = /* @__PURE__ */ s(function() {
  }, "Noop");
  var rCe = _u.default = co;
  function Sne() {
    this.tokenChar(44), this.space();
  }
  s(Sne, "commaSeparator");
});

// ../node_modules/@babel/generator/lib/index.js
var fo = T((Ou) => {
  "use strict";
  Object.defineProperty(Ou, "__esModule", {
    value: !0
  });
  Ou.default = Pne;
  var pP = xS(), dP = fP();
  function hP(e, t) {
    let r = {
      auxiliaryCommentBefore: t.auxiliaryCommentBefore,
      auxiliaryCommentAfter: t.auxiliaryCommentAfter,
      shouldPrintComment: t.shouldPrintComment,
      retainLines: t.retainLines,
      retainFunctionParens: t.retainFunctionParens,
      comments: t.comments == null || t.comments,
      compact: t.compact,
      minified: t.minified,
      concise: t.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, t.jsescOption),
      topicToken: t.topicToken,
      importAttributesKeyword: t.importAttributesKeyword
    };
    {
      var n;
      r.decoratorsBeforeExport = t.decoratorsBeforeExport, r.jsescOption.json = t.jsonCompatibleStrings, r.recordAndTupleSyntaxType = (n = t.
      recordAndTupleSyntaxType) != null ? n : "hash";
    }
    r.minified ? (r.compact = !0, r.shouldPrintComment = r.shouldPrintComment || (() => r.comments)) : r.shouldPrintComment = r.shouldPrintComment ||
    ((l) => r.comments || l.includes("@license") || l.includes("@preserve")), r.compact === "auto" && (r.compact = typeof e == "string" && e.
    length > 5e5, r.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${t.filename} as it exceeds th\
e max of 500KB.`)), r.compact && (r.indent.adjustMultilineComment = !1);
    let {
      auxiliaryCommentBefore: i,
      auxiliaryCommentAfter: a,
      shouldPrintComment: o
    } = r;
    return i && !o(i) && (r.auxiliaryCommentBefore = void 0), a && !o(a) && (r.auxiliaryCommentAfter = void 0), r;
  }
  s(hP, "normalizeOptions");
  Ou.CodeGenerator = class {
    static {
      s(this, "CodeGenerator");
    }
    constructor(t, r = {}, n) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = t, this._format = hP(n, r), this._map = r.sourceMaps ? new pP.
      default(r, n) : null;
    }
    generate() {
      return new dP.default(this._format, this._map).generate(this._ast);
    }
  };
  function Pne(e, t = {}, r) {
    let n = hP(r, t), i = t.sourceMaps ? new pP.default(t, r) : null;
    return new dP.default(n, i).generate(e);
  }
  s(Pne, "generate");
});

// ../node_modules/@babel/traverse/lib/path/ancestry.js
var mP = T((Br) => {
  "use strict";
  Object.defineProperty(Br, "__esModule", {
    value: !0
  });
  Br.find = Dne;
  Br.findParent = wne;
  Br.getAncestry = Bne;
  Br.getDeepestCommonAncestorFrom = Nne;
  Br.getEarliestCommonAncestorFrom = One;
  Br.getFunctionParent = Ine;
  Br.getStatementParent = _ne;
  Br.inType = jne;
  Br.isAncestor = kne;
  Br.isDescendant = Fne;
  var Ane = Pe(), {
    VISITOR_KEYS: Cne
  } = Ane;
  function wne(e) {
    let t = this;
    for (; t = t.parentPath; )
      if (e(t)) return t;
    return null;
  }
  s(wne, "findParent");
  function Dne(e) {
    let t = this;
    do
      if (e(t)) return t;
    while (t = t.parentPath);
    return null;
  }
  s(Dne, "find");
  function Ine() {
    return this.findParent((e) => e.isFunction());
  }
  s(Ine, "getFunctionParent");
  function _ne() {
    let e = this;
    do {
      if (!e.parentPath || Array.isArray(e.container) && e.isStatement())
        break;
      e = e.parentPath;
    } while (e);
    if (e && (e.isProgram() || e.isFile()))
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    return e;
  }
  s(_ne, "getStatementParent");
  function One(e) {
    return this.getDeepestCommonAncestorFrom(e, function(t, r, n) {
      let i, a = Cne[t.type];
      for (let o of n) {
        let l = o[r + 1];
        if (!i) {
          i = l;
          continue;
        }
        if (l.listKey && i.listKey === l.listKey && l.key < i.key) {
          i = l;
          continue;
        }
        let u = a.indexOf(i.parentKey), c = a.indexOf(l.parentKey);
        u > c && (i = l);
      }
      return i;
    });
  }
  s(One, "getEarliestCommonAncestorFrom");
  function Nne(e, t) {
    if (!e.length)
      return this;
    if (e.length === 1)
      return e[0];
    let r = 1 / 0, n, i, a = e.map((l) => {
      let u = [];
      do
        u.unshift(l);
      while ((l = l.parentPath) && l !== this);
      return u.length < r && (r = u.length), u;
    }), o = a[0];
    e: for (let l = 0; l < r; l++) {
      let u = o[l];
      for (let c of a)
        if (c[l] !== u)
          break e;
      n = l, i = u;
    }
    if (i)
      return t ? t(i, n, a) : i;
    throw new Error("Couldn't find intersection");
  }
  s(Nne, "getDeepestCommonAncestorFrom");
  function Bne() {
    let e = this, t = [];
    do
      t.push(e);
    while (e = e.parentPath);
    return t;
  }
  s(Bne, "getAncestry");
  function kne(e) {
    return e.isDescendant(this);
  }
  s(kne, "isAncestor");
  function Fne(e) {
    return !!this.findParent((t) => t === e);
  }
  s(Fne, "isDescendant");
  function jne(...e) {
    let t = this;
    for (; t; ) {
      for (let r of e)
        if (t.node.type === r) return !0;
      t = t.parentPath;
    }
    return !1;
  }
  s(jne, "inType");
});

// ../node_modules/@babel/traverse/lib/path/inference/util.js
var Zm = T((Qm) => {
  "use strict";
  Object.defineProperty(Qm, "__esModule", {
    value: !0
  });
  Qm.createUnionType = Une;
  var Lne = Pe(), {
    createFlowUnionType: yP,
    createTSUnionType: gP,
    createUnionTypeAnnotation: Mne,
    isFlowType: Rne,
    isTSType: qne
  } = Lne;
  function Une(e) {
    {
      if (e.every((t) => Rne(t)))
        return yP ? yP(e) : Mne(e);
      if (e.every((t) => qne(t)) && gP)
        return gP(e);
    }
  }
  s(Une, "createUnionType");
});

// ../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var xP = T((ey) => {
  "use strict";
  Object.defineProperty(ey, "__esModule", {
    value: !0
  });
  ey.default = Gne;
  var Vne = Pe(), EP = Zm(), {
    BOOLEAN_NUMBER_BINARY_OPERATORS: $ne,
    createTypeAnnotationBasedOnTypeof: Wne,
    numberTypeAnnotation: vP,
    voidTypeAnnotation: Kne
  } = Vne;
  function Gne(e) {
    if (!this.isReferenced()) return;
    let t = this.scope.getBinding(e.name);
    if (t)
      return t.identifier.typeAnnotation ? t.identifier.typeAnnotation : Hne(t, this, e.name);
    if (e.name === "undefined")
      return Kne();
    if (e.name === "NaN" || e.name === "Infinity")
      return vP();
    e.name;
  }
  s(Gne, "_default");
  function Hne(e, t, r) {
    let n = [], i = [], a = bP(e, t, i), o = TP(e, t, r);
    if (o) {
      let l = bP(e, o.ifStatement);
      a = a.filter((u) => !l.includes(u)), n.push(o.typeAnnotation);
    }
    if (a.length) {
      a.push(...i);
      for (let l of a)
        n.push(l.getTypeAnnotation());
    }
    if (n.length)
      return (0, EP.createUnionType)(n);
  }
  s(Hne, "getTypeAnnotationBindingConstantViolations");
  function bP(e, t, r) {
    let n = e.constantViolations.slice();
    return n.unshift(e.path), n.filter((i) => {
      i = i.resolve();
      let a = i._guessExecutionStatusRelativeTo(t);
      return r && a === "unknown" && r.push(i), a === "before";
    });
  }
  s(bP, "getConstantViolationsBefore");
  function Yne(e, t) {
    let r = t.node.operator, n = t.get("right").resolve(), i = t.get("left").resolve(), a;
    if (i.isIdentifier({
      name: e
    }) ? a = n : n.isIdentifier({
      name: e
    }) && (a = i), a)
      return r === "===" ? a.getTypeAnnotation() : $ne.includes(r) ? vP() : void 0;
    if (r !== "===" && r !== "==") return;
    let o, l;
    if (i.isUnaryExpression({
      operator: "typeof"
    }) ? (o = i, l = n) : n.isUnaryExpression({
      operator: "typeof"
    }) && (o = n, l = i), !o || !o.get("argument").isIdentifier({
      name: e
    }) || (l = l.resolve(), !l.isLiteral())) return;
    let u = l.node.value;
    if (typeof u == "string")
      return Wne(u);
  }
  s(Yne, "inferAnnotationFromBinaryExpression");
  function zne(e, t, r) {
    let n;
    for (; n = t.parentPath; ) {
      if (n.isIfStatement() || n.isConditionalExpression())
        return t.key === "test" ? void 0 : n;
      if (n.isFunction() && n.parentPath.scope.getBinding(r) !== e)
        return;
      t = n;
    }
  }
  s(zne, "getParentConditionalPath");
  function TP(e, t, r) {
    let n = zne(e, t, r);
    if (!n) return;
    let a = [n.get("test")], o = [];
    for (let l = 0; l < a.length; l++) {
      let u = a[l];
      if (u.isLogicalExpression())
        u.node.operator === "&&" && (a.push(u.get("left")), a.push(u.get("right")));
      else if (u.isBinaryExpression()) {
        let c = Yne(r, u);
        c && o.push(c);
      }
    }
    return o.length ? {
      typeAnnotation: (0, EP.createUnionType)(o),
      ifStatement: n
    } : TP(e, n, r);
  }
  s(TP, "getConditionalAnnotation");
});

// ../node_modules/@babel/traverse/lib/path/inference/inferers.js
var _P = T((nt) => {
  "use strict";
  Object.defineProperty(nt, "__esModule", {
    value: !0
  });
  nt.ArrayExpression = wP;
  nt.AssignmentExpression = bse;
  nt.BinaryExpression = dse;
  nt.BooleanLiteral = xse;
  nt.CallExpression = Ose;
  nt.ConditionalExpression = mse;
  nt.ClassDeclaration = nt.ClassExpression = nt.FunctionDeclaration = nt.ArrowFunctionExpression = nt.FunctionExpression = Cse;
  Object.defineProperty(nt, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Xne.default;
    }, "get")
  });
  nt.LogicalExpression = hse;
  nt.NewExpression = cse;
  nt.NullLiteral = Sse;
  nt.NumericLiteral = Tse;
  nt.ObjectExpression = Ase;
  nt.ParenthesizedExpression = gse;
  nt.RegExpLiteral = Pse;
  nt.RestElement = DP;
  nt.SequenceExpression = yse;
  nt.StringLiteral = vse;
  nt.TSAsExpression = CP;
  nt.TSNonNullExpression = use;
  nt.TaggedTemplateExpression = Nse;
  nt.TemplateLiteral = fse;
  nt.TypeCastExpression = AP;
  nt.UnaryExpression = pse;
  nt.UpdateExpression = Ese;
  nt.VariableDeclarator = lse;
  var Jne = Pe(), Xne = xP(), PP = Zm(), {
    BOOLEAN_BINARY_OPERATORS: Qne,
    BOOLEAN_UNARY_OPERATORS: Zne,
    NUMBER_BINARY_OPERATORS: ese,
    NUMBER_UNARY_OPERATORS: tse,
    STRING_UNARY_OPERATORS: rse,
    anyTypeAnnotation: SP,
    arrayTypeAnnotation: ty,
    booleanTypeAnnotation: ry,
    buildMatchMemberExpression: Nu,
    genericTypeAnnotation: us,
    identifier: Hs,
    nullLiteralTypeAnnotation: nse,
    numberTypeAnnotation: Mi,
    stringTypeAnnotation: Ys,
    tupleTypeAnnotation: sse,
    unionTypeAnnotation: ise,
    voidTypeAnnotation: ase,
    isIdentifier: ose
  } = Jne;
  function lse() {
    if (this.get("id").isIdentifier())
      return this.get("init").getTypeAnnotation();
  }
  s(lse, "VariableDeclarator");
  function AP(e) {
    return e.typeAnnotation;
  }
  s(AP, "TypeCastExpression");
  AP.validParent = !0;
  function CP(e) {
    return e.typeAnnotation;
  }
  s(CP, "TSAsExpression");
  CP.validParent = !0;
  function use() {
    return this.get("expression").getTypeAnnotation();
  }
  s(use, "TSNonNullExpression");
  function cse(e) {
    if (e.callee.type === "Identifier")
      return us(e.callee);
  }
  s(cse, "NewExpression");
  function fse() {
    return Ys();
  }
  s(fse, "TemplateLiteral");
  function pse(e) {
    let t = e.operator;
    if (t === "void")
      return ase();
    if (tse.includes(t))
      return Mi();
    if (rse.includes(t))
      return Ys();
    if (Zne.includes(t))
      return ry();
  }
  s(pse, "UnaryExpression");
  function dse(e) {
    let t = e.operator;
    if (ese.includes(t))
      return Mi();
    if (Qne.includes(t))
      return ry();
    if (t === "+") {
      let r = this.get("right"), n = this.get("left");
      return n.isBaseType("number") && r.isBaseType("number") ? Mi() : n.isBaseType("string") || r.isBaseType("string") ? Ys() : ise([Ys(), Mi()]);
    }
  }
  s(dse, "BinaryExpression");
  function hse() {
    let e = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, PP.createUnionType)(e);
  }
  s(hse, "LogicalExpression");
  function mse() {
    let e = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, PP.createUnionType)(e);
  }
  s(mse, "ConditionalExpression");
  function yse() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  s(yse, "SequenceExpression");
  function gse() {
    return this.get("expression").getTypeAnnotation();
  }
  s(gse, "ParenthesizedExpression");
  function bse() {
    return this.get("right").getTypeAnnotation();
  }
  s(bse, "AssignmentExpression");
  function Ese(e) {
    let t = e.operator;
    if (t === "++" || t === "--")
      return Mi();
  }
  s(Ese, "UpdateExpression");
  function vse() {
    return Ys();
  }
  s(vse, "StringLiteral");
  function Tse() {
    return Mi();
  }
  s(Tse, "NumericLiteral");
  function xse() {
    return ry();
  }
  s(xse, "BooleanLiteral");
  function Sse() {
    return nse();
  }
  s(Sse, "NullLiteral");
  function Pse() {
    return us(Hs("RegExp"));
  }
  s(Pse, "RegExpLiteral");
  function Ase() {
    return us(Hs("Object"));
  }
  s(Ase, "ObjectExpression");
  function wP() {
    return us(Hs("Array"));
  }
  s(wP, "ArrayExpression");
  function DP() {
    return wP();
  }
  s(DP, "RestElement");
  DP.validParent = !0;
  function Cse() {
    return us(Hs("Function"));
  }
  s(Cse, "Func");
  var wse = Nu("Array.from"), Dse = Nu("Object.keys"), Ise = Nu("Object.values"), _se = Nu("Object.entries");
  function Ose() {
    let {
      callee: e
    } = this.node;
    return Dse(e) ? ty(Ys()) : wse(e) || Ise(e) || ose(e, {
      name: "Array"
    }) ? ty(SP()) : _se(e) ? ty(sse([Ys(), SP()])) : IP(this.get("callee"));
  }
  s(Ose, "CallExpression");
  function Nse() {
    return IP(this.get("tag"));
  }
  s(Nse, "TaggedTemplateExpression");
  function IP(e) {
    if (e = e.resolve(), e.isFunction()) {
      let {
        node: t
      } = e;
      if (t.async)
        return t.generator ? us(Hs("AsyncIterator")) : us(Hs("Promise"));
      if (t.generator)
        return us(Hs("Iterator"));
      if (e.node.returnType)
        return e.node.returnType;
    }
  }
  s(IP, "resolveCall");
});

// ../node_modules/@babel/traverse/lib/path/inference/index.js
var FP = T((cs) => {
  "use strict";
  Object.defineProperty(cs, "__esModule", {
    value: !0
  });
  cs._getTypeAnnotation = kP;
  cs.baseTypeStrictlyMatches = eie;
  cs.couldBeBaseType = Zse;
  cs.getTypeAnnotation = Xse;
  cs.isBaseType = Qse;
  cs.isGenericType = tie;
  var OP = _P(), Bse = Pe(), {
    anyTypeAnnotation: BP,
    isAnyTypeAnnotation: Bu,
    isArrayTypeAnnotation: kse,
    isBooleanTypeAnnotation: Fse,
    isEmptyTypeAnnotation: jse,
    isFlowBaseAnnotation: Lse,
    isGenericTypeAnnotation: Mse,
    isIdentifier: NP,
    isMixedTypeAnnotation: Rse,
    isNumberTypeAnnotation: qse,
    isStringTypeAnnotation: Use,
    isTSArrayType: Vse,
    isTSTypeAnnotation: $se,
    isTSTypeReference: Wse,
    isTupleTypeAnnotation: Kse,
    isTypeAnnotation: Gse,
    isUnionTypeAnnotation: Hse,
    isVoidTypeAnnotation: Yse,
    stringTypeAnnotation: zse,
    voidTypeAnnotation: Jse
  } = Bse;
  function Xse() {
    let e = this.getData("typeAnnotation");
    return e != null || (e = kP.call(this) || BP(), (Gse(e) || $se(e)) && (e = e.typeAnnotation), this.setData("typeAnnotation", e)), e;
  }
  s(Xse, "getTypeAnnotation");
  var ny = /* @__PURE__ */ new WeakSet();
  function kP() {
    let e = this.node;
    if (!e)
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        let r = this.parentPath.parentPath, n = r.parentPath;
        return r.key === "left" && n.isForInStatement() ? zse() : r.key === "left" && n.isForOfStatement() ? BP() : Jse();
      } else
        return;
    if (e.typeAnnotation)
      return e.typeAnnotation;
    if (!ny.has(e)) {
      ny.add(e);
      try {
        var t;
        let r = OP[e.type];
        if (r)
          return r.call(this, e);
        if (r = OP[this.parentPath.type], (t = r) != null && t.validParent)
          return this.parentPath.getTypeAnnotation();
      } finally {
        ny.delete(e);
      }
    }
  }
  s(kP, "_getTypeAnnotation");
  function Qse(e, t) {
    return sy(e, this.getTypeAnnotation(), t);
  }
  s(Qse, "isBaseType");
  function sy(e, t, r) {
    if (e === "string")
      return Use(t);
    if (e === "number")
      return qse(t);
    if (e === "boolean")
      return Fse(t);
    if (e === "any")
      return Bu(t);
    if (e === "mixed")
      return Rse(t);
    if (e === "empty")
      return jse(t);
    if (e === "void")
      return Yse(t);
    if (r)
      return !1;
    throw new Error(`Unknown base type ${e}`);
  }
  s(sy, "_isBaseType");
  function Zse(e) {
    let t = this.getTypeAnnotation();
    if (Bu(t)) return !0;
    if (Hse(t)) {
      for (let r of t.types)
        if (Bu(r) || sy(e, r, !0))
          return !0;
      return !1;
    } else
      return sy(e, t, !0);
  }
  s(Zse, "couldBeBaseType");
  function eie(e) {
    let t = this.getTypeAnnotation(), r = e.getTypeAnnotation();
    return !Bu(t) && Lse(t) ? r.type === t.type : !1;
  }
  s(eie, "baseTypeStrictlyMatches");
  function tie(e) {
    let t = this.getTypeAnnotation();
    return e === "Array" && (Vse(t) || kse(t) || Kse(t)) ? !0 : Mse(t) && NP(t.id, {
      name: e
    }) || Wse(t) && NP(t.typeName, {
      name: e
    });
  }
  s(tie, "isGenericType");
});

// ../node_modules/@babel/traverse/lib/path/lib/hoister.js
var LP = T((ku) => {
  "use strict";
  Object.defineProperty(ku, "__esModule", {
    value: !0
  });
  ku.default = void 0;
  var jP = Pe(), rie = jP, {
    react: nie
  } = jP, {
    cloneNode: sie,
    jsxExpressionContainer: iie,
    variableDeclaration: aie,
    variableDeclarator: oie
  } = rie, lie = {
    ReferencedIdentifier(e, t) {
      if (e.isJSXIdentifier() && nie.isCompatTag(e.node.name) && !e.parentPath.isJSXMemberExpression())
        return;
      if (e.node.name === "this") {
        let n = e.scope;
        do
          if (n.path.isFunction() && !n.path.isArrowFunctionExpression())
            break;
        while (n = n.parent);
        n && t.breakOnScopePaths.push(n.path);
      }
      let r = e.scope.getBinding(e.node.name);
      if (r) {
        for (let n of r.constantViolations)
          if (n.scope !== r.path.scope) {
            t.mutableBinding = !0, e.stop();
            return;
          }
        r === t.scope.getBinding(e.node.name) && (t.bindings[e.node.name] = r);
      }
    }
  }, iy = class {
    static {
      s(this, "PathHoister");
    }
    constructor(t, r) {
      this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.
      path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [],
      this.scope = r, this.path = t, this.attachAfter = !1;
    }
    isCompatibleScope(t) {
      for (let r of Object.keys(this.bindings)) {
        let n = this.bindings[r];
        if (!t.bindingIdentifierEquals(r, n.identifier))
          return !1;
      }
      return !0;
    }
    getCompatibleScopes() {
      let t = this.path.scope;
      do {
        if (this.isCompatibleScope(t))
          this.scopes.push(t);
        else
          break;
        if (this.breakOnScopePaths.includes(t.path))
          break;
      } while (t = t.parent);
    }
    getAttachmentPath() {
      let t = this._getAttachmentPath();
      if (!t) return;
      let r = t.scope;
      if (r.path === t && (r = t.scope.parent), r.path.isProgram() || r.path.isFunction())
        for (let n of Object.keys(this.bindings)) {
          if (!r.hasOwnBinding(n)) continue;
          let i = this.bindings[n];
          if (i.kind === "param" || i.path.parentKey === "params")
            continue;
          if (this.getAttachmentParentForPath(i.path).key >= t.key) {
            this.attachAfter = !0, t = i.path;
            for (let o of i.constantViolations)
              this.getAttachmentParentForPath(o).key > t.key && (t = o);
          }
        }
      return t;
    }
    _getAttachmentPath() {
      let r = this.scopes.pop();
      if (r) {
        if (r.path.isFunction())
          if (this.hasOwnParamBindings(r)) {
            if (this.scope === r) return;
            let n = r.path.get("body").get("body");
            for (let i = 0; i < n.length; i++)
              if (!n[i].node._blockHoist)
                return n[i];
          } else
            return this.getNextScopeAttachmentParent();
        else if (r.path.isProgram())
          return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      let t = this.scopes.pop();
      if (t) return this.getAttachmentParentForPath(t.path);
    }
    getAttachmentParentForPath(t) {
      do
        if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
          return t;
      while (t = t.parentPath);
    }
    hasOwnParamBindings(t) {
      for (let r of Object.keys(this.bindings)) {
        if (!t.hasOwnBinding(r)) continue;
        let n = this.bindings[r];
        if (n.kind === "param" && n.constant) return !0;
      }
      return !1;
    }
    run() {
      if (this.path.traverse(lie, this), this.mutableBinding) return;
      this.getCompatibleScopes();
      let t = this.getAttachmentPath();
      if (!t || t.getFunctionParent() === this.path.getFunctionParent()) return;
      let r = t.scope.generateUidIdentifier("ref"), n = oie(r, this.path.node), i = this.attachAfter ? "insertAfter" : "insertBefore", [a] = t[i](
      [t.isVariableDeclarator() ? n : aie("var", [n])]), o = this.path.parentPath;
      return o.isJSXElement() && this.path.container === o.node.children && (r = iie(r)), this.path.replaceWith(sie(r)), t.isVariableDeclarator() ?
      a.get("init") : a.get("declarations.0.init");
    }
  };
  ku.default = iy;
});

// ../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var MP = T((Fu) => {
  "use strict";
  Object.defineProperty(Fu, "__esModule", {
    value: !0
  });
  Fu.hooks = void 0;
  var vCe = Fu.hooks = [function(e, t) {
    if (e.key === "test" && (t.isWhile() || t.isSwitchCase()) || e.key === "declaration" && t.isExportDeclaration() || e.key === "body" && t.
    isLabeledStatement() || e.listKey === "declarations" && t.isVariableDeclaration() && t.node.declarations.length === 1 || e.key === "expr\
ession" && t.isExpressionStatement())
      return t.remove(), !0;
  }, function(e, t) {
    if (t.isSequenceExpression() && t.node.expressions.length === 1)
      return t.replaceWith(t.node.expressions[0]), !0;
  }, function(e, t) {
    if (t.isBinary())
      return e.key === "left" ? t.replaceWith(t.node.right) : t.replaceWith(t.node.left), !0;
  }, function(e, t) {
    if (t.isIfStatement() && e.key === "consequent" || e.key === "body" && (t.isLoop() || t.isArrowFunctionExpression()))
      return e.replaceWith({
        type: "BlockStatement",
        body: []
      }), !0;
  }];
});

// ../node_modules/@babel/traverse/lib/path/removal.js
var ju = T((fs) => {
  "use strict";
  Object.defineProperty(fs, "__esModule", {
    value: !0
  });
  fs._assertUnremoved = $P;
  fs._callRemovalHooks = UP;
  fs._markRemoved = ay;
  fs._remove = VP;
  fs._removeFromScope = qP;
  fs.remove = hie;
  var uie = MP(), cie = $s(), fie = oy(), RP = ps(), pie = Pe(), {
    getBindingIdentifiers: die
  } = pie;
  function hie() {
    var e;
    if ($P.call(this), this.resync(), UP.call(this)) {
      ay.call(this);
      return;
    }
    (e = this.opts) != null && e.noScope || qP.call(this), this.shareCommentsWithSiblings(), VP.call(this), ay.call(this);
  }
  s(hie, "remove");
  function qP() {
    let e = die(this.node, !1, !1, !0);
    Object.keys(e).forEach((t) => this.scope.removeBinding(t));
  }
  s(qP, "_removeFromScope");
  function UP() {
    if (this.parentPath) {
      for (let e of uie.hooks)
        if (e(this, this.parentPath)) return !0;
    }
  }
  s(UP, "_callRemovalHooks");
  function VP() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : fie._replaceWith.call(this,
    null);
  }
  s(VP, "_remove");
  function ay() {
    this._traverseFlags |= RP.SHOULD_SKIP | RP.REMOVED, this.parent && (0, cie.getCachedPaths)(this.hub, this.parent).delete(this.node), this.
    node = null;
  }
  s(ay, "_markRemoved");
  function $P() {
    if (this.removed)
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
  s($P, "_assertUnremoved");
});

// ../node_modules/@babel/traverse/lib/path/modification.js
var dy = T((kr) => {
  "use strict";
  Object.defineProperty(kr, "__esModule", {
    value: !0
  });
  kr._containerInsert = fy;
  kr._containerInsertAfter = GP;
  kr._containerInsertBefore = py;
  kr._verifyNodeList = po;
  kr.hoist = jie;
  kr.insertAfter = Nie;
  kr.insertBefore = _ie;
  kr.pushContainer = Fie;
  kr.unshiftContainer = kie;
  kr.updateSiblingKeys = Bie;
  var mie = $s(), yie = LP(), cy = ps(), gie = ji(), Lu = ju(), bie = Pe(), {
    arrowFunctionExpression: Eie,
    assertExpression: vie,
    assignmentExpression: Tie,
    blockStatement: WP,
    callExpression: xie,
    cloneNode: ly,
    expressionStatement: uy,
    isAssignmentExpression: Sie,
    isCallExpression: Pie,
    isExportNamedDeclaration: KP,
    isExpression: Aie,
    isIdentifier: Cie,
    isSequenceExpression: wie,
    isSuper: Die,
    thisExpression: Iie
  } = bie;
  function _ie(e) {
    Lu._assertUnremoved.call(this);
    let t = po.call(this, e), {
      parentPath: r,
      parent: n
    } = this;
    if (r.isExpressionStatement() || r.isLabeledStatement() || KP(n) || r.isExportDefaultDeclaration() && this.isDeclaration())
      return r.insertBefore(t);
    if (this.isNodeType("Expression") && !this.isJSXElement() || r.isForStatement() && this.key === "init")
      return this.node && t.push(this.node), this.replaceExpressionWithStatements(t);
    if (Array.isArray(this.container))
      return py.call(this, t);
    if (this.isStatementOrBlock()) {
      let i = this.node, a = i && (!this.isExpressionStatement() || i.expression != null);
      return this.replaceWith(WP(a ? [i] : [])), this.unshiftContainer("body", t);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
  s(_ie, "insertBefore");
  function fy(e, t) {
    this.updateSiblingKeys(e, t.length);
    let r = [];
    this.container.splice(e, 0, ...t);
    for (let a = 0; a < t.length; a++) {
      var n;
      let o = e + a, l = this.getSibling(o);
      r.push(l), (n = this.context) != null && n.queue && l.pushContext(this.context);
    }
    let i = gie._getQueueContexts.call(this);
    for (let a of r) {
      a.setScope(), a.debug("Inserted.");
      for (let o of i)
        o.maybeQueue(a, !0);
    }
    return r;
  }
  s(fy, "_containerInsert");
  function py(e) {
    return fy.call(this, this.key, e);
  }
  s(py, "_containerInsertBefore");
  function GP(e) {
    return fy.call(this, this.key + 1, e);
  }
  s(GP, "_containerInsertAfter");
  var HP = /* @__PURE__ */ s((e) => e[e.length - 1], "last");
  function YP(e) {
    return wie(e.parent) && (HP(e.parent.expressions) !== e.node || YP(e.parentPath));
  }
  s(YP, "isHiddenInSequenceExpression");
  function Oie(e, t) {
    if (!Sie(e) || !Cie(e.left))
      return !1;
    let r = t.getBlockParent();
    return r.hasOwnBinding(e.left.name) && r.getOwnBinding(e.left.name).constantViolations.length <= 1;
  }
  s(Oie, "isAlmostConstantAssignment");
  function Nie(e) {
    if (Lu._assertUnremoved.call(this), this.isSequenceExpression())
      return HP(this.get("expressions")).insertAfter(e);
    let t = po.call(this, e), {
      parentPath: r,
      parent: n
    } = this;
    if (r.isExpressionStatement() || r.isLabeledStatement() || KP(n) || r.isExportDefaultDeclaration() && this.isDeclaration())
      return r.insertAfter(t.map((i) => Aie(i) ? uy(i) : i));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !r.isJSXElement() || r.isForStatement() && this.key === "init") {
      let i = this;
      if (i.node) {
        let a = i.node, {
          scope: o
        } = this;
        if (o.path.isPattern())
          return vie(a), i.replaceWith(xie(Eie([], a), [])), i.get("callee.body").insertAfter(t), [i];
        if (YP(i))
          t.unshift(a);
        else if (Pie(a) && Die(a.callee))
          t.unshift(a), t.push(Iie());
        else if (Oie(a, o))
          t.unshift(a), t.push(ly(a.left));
        else if (o.isPure(a, !0))
          t.push(a);
        else {
          r.isMethod({
            computed: !0,
            key: a
          }) && (o = o.parent);
          let l = o.generateDeclaredUidIdentifier();
          t.unshift(uy(Tie("=", ly(l), a))), t.push(uy(ly(l)));
        }
      }
      return this.replaceExpressionWithStatements(t);
    } else {
      if (Array.isArray(this.container))
        return GP.call(this, t);
      if (this.isStatementOrBlock()) {
        let i = this.node, a = i && (!this.isExpressionStatement() || i.expression != null);
        return this.replaceWith(WP(a ? [i] : [])), this.pushContainer("body", t);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  s(Nie, "insertAfter");
  function Bie(e, t) {
    if (!this.parent) return;
    let r = (0, mie.getCachedPaths)(this.hub, this.parent) || [];
    for (let [, n] of r)
      typeof n.key == "number" && n.key >= e && (n.key += t);
  }
  s(Bie, "updateSiblingKeys");
  function po(e) {
    if (!e)
      return [];
    Array.isArray(e) || (e = [e]);
    for (let t = 0; t < e.length; t++) {
      let r = e[t], n;
      if (r ? typeof r != "object" ? n = "contains a non-object node" : r.type ? r instanceof cy.default && (n = "has a NodePath when it exp\
ected a raw object") : n = "without a type" : n = "has falsy node", n) {
        let i = Array.isArray(r) ? "array" : typeof r;
        throw new Error(`Node list ${n} with the index of ${t} and type of ${i}`);
      }
    }
    return e;
  }
  s(po, "_verifyNodeList");
  function kie(e, t) {
    Lu._assertUnremoved.call(this), t = po.call(this, t);
    let r = cy.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[e],
      listKey: e,
      key: 0
    }).setContext(this.context);
    return py.call(r, t);
  }
  s(kie, "unshiftContainer");
  function Fie(e, t) {
    Lu._assertUnremoved.call(this);
    let r = po.call(this, t), n = this.node[e];
    return cy.default.get({
      parentPath: this,
      parent: this.node,
      container: n,
      listKey: e,
      key: n.length
    }).setContext(this.context).replaceWithMultiple(r);
  }
  s(Fie, "pushContainer");
  function jie(e = this.scope) {
    return new yie.default(this, e).run();
  }
  s(jie, "hoist");
});

// ../node_modules/@babel/traverse/lib/path/replacement.js
var oy = T((ds) => {
  "use strict";
  Object.defineProperty(ds, "__esModule", {
    value: !0
  });
  ds._replaceWith = rA;
  ds.replaceExpressionWithStatements = cae;
  ds.replaceInline = fae;
  ds.replaceWith = uae;
  ds.replaceWithMultiple = oae;
  ds.replaceWithSourceString = lae;
  var Lie = to(), my = _r(), Mie = ps(), ZP = $s(), yy = dy(), Rie = Ls(), qie = Pe(), {
    FUNCTION_TYPES: zP,
    arrowFunctionExpression: Uie,
    assignmentExpression: eA,
    awaitExpression: Vie,
    blockStatement: $ie,
    buildUndefinedNode: hy,
    callExpression: Wie,
    cloneNode: gy,
    conditionalExpression: Kie,
    expressionStatement: Gie,
    getBindingIdentifiers: Hie,
    identifier: Yie,
    inheritLeadingComments: zie,
    inheritTrailingComments: Jie,
    inheritsComments: Xie,
    isBlockStatement: Qie,
    isEmptyStatement: JP,
    isExpression: tA,
    isExpressionStatement: Zie,
    isIfStatement: eae,
    isProgram: tae,
    isStatement: rae,
    isVariableDeclaration: nae,
    removeComments: sae,
    returnStatement: XP,
    sequenceExpression: iae,
    validate: QP,
    yieldExpression: aae
  } = qie;
  function oae(e) {
    var t;
    this.resync(), e = yy._verifyNodeList.call(this, e), zie(e[0], this.node), Jie(e[e.length - 1], this.node), (t = (0, ZP.getCachedPaths)(
    this.hub, this.parent)) == null || t.delete(this.node), this.node = this.container[this.key] = null;
    let r = this.insertAfter(e);
    return this.node ? this.requeue() : this.remove(), r;
  }
  s(oae, "replaceWithMultiple");
  function lae(e) {
    this.resync();
    let t;
    try {
      e = `(${e})`, t = (0, Rie.parse)(e);
    } catch (n) {
      let i = n.loc;
      throw i && (n.message += ` - make sure this is an expression.
` + (0, Lie.codeFrameColumns)(e, {
        start: {
          line: i.line,
          column: i.column + 1
        }
      }), n.code = "BABEL_REPLACE_SOURCE_ERROR"), n;
    }
    let r = t.program.body[0].expression;
    return my.default.removeProperties(r), this.replaceWith(r);
  }
  s(lae, "replaceWithSourceString");
  function uae(e) {
    if (this.resync(), this.removed)
      throw new Error("You can't replace this node, we've already removed it");
    let t = e instanceof Mie.default ? e.node : e;
    if (!t)
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === t)
      return [this];
    if (this.isProgram() && !tae(t))
      throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(t))
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if (typeof t == "string")
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let r = "";
    if (this.isNodeType("Statement") && tA(t) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(
    t) && !this.parentPath.isExportDefaultDeclaration() && (t = Gie(t), r = "expression"), this.isNodeType("Expression") && rae(t) && !this.
    canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(t))
      return this.replaceExpressionWithStatements([t]);
    let n = this.node;
    return n && (Xie(t, n), sae(n)), rA.call(this, t), this.type = t.type, this.setScope(), this.requeue(), [r ? this.get(r) : this];
  }
  s(uae, "replaceWith");
  function rA(e) {
    var t;
    if (!this.container)
      throw new ReferenceError("Container is falsy");
    this.inList ? QP(this.parent, this.key, [e]) : QP(this.parent, this.key, e), this.debug(`Replace with ${e?.type}`), (t = (0, ZP.getCachedPaths)(
    this.hub, this.parent)) == null || t.set(e, this).delete(this.node), this.node = this.container[this.key] = e;
  }
  s(rA, "_replaceWith");
  function cae(e) {
    this.resync();
    let t = [], r = Mu(e, t);
    if (r) {
      for (let h of t) this.scope.push({
        id: h
      });
      return this.replaceWith(r)[0].get("expressions");
    }
    let n = this.getFunctionParent(), i = n?.is("async"), a = n?.is("generator"), o = Uie([], $ie(e));
    this.replaceWith(Wie(o, []));
    let l = this.get("callee");
    l.get("body").scope.hoistVariables((h) => this.scope.push({
      id: h
    }));
    let u = l.getCompletionRecords();
    for (let h of u) {
      if (!h.isExpressionStatement()) continue;
      let y = h.findParent((v) => v.isLoop());
      if (y) {
        let v = y.getData("expressionReplacementReturnUid");
        v ? v = Yie(v.name) : (v = l.scope.generateDeclaredUidIdentifier("ret"), l.get("body").pushContainer("body", XP(gy(v))), y.setData("\
expressionReplacementReturnUid", v)), h.get("expression").replaceWith(eA("=", gy(v), h.node.expression));
      } else
        h.replaceWith(XP(h.node.expression));
    }
    l.arrowFunctionToExpression();
    let c = l, f = i && my.default.hasType(this.get("callee.body").node, "AwaitExpression", zP), p = a && my.default.hasType(this.get("calle\
e.body").node, "YieldExpression", zP);
    return f && (c.set("async", !0), p || this.replaceWith(Vie(this.node))), p && (c.set("generator", !0), this.replaceWith(aae(this.node, !0))),
    c.get("body.body");
  }
  s(cae, "replaceExpressionWithStatements");
  function Mu(e, t) {
    let r = [], n = !0;
    for (let i of e)
      if (JP(i) || (n = !1), tA(i))
        r.push(i);
      else if (Zie(i))
        r.push(i.expression);
      else if (nae(i)) {
        if (i.kind !== "var") return;
        for (let a of i.declarations) {
          let o = Hie(a);
          for (let l of Object.keys(o))
            t.push(gy(o[l]));
          a.init && r.push(eA("=", a.id, a.init));
        }
        n = !0;
      } else if (eae(i)) {
        let a = i.consequent ? Mu([i.consequent], t) : hy(), o = i.alternate ? Mu([i.alternate], t) : hy();
        if (!a || !o) return;
        r.push(Kie(i.test, a, o));
      } else if (Qie(i)) {
        let a = Mu(i.body, t);
        if (!a) return;
        r.push(a);
      } else if (JP(i))
        e.indexOf(i) === 0 && (n = !0);
      else
        return;
    return n && r.push(hy()), r.length === 1 ? r[0] : iae(r);
  }
  s(Mu, "gatherSequenceExpressions");
  function fae(e) {
    if (this.resync(), Array.isArray(e))
      if (Array.isArray(this.container)) {
        e = yy._verifyNodeList.call(this, e);
        let t = yy._containerInsertAfter.call(this, e);
        return this.remove(), t;
      } else
        return this.replaceWithMultiple(e);
    else
      return this.replaceWith(e);
  }
  s(fae, "replaceInline");
});

// ../node_modules/@babel/traverse/lib/path/evaluation.js
var aA = T((Ru) => {
  "use strict";
  Object.defineProperty(Ru, "__esModule", {
    value: !0
  });
  Ru.evaluate = Eae;
  Ru.evaluateTruthy = gae;
  var pae = ["Number", "String", "Math"], dae = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeUR\
I", "encodeURIComponent", null, null], hae = ["random"];
  function nA(e) {
    return pae.includes(e);
  }
  s(nA, "isValidObjectCallee");
  function mae(e) {
    return dae.includes(e);
  }
  s(mae, "isValidIdentifierCallee");
  function yae(e) {
    return hae.includes(e);
  }
  s(yae, "isInvalidMethod");
  function gae() {
    let e = this.evaluate();
    if (e.confident) return !!e.value;
  }
  s(gae, "evaluateTruthy");
  function Nn(e, t) {
    t.confident && (t.deoptPath = e, t.confident = !1);
  }
  s(Nn, "deopt");
  var sA = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
  function ur(e, t) {
    let {
      node: r
    } = e, {
      seen: n
    } = t;
    if (n.has(r)) {
      let i = n.get(r);
      if (i.resolved)
        return i.value;
      Nn(e, t);
      return;
    } else {
      let i = {
        resolved: !1
      };
      n.set(r, i);
      let a = bae(e, t);
      return t.confident && (i.resolved = !0, i.value = a), a;
    }
  }
  s(ur, "evaluateCached");
  function bae(e, t) {
    if (t.confident) {
      if (e.isSequenceExpression()) {
        let r = e.get("expressions");
        return ur(r[r.length - 1], t);
      }
      if (e.isStringLiteral() || e.isNumericLiteral() || e.isBooleanLiteral())
        return e.node.value;
      if (e.isNullLiteral())
        return null;
      if (e.isTemplateLiteral())
        return iA(e, e.node.quasis, t);
      if (e.isTaggedTemplateExpression() && e.get("tag").isMemberExpression()) {
        let r = e.get("tag.object"), {
          node: {
            name: n
          }
        } = r, i = e.get("tag.property");
        if (r.isIdentifier() && n === "String" && !e.scope.getBinding(n) && i.isIdentifier() && i.node.name === "raw")
          return iA(e, e.node.quasi.quasis, t, !0);
      }
      if (e.isConditionalExpression()) {
        let r = ur(e.get("test"), t);
        return t.confident ? ur(r ? e.get("consequent") : e.get("alternate"), t) : void 0;
      }
      if (e.isExpressionWrapper())
        return ur(e.get("expression"), t);
      if (e.isMemberExpression() && !e.parentPath.isCallExpression({
        callee: e.node
      })) {
        let r = e.get("property"), n = e.get("object");
        if (n.isLiteral()) {
          let i = n.node.value, a = typeof i, o = null;
          if (e.node.computed) {
            if (o = ur(r, t), !t.confident) return;
          } else r.isIdentifier() && (o = r.node.name);
          if ((a === "number" || a === "string") && o != null && (typeof o == "number" || typeof o == "string"))
            return i[o];
        }
      }
      if (e.isReferencedIdentifier()) {
        let r = e.scope.getBinding(e.node.name);
        if (r) {
          if (r.constantViolations.length > 0 || e.node.start < r.path.node.end) {
            Nn(r.path, t);
            return;
          }
          if (r.hasValue)
            return r.value;
        }
        let n = e.node.name;
        if (sA.has(n)) {
          if (!r)
            return sA.get(n);
          Nn(r.path, t);
          return;
        }
        let i = e.resolve();
        if (i === e) {
          Nn(e, t);
          return;
        } else
          return ur(i, t);
      }
      if (e.isUnaryExpression({
        prefix: !0
      })) {
        if (e.node.operator === "void")
          return;
        let r = e.get("argument");
        if (e.node.operator === "typeof" && (r.isFunction() || r.isClass()))
          return "function";
        let n = ur(r, t);
        if (!t.confident) return;
        switch (e.node.operator) {
          case "!":
            return !n;
          case "+":
            return +n;
          case "-":
            return -n;
          case "~":
            return ~n;
          case "typeof":
            return typeof n;
        }
      }
      if (e.isArrayExpression()) {
        let r = [], n = e.get("elements");
        for (let i of n) {
          let a = i.evaluate();
          if (a.confident)
            r.push(a.value);
          else {
            Nn(a.deopt, t);
            return;
          }
        }
        return r;
      }
      if (e.isObjectExpression()) {
        let r = {}, n = e.get("properties");
        for (let i of n) {
          if (i.isObjectMethod() || i.isSpreadElement()) {
            Nn(i, t);
            return;
          }
          let a = i.get("key"), o;
          if (i.node.computed) {
            if (o = a.evaluate(), !o.confident) {
              Nn(o.deopt, t);
              return;
            }
            o = o.value;
          } else a.isIdentifier() ? o = a.node.name : o = a.node.value;
          let u = i.get("value").evaluate();
          if (!u.confident) {
            Nn(u.deopt, t);
            return;
          }
          u = u.value, r[o] = u;
        }
        return r;
      }
      if (e.isLogicalExpression()) {
        let r = t.confident, n = ur(e.get("left"), t), i = t.confident;
        t.confident = r;
        let a = ur(e.get("right"), t), o = t.confident;
        switch (e.node.operator) {
          case "||":
            return t.confident = i && (!!n || o), t.confident ? n || a : void 0;
          case "&&":
            return t.confident = i && (!n || o), t.confident ? n && a : void 0;
          case "??":
            return t.confident = i && (n != null || o), t.confident ? n ?? a : void 0;
        }
      }
      if (e.isBinaryExpression()) {
        let r = ur(e.get("left"), t);
        if (!t.confident) return;
        let n = ur(e.get("right"), t);
        if (!t.confident) return;
        switch (e.node.operator) {
          case "-":
            return r - n;
          case "+":
            return r + n;
          case "/":
            return r / n;
          case "*":
            return r * n;
          case "%":
            return r % n;
          case "**":
            return Math.pow(r, n);
          case "<":
            return r < n;
          case ">":
            return r > n;
          case "<=":
            return r <= n;
          case ">=":
            return r >= n;
          case "==":
            return r == n;
          case "!=":
            return r != n;
          case "===":
            return r === n;
          case "!==":
            return r !== n;
          case "|":
            return r | n;
          case "&":
            return r & n;
          case "^":
            return r ^ n;
          case "<<":
            return r << n;
          case ">>":
            return r >> n;
          case ">>>":
            return r >>> n;
        }
      }
      if (e.isCallExpression()) {
        let r = e.get("callee"), n, i;
        if (r.isIdentifier() && !e.scope.getBinding(r.node.name) && (nA(r.node.name) || mae(r.node.name)) && (i = global[r.node.name]), r.isMemberExpression()) {
          let a = r.get("object"), o = r.get("property");
          if (a.isIdentifier() && o.isIdentifier() && nA(a.node.name) && !yae(o.node.name)) {
            n = global[a.node.name];
            let l = o.node.name;
            hasOwnProperty.call(n, l) && (i = n[l]);
          }
          if (a.isLiteral() && o.isIdentifier()) {
            let l = typeof a.node.value;
            (l === "string" || l === "number") && (n = a.node.value, i = n[o.node.name]);
          }
        }
        if (i) {
          let a = e.get("arguments").map((o) => ur(o, t));
          return t.confident ? i.apply(n, a) : void 0;
        }
      }
      Nn(e, t);
    }
  }
  s(bae, "_evaluate");
  function iA(e, t, r, n = !1) {
    let i = "", a = 0, o = e.isTemplateLiteral() ? e.get("expressions") : e.get("quasi.expressions");
    for (let l of t) {
      if (!r.confident) break;
      i += n ? l.value.raw : l.value.cooked;
      let u = o[a++];
      u && (i += String(ur(u, r)));
    }
    if (r.confident)
      return i;
  }
  s(iA, "evaluateQuasis");
  function Eae() {
    let e = {
      confident: !0,
      deoptPath: null,
      seen: /* @__PURE__ */ new Map()
    }, t = ur(this, e);
    return e.confident || (t = void 0), {
      confident: e.confident,
      deopt: e.deoptPath,
      value: t
    };
  }
  s(Eae, "evaluate");
});

// ../node_modules/@babel/traverse/lib/path/conversion.js
var hA = T((Bn) => {
  "use strict";
  Object.defineProperty(Bn, "__esModule", {
    value: !0
  });
  Bn.arrowFunctionToExpression = Yae;
  Bn.ensureBlock = Kae;
  Bn.ensureFunctionName = aoe;
  Bn.splitExportDeclaration = soe;
  Bn.toComputedKey = Wae;
  Bn.unwrapFunctionEnvironment = Gae;
  var vae = Pe(), Tae = Ni(), vy = io(), {
    arrowFunctionExpression: Ty,
    assignmentExpression: zs,
    binaryExpression: by,
    blockStatement: xae,
    callExpression: Ri,
    conditionalExpression: Sae,
    expressionStatement: uA,
    identifier: ot,
    isIdentifier: Pae,
    jsxIdentifier: Aae,
    logicalExpression: Cae,
    LOGICAL_OPERATORS: wae,
    memberExpression: Hr,
    metaProperty: Dae,
    numericLiteral: Iae,
    objectExpression: _ae,
    restElement: Oae,
    returnStatement: Nae,
    sequenceExpression: Bae,
    spreadElement: kae,
    stringLiteral: cA,
    super: Ey,
    thisExpression: ho,
    toExpression: fA,
    unaryExpression: Fae,
    toBindingIdentifierName: jae,
    isFunction: Lae,
    isAssignmentPattern: Mae,
    isRestElement: Rae,
    getFunctionName: qae,
    cloneNode: Js,
    variableDeclaration: Uae,
    variableDeclarator: Vae,
    exportNamedDeclaration: oA,
    exportSpecifier: lA,
    inherits: $ae
  } = vae;
  function Wae() {
    let e;
    if (this.isMemberExpression())
      e = this.node.property;
    else if (this.isProperty() || this.isMethod())
      e = this.node.key;
    else
      throw new ReferenceError("todo");
    return this.node.computed || Pae(e) && (e = cA(e.name)), e;
  }
  s(Wae, "toComputedKey");
  function Kae() {
    let e = this.get("body"), t = e.node;
    if (Array.isArray(e))
      throw new Error("Can't convert array path to a block statement");
    if (!t)
      throw new Error("Can't convert node without a body");
    if (e.isBlockStatement())
      return t;
    let r = [], n = "body", i, a;
    e.isStatement() ? (a = "body", i = 0, r.push(e.node)) : (n += ".body.0", this.isFunction() ? (i = "argument", r.push(Nae(e.node))) : (i =
    "expression", r.push(uA(e.node)))), this.node.body = xae(r);
    let o = this.get(n);
    return e.setup(o, a ? o.node[a] : o.node, a, i), this.node;
  }
  s(Kae, "ensureBlock");
  Bn.arrowFunctionToShadowed = function() {
    this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
  };
  function Gae() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    pA(this);
  }
  s(Gae, "unwrapFunctionEnvironment");
  function Hae(e, t) {
    e.node.type = t;
  }
  s(Hae, "setType");
  function Yae({
    allowInsertArrow: e = !0,
    allowInsertArrowWithRest: t = e,
    noNewArrows: r = !((n) => (n = arguments[0]) == null ? void 0 : n.specCompliant)()
  } = {}) {
    if (!this.isArrowFunctionExpression())
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    let n = this;
    if (!r) {
      var i;
      n = (i = n.ensureFunctionName(!1)) != null ? i : n;
    }
    let {
      thisBinding: a,
      fnPath: o
    } = pA(n, r, e, t);
    if (o.ensureBlock(), Hae(o, "FunctionExpression"), !r) {
      let l = a ? null : o.scope.generateUidIdentifier("arrowCheckId");
      return l && o.parentPath.scope.push({
        id: l,
        init: _ae([])
      }), o.get("body").unshiftContainer("body", uA(Ri(this.hub.addHelper("newArrowCheck"), [ho(), ot(l ? l.name : a)]))), o.replaceWith(Ri(
      Hr(o.node, ot("bind")), [l ? ot(l.name) : ho()])), o.get("callee.object");
    }
    return o;
  }
  s(Yae, "arrowFunctionToExpression");
  var zae = (0, vy.environmentVisitor)({
    CallExpression(e, {
      allSuperCalls: t
    }) {
      e.get("callee").isSuper() && t.push(e);
    }
  });
  function pA(e, t = !0, r = !0, n = !0) {
    let i, a = e.findParent((y) => {
      if (y.isArrowFunctionExpression()) {
        var v;
        return (v = i) != null || (i = y), !1;
      }
      return y.isFunction() || y.isProgram() || y.isClassProperty({
        static: !1
      }) || y.isClassPrivateProperty({
        static: !1
      });
    }), o = a.isClassMethod({
      kind: "constructor"
    });
    if (a.isClassProperty() || a.isClassPrivateProperty())
      if (i)
        a = i;
      else if (r)
        e.replaceWith(Ri(Ty([], fA(e.node)), [])), a = e.get("callee"), e = a.get("body");
      else
        throw e.buildCodeFrameError("Unable to transform arrow inside class property");
    let {
      thisPaths: l,
      argumentsPaths: u,
      newTargetPaths: c,
      superProps: f,
      superCalls: p
    } = noe(e);
    if (o && p.length > 0) {
      if (!r)
        throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an a\
rrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      if (!n)
        throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow \
function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration\
.");
      let y = [];
      a.traverse(zae, {
        allSuperCalls: y
      });
      let v = eoe(a);
      y.forEach((d) => {
        let b = ot(v);
        b.loc = d.node.callee.loc, d.get("callee").replaceWith(b);
      });
    }
    if (u.length > 0) {
      let y = mo(a, "arguments", () => {
        let v = /* @__PURE__ */ s(() => ot("arguments"), "args");
        return a.scope.path.isProgram() ? Sae(by("===", Fae("typeof", v()), cA("undefined")), a.scope.buildUndefinedNode(), v()) : v();
      });
      u.forEach((v) => {
        let d = ot(y);
        d.loc = v.node.loc, v.replaceWith(d);
      });
    }
    if (c.length > 0) {
      let y = mo(a, "newtarget", () => Dae(ot("new"), ot("target")));
      c.forEach((v) => {
        let d = ot(y);
        d.loc = v.node.loc, v.replaceWith(d);
      });
    }
    if (f.length > 0) {
      if (!r)
        throw f[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in a\
n arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      f.reduce((v, d) => v.concat(Xae(d)), []).forEach((v) => {
        let d = v.node.computed ? "" : v.get("property").node.name, b = v.parentPath, E = b.isAssignmentExpression({
          left: v.node
        }), I = b.isCallExpression({
          callee: v.node
        }), O = b.isTaggedTemplateExpression({
          tag: v.node
        }), k = toe(a, E, d), j = [];
        if (v.node.computed && j.push(v.get("property").node), E) {
          let U = b.node.right;
          j.push(U);
        }
        let R = Ri(ot(k), j);
        I ? (b.unshiftContainer("arguments", ho()), v.replaceWith(Hr(R, ot("call"))), l.push(b.get("arguments.0"))) : E ? b.replaceWith(R) :
        O ? (v.replaceWith(Ri(Hr(R, ot("bind"), !1), [ho()])), l.push(v.get("arguments.0"))) : v.replaceWith(R);
      });
    }
    let h;
    return (l.length > 0 || !t) && (h = Zae(a, o), (t || o && dA(a)) && (l.forEach((y) => {
      let v = y.isJSX() ? Aae(h) : ot(h);
      v.loc = y.node.loc, y.replaceWith(v);
    }), t || (h = null))), {
      thisBinding: h,
      fnPath: e
    };
  }
  s(pA, "hoistFunctionEnvironment");
  function Jae(e) {
    return wae.includes(e);
  }
  s(Jae, "isLogicalOp");
  function Xae(e) {
    if (e.parentPath.isAssignmentExpression() && e.parentPath.node.operator !== "=") {
      let r = e.parentPath, n = r.node.operator.slice(0, -1), i = r.node.right, a = Jae(n);
      if (e.node.computed) {
        let o = e.scope.generateDeclaredUidIdentifier("tmp"), l = e.node.object, u = e.node.property;
        r.get("left").replaceWith(Hr(l, zs("=", o, u), !0)), r.get("right").replaceWith(t(a ? "=" : n, Hr(l, ot(o.name), !0), i));
      } else {
        let o = e.node.object, l = e.node.property;
        r.get("left").replaceWith(Hr(o, l)), r.get("right").replaceWith(t(a ? "=" : n, Hr(o, ot(l.name)), i));
      }
      return a ? r.replaceWith(Cae(n, r.node.left, r.node.right)) : r.node.operator = "=", [r.get("left"), r.get("right").get("left")];
    } else if (e.parentPath.isUpdateExpression()) {
      let r = e.parentPath, n = e.scope.generateDeclaredUidIdentifier("tmp"), i = e.node.computed ? e.scope.generateDeclaredUidIdentifier("p\
rop") : null, a = [zs("=", n, Hr(e.node.object, i ? zs("=", i, e.node.property) : e.node.property, e.node.computed)), zs("=", Hr(e.node.object,
      i ? ot(i.name) : e.node.property, e.node.computed), by(e.parentPath.node.operator[0], ot(n.name), Iae(1)))];
      e.parentPath.node.prefix || a.push(ot(n.name)), r.replaceWith(Bae(a));
      let o = r.get("expressions.0.right"), l = r.get("expressions.1.left");
      return [o, l];
    }
    return [e];
    function t(r, n, i) {
      return r === "=" ? zs("=", n, i) : by(r, n, i);
    }
  }
  s(Xae, "standardizeSuperProperty");
  function dA(e) {
    return e.isClassMethod() && !!e.parentPath.parentPath.node.superClass;
  }
  s(dA, "hasSuperClass");
  var Qae = (0, vy.environmentVisitor)({
    CallExpression(e, {
      supers: t,
      thisBinding: r
    }) {
      e.get("callee").isSuper() && (t.has(e.node) || (t.add(e.node), e.replaceWithMultiple([e.node, zs("=", ot(r), ot("this"))])));
    }
  });
  function Zae(e, t) {
    return mo(e, "this", (r) => {
      if (!t || !dA(e)) return ho();
      e.traverse(Qae, {
        supers: /* @__PURE__ */ new WeakSet(),
        thisBinding: r
      });
    });
  }
  s(Zae, "getThisBinding");
  function eoe(e) {
    return mo(e, "supercall", () => {
      let t = e.scope.generateUidIdentifier("args");
      return Ty([Oae(t)], Ri(Ey(), [kae(ot(t.name))]));
    });
  }
  s(eoe, "getSuperBinding");
  function toe(e, t, r) {
    return mo(e, `superprop_${t ? "set" : "get"}:${r || ""}`, () => {
      let i = [], a;
      if (r)
        a = Hr(Ey(), ot(r));
      else {
        let o = e.scope.generateUidIdentifier("prop");
        i.unshift(o), a = Hr(Ey(), ot(o.name), !0);
      }
      if (t) {
        let o = e.scope.generateUidIdentifier("value");
        i.push(o), a = zs("=", a, ot(o.name));
      }
      return Ty(i, a);
    });
  }
  s(toe, "getSuperPropBinding");
  function mo(e, t, r) {
    let n = "binding:" + t, i = e.getData(n);
    if (!i) {
      let a = e.scope.generateUidIdentifier(t);
      i = a.name, e.setData(n, i), e.scope.push({
        id: a,
        init: r(i)
      });
    }
    return i;
  }
  s(mo, "getBinding");
  var roe = (0, vy.environmentVisitor)({
    ThisExpression(e, {
      thisPaths: t
    }) {
      t.push(e);
    },
    JSXIdentifier(e, {
      thisPaths: t
    }) {
      e.node.name === "this" && (!e.parentPath.isJSXMemberExpression({
        object: e.node
      }) && !e.parentPath.isJSXOpeningElement({
        name: e.node
      }) || t.push(e));
    },
    CallExpression(e, {
      superCalls: t
    }) {
      e.get("callee").isSuper() && t.push(e);
    },
    MemberExpression(e, {
      superProps: t
    }) {
      e.get("object").isSuper() && t.push(e);
    },
    Identifier(e, {
      argumentsPaths: t
    }) {
      if (!e.isReferencedIdentifier({
        name: "arguments"
      })) return;
      let r = e.scope;
      do {
        if (r.hasOwnBinding("arguments")) {
          r.rename("arguments");
          return;
        }
        if (r.path.isFunction() && !r.path.isArrowFunctionExpression())
          break;
      } while (r = r.parent);
      t.push(e);
    },
    MetaProperty(e, {
      newTargetPaths: t
    }) {
      e.get("meta").isIdentifier({
        name: "new"
      }) && e.get("property").isIdentifier({
        name: "target"
      }) && t.push(e);
    }
  });
  function noe(e) {
    let t = [], r = [], n = [], i = [], a = [];
    return e.traverse(roe, {
      thisPaths: t,
      argumentsPaths: r,
      newTargetPaths: n,
      superProps: i,
      superCalls: a
    }), {
      thisPaths: t,
      argumentsPaths: r,
      newTargetPaths: n,
      superProps: i,
      superCalls: a
    };
  }
  s(noe, "getScopeInformation");
  function soe() {
    if (!this.isExportDeclaration() || this.isExportAllDeclaration())
      throw new Error("Only default and named export declarations can be split.");
    if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    let e = this.get("declaration");
    if (this.isExportDefaultDeclaration()) {
      let i = e.isFunctionDeclaration() || e.isClassDeclaration(), a = e.isFunctionExpression() || e.isClassExpression(), o = e.isScope() ? e.
      scope.parent : e.scope, l = e.node.id, u = !1;
      l ? a && o.hasBinding(l.name) && (u = !0, l = o.generateUidIdentifier(l.name)) : (u = !0, l = o.generateUidIdentifier("default"), (i ||
      a) && (e.node.id = Js(l)));
      let c = i ? e.node : Uae("var", [Vae(Js(l), e.node)]), f = oA(null, [lA(Js(l), ot("default"))]);
      return this.insertAfter(f), this.replaceWith(c), u && o.registerDeclaration(this), this;
    } else if (this.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    let t = e.getOuterBindingIdentifiers(), r = Object.keys(t).map((i) => lA(ot(i), ot(i))), n = oA(null, r);
    return this.insertAfter(n), this.replaceWith(e.node), this;
  }
  s(soe, "splitExportDeclaration");
  var ioe = {
    "ReferencedIdentifier|BindingIdentifier"(e, t) {
      e.node.name === t.name && (t.needsRename = !0, e.stop());
    },
    Scope(e, t) {
      e.scope.hasOwnBinding(t.name) && e.skip();
    }
  };
  function aoe(e) {
    if (this.node.id) return this;
    let t = qae(this.node, this.parent);
    if (t == null) return this;
    let {
      name: r
    } = t;
    if (!e && /[\uD800-\uDFFF]/.test(r) || r.startsWith("get ") || r.startsWith("set "))
      return null;
    r = jae(r.replace(/[/ ]/g, "_"));
    let n = ot(r);
    $ae(n, t.originalNode);
    let i = {
      needsRename: !1,
      name: r
    }, {
      scope: a
    } = this, o = a.getOwnBinding(r);
    if (o ? o.kind === "param" && (i.needsRename = !0) : (a.parent.hasBinding(r) || a.hasGlobal(r)) && this.traverse(ioe, i), !i.needsRename)
      return this.node.id = n, a.getProgramParent().references[n.name] = !0, this;
    if (a.hasBinding(n.name) && !a.hasGlobal(n.name))
      return a.rename(n.name), this.node.id = n, a.getProgramParent().references[n.name] = !0, this;
    if (!Lae(this.node)) return null;
    let l = a.generateUidIdentifier(n.name), u = [];
    for (let f = 0, p = ooe(this.node); f < p; f++)
      u.push(a.generateUidIdentifier("x"));
    let c = Tae.default.expression.ast`
    (function (${l}) {
      function ${n}(${u}) {
        return ${Js(l)}.apply(this, arguments);
      }

      ${Js(n)}.toString = function () {
        return ${Js(l)}.toString();
      }

      return ${Js(n)};
    })(${fA(this.node)})
  `;
    return this.replaceWith(c)[0].get("arguments.0");
  }
  s(aoe, "ensureFunctionName");
  function ooe(e) {
    let t = e.params.findIndex((r) => Mae(r) || Rae(r));
    return t === -1 ? e.params.length : t;
  }
  s(ooe, "getFunctionArity");
});

// ../node_modules/@babel/traverse/lib/path/introspection.js
var TA = T((xt) => {
  "use strict";
  Object.defineProperty(xt, "__esModule", {
    value: !0
  });
  xt._guessExecutionStatusRelativeTo = _oe;
  xt._resolve = vA;
  xt.canHaveVariableDeclarationOrExpression = xoe;
  xt.canSwapBetweenExpressionAndStatement = Soe;
  xt.equals = voe;
  xt.getSource = woe;
  xt.has = EA;
  xt.is = void 0;
  xt.isCompletionRecord = Poe;
  xt.isConstantExpression = koe;
  xt.isInStrictMode = Foe;
  xt.isNodeType = Toe;
  xt.isStatementOrBlock = Aoe;
  xt.isStatic = boe;
  xt.isnt = Eoe;
  xt.matchesPattern = goe;
  xt.referencesImport = Coe;
  xt.resolve = Boe;
  xt.willIMaybeExecuteBefore = Doe;
  var loe = Pe(), {
    STATEMENT_OR_BLOCK_KEYS: uoe,
    VISITOR_KEYS: coe,
    isBlockStatement: bA,
    isExpression: foe,
    isIdentifier: poe,
    isLiteral: doe,
    isStringLiteral: hoe,
    isType: moe,
    matchesPattern: yoe
  } = loe;
  function goe(e, t) {
    return yoe(this.node, e, t);
  }
  s(goe, "matchesPattern");
  function EA(e) {
    var t;
    let r = (t = this.node) == null ? void 0 : t[e];
    return r && Array.isArray(r) ? !!r.length : !!r;
  }
  s(EA, "has");
  function boe() {
    return this.scope.isStatic(this.node);
  }
  s(boe, "isStatic");
  var NCe = xt.is = EA;
  function Eoe(e) {
    return !this.has(e);
  }
  s(Eoe, "isnt");
  function voe(e, t) {
    return this.node[e] === t;
  }
  s(voe, "equals");
  function Toe(e) {
    return moe(this.type, e);
  }
  s(Toe, "isNodeType");
  function xoe() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }
  s(xoe, "canHaveVariableDeclarationOrExpression");
  function Soe(e) {
    return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? bA(e) : this.isBlockStatement() ?
    foe(e) : !1;
  }
  s(Soe, "canSwapBetweenExpressionAndStatement");
  function Poe(e) {
    let t = this, r = !0;
    do {
      let {
        type: n,
        container: i
      } = t;
      if (!r && (t.isFunction() || n === "StaticBlock"))
        return !!e;
      if (r = !1, Array.isArray(i) && t.key !== i.length - 1)
        return !1;
    } while ((t = t.parentPath) && !t.isProgram() && !t.isDoExpression());
    return !0;
  }
  s(Poe, "isCompletionRecord");
  function Aoe() {
    return this.parentPath.isLabeledStatement() || bA(this.container) ? !1 : uoe.includes(this.key);
  }
  s(Aoe, "isStatementOrBlock");
  function Coe(e, t) {
    if (!this.isReferencedIdentifier()) {
      if (this.isJSXMemberExpression() && this.node.property.name === t || (this.isMemberExpression() || this.isOptionalMemberExpression()) &&
      (this.node.computed ? hoe(this.node.property, {
        value: t
      }) : this.node.property.name === t)) {
        let a = this.get("object");
        return a.isReferencedIdentifier() && a.referencesImport(e, "*");
      }
      return !1;
    }
    let r = this.scope.getBinding(this.node.name);
    if (!r || r.kind !== "module") return !1;
    let n = r.path, i = n.parentPath;
    if (!i.isImportDeclaration()) return !1;
    if (i.node.source.value === e) {
      if (!t) return !0;
    } else
      return !1;
    return !!(n.isImportDefaultSpecifier() && t === "default" || n.isImportNamespaceSpecifier() && t === "*" || n.isImportSpecifier() && poe(
    n.node.imported, {
      name: t
    }));
  }
  s(Coe, "referencesImport");
  function woe() {
    let e = this.node;
    if (e.end) {
      let t = this.hub.getCode();
      if (t) return t.slice(e.start, e.end);
    }
    return "";
  }
  s(woe, "getSource");
  function Doe(e) {
    return this._guessExecutionStatusRelativeTo(e) !== "after";
  }
  s(Doe, "willIMaybeExecuteBefore");
  function mA(e) {
    return e.isProgram() ? e : (e.parentPath.scope.getFunctionParent() || e.parentPath.scope.getProgramParent()).path;
  }
  s(mA, "getOuterFunction");
  function Ioe(e, t) {
    switch (e) {
      case "LogicalExpression":
        return t === "right";
      case "ConditionalExpression":
      case "IfStatement":
        return t === "consequent" || t === "alternate";
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return t === "body";
      case "ForStatement":
        return t === "body" || t === "update";
      case "SwitchStatement":
        return t === "cases";
      case "TryStatement":
        return t === "handler";
      case "AssignmentPattern":
        return t === "right";
      case "OptionalMemberExpression":
        return t === "property";
      case "OptionalCallExpression":
        return t === "arguments";
      default:
        return !1;
    }
  }
  s(Ioe, "isExecutionUncertain");
  function yA(e, t) {
    for (let r = 0; r < t; r++) {
      let n = e[r];
      if (Ioe(n.parent.type, n.parentKey))
        return !0;
    }
    return !1;
  }
  s(yA, "isExecutionUncertainInList");
  var gA = Symbol();
  function _oe(e) {
    return xy(this, e, /* @__PURE__ */ new Map());
  }
  s(_oe, "_guessExecutionStatusRelativeTo");
  function xy(e, t, r) {
    let n = {
      this: mA(e),
      target: mA(t)
    };
    if (n.target.node !== n.this.node)
      return Noe(e, n.target, r);
    let i = {
      target: t.getAncestry(),
      this: e.getAncestry()
    };
    if (i.target.includes(e)) return "after";
    if (i.this.includes(t)) return "before";
    let a, o = {
      target: 0,
      this: 0
    };
    for (; !a && o.this < i.this.length; ) {
      let f = i.this[o.this];
      o.target = i.target.indexOf(f), o.target >= 0 ? a = f : o.this++;
    }
    if (!a)
      throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
    if (yA(i.this, o.this - 1) || yA(i.target, o.target - 1))
      return "unknown";
    let l = {
      this: i.this[o.this - 1],
      target: i.target[o.target - 1]
    };
    if (l.target.listKey && l.this.listKey && l.target.container === l.this.container)
      return l.target.key > l.this.key ? "before" : "after";
    let u = coe[a.type], c = {
      this: u.indexOf(l.this.parentKey),
      target: u.indexOf(l.target.parentKey)
    };
    return c.target > c.this ? "before" : "after";
  }
  s(xy, "_guessExecutionStatusRelativeToCached");
  function Ooe(e, t, r) {
    if (t.isFunctionDeclaration()) {
      if (t.parentPath.isExportDeclaration())
        return "unknown";
    } else return xy(e, t, r) === "before" ? "before" : "unknown";
    let n = t.scope.getBinding(t.node.id.name);
    if (!n.references) return "before";
    let i = n.referencePaths, a;
    for (let o of i) {
      if (!!o.find((c) => c.node === t.node)) continue;
      if (o.key !== "callee" || !o.parentPath.isCallExpression())
        return "unknown";
      let u = xy(e, o, r);
      if (a && a !== u)
        return "unknown";
      a = u;
    }
    return a;
  }
  s(Ooe, "_guessExecutionStatusRelativeToDifferentFunctionsInternal");
  function Noe(e, t, r) {
    let n = r.get(e.node), i;
    if (!n)
      r.set(e.node, n = /* @__PURE__ */ new Map());
    else if (i = n.get(t.node))
      return i === gA ? "unknown" : i;
    n.set(t.node, gA);
    let a = Ooe(e, t, r);
    return n.set(t.node, a), a;
  }
  s(Noe, "_guessExecutionStatusRelativeToDifferentFunctionsCached");
  function Boe(e, t) {
    return vA.call(this, e, t) || this;
  }
  s(Boe, "resolve");
  function vA(e, t) {
    var r;
    if (!((r = t) != null && r.includes(this)))
      if (t = t || [], t.push(this), this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier())
          return this.get("init").resolve(e, t);
      } else if (this.isReferencedIdentifier()) {
        let n = this.scope.getBinding(this.node.name);
        if (!n || !n.constant || n.kind === "module") return;
        if (n.path !== this) {
          let i = n.path.resolve(e, t);
          return this.find((a) => a.node === i.node) ? void 0 : i;
        }
      } else {
        if (this.isTypeCastExpression())
          return this.get("expression").resolve(e, t);
        if (e && this.isMemberExpression()) {
          let n = this.toComputedKey();
          if (!doe(n)) return;
          let i = n.value, a = this.get("object").resolve(e, t);
          if (a.isObjectExpression()) {
            let o = a.get("properties");
            for (let l of o) {
              if (!l.isProperty()) continue;
              let u = l.get("key"), c = l.isnt("computed") && u.isIdentifier({
                name: i
              });
              if (c = c || u.isLiteral({
                value: i
              }), c) return l.get("value").resolve(e, t);
            }
          } else if (a.isArrayExpression() && !isNaN(+i)) {
            let l = a.get("elements")[i];
            if (l) return l.resolve(e, t);
          }
        }
      }
  }
  s(vA, "_resolve");
  function koe() {
    if (this.isIdentifier()) {
      let e = this.scope.getBinding(this.node.name);
      return e ? e.constant : !1;
    }
    if (this.isLiteral())
      return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every((e) => e.isConstantExpression()) : !0;
    if (this.isUnaryExpression())
      return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
    if (this.isBinaryExpression()) {
      let {
        operator: e
      } = this.node;
      return e !== "in" && e !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }
    return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({
      name: "Symbol"
    }) && !this.scope.hasBinding("Symbol", {
      noGlobals: !0
    }) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding(
    "Symbol", {
      noGlobals: !0
    }) && this.get("arguments")[0].isStringLiteral() : !1;
  }
  s(koe, "isConstantExpression");
  function Foe() {
    return !!(this.isProgram() ? this : this.parentPath).find((r) => {
      if (r.isProgram({
        sourceType: "module"
      }) || r.isClass()) return !0;
      if (r.isArrowFunctionExpression() && !r.get("body").isBlockStatement())
        return !1;
      let n;
      if (r.isFunction())
        n = r.node.body;
      else if (r.isProgram())
        n = r.node;
      else
        return !1;
      for (let i of n.directives)
        if (i.value.value === "use strict")
          return !0;
    });
  }
  s(Foe, "isInStrictMode");
});

// ../node_modules/@babel/traverse/lib/path/family.js
var CA = T(($t) => {
  "use strict";
  Object.defineProperty($t, "__esModule", {
    value: !0
  });
  $t._getKey = PA;
  $t._getPattern = AA;
  $t.get = Qoe;
  $t.getAllNextSiblings = Joe;
  $t.getAllPrevSiblings = Xoe;
  $t.getAssignmentIdentifiers = Zoe;
  $t.getBindingIdentifierPaths = rle;
  $t.getBindingIdentifiers = ele;
  $t.getCompletionRecords = Goe;
  $t.getNextSibling = zoe;
  $t.getOpposite = $oe;
  $t.getOuterBindingIdentifierPaths = nle;
  $t.getOuterBindingIdentifiers = tle;
  $t.getPrevSibling = Yoe;
  $t.getSibling = Hoe;
  var Py = ps(), joe = Pe(), {
    getAssignmentIdentifiers: Loe,
    getBindingIdentifiers: SA,
    getOuterBindingIdentifiers: Moe,
    numericLiteral: Roe,
    unaryExpression: qoe
  } = joe, Ay = 0, yo = 1;
  function Uoe(e) {
    return {
      type: Ay,
      path: e
    };
  }
  s(Uoe, "NormalCompletion");
  function Voe(e) {
    return {
      type: yo,
      path: e
    };
  }
  s(Voe, "BreakCompletion");
  function $oe() {
    return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
  }
  s($oe, "getOpposite");
  function qi(e, t, r) {
    return e && t.push(...Ui(e, r)), t;
  }
  s(qi, "addCompletionRecords");
  function Woe(e, t, r) {
    let n = [];
    for (let i = 0; i < e.length; i++) {
      let a = e[i], o = Ui(a, r), l = [], u = [];
      for (let c of o)
        c.type === Ay && l.push(c), c.type === yo && u.push(c);
      l.length && (n = l), t.push(...u);
    }
    return t.push(...n), t;
  }
  s(Woe, "completionRecordForSwitch");
  function Koe(e) {
    e.forEach((t) => {
      t.type = yo;
    });
  }
  s(Koe, "normalCompletionToBreak");
  function Sy(e, t) {
    e.forEach((r) => {
      r.path.isBreakStatement({
        label: null
      }) && (t ? r.path.replaceWith(qoe("void", Roe(0))) : r.path.remove());
    });
  }
  s(Sy, "replaceBreakStatementInBreakCompletion");
  function xA(e, t) {
    let r = [];
    if (t.canHaveBreak) {
      let n = [];
      for (let i = 0; i < e.length; i++) {
        let a = e[i], o = Object.assign({}, t, {
          inCaseClause: !1
        });
        a.isBlockStatement() && (t.inCaseClause || t.shouldPopulateBreak) ? o.shouldPopulateBreak = !0 : o.shouldPopulateBreak = !1;
        let l = Ui(a, o);
        if (l.length > 0 && l.every((u) => u.type === yo)) {
          n.length > 0 && l.every((u) => u.path.isBreakStatement({
            label: null
          })) ? (Koe(n), r.push(...n), n.some((u) => u.path.isDeclaration()) && (r.push(...l), Sy(l, !0)), Sy(l, !1)) : (r.push(...l), t.shouldPopulateBreak ||
          Sy(l, !0));
          break;
        }
        if (i === e.length - 1)
          r.push(...l);
        else {
          n = [];
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c.type === yo && r.push(c), c.type === Ay && n.push(c);
          }
        }
      }
    } else if (e.length)
      for (let n = e.length - 1; n >= 0; n--) {
        let i = Ui(e[n], t);
        if (i.length > 1 || i.length === 1 && !i[0].path.isVariableDeclaration()) {
          r.push(...i);
          break;
        }
      }
    return r;
  }
  s(xA, "getStatementListCompletion");
  function Ui(e, t) {
    let r = [];
    if (e.isIfStatement())
      r = qi(e.get("consequent"), r, t), r = qi(e.get("alternate"), r, t);
    else {
      if (e.isDoExpression() || e.isFor() || e.isWhile() || e.isLabeledStatement())
        return qi(e.get("body"), r, t);
      if (e.isProgram() || e.isBlockStatement())
        return xA(e.get("body"), t);
      if (e.isFunction())
        return Ui(e.get("body"), t);
      if (e.isTryStatement())
        r = qi(e.get("block"), r, t), r = qi(e.get("handler"), r, t);
      else {
        if (e.isCatchClause())
          return qi(e.get("body"), r, t);
        if (e.isSwitchStatement())
          return Woe(e.get("cases"), r, t);
        if (e.isSwitchCase())
          return xA(e.get("consequent"), {
            canHaveBreak: !0,
            shouldPopulateBreak: !1,
            inCaseClause: !0
          });
        e.isBreakStatement() ? r.push(Voe(e)) : r.push(Uoe(e));
      }
    }
    return r;
  }
  s(Ui, "_getCompletionRecords");
  function Goe() {
    return Ui(this, {
      canHaveBreak: !1,
      shouldPopulateBreak: !1,
      inCaseClause: !1
    }).map((t) => t.path);
  }
  s(Goe, "getCompletionRecords");
  function Hoe(e) {
    return Py.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: e
    }).setContext(this.context);
  }
  s(Hoe, "getSibling");
  function Yoe() {
    return this.getSibling(this.key - 1);
  }
  s(Yoe, "getPrevSibling");
  function zoe() {
    return this.getSibling(this.key + 1);
  }
  s(zoe, "getNextSibling");
  function Joe() {
    let e = this.key, t = this.getSibling(++e), r = [];
    for (; t.node; )
      r.push(t), t = this.getSibling(++e);
    return r;
  }
  s(Joe, "getAllNextSiblings");
  function Xoe() {
    let e = this.key, t = this.getSibling(--e), r = [];
    for (; t.node; )
      r.push(t), t = this.getSibling(--e);
    return r;
  }
  s(Xoe, "getAllPrevSiblings");
  function Qoe(e, t = !0) {
    t === !0 && (t = this.context);
    let r = e.split(".");
    return r.length === 1 ? PA.call(this, e, t) : AA.call(this, r, t);
  }
  s(Qoe, "get");
  function PA(e, t) {
    let r = this.node, n = r[e];
    return Array.isArray(n) ? n.map((i, a) => Py.default.get({
      listKey: e,
      parentPath: this,
      parent: r,
      container: n,
      key: a
    }).setContext(t)) : Py.default.get({
      parentPath: this,
      parent: r,
      container: r,
      key: e
    }).setContext(t);
  }
  s(PA, "_getKey");
  function AA(e, t) {
    let r = this;
    for (let n of e)
      n === "." ? r = r.parentPath : Array.isArray(r) ? r = r[n] : r = r.get(n, t);
    return r;
  }
  s(AA, "_getPattern");
  function Zoe() {
    return Loe(this.node);
  }
  s(Zoe, "getAssignmentIdentifiers");
  function ele(e) {
    return SA(this.node, e);
  }
  s(ele, "getBindingIdentifiers");
  function tle(e) {
    return Moe(this.node, e);
  }
  s(tle, "getOuterBindingIdentifiers");
  function rle(e = !1, t = !1) {
    let n = [this], i = /* @__PURE__ */ Object.create(null);
    for (; n.length; ) {
      let a = n.shift();
      if (!a || !a.node) continue;
      let o = SA.keys[a.node.type];
      if (a.isIdentifier()) {
        e ? (i[a.node.name] = i[a.node.name] || []).push(a) : i[a.node.name] = a;
        continue;
      }
      if (a.isExportDeclaration()) {
        let l = a.get("declaration");
        l.isDeclaration() && n.push(l);
        continue;
      }
      if (t) {
        if (a.isFunctionDeclaration()) {
          n.push(a.get("id"));
          continue;
        }
        if (a.isFunctionExpression())
          continue;
      }
      if (o)
        for (let l = 0; l < o.length; l++) {
          let u = o[l], c = a.get(u);
          Array.isArray(c) ? n.push(...c) : c.node && n.push(c);
        }
    }
    return i;
  }
  s(rle, "getBindingIdentifierPaths");
  function nle(e = !1) {
    return this.getBindingIdentifierPaths(e, !0);
  }
  s(nle, "getOuterBindingIdentifierPaths");
});

// ../node_modules/@babel/traverse/lib/path/comments.js
var DA = T((go) => {
  "use strict";
  Object.defineProperty(go, "__esModule", {
    value: !0
  });
  go.addComment = lle;
  go.addComments = ule;
  go.shareCommentsWithSiblings = ole;
  var sle = Pe(), {
    addComment: ile,
    addComments: ale
  } = sle;
  function ole() {
    if (typeof this.key == "string") return;
    let e = this.node;
    if (!e) return;
    let t = e.trailingComments, r = e.leadingComments;
    if (!t && !r) return;
    let n = this.getSibling(this.key - 1), i = this.getSibling(this.key + 1), a = !!n.node, o = !!i.node;
    a && (r && n.addComments("trailing", wA(r, n.node.trailingComments)), t && !o && n.addComments("trailing", t)), o && (t && i.addComments(
    "leading", wA(t, i.node.leadingComments)), r && !a && i.addComments("leading", r));
  }
  s(ole, "shareCommentsWithSiblings");
  function wA(e, t) {
    if (!(t != null && t.length)) return e;
    let r = new Set(t);
    return e.filter((n) => !r.has(n));
  }
  s(wA, "removeIfExisting");
  function lle(e, t, r) {
    ile(this.node, e, t, r);
  }
  s(lle, "addComment");
  function ule(e, t) {
    ale(this.node, e, t);
  }
  s(ule, "addComments");
});

// ../node_modules/@babel/traverse/lib/path/index.js
var ps = T((mn) => {
  "use strict";
  Object.defineProperty(mn, "__esModule", {
    value: !0
  });
  mn.default = mn.SHOULD_STOP = mn.SHOULD_SKIP = mn.REMOVED = void 0;
  var cle = lm(), fle = qs(), ple = _r(), dle = Tm(), OA = Pe(), qu = OA, hle = $s(), mle = fo(), dn = mP(), Vi = FP(), $i = oy(), IA = aA(),
  Xs = hA(), wt = TA(), St = ji(), Wi = ju(), hn = dy(), cr = CA(), Cy = DA(), yle = hm(), {
    validate: gle
  } = OA, _A = fle("babel"), RCe = mn.REMOVED = 1, qCe = mn.SHOULD_STOP = 2, UCe = mn.SHOULD_SKIP = 4, hs = mn.default = class NA {
    static {
      s(this, "NodePath");
    }
    constructor(t, r) {
      this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container =
      null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = r, this.hub = t, this.data = null, this.
      context = null, this.scope = null;
    }
    get removed() {
      return (this._traverseFlags & 1) > 0;
    }
    set removed(t) {
      t ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
    }
    get shouldStop() {
      return (this._traverseFlags & 2) > 0;
    }
    set shouldStop(t) {
      t ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
    }
    get shouldSkip() {
      return (this._traverseFlags & 4) > 0;
    }
    set shouldSkip(t) {
      t ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
    }
    static get({
      hub: t,
      parentPath: r,
      parent: n,
      container: i,
      listKey: a,
      key: o
    }) {
      if (!t && r && (t = r.hub), !n)
        throw new Error("To get a node path the parent needs to exist");
      let l = i[o], u = hle.getOrCreateCachedPaths(t, n), c = u.get(l);
      return c || (c = new NA(t, n), l && u.set(l, c)), c.setup(r, i, a, o), c;
    }
    getScope(t) {
      return this.isScope() ? new dle.default(this) : t;
    }
    setData(t, r) {
      return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[t] = r;
    }
    getData(t, r) {
      this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
      let n = this.data[t];
      return n === void 0 && r !== void 0 && (n = this.data[t] = r), n;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(t, r = SyntaxError) {
      return this.hub.buildError(this.node, t, r);
    }
    traverse(t, r) {
      (0, ple.default)(this.node, t, this.scope, r, this);
    }
    set(t, r) {
      gle(this.node, t, r), this.node[t] = r;
    }
    getPathLocation() {
      let t = [], r = this;
      do {
        let n = r.key;
        r.inList && (n = `${r.listKey}[${n}]`), t.unshift(n);
      } while (r = r.parentPath);
      return t.join(".");
    }
    debug(t) {
      _A.enabled && _A(`${this.getPathLocation()} ${this.type}: ${t}`);
    }
    toString() {
      return (0, mle.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(t) {
      t || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
  }, ble = {
    findParent: dn.findParent,
    find: dn.find,
    getFunctionParent: dn.getFunctionParent,
    getStatementParent: dn.getStatementParent,
    getEarliestCommonAncestorFrom: dn.getEarliestCommonAncestorFrom,
    getDeepestCommonAncestorFrom: dn.getDeepestCommonAncestorFrom,
    getAncestry: dn.getAncestry,
    isAncestor: dn.isAncestor,
    isDescendant: dn.isDescendant,
    inType: dn.inType,
    getTypeAnnotation: Vi.getTypeAnnotation,
    isBaseType: Vi.isBaseType,
    couldBeBaseType: Vi.couldBeBaseType,
    baseTypeStrictlyMatches: Vi.baseTypeStrictlyMatches,
    isGenericType: Vi.isGenericType,
    replaceWithMultiple: $i.replaceWithMultiple,
    replaceWithSourceString: $i.replaceWithSourceString,
    replaceWith: $i.replaceWith,
    replaceExpressionWithStatements: $i.replaceExpressionWithStatements,
    replaceInline: $i.replaceInline,
    evaluateTruthy: IA.evaluateTruthy,
    evaluate: IA.evaluate,
    toComputedKey: Xs.toComputedKey,
    ensureBlock: Xs.ensureBlock,
    unwrapFunctionEnvironment: Xs.unwrapFunctionEnvironment,
    arrowFunctionToExpression: Xs.arrowFunctionToExpression,
    splitExportDeclaration: Xs.splitExportDeclaration,
    ensureFunctionName: Xs.ensureFunctionName,
    matchesPattern: wt.matchesPattern,
    has: wt.has,
    isStatic: wt.isStatic,
    is: wt.is,
    isnt: wt.isnt,
    equals: wt.equals,
    isNodeType: wt.isNodeType,
    canHaveVariableDeclarationOrExpression: wt.canHaveVariableDeclarationOrExpression,
    canSwapBetweenExpressionAndStatement: wt.canSwapBetweenExpressionAndStatement,
    isCompletionRecord: wt.isCompletionRecord,
    isStatementOrBlock: wt.isStatementOrBlock,
    referencesImport: wt.referencesImport,
    getSource: wt.getSource,
    willIMaybeExecuteBefore: wt.willIMaybeExecuteBefore,
    _guessExecutionStatusRelativeTo: wt._guessExecutionStatusRelativeTo,
    resolve: wt.resolve,
    isConstantExpression: wt.isConstantExpression,
    isInStrictMode: wt.isInStrictMode,
    call: St.call,
    isDenylisted: St.isDenylisted,
    isBlacklisted: St.isBlacklisted,
    visit: St.visit,
    skip: St.skip,
    skipKey: St.skipKey,
    stop: St.stop,
    setScope: St.setScope,
    setContext: St.setContext,
    resync: St.resync,
    popContext: St.popContext,
    pushContext: St.pushContext,
    setup: St.setup,
    setKey: St.setKey,
    requeue: St.requeue,
    requeueComputedKeyAndDecorators: St.requeueComputedKeyAndDecorators,
    remove: Wi.remove,
    insertBefore: hn.insertBefore,
    insertAfter: hn.insertAfter,
    updateSiblingKeys: hn.updateSiblingKeys,
    unshiftContainer: hn.unshiftContainer,
    pushContainer: hn.pushContainer,
    hoist: hn.hoist,
    getOpposite: cr.getOpposite,
    getCompletionRecords: cr.getCompletionRecords,
    getSibling: cr.getSibling,
    getPrevSibling: cr.getPrevSibling,
    getNextSibling: cr.getNextSibling,
    getAllNextSiblings: cr.getAllNextSiblings,
    getAllPrevSiblings: cr.getAllPrevSiblings,
    get: cr.get,
    getAssignmentIdentifiers: cr.getAssignmentIdentifiers,
    getBindingIdentifiers: cr.getBindingIdentifiers,
    getOuterBindingIdentifiers: cr.getOuterBindingIdentifiers,
    getBindingIdentifierPaths: cr.getBindingIdentifierPaths,
    getOuterBindingIdentifierPaths: cr.getOuterBindingIdentifierPaths,
    shareCommentsWithSiblings: Cy.shareCommentsWithSiblings,
    addComment: Cy.addComment,
    addComments: Cy.addComments
  };
  Object.assign(hs.prototype, ble);
  hs.prototype.arrowFunctionToShadowed = Xs.arrowFunctionToShadowed;
  hs.prototype._guessExecutionStatusRelativeToDifferentFunctions = wt._guessExecutionStatusRelativeTo;
  hs.prototype._guessExecutionStatusRelativeToDifferentFunctions = wt._guessExecutionStatusRelativeTo, Object.assign(hs.prototype, {
    _getTypeAnnotation: Vi._getTypeAnnotation,
    _replaceWith: $i._replaceWith,
    _resolve: wt._resolve,
    _call: St._call,
    _resyncParent: St._resyncParent,
    _resyncKey: St._resyncKey,
    _resyncList: St._resyncList,
    _resyncRemoved: St._resyncRemoved,
    _getQueueContexts: St._getQueueContexts,
    _removeFromScope: Wi._removeFromScope,
    _callRemovalHooks: Wi._callRemovalHooks,
    _remove: Wi._remove,
    _markRemoved: Wi._markRemoved,
    _assertUnremoved: Wi._assertUnremoved,
    _containerInsert: hn._containerInsert,
    _containerInsertBefore: hn._containerInsertBefore,
    _containerInsertAfter: hn._containerInsertAfter,
    _verifyNodeList: hn._verifyNodeList,
    _getKey: cr._getKey,
    _getPattern: cr._getPattern
  });
  for (let e of qu.TYPES) {
    let t = `is${e}`, r = qu[t];
    hs.prototype[t] = function(n) {
      return r(this.node, n);
    }, hs.prototype[`assert${e}`] = function(n) {
      if (!r(this.node, n))
        throw new TypeError(`Expected node path of type ${e}`);
    };
  }
  Object.assign(hs.prototype, yle);
  for (let e of Object.keys(cle))
    e[0] !== "_" && (qu.TYPES.includes(e) || qu.TYPES.push(e));
});

// ../node_modules/@babel/traverse/lib/context.js
var BA = T((Uu) => {
  "use strict";
  Object.defineProperty(Uu, "__esModule", {
    value: !0
  });
  Uu.default = void 0;
  var Ele = ps(), vle = Pe(), {
    VISITOR_KEYS: Tle
  } = vle, wy = class {
    static {
      s(this, "TraversalContext");
    }
    constructor(t, r, n, i) {
      this.queue = null, this.priorityQueue = null, this.parentPath = i, this.scope = t, this.state = n, this.opts = r;
    }
    shouldVisit(t) {
      let r = this.opts;
      if (r.enter || r.exit || r[t.type]) return !0;
      let n = Tle[t.type];
      if (!(n != null && n.length)) return !1;
      for (let i of n)
        if (t[i])
          return !0;
      return !1;
    }
    create(t, r, n, i) {
      return Ele.default.get({
        parentPath: this.parentPath,
        parent: t,
        container: r,
        key: n,
        listKey: i
      });
    }
    maybeQueue(t, r) {
      this.queue && (r ? this.queue.push(t) : this.priorityQueue.push(t));
    }
    visitMultiple(t, r, n) {
      if (t.length === 0) return !1;
      let i = [];
      for (let a = 0; a < t.length; a++) {
        let o = t[a];
        o && this.shouldVisit(o) && i.push(this.create(r, t, a, n));
      }
      return this.visitQueue(i);
    }
    visitSingle(t, r) {
      return this.shouldVisit(t[r]) ? this.visitQueue([this.create(t, t, r)]) : !1;
    }
    visitQueue(t) {
      this.queue = t, this.priorityQueue = [];
      let r = /* @__PURE__ */ new WeakSet(), n = !1, i = 0;
      for (; i < t.length; ) {
        let a = t[i];
        if (i++, a.resync(), (a.contexts.length === 0 || a.contexts[a.contexts.length - 1] !== this) && a.pushContext(this), a.key === null)
         continue;
        let {
          node: o
        } = a;
        if (!r.has(o)) {
          if (o && r.add(o), a.visit()) {
            n = !0;
            break;
          }
          if (this.priorityQueue.length && (n = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = t, n))
            break;
        }
      }
      for (let a = 0; a < i; a++)
        t[a].popContext();
      return this.queue = null, n;
    }
    visit(t, r) {
      let n = t[r];
      return n ? Array.isArray(n) ? this.visitMultiple(n, t, r) : this.visitSingle(t, r) : !1;
    }
  };
  Uu.default = wy;
});

// ../node_modules/@babel/traverse/lib/traverse-node.js
var cu = T((Dy) => {
  "use strict";
  Object.defineProperty(Dy, "__esModule", {
    value: !0
  });
  Dy.traverseNode = Ale;
  var xle = BA(), Sle = Pe(), {
    VISITOR_KEYS: Ple
  } = Sle;
  function Ale(e, t, r, n, i, a, o) {
    let l = Ple[e.type];
    if (!l) return !1;
    let u = new xle.default(r, t, n, i);
    if (o)
      return a != null && a[i.parentKey] ? !1 : u.visitQueue([i]);
    for (let c of l)
      if (!(a != null && a[c]) && u.visit(e, c))
        return !0;
    return !1;
  }
  s(Ale, "traverseNode");
});

// ../node_modules/@babel/traverse/lib/path/context.js
var ji = T((yt) => {
  "use strict";
  Object.defineProperty(yt, "__esModule", {
    value: !0
  });
  yt._call = Iy;
  yt._getQueueContexts = Kle;
  yt._resyncKey = LA;
  yt._resyncList = MA;
  yt._resyncParent = jA;
  yt._resyncRemoved = Mle;
  yt.call = Ile;
  yt.isBlacklisted = yt.isDenylisted = _le;
  yt.popContext = Rle;
  yt.pushContext = qle;
  yt.requeue = $le;
  yt.requeueComputedKeyAndDecorators = Wle;
  yt.resync = Lle;
  yt.setContext = jle;
  yt.setKey = Vle;
  yt.setScope = Fle;
  yt.setup = Ule;
  yt.skip = Nle;
  yt.skipKey = Ble;
  yt.stop = kle;
  yt.visit = Ole;
  var Cle = cu(), kA = ps(), wle = ju(), Dle = Pe();
  function Ile(e) {
    let t = this.opts;
    if (this.debug(e), this.node && Iy.call(this, t[e]))
      return !0;
    if (this.node) {
      var r;
      return Iy.call(this, (r = t[this.node.type]) == null ? void 0 : r[e]);
    }
    return !1;
  }
  s(Ile, "call");
  function Iy(e) {
    if (!e) return !1;
    for (let t of e) {
      if (!t) continue;
      let r = this.node;
      if (!r) return !0;
      let n = t.call(this.state, this, this.state);
      if (n && typeof n == "object" && typeof n.then == "function")
        throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not suppo\
rt. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (n)
        throw new Error(`Unexpected return value from visitor method ${t}`);
      if (this.node !== r || this._traverseFlags > 0) return !0;
    }
    return !1;
  }
  s(Iy, "_call");
  function _le() {
    var e;
    let t = (e = this.opts.denylist) != null ? e : this.opts.blacklist;
    return t && t.indexOf(this.node.type) > -1;
  }
  s(_le, "isDenylisted");
  function FA(e, t) {
    e.context !== t && (e.context = t, e.state = t.state, e.opts = t.opts);
  }
  s(FA, "restoreContext");
  function Ole() {
    var e, t;
    if (!this.node || this.isDenylisted() || (e = (t = this.opts).shouldSkip) != null && e.call(t, this))
      return !1;
    let r = this.context;
    return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (FA(this, r), this.debug("Recursing into..."),
    this.shouldStop = (0, Cle.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), FA(this, r), this.call("exit"),
    this.shouldStop);
  }
  s(Ole, "visit");
  function Nle() {
    this.shouldSkip = !0;
  }
  s(Nle, "skip");
  function Ble(e) {
    this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[e] = !0;
  }
  s(Ble, "skipKey");
  function kle() {
    this._traverseFlags |= kA.SHOULD_SKIP | kA.SHOULD_STOP;
  }
  s(kle, "stop");
  function Fle() {
    var e, t;
    if ((e = this.opts) != null && e.noScope) return;
    let r = this.parentPath;
    ((this.key === "key" || this.listKey === "decorators") && r.isMethod() || this.key === "discriminant" && r.isSwitchStatement()) && (r = r.
    parentPath);
    let n;
    for (; r && !n; ) {
      var i;
      if ((i = r.opts) != null && i.noScope) return;
      n = r.scope, r = r.parentPath;
    }
    this.scope = this.getScope(n), (t = this.scope) == null || t.init();
  }
  s(Fle, "setScope");
  function jle(e) {
    return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, e && (this.context = e, this.state = e.state, this.opts =
    e.opts), this.setScope(), this;
  }
  s(jle, "setContext");
  function Lle() {
    this.removed || (jA.call(this), MA.call(this), LA.call(this));
  }
  s(Lle, "resync");
  function jA() {
    this.parentPath && (this.parent = this.parentPath.node);
  }
  s(jA, "_resyncParent");
  function LA() {
    if (this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let e = 0; e < this.container.length; e++)
          if (this.container[e] === this.node) {
            this.setKey(e);
            return;
          }
      } else
        for (let e of Object.keys(this.container))
          if (this.container[e] === this.node) {
            this.setKey(e);
            return;
          }
      this.key = null;
    }
  }
  s(LA, "_resyncKey");
  function MA() {
    if (!this.parent || !this.inList) return;
    let e = this.parent[this.listKey];
    this.container !== e && (this.container = e || null);
  }
  s(MA, "_resyncList");
  function Mle() {
    (this.key == null || !this.container || this.container[this.key] !== this.node) && wle._markRemoved.call(this);
  }
  s(Mle, "_resyncRemoved");
  function Rle() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }
  s(Rle, "popContext");
  function qle(e) {
    this.contexts.push(e), this.setContext(e);
  }
  s(qle, "pushContext");
  function Ule(e, t, r, n) {
    this.listKey = r, this.container = t, this.parentPath = e || this.parentPath, this.setKey(n);
  }
  s(Ule, "setup");
  function Vle(e) {
    var t;
    this.key = e, this.node = this.container[this.key], this.type = (t = this.node) == null ? void 0 : t.type;
  }
  s(Vle, "setKey");
  function $le(e = this) {
    if (e.removed) return;
    let t = this.contexts;
    for (let r of t)
      r.maybeQueue(e);
  }
  s($le, "requeue");
  function Wle() {
    let {
      context: e,
      node: t
    } = this;
    if (!Dle.isPrivate(t) && t.computed && e.maybeQueue(this.get("key")), t.decorators)
      for (let r of this.get("decorators"))
        e.maybeQueue(r);
  }
  s(Wle, "requeueComputedKeyAndDecorators");
  function Kle() {
    let e = this, t = this.contexts;
    for (; !t.length && (e = e.parentPath, !!e); )
      t = e.contexts;
    return t;
  }
  s(Kle, "_getQueueContexts");
});

// ../node_modules/@babel/traverse/lib/hub.js
var RA = T((Vu) => {
  "use strict";
  Object.defineProperty(Vu, "__esModule", {
    value: !0
  });
  Vu.default = void 0;
  var _y = class {
    static {
      s(this, "Hub");
    }
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(t, r, n = TypeError) {
      return new n(r);
    }
  };
  Vu.default = _y;
});

// ../node_modules/@babel/traverse/lib/index.js
var _r = T((kn) => {
  "use strict";
  Object.defineProperty(kn, "__esModule", {
    value: !0
  });
  Object.defineProperty(kn, "Hub", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Jle.default;
    }, "get")
  });
  Object.defineProperty(kn, "NodePath", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Yle.default;
    }, "get")
  });
  Object.defineProperty(kn, "Scope", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return zle.default;
    }, "get")
  });
  kn.visitors = kn.default = void 0;
  ji();
  var bo = io();
  kn.visitors = bo;
  var Gle = Pe(), Hle = $s(), qA = cu(), Yle = ps(), zle = Tm(), Jle = RA(), {
    VISITOR_KEYS: Xle,
    removeProperties: Qle,
    traverseFast: UA
  } = Gle;
  function Fr(e, t = {}, r, n, i, a) {
    if (e) {
      if (!t.noScope && !r && e.type !== "Program" && e.type !== "File")
        throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${e.
        type} node without passing scope and parentPath.`);
      if (!i && a)
        throw new Error("visitSelf can only be used when providing a NodePath.");
      Xle[e.type] && (bo.explode(t), (0, qA.traverseNode)(e, t, r, n, i, null, a));
    }
  }
  s(Fr, "traverse");
  var QCe = kn.default = Fr;
  Fr.visitors = bo;
  Fr.verify = bo.verify;
  Fr.explode = bo.explode;
  Fr.cheap = function(e, t) {
    UA(e, t);
  };
  Fr.node = function(e, t, r, n, i, a) {
    (0, qA.traverseNode)(e, t, r, n, i, a);
  };
  Fr.clearNode = function(e, t) {
    Qle(e, t);
  };
  Fr.removeProperties = function(e, t) {
    return UA(e, Fr.clearNode, t), e;
  };
  function Zle(e, t) {
    e.node.type === t.type && (t.has = !0, e.stop());
  }
  s(Zle, "hasDenylistedType");
  Fr.hasType = function(e, t, r) {
    if (r != null && r.includes(e.type)) return !1;
    if (e.type === t) return !0;
    let n = {
      has: !1,
      type: t
    };
    return Fr(e, {
      noScope: !0,
      denylist: r,
      enter: Zle
    }, null, n), n.has;
  };
  Fr.cache = Hle;
});

// ../node_modules/@babel/helper-module-imports/lib/import-builder.js
var WA = T((Wu) => {
  "use strict";
  Object.defineProperty(Wu, "__esModule", {
    value: !0
  });
  Wu.default = void 0;
  var Yr = ie("assert"), eue = Pe(), {
    callExpression: Oy,
    cloneNode: $u,
    expressionStatement: VA,
    identifier: Eo,
    importDeclaration: tue,
    importDefaultSpecifier: rue,
    importNamespaceSpecifier: nue,
    importSpecifier: sue,
    memberExpression: Ny,
    stringLiteral: $A,
    variableDeclaration: iue,
    variableDeclarator: aue
  } = eue, By = class {
    static {
      s(this, "ImportBuilder");
    }
    constructor(t, r, n) {
      this._statements = [], this._resultName = null, this._importedSource = void 0, this._scope = r, this._hub = n, this._importedSource = t;
    }
    done() {
      return {
        statements: this._statements,
        resultName: this._resultName
      };
    }
    import() {
      return this._statements.push(tue([], $A(this._importedSource))), this;
    }
    require() {
      return this._statements.push(VA(Oy(Eo("require"), [$A(this._importedSource)]))), this;
    }
    namespace(t = "namespace") {
      let r = this._scope.generateUidIdentifier(t), n = this._statements[this._statements.length - 1];
      return Yr(n.type === "ImportDeclaration"), Yr(n.specifiers.length === 0), n.specifiers = [nue(r)], this._resultName = $u(r), this;
    }
    default(t) {
      let r = this._scope.generateUidIdentifier(t), n = this._statements[this._statements.length - 1];
      return Yr(n.type === "ImportDeclaration"), Yr(n.specifiers.length === 0), n.specifiers = [rue(r)], this._resultName = $u(r), this;
    }
    named(t, r) {
      if (r === "default") return this.default(t);
      let n = this._scope.generateUidIdentifier(t), i = this._statements[this._statements.length - 1];
      return Yr(i.type === "ImportDeclaration"), Yr(i.specifiers.length === 0), i.specifiers = [sue(n, Eo(r))], this._resultName = $u(n), this;
    }
    var(t) {
      let r = this._scope.generateUidIdentifier(t), n = this._statements[this._statements.length - 1];
      return n.type !== "ExpressionStatement" && (Yr(this._resultName), n = VA(this._resultName), this._statements.push(n)), this._statements[this.
      _statements.length - 1] = iue("var", [aue(r, n.expression)]), this._resultName = $u(r), this;
    }
    defaultInterop() {
      return this._interop(this._hub.addHelper("interopRequireDefault"));
    }
    wildcardInterop() {
      return this._interop(this._hub.addHelper("interopRequireWildcard"));
    }
    _interop(t) {
      let r = this._statements[this._statements.length - 1];
      return r.type === "ExpressionStatement" ? r.expression = Oy(t, [r.expression]) : r.type === "VariableDeclaration" ? (Yr(r.declarations.
      length === 1), r.declarations[0].init = Oy(t, [r.declarations[0].init])) : Yr.fail("Unexpected type."), this;
    }
    prop(t) {
      let r = this._statements[this._statements.length - 1];
      return r.type === "ExpressionStatement" ? r.expression = Ny(r.expression, Eo(t)) : r.type === "VariableDeclaration" ? (Yr(r.declarations.
      length === 1), r.declarations[0].init = Ny(r.declarations[0].init, Eo(t))) : Yr.fail("Unexpected type:" + r.type), this;
    }
    read(t) {
      this._resultName = Ny(this._resultName, Eo(t));
    }
  };
  Wu.default = By;
});

// ../node_modules/@babel/helper-module-imports/lib/is-module.js
var Fy = T((ky) => {
  "use strict";
  Object.defineProperty(ky, "__esModule", {
    value: !0
  });
  ky.default = oue;
  function oue(e) {
    return e.node.sourceType === "module";
  }
  s(oue, "isModule");
});

// ../node_modules/@babel/helper-module-imports/lib/import-injector.js
var JA = T((Gu) => {
  "use strict";
  Object.defineProperty(Gu, "__esModule", {
    value: !0
  });
  Gu.default = void 0;
  var KA = ie("assert"), lue = Pe(), uue = WA(), cue = Fy(), {
    identifier: fue,
    importSpecifier: pue,
    numericLiteral: due,
    sequenceExpression: hue,
    isImportDeclaration: GA
  } = lue, jy = class {
    static {
      s(this, "ImportInjector");
    }
    constructor(t, r, n) {
      this._defaultOpts = {
        importedSource: null,
        importedType: "commonjs",
        importedInterop: "babel",
        importingInterop: "babel",
        ensureLiveReference: !1,
        ensureNoContext: !1,
        importPosition: "before"
      };
      let i = t.find((a) => a.isProgram());
      this._programPath = i, this._programScope = i.scope, this._hub = i.hub, this._defaultOpts = this._applyDefaults(r, n, !0);
    }
    addDefault(t, r) {
      return this.addNamed("default", t, r);
    }
    addNamed(t, r, n) {
      return KA(typeof t == "string"), this._generateImport(this._applyDefaults(r, n), t);
    }
    addNamespace(t, r) {
      return this._generateImport(this._applyDefaults(t, r), null);
    }
    addSideEffect(t, r) {
      return this._generateImport(this._applyDefaults(t, r), void 0);
    }
    _applyDefaults(t, r, n = !1) {
      let i;
      return typeof t == "string" ? i = Object.assign({}, this._defaultOpts, {
        importedSource: t
      }, r) : (KA(!r, "Unexpected secondary arguments."), i = Object.assign({}, this._defaultOpts, t)), !n && r && (r.nameHint !== void 0 &&
      (i.nameHint = r.nameHint), r.blockHoist !== void 0 && (i.blockHoist = r.blockHoist)), i;
    }
    _generateImport(t, r) {
      let n = r === "default", i = !!r && !n, a = r === null, {
        importedSource: o,
        importedType: l,
        importedInterop: u,
        importingInterop: c,
        ensureLiveReference: f,
        ensureNoContext: p,
        nameHint: h,
        importPosition: y,
        blockHoist: v
      } = t, d = h || r, b = (0, cue.default)(this._programPath), E = b && c === "node", I = b && c === "babel";
      if (y === "after" && !b)
        throw new Error('"importPosition": "after" is only supported in modules');
      let O = new uue.default(o, this._programScope, this._hub);
      if (l === "es6") {
        if (!E && !I)
          throw new Error("Cannot import an ES6 module from CommonJS");
        O.import(), a ? O.namespace(h || o) : (n || i) && O.named(d, r);
      } else {
        if (l !== "commonjs")
          throw new Error(`Unexpected interopType "${l}"`);
        if (u === "babel")
          if (E) {
            d = d !== "default" ? d : o;
            let R = `${o}$es6Default`;
            O.import(), a ? O.default(R).var(d || o).wildcardInterop() : n ? f ? O.default(R).var(d || o).defaultInterop().read("default") :
            O.default(R).var(d).defaultInterop().prop(r) : i && O.default(R).read(r);
          } else I ? (O.import(), a ? O.namespace(d || o) : (n || i) && O.named(d, r)) : (O.require(), a ? O.var(d || o).wildcardInterop() :
          (n || i) && f ? n ? (d = d !== "default" ? d : o, O.var(d).read(r), O.defaultInterop()) : O.var(o).read(r) : n ? O.var(d).defaultInterop().
          prop(r) : i && O.var(d).prop(r));
        else if (u === "compiled")
          E ? (O.import(), a ? O.default(d || o) : (n || i) && O.default(o).read(d)) : I ? (O.import(), a ? O.namespace(d || o) : (n || i) &&
          O.named(d, r)) : (O.require(), a ? O.var(d || o) : (n || i) && (f ? O.var(o).read(d) : O.prop(r).var(d)));
        else if (u === "uncompiled") {
          if (n && f)
            throw new Error("No live reference for commonjs default");
          E ? (O.import(), a ? O.default(d || o) : n ? O.default(d) : i && O.default(o).read(d)) : I ? (O.import(), a ? O.default(d || o) : n ?
          O.default(d) : i && O.named(d, r)) : (O.require(), a ? O.var(d || o) : n ? O.var(d) : i && (f ? O.var(o).read(d) : O.var(d).prop(r)));
        } else
          throw new Error(`Unknown importedInterop "${u}".`);
      }
      let {
        statements: k,
        resultName: j
      } = O.done();
      return this._insertStatements(k, y, v), (n || i) && p && j.type !== "Identifier" ? hue([due(0), j]) : j;
    }
    _insertStatements(t, r = "before", n = 3) {
      if (r === "after") {
        if (this._insertStatementsAfter(t)) return;
      } else if (this._insertStatementsBefore(t, n)) return;
      this._programPath.unshiftContainer("body", t);
    }
    _insertStatementsBefore(t, r) {
      if (t.length === 1 && GA(t[0]) && Ku(t[0])) {
        let i = this._programPath.get("body").find((a) => a.isImportDeclaration() && Ku(a.node));
        if (i?.node.source.value === t[0].source.value && zA(i.node, t[0]))
          return !0;
      }
      t.forEach((i) => {
        i._blockHoist = r;
      });
      let n = this._programPath.get("body").find((i) => {
        let a = i.node._blockHoist;
        return Number.isFinite(a) && a < 4;
      });
      return n ? (n.insertBefore(t), !0) : !1;
    }
    _insertStatementsAfter(t) {
      let r = new Set(t), n = /* @__PURE__ */ new Map();
      for (let a of t)
        if (GA(a) && Ku(a)) {
          let o = a.source.value;
          n.has(o) || n.set(o, []), n.get(o).push(a);
        }
      let i = null;
      for (let a of this._programPath.get("body"))
        if (a.isImportDeclaration() && Ku(a.node)) {
          i = a;
          let o = a.node.source.value, l = n.get(o);
          if (!l) continue;
          for (let u of l)
            r.has(u) && zA(a.node, u) && r.delete(u);
        }
      return r.size === 0 ? !0 : (i && i.insertAfter(Array.from(r)), !!i);
    }
  };
  Gu.default = jy;
  function Ku(e) {
    return e.importKind !== "type" && e.importKind !== "typeof";
  }
  s(Ku, "isValueImport");
  function HA(e) {
    return e.specifiers.length === 1 && e.specifiers[0].type === "ImportNamespaceSpecifier" || e.specifiers.length === 2 && e.specifiers[1].
    type === "ImportNamespaceSpecifier";
  }
  s(HA, "hasNamespaceImport");
  function YA(e) {
    return e.specifiers.length > 0 && e.specifiers[0].type === "ImportDefaultSpecifier";
  }
  s(YA, "hasDefaultImport");
  function zA(e, t) {
    return e.specifiers.length ? t.specifiers.length ? HA(e) || HA(t) ? !1 : (YA(t) && (YA(e) ? t.specifiers[0] = pue(t.specifiers[0].local,
    fue("default")) : e.specifiers.unshift(t.specifiers.shift())), e.specifiers.push(...t.specifiers), !0) : !0 : (e.specifiers = t.specifiers,
    !0);
  }
  s(zA, "maybeAppendImportSpecifiers");
});

// ../node_modules/@babel/helper-module-imports/lib/index.js
var XA = T((ms) => {
  "use strict";
  Object.defineProperty(ms, "__esModule", {
    value: !0
  });
  Object.defineProperty(ms, "ImportInjector", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return vo.default;
    }, "get")
  });
  ms.addDefault = yue;
  ms.addNamed = gue;
  ms.addNamespace = bue;
  ms.addSideEffect = Eue;
  Object.defineProperty(ms, "isModule", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return mue.default;
    }, "get")
  });
  var vo = JA(), mue = Fy();
  function yue(e, t, r) {
    return new vo.default(e).addDefault(t, r);
  }
  s(yue, "addDefault");
  function gue(e, t, r, n) {
    return new vo.default(e).addNamed(t, r, n);
  }
  s(gue, "addNamed");
  function bue(e, t, r) {
    return new vo.default(e).addNamespace(t, r);
  }
  s(bue, "addNamespace");
  function Eue(e, t, r) {
    return new vo.default(e).addSideEffect(t, r);
  }
  s(Eue, "addSideEffect");
});

// ../node_modules/@babel/helper-module-transforms/lib/rewrite-this.js
var eC = T((Ly) => {
  "use strict";
  Object.defineProperty(Ly, "__esModule", {
    value: !0
  });
  Ly.default = vue;
  var QA = bt(), ZA = _r(), Hu;
  function vue(e) {
    Hu || (Hu = ZA.visitors.environmentVisitor({
      ThisExpression(t) {
        t.replaceWith(QA.types.unaryExpression("void", QA.types.numericLiteral(0), !0));
      }
    }), Hu.noScope = !0), (0, ZA.default)(e.node, Hu);
  }
  s(vue, "rewriteThis");
});

// ../node_modules/@babel/helper-simple-access/lib/index.js
var Vy = T((Uy) => {
  "use strict";
  Object.defineProperty(Uy, "__esModule", {
    value: !0
  });
  Uy.default = Aue;
  var Tue = Pe(), {
    LOGICAL_OPERATORS: xue,
    assignmentExpression: To,
    binaryExpression: Ry,
    cloneNode: qy,
    identifier: Yu,
    logicalExpression: Sue,
    numericLiteral: My,
    sequenceExpression: Pue,
    unaryExpression: tC
  } = Tue, rC = {
    AssignmentExpression: {
      exit(e) {
        let {
          scope: t,
          seen: r,
          bindingNames: n
        } = this;
        if (e.node.operator === "=" || r.has(e.node)) return;
        r.add(e.node);
        let i = e.get("left");
        if (!i.isIdentifier()) return;
        let a = i.node.name;
        if (!n.has(a) || t.getBinding(a) !== e.scope.getBinding(a))
          return;
        let o = e.node.operator.slice(0, -1);
        xue.includes(o) ? e.replaceWith(Sue(o, e.node.left, To("=", qy(e.node.left), e.node.right))) : (e.node.right = Ry(o, qy(e.node.left),
        e.node.right), e.node.operator = "=");
      }
    }
  };
  rC.UpdateExpression = {
    exit(e) {
      if (!this.includeUpdateExpression) return;
      let {
        scope: t,
        bindingNames: r
      } = this, n = e.get("argument");
      if (!n.isIdentifier()) return;
      let i = n.node.name;
      if (r.has(i) && t.getBinding(i) === e.scope.getBinding(i))
        if (e.parentPath.isExpressionStatement() && !e.isCompletionRecord()) {
          let a = e.node.operator === "++" ? "+=" : "-=";
          e.replaceWith(To(a, n.node, My(1)));
        } else if (e.node.prefix)
          e.replaceWith(To("=", Yu(i), Ry(e.node.operator[0], tC("+", n.node), My(1))));
        else {
          let a = e.scope.generateUidIdentifierBasedOnNode(n.node, "old"), o = a.name;
          e.scope.push({
            id: a
          });
          let l = Ry(e.node.operator[0], Yu(o), My(1));
          e.replaceWith(Pue([To("=", Yu(o), tC("+", n.node)), To("=", qy(n.node), l), Yu(o)]));
        }
    }
  };
  function Aue(e, t) {
    {
      var r;
      e.traverse(rC, {
        scope: e.scope,
        bindingNames: t,
        seen: /* @__PURE__ */ new WeakSet(),
        includeUpdateExpression: (r = arguments[2]) != null ? r : !0
      });
    }
  }
  s(Aue, "simplifyAccess");
});

// ../node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js
var nC = T(($y) => {
  "use strict";
  Object.defineProperty($y, "__esModule", {
    value: !0
  });
  $y.default = Iue;
  var Cue = ie("assert"), Be = bt(), wue = Vy();
  function Due(e) {
    do
      switch (e.parent.type) {
        case "TSTypeAnnotation":
        case "TSTypeAliasDeclaration":
        case "TSTypeReference":
        case "TypeAnnotation":
        case "TypeAlias":
          return !0;
        case "ExportSpecifier":
          return e.parentPath.parent.exportKind === "type";
        default:
          if (e.parentPath.isStatement() || e.parentPath.isExpression())
            return !1;
      }
    while (e = e.parentPath);
  }
  s(Due, "isInType");
  function Iue(e, t, r) {
    let n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ s((c) => {
      e.requeue(c);
    }, "requeueInParent");
    for (let [c, f] of t.source) {
      for (let [p, h] of f.imports)
        n.set(p, [c, h, null]);
      for (let p of f.importsNamespace)
        n.set(p, [c, null, p]);
    }
    for (let [c, f] of t.local) {
      let p = i.get(c);
      p || (p = [], i.set(c, p)), p.push(...f.names);
    }
    let o = {
      metadata: t,
      requeueInParent: a,
      scope: e.scope,
      exported: i
    };
    e.traverse(_ue, o);
    let l = /* @__PURE__ */ new Set([...Array.from(n.keys()), ...Array.from(i.keys())]);
    (0, wue.default)(e, l, !1);
    let u = {
      seen: /* @__PURE__ */ new WeakSet(),
      metadata: t,
      requeueInParent: a,
      scope: e.scope,
      imported: n,
      exported: i,
      buildImportReference([c, f, p], h) {
        let y = t.source.get(c);
        if (y.referenced = !0, p) {
          if (y.wrap) {
            var v;
            h = (v = r(h, y.wrap)) != null ? v : h;
          }
          return h;
        }
        let d = Be.types.identifier(y.name);
        if (y.wrap) {
          var b;
          d = (b = r(d, y.wrap)) != null ? b : d;
        }
        if (f === "default" && y.interop === "node-default")
          return d;
        let E = t.stringSpecifiers.has(f);
        return Be.types.memberExpression(d, E ? Be.types.stringLiteral(f) : Be.types.identifier(f), E);
      }
    };
    e.traverse(Oue, u);
  }
  s(Iue, "rewriteLiveReferences");
  var _ue = {
    Scope(e) {
      e.skip();
    },
    ClassDeclaration(e) {
      let {
        requeueInParent: t,
        exported: r,
        metadata: n
      } = this, {
        id: i
      } = e.node;
      if (!i) throw new Error("Expected class to have a name");
      let a = i.name, o = r.get(a) || [];
      if (o.length > 0) {
        let l = Be.types.expressionStatement(Qs(n, o, Be.types.identifier(a), e.scope));
        l._blockHoist = e.node._blockHoist, t(e.insertAfter(l)[0]);
      }
    },
    VariableDeclaration(e) {
      let {
        requeueInParent: t,
        exported: r,
        metadata: n
      } = this, i = e.node.kind === "var";
      for (let a of e.get("declarations")) {
        let {
          id: o
        } = a.node, {
          init: l
        } = a.node;
        if (Be.types.isIdentifier(o) && r.has(o.name) && !Be.types.isArrowFunctionExpression(l) && (!Be.types.isFunctionExpression(l) || l.id) &&
        (!Be.types.isClassExpression(l) || l.id)) {
          if (!l) {
            if (i)
              continue;
            l = e.scope.buildUndefinedNode();
          }
          a.node.init = Qs(n, r.get(o.name), l, e.scope), t(a.get("init"));
        } else
          for (let u of Object.keys(a.getOuterBindingIdentifiers()))
            if (r.has(u)) {
              let c = Be.types.expressionStatement(Qs(n, r.get(u), Be.types.identifier(u), e.scope));
              c._blockHoist = e.node._blockHoist, t(e.insertAfter(c)[0]);
            }
      }
    }
  }, Qs = /* @__PURE__ */ s((e, t, r, n) => {
    let i = e.exportName;
    for (let a = n; a != null; a = a.parent)
      a.hasOwnBinding(i) && a.rename(i);
    return (t || []).reduce((a, o) => {
      let {
        stringSpecifiers: l
      } = e, u = l.has(o);
      return Be.types.assignmentExpression("=", Be.types.memberExpression(Be.types.identifier(i), u ? Be.types.stringLiteral(o) : Be.types.identifier(
      o), u), a);
    }, r);
  }, "buildBindingExportAssignmentExpression"), zu = /* @__PURE__ */ s((e) => Be.template.expression.ast`
    (function() {
      throw new Error('"' + '${e}' + '" is read-only.');
    })()
  `, "buildImportThrow"), Oue = {
    ReferencedIdentifier(e) {
      let {
        seen: t,
        buildImportReference: r,
        scope: n,
        imported: i,
        requeueInParent: a
      } = this;
      if (t.has(e.node)) return;
      t.add(e.node);
      let o = e.node.name, l = i.get(o);
      if (l) {
        if (Due(e))
          throw e.buildCodeFrameError(`Cannot transform the imported binding "${o}" since it's also used in a type annotation. Please strip \
type annotations using @babel/preset-typescript or @babel/preset-flow.`);
        let u = e.scope.getBinding(o);
        if (n.getBinding(o) !== u) return;
        let f = r(l, e.node);
        if (f.loc = e.node.loc, (e.parentPath.isCallExpression({
          callee: e.node
        }) || e.parentPath.isOptionalCallExpression({
          callee: e.node
        }) || e.parentPath.isTaggedTemplateExpression({
          tag: e.node
        })) && Be.types.isMemberExpression(f))
          e.replaceWith(Be.types.sequenceExpression([Be.types.numericLiteral(0), f]));
        else if (e.isJSXIdentifier() && Be.types.isMemberExpression(f)) {
          let {
            object: p,
            property: h
          } = f;
          e.replaceWith(Be.types.jsxMemberExpression(Be.types.jsxIdentifier(p.name), Be.types.jsxIdentifier(h.name)));
        } else
          e.replaceWith(f);
        a(e), e.skip();
      }
    },
    UpdateExpression(e) {
      let {
        scope: t,
        seen: r,
        imported: n,
        exported: i,
        requeueInParent: a,
        buildImportReference: o
      } = this;
      if (r.has(e.node)) return;
      r.add(e.node);
      let l = e.get("argument");
      if (l.isMemberExpression()) return;
      let u = e.node;
      if (l.isIdentifier()) {
        let c = l.node.name;
        if (t.getBinding(c) !== e.scope.getBinding(c))
          return;
        let f = i.get(c), p = n.get(c);
        if (f?.length > 0 || p)
          if (p)
            e.replaceWith(Be.types.assignmentExpression(u.operator[0] + "=", o(p, l.node), zu(c)));
          else if (u.prefix)
            e.replaceWith(Qs(this.metadata, f, Be.types.cloneNode(u), e.scope));
          else {
            let h = t.generateDeclaredUidIdentifier(c);
            e.replaceWith(Be.types.sequenceExpression([Be.types.assignmentExpression("=", Be.types.cloneNode(h), Be.types.cloneNode(u)), Qs(
            this.metadata, f, Be.types.identifier(c), e.scope), Be.types.cloneNode(h)]));
          }
      }
      a(e), e.skip();
    },
    AssignmentExpression: {
      exit(e) {
        let {
          scope: t,
          seen: r,
          imported: n,
          exported: i,
          requeueInParent: a,
          buildImportReference: o
        } = this;
        if (r.has(e.node)) return;
        r.add(e.node);
        let l = e.get("left");
        if (!l.isMemberExpression())
          if (l.isIdentifier()) {
            let u = l.node.name;
            if (t.getBinding(u) !== e.scope.getBinding(u))
              return;
            let c = i.get(u), f = n.get(u);
            if (c?.length > 0 || f) {
              Cue(e.node.operator === "=", "Path was not simplified");
              let p = e.node;
              f && (p.left = o(f, l.node), p.right = Be.types.sequenceExpression([p.right, zu(u)])), e.replaceWith(Qs(this.metadata, c, p, e.
              scope)), a(e);
            }
          } else {
            let u = l.getOuterBindingIdentifiers(), c = Object.keys(u).filter((h) => t.getBinding(h) === e.scope.getBinding(h)), f = c.find(
            (h) => n.has(h));
            f && (e.node.right = Be.types.sequenceExpression([e.node.right, zu(f)]));
            let p = [];
            if (c.forEach((h) => {
              let y = i.get(h) || [];
              y.length > 0 && p.push(Qs(this.metadata, y, Be.types.identifier(h), e.scope));
            }), p.length > 0) {
              let h = Be.types.sequenceExpression(p);
              e.parentPath.isExpressionStatement() && (h = Be.types.expressionStatement(h), h._blockHoist = e.parentPath.node._blockHoist);
              let y = e.insertAfter(h)[0];
              a(y);
            }
          }
      }
    },
    "ForOfStatement|ForInStatement"(e) {
      let {
        scope: t,
        node: r
      } = e, {
        left: n
      } = r, {
        exported: i,
        imported: a,
        scope: o
      } = this;
      if (!Be.types.isVariableDeclaration(n)) {
        let l = !1, u, c = e.get("body").scope;
        for (let h of Object.keys(Be.types.getOuterBindingIdentifiers(n)))
          o.getBinding(h) === t.getBinding(h) && (i.has(h) && (l = !0, c.hasOwnBinding(h) && c.rename(h)), a.has(h) && !u && (u = h));
        if (!l && !u)
          return;
        e.ensureBlock();
        let f = e.get("body"), p = t.generateUidIdentifierBasedOnNode(n);
        e.get("left").replaceWith(Be.types.variableDeclaration("let", [Be.types.variableDeclarator(Be.types.cloneNode(p))])), t.registerDeclaration(
        e.get("left")), l && f.unshiftContainer("body", Be.types.expressionStatement(Be.types.assignmentExpression("=", n, p))), u && f.unshiftContainer(
        "body", Be.types.expressionStatement(zu(u)));
      }
    }
  };
});

// ../node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js
var Wy = T((Ki) => {
  "use strict";
  Object.defineProperty(Ki, "__esModule", {
    value: !0
  });
  Ki.default = jue;
  Ki.hasExports = Bue;
  Ki.isSideEffectImport = kue;
  Ki.validateImportInteropOption = iC;
  var sC = ie("path"), Nue = gi();
  function Bue(e) {
    return e.hasExports;
  }
  s(Bue, "hasExports");
  function kue(e) {
    return e.imports.size === 0 && e.importsNamespace.size === 0 && e.reexports.size === 0 && e.reexportNamespace.size === 0 && !e.reexportAll;
  }
  s(kue, "isSideEffectImport");
  function iC(e) {
    if (typeof e != "function" && e !== "none" && e !== "babel" && e !== "node")
      throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${e}).`);
    return e;
  }
  s(iC, "validateImportInteropOption");
  function Fue(e, t, r) {
    return typeof e == "function" ? iC(e(t, r)) : e;
  }
  s(Fue, "resolveImportInterop");
  function jue(e, t, {
    importInterop: r,
    initializeReexports: n = !1,
    getWrapperPayload: i,
    esNamespaceOnly: a = !1,
    filename: o
  }) {
    t || (t = e.scope.generateUidIdentifier("exports").name);
    let l = /* @__PURE__ */ new Set();
    Rue(e);
    let {
      local: u,
      sources: c,
      hasExports: f
    } = Lue(e, {
      initializeReexports: n,
      getWrapperPayload: i
    }, l);
    que(e);
    for (let [p, h] of c) {
      let {
        importsNamespace: y,
        imports: v
      } = h;
      if (y.size > 0 && v.size === 0) {
        let [b] = y;
        h.name = b;
      }
      let d = Fue(r, p, o);
      d === "none" ? h.interop = "none" : d === "node" && h.interop === "namespace" ? h.interop = "node-namespace" : d === "node" && h.interop ===
      "default" ? h.interop = "node-default" : a && h.interop === "namespace" && (h.interop = "default");
    }
    return {
      exportName: t,
      exportNameListName: null,
      hasExports: f,
      local: u,
      source: c,
      stringSpecifiers: l
    };
  }
  s(jue, "normalizeModuleAndLoadMetadata");
  function Ju(e, t) {
    if (e.isIdentifier())
      return e.node.name;
    if (e.isStringLiteral()) {
      let r = e.node.value;
      return (0, Nue.isIdentifierName)(r) || t.add(r), r;
    } else
      throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${e.node.type}`);
  }
  s(Ju, "getExportSpecifierName");
  function aC(e) {
    if (!e.isExportSpecifier())
      throw e.isExportNamespaceSpecifier() ? e.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform\
-export-namespace-from`.") : e.buildCodeFrameError("Unexpected export specifier type");
  }
  s(aC, "assertExportSpecifier");
  function Lue(e, {
    getWrapperPayload: t,
    initializeReexports: r
  }, n) {
    let i = Mue(e, r, n), a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ s((c, f) => {
      let p = c.value, h = o.get(p);
      return h ? a.get(p).push(f) : (h = {
        name: e.scope.generateUidIdentifier((0, sC.basename)(p, (0, sC.extname)(p))).name,
        interop: "none",
        loc: null,
        imports: /* @__PURE__ */ new Map(),
        importsNamespace: /* @__PURE__ */ new Set(),
        reexports: /* @__PURE__ */ new Map(),
        reexportNamespace: /* @__PURE__ */ new Set(),
        reexportAll: null,
        wrap: null,
        get lazy() {
          return this.wrap === "lazy";
        },
        referenced: !1
      }, o.set(p, h), a.set(p, [f])), h;
    }, "getData"), u = !1;
    e.get("body").forEach((c) => {
      if (c.isImportDeclaration()) {
        let f = l(c.node.source, c.node);
        f.loc || (f.loc = c.node.loc), c.get("specifiers").forEach((p) => {
          if (p.isImportDefaultSpecifier()) {
            let h = p.get("local").node.name;
            f.imports.set(h, "default");
            let y = i.get(h);
            y && (i.delete(h), y.names.forEach((v) => {
              f.reexports.set(v, "default");
            }), f.referenced = !0);
          } else if (p.isImportNamespaceSpecifier()) {
            let h = p.get("local").node.name;
            f.importsNamespace.add(h);
            let y = i.get(h);
            y && (i.delete(h), y.names.forEach((v) => {
              f.reexportNamespace.add(v);
            }), f.referenced = !0);
          } else if (p.isImportSpecifier()) {
            let h = Ju(p.get("imported"), n), y = p.get("local").node.name;
            f.imports.set(y, h);
            let v = i.get(y);
            v && (i.delete(y), v.names.forEach((d) => {
              f.reexports.set(d, h);
            }), f.referenced = !0);
          }
        });
      } else if (c.isExportAllDeclaration()) {
        u = !0;
        let f = l(c.node.source, c.node);
        f.loc || (f.loc = c.node.loc), f.reexportAll = {
          loc: c.node.loc
        }, f.referenced = !0;
      } else if (c.isExportNamedDeclaration() && c.node.source) {
        u = !0;
        let f = l(c.node.source, c.node);
        f.loc || (f.loc = c.node.loc), c.get("specifiers").forEach((p) => {
          aC(p);
          let h = Ju(p.get("local"), n), y = Ju(p.get("exported"), n);
          if (f.reexports.set(y, h), f.referenced = !0, y === "__esModule")
            throw p.get("exported").buildCodeFrameError('Illegal export "__esModule".');
        });
      } else (c.isExportNamedDeclaration() || c.isExportDefaultDeclaration()) && (u = !0);
    });
    for (let c of o.values()) {
      let f = !1, p = !1;
      c.importsNamespace.size > 0 && (f = !0, p = !0), c.reexportAll && (p = !0);
      for (let h of c.imports.values())
        h === "default" ? f = !0 : p = !0;
      for (let h of c.reexports.values())
        h === "default" ? f = !0 : p = !0;
      f && p ? c.interop = "namespace" : f && (c.interop = "default");
    }
    if (t)
      for (let [c, f] of o)
        f.wrap = t(c, f, a.get(c));
    return {
      hasExports: u,
      local: i,
      sources: o
    };
  }
  s(Lue, "getModuleMetadata");
  function Mue(e, t, r) {
    let n = /* @__PURE__ */ new Map();
    e.get("body").forEach((o) => {
      let l;
      if (o.isImportDeclaration())
        l = "import";
      else {
        if (o.isExportDefaultDeclaration() && (o = o.get("declaration")), o.isExportNamedDeclaration()) {
          if (o.node.declaration)
            o = o.get("declaration");
          else if (t && o.node.source && o.get("source").isStringLiteral()) {
            o.get("specifiers").forEach((u) => {
              aC(u), n.set(u.get("local").node.name, "block");
            });
            return;
          }
        }
        if (o.isFunctionDeclaration())
          l = "hoisted";
        else if (o.isClassDeclaration())
          l = "block";
        else if (o.isVariableDeclaration({
          kind: "var"
        }))
          l = "var";
        else if (o.isVariableDeclaration())
          l = "block";
        else
          return;
      }
      Object.keys(o.getOuterBindingIdentifiers()).forEach((u) => {
        n.set(u, l);
      });
    });
    let i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ s((o) => {
      let l = o.node.name, u = i.get(l);
      if (!u) {
        let c = n.get(l);
        if (c === void 0)
          throw o.buildCodeFrameError(`Exporting local "${l}", which is not declared.`);
        u = {
          names: [],
          kind: c
        }, i.set(l, u);
      }
      return u;
    }, "getLocalMetadata");
    return e.get("body").forEach((o) => {
      if (o.isExportNamedDeclaration() && (t || !o.node.source))
        if (o.node.declaration) {
          let l = o.get("declaration"), u = l.getOuterBindingIdentifierPaths();
          Object.keys(u).forEach((c) => {
            if (c === "__esModule")
              throw l.buildCodeFrameError('Illegal export "__esModule".');
            a(u[c]).names.push(c);
          });
        } else
          o.get("specifiers").forEach((l) => {
            let u = l.get("local"), c = l.get("exported"), f = a(u), p = Ju(c, r);
            if (p === "__esModule")
              throw c.buildCodeFrameError('Illegal export "__esModule".');
            f.names.push(p);
          });
      else if (o.isExportDefaultDeclaration()) {
        let l = o.get("declaration");
        if (l.isFunctionDeclaration() || l.isClassDeclaration())
          a(l.get("id")).names.push("default");
        else
          throw l.buildCodeFrameError("Unexpected default expression export.");
      }
    }), i;
  }
  s(Mue, "getLocalExportMetadata");
  function Rue(e) {
    e.get("body").forEach((t) => {
      if (t.isExportDefaultDeclaration()) {
        {
          var r;
          (r = t.splitExportDeclaration) != null || (t.splitExportDeclaration = _r().NodePath.prototype.splitExportDeclaration);
        }
        t.splitExportDeclaration();
      }
    });
  }
  s(Rue, "nameAnonymousExports");
  function que(e) {
    e.get("body").forEach((t) => {
      if (t.isImportDeclaration())
        t.remove();
      else if (t.isExportNamedDeclaration())
        t.node.declaration ? (t.node.declaration._blockHoist = t.node._blockHoist, t.replaceWith(t.node.declaration)) : t.remove();
      else if (t.isExportDefaultDeclaration()) {
        let r = t.get("declaration");
        if (r.isFunctionDeclaration() || r.isClassDeclaration())
          r._blockHoist = t.node._blockHoist, t.replaceWith(r);
        else
          throw r.buildCodeFrameError("Unexpected default expression export.");
      } else t.isExportAllDeclaration() && t.remove();
    });
  }
  s(que, "removeImportExportDeclarations");
});

// ../node_modules/@babel/helper-module-transforms/lib/lazy-modules.js
var oC = T((Xu) => {
  "use strict";
  Object.defineProperty(Xu, "__esModule", {
    value: !0
  });
  Xu.toGetWrapperPayload = $ue;
  Xu.wrapReference = Wue;
  var Uue = bt(), Vue = Wy();
  function $ue(e) {
    return (t, r) => {
      if (e === !1 || (0, Vue.isSideEffectImport)(r) || r.reexportAll) return null;
      if (e === !0)
        return t.includes(".") ? null : "lazy";
      if (Array.isArray(e))
        return e.includes(t) ? "lazy" : null;
      if (typeof e == "function")
        return e(t) ? "lazy" : null;
      throw new Error(".lazy must be a boolean, string array, or function");
    };
  }
  s($ue, "toGetWrapperPayload");
  function Wue(e, t) {
    return t === "lazy" ? Uue.types.callExpression(e, []) : null;
  }
  s(Wue, "wrapReference");
});

// ../node_modules/@babel/helper-module-transforms/lib/dynamic-import.js
var Ky = T((Qu) => {
  "use strict";
  Object.defineProperty(Qu, "__esModule", {
    value: !0
  });
  Qu.buildDynamicImport = Kue;
  var Wt = bt();
  Qu.getDynamicImportSource = /* @__PURE__ */ s(function(t) {
    let [r] = t.arguments;
    return Wt.types.isStringLiteral(r) || Wt.types.isTemplateLiteral(r) ? r : Wt.template.expression.ast`\`\${${r}}\``;
  }, "getDynamicImportSource");
  function Kue(e, t, r, n) {
    let i = Wt.types.isCallExpression(e) ? e.arguments[0] : e.source;
    if (Wt.types.isStringLiteral(i) || Wt.types.isTemplateLiteral(i) && i.quasis.length === 0)
      return t ? Wt.template.expression.ast`
        Promise.resolve().then(() => ${n(i)})
      ` : n(i);
    let a = Wt.types.isTemplateLiteral(i) ? Wt.types.identifier("specifier") : Wt.types.templateLiteral([Wt.types.templateElement({
      raw: ""
    }), Wt.types.templateElement({
      raw: ""
    })], [Wt.types.identifier("specifier")]);
    return t ? Wt.template.expression.ast`
      (specifier =>
        new Promise(r => r(${a}))
          .then(s => ${n(Wt.types.identifier("s"))})
      )(${i})
    ` : r ? Wt.template.expression.ast`
      (specifier =>
        new Promise(r => r(${n(a)}))
      )(${i})
    ` : Wt.template.expression.ast`
      (specifier => ${n(a)})(${i})
    `;
  }
  s(Kue, "buildDynamicImport");
});

// ../node_modules/@babel/helper-module-transforms/lib/get-module-name.js
var lC = T((Zu) => {
  "use strict";
  Object.defineProperty(Zu, "__esModule", {
    value: !0
  });
  Zu.default = Gy;
  {
    let e = Gy;
    Zu.default = Gy = /* @__PURE__ */ s(function(r, n) {
      var i, a, o, l;
      return e(r, {
        moduleId: (i = n.moduleId) != null ? i : r.moduleId,
        moduleIds: (a = n.moduleIds) != null ? a : r.moduleIds,
        getModuleId: (o = n.getModuleId) != null ? o : r.getModuleId,
        moduleRoot: (l = n.moduleRoot) != null ? l : r.moduleRoot
      });
    }, "getModuleName");
  }
  function Gy(e, t) {
    let {
      filename: r,
      filenameRelative: n = r,
      sourceRoot: i = t.moduleRoot
    } = e, {
      moduleId: a,
      moduleIds: o = !!a,
      getModuleId: l,
      moduleRoot: u = i
    } = t;
    if (!o) return null;
    if (a != null && !l)
      return a;
    let c = u != null ? u + "/" : "";
    if (n) {
      let f = i != null ? new RegExp("^" + i + "/?") : "";
      c += n.replace(f, "").replace(/\.\w*$/, "");
    }
    return c = c.replace(/\\/g, "/"), l && l(c) || c;
  }
  s(Gy, "getModuleName");
});

// ../node_modules/@babel/helper-module-transforms/lib/index.js
var So = T((Er) => {
  "use strict";
  Object.defineProperty(Er, "__esModule", {
    value: !0
  });
  Object.defineProperty(Er, "buildDynamicImport", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Yue.buildDynamicImport;
    }, "get")
  });
  Er.buildNamespaceInitStatements = Zue;
  Er.ensureStatementsHoisted = Xue;
  Object.defineProperty(Er, "getModuleName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return zue.default;
    }, "get")
  });
  Object.defineProperty(Er, "hasExports", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return xo.hasExports;
    }, "get")
  });
  Object.defineProperty(Er, "isModule", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return uC.isModule;
    }, "get")
  });
  Object.defineProperty(Er, "isSideEffectImport", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return xo.isSideEffectImport;
    }, "get")
  });
  Er.rewriteModuleStatementsAndPrepareHeader = Jue;
  Object.defineProperty(Er, "rewriteThis", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return cC.default;
    }, "get")
  });
  Er.wrapInterop = Que;
  var Gue = ie("assert"), Ke = bt(), uC = XA(), cC = eC(), Hue = nC(), xo = Wy(), Jy = oC(), Yue = Ky(), zue = lC();
  Er.getDynamicImportSource = Ky().getDynamicImportSource;
  function Jue(e, {
    exportName: t,
    strict: r,
    allowTopLevelThis: n,
    strictMode: i,
    noInterop: a,
    importInterop: o = a ? "none" : "babel",
    lazy: l,
    getWrapperPayload: u = Jy.toGetWrapperPayload(l ?? !1),
    wrapReference: c = Jy.wrapReference,
    esNamespaceOnly: f,
    filename: p,
    constantReexports: h = arguments[1].loose,
    enumerableModuleMeta: y = arguments[1].loose,
    noIncompleteNsImportDetection: v
  }) {
    (0, xo.validateImportInteropOption)(o), Gue((0, uC.isModule)(e), "Cannot process module statements in a script"), e.node.sourceType = "s\
cript";
    let d = (0, xo.default)(e, t, {
      importInterop: o,
      initializeReexports: h,
      getWrapperPayload: u,
      esNamespaceOnly: f,
      filename: p
    });
    n || (0, cC.default)(e), (0, Hue.default)(e, d, c), i !== !1 && (e.node.directives.some((O) => O.value.value === "use strict") || e.unshiftContainer(
    "directives", Ke.types.directive(Ke.types.directiveLiteral("use strict"))));
    let b = [];
    (0, xo.hasExports)(d) && !r && b.push(ece(d, y));
    let E = rce(e, d);
    return E && (d.exportNameListName = E.name, b.push(E.statement)), b.push(...nce(e, d, c, h, v)), {
      meta: d,
      headers: b
    };
  }
  s(Jue, "rewriteModuleStatementsAndPrepareHeader");
  function Xue(e) {
    e.forEach((t) => {
      t._blockHoist = 3;
    });
  }
  s(Xue, "ensureStatementsHoisted");
  function Que(e, t, r) {
    if (r === "none")
      return null;
    if (r === "node-namespace")
      return Ke.types.callExpression(e.hub.addHelper("interopRequireWildcard"), [t, Ke.types.booleanLiteral(!0)]);
    if (r === "node-default")
      return null;
    let n;
    if (r === "default")
      n = "interopRequireDefault";
    else if (r === "namespace")
      n = "interopRequireWildcard";
    else
      throw new Error(`Unknown interop: ${r}`);
    return Ke.types.callExpression(e.hub.addHelper(n), [t]);
  }
  s(Que, "wrapInterop");
  function Zue(e, t, r = !1, n = Jy.wrapReference) {
    var i;
    let a = [], o = Ke.types.identifier(t.name);
    for (let u of t.importsNamespace)
      u !== t.name && a.push(Ke.template.statement`var NAME = SOURCE;`({
        NAME: u,
        SOURCE: Ke.types.cloneNode(o)
      }));
    let l = (i = n(o, t.wrap)) != null ? i : o;
    r && a.push(...fC(e, t, !0, n));
    for (let u of t.reexportNamespace)
      a.push((Ke.types.isIdentifier(l) ? Ke.template.statement`EXPORTS.NAME = NAMESPACE;` : Ke.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `)({
        EXPORTS: e.exportName,
        NAME: u,
        NAMESPACE: Ke.types.cloneNode(l)
      }));
    if (t.reexportAll) {
      let u = tce(e, Ke.types.cloneNode(l), r);
      u.loc = t.reexportAll.loc, a.push(u);
    }
    return a;
  }
  s(Zue, "buildNamespaceInitStatements");
  var Hy = {
    constant: /* @__PURE__ */ s(({
      exports: e,
      exportName: t,
      namespaceImport: r
    }) => Ke.template.statement.ast`
      ${e}.${t} = ${r};
    `, "constant"),
    constantComputed: /* @__PURE__ */ s(({
      exports: e,
      exportName: t,
      namespaceImport: r
    }) => Ke.template.statement.ast`
      ${e}["${t}"] = ${r};
    `, "constantComputed"),
    spec: /* @__PURE__ */ s(({
      exports: e,
      exportName: t,
      namespaceImport: r
    }) => Ke.template.statement.ast`
      Object.defineProperty(${e}, "${t}", {
        enumerable: true,
        get: function() {
          return ${r};
        },
      });
    `, "spec")
  };
  function fC(e, t, r, n) {
    var i;
    let a = Ke.types.identifier(t.name);
    a = (i = n(a, t.wrap)) != null ? i : a;
    let {
      stringSpecifiers: o
    } = e;
    return Array.from(t.reexports, ([l, u]) => {
      let c = Ke.types.cloneNode(a);
      u === "default" && t.interop === "node-default" || (o.has(u) ? c = Ke.types.memberExpression(c, Ke.types.stringLiteral(u), !0) : c = Ke.
      types.memberExpression(c, Ke.types.identifier(u)));
      let f = {
        exports: e.exportName,
        exportName: l,
        namespaceImport: c
      };
      return r || Ke.types.isIdentifier(c) ? o.has(l) ? Hy.constantComputed(f) : Hy.constant(f) : Hy.spec(f);
    });
  }
  s(fC, "buildReexportsFromMeta");
  function ece(e, t = !1) {
    return (t ? Ke.template.statement`
        EXPORTS.__esModule = true;
      ` : Ke.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({
      EXPORTS: e.exportName
    });
  }
  s(ece, "buildESModuleHeader");
  function tce(e, t, r) {
    return (r ? Ke.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : Ke.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({
      NAMESPACE: t,
      EXPORTS: e.exportName,
      VERIFY_NAME_LIST: e.exportNameListName ? (0, Ke.template)`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({
        EXPORTS_LIST: e.exportNameListName
      }) : null
    });
  }
  s(tce, "buildNamespaceReexport");
  function rce(e, t) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let a of t.local.values())
      for (let o of a.names)
        r[o] = !0;
    let n = !1;
    for (let a of t.source.values()) {
      for (let o of a.reexports.keys())
        r[o] = !0;
      for (let o of a.reexportNamespace)
        r[o] = !0;
      n = n || !!a.reexportAll;
    }
    if (!n || Object.keys(r).length === 0) return null;
    let i = e.scope.generateUidIdentifier("exportNames");
    return delete r.default, {
      name: i.name,
      statement: Ke.types.variableDeclaration("var", [Ke.types.variableDeclarator(i, Ke.types.valueToNode(r))])
    };
  }
  s(rce, "buildExportNameListDeclaration");
  function nce(e, t, r, n = !1, i = !1) {
    let a = [];
    for (let [l, u] of t.local)
      if (u.kind !== "import") {
        if (u.kind === "hoisted")
          a.push([u.names[0], zy(t, u.names, Ke.types.identifier(l))]);
        else if (!i)
          for (let c of u.names)
            a.push([c, null]);
      }
    for (let l of t.source.values()) {
      if (!n) {
        let u = fC(t, l, !1, r), c = [...l.reexports.keys()];
        for (let f = 0; f < u.length; f++)
          a.push([c[f], u[f]]);
      }
      if (!i)
        for (let u of l.reexportNamespace)
          a.push([u, null]);
    }
    a.sort(([l], [u]) => l < u ? -1 : u < l ? 1 : 0);
    let o = [];
    if (i)
      for (let [, l] of a)
        o.push(l);
    else
      for (let u = 0; u < a.length; u += 100) {
        let c = [];
        for (let f = 0; f < 100 && u + f < a.length; f++) {
          let [p, h] = a[u + f];
          h !== null ? (c.length > 0 && (o.push(zy(t, c, e.scope.buildUndefinedNode())), c = []), o.push(h)) : c.push(p);
        }
        c.length > 0 && o.push(zy(t, c, e.scope.buildUndefinedNode()));
      }
    return o;
  }
  s(nce, "buildExportInitializationStatements");
  var Yy = {
    computed: /* @__PURE__ */ s(({
      exports: e,
      name: t,
      value: r
    }) => Ke.template.expression.ast`${e}["${t}"] = ${r}`, "computed"),
    default: /* @__PURE__ */ s(({
      exports: e,
      name: t,
      value: r
    }) => Ke.template.expression.ast`${e}.${t} = ${r}`, "default"),
    define: /* @__PURE__ */ s(({
      exports: e,
      name: t,
      value: r
    }) => Ke.template.expression.ast`
      Object.defineProperty(${e}, "${t}", {
        enumerable: true,
        value: void 0,
        writable: true
      })["${t}"] = ${r}`, "define")
  };
  function zy(e, t, r) {
    let {
      stringSpecifiers: n,
      exportName: i
    } = e;
    return Ke.types.expressionStatement(t.reduce((a, o) => {
      let l = {
        exports: i,
        name: o,
        value: a
      };
      return o === "__proto__" ? Yy.define(l) : n.has(o) ? Yy.computed(l) : Yy.default(l);
    }, r));
  }
  s(zy, "buildInitStatement");
});

// ../node_modules/@babel/core/lib/transformation/file/babel-7-helpers.cjs
var dC = T((pC) => {
  pC.getModuleName = () => So().getModuleName;
});

// ../node_modules/@babel/core/lib/transformation/file/file.js
var Qy = T((tc) => {
  "use strict";
  Object.defineProperty(tc, "__esModule", {
    value: !0
  });
  tc.default = void 0;
  function Po() {
    let e = om();
    return Po = /* @__PURE__ */ s(function() {
      return e;
    }, "helpers"), e;
  }
  s(Po, "helpers");
  function Xy() {
    let e = _r();
    return Xy = /* @__PURE__ */ s(function() {
      return e;
    }, "_traverse"), e;
  }
  s(Xy, "_traverse");
  function hC() {
    let e = to();
    return hC = /* @__PURE__ */ s(function() {
      return e;
    }, "_codeFrame"), e;
  }
  s(hC, "_codeFrame");
  function mC() {
    let e = Pe();
    return mC = /* @__PURE__ */ s(function() {
      return e;
    }, "_t"), e;
  }
  s(mC, "_t");
  function ec() {
    let e = ie("semver");
    return ec = /* @__PURE__ */ s(function() {
      return e;
    }, "_semver"), e;
  }
  s(ec, "_semver");
  var sce = ice(dC(), !0);
  function yC(e) {
    if (typeof WeakMap != "function") return null;
    var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (yC = /* @__PURE__ */ s(function(n) {
      return n ? r : t;
    }, "_getRequireWildcardCache"))(e);
  }
  s(yC, "_getRequireWildcardCache");
  function ice(e, t) {
    if (!t && e && e.__esModule) return e;
    if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
    var r = yC(t);
    if (r && r.has(e)) return r.get(e);
    var n = { __proto__: null }, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in e) if (a !== "default" && {}.hasOwnProperty.call(e, a)) {
      var o = i ? Object.getOwnPropertyDescriptor(e, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(n, a, o) : n[a] = e[a];
    }
    return n.default = e, r && r.set(e, n), n;
  }
  s(ice, "_interopRequireWildcard");
  var {
    cloneNode: ace,
    interpreterDirective: oce
  } = mC(), lce = {
    enter(e, t) {
      let r = e.node.loc;
      r && (t.loc = r, e.stop());
    }
  }, Gi = class {
    static {
      s(this, "File");
    }
    constructor(t, {
      code: r,
      ast: n,
      inputMap: i
    }) {
      this._map = /* @__PURE__ */ new Map(), this.opts = void 0, this.declarations = {}, this.path = void 0, this.ast = void 0, this.scope =
      void 0, this.metadata = {}, this.code = "", this.inputMap = void 0, this.hub = {
        file: this,
        getCode: /* @__PURE__ */ s(() => this.code, "getCode"),
        getScope: /* @__PURE__ */ s(() => this.scope, "getScope"),
        addHelper: this.addHelper.bind(this),
        buildError: this.buildCodeFrameError.bind(this)
      }, this.opts = t, this.code = r, this.ast = n, this.inputMap = i, this.path = Xy().NodePath.get({
        hub: this.hub,
        parentPath: null,
        parent: this.ast,
        container: this.ast,
        key: "program"
      }).setContext(), this.scope = this.path.scope;
    }
    get shebang() {
      let {
        interpreter: t
      } = this.path.node;
      return t ? t.value : "";
    }
    set shebang(t) {
      t ? this.path.get("interpreter").replaceWith(oce(t)) : this.path.get("interpreter").remove();
    }
    set(t, r) {
      if (t === "helpersNamespace")
        throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-\
helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to \
explore using 'helperGenerator' alongside 'file.availableHelper()'.");
      this._map.set(t, r);
    }
    get(t) {
      return this._map.get(t);
    }
    has(t) {
      return this._map.has(t);
    }
    availableHelper(t, r) {
      let n;
      try {
        n = Po().minVersion(t);
      } catch (i) {
        if (i.code !== "BABEL_HELPER_UNKNOWN") throw i;
        return !1;
      }
      return typeof r != "string" ? !0 : (ec().valid(r) && (r = `^${r}`), !ec().intersects(`<${n}`, r) && !ec().intersects(">=8.0.0", r));
    }
    addHelper(t) {
      let r = this.declarations[t];
      if (r) return ace(r);
      let n = this.get("helperGenerator");
      if (n) {
        let c = n(t);
        if (c) return c;
      }
      Po().minVersion(t);
      let i = this.declarations[t] = this.scope.generateUidIdentifier(t), a = {};
      for (let c of Po().getDependencies(t))
        a[c] = this.addHelper(c);
      let {
        nodes: o,
        globals: l
      } = Po().get(t, (c) => a[c], i.name, Object.keys(this.scope.getAllBindings()));
      l.forEach((c) => {
        this.path.scope.hasBinding(c, !0) && this.path.scope.rename(c);
      }), o.forEach((c) => {
        c._compact = !0;
      });
      let u = this.path.unshiftContainer("body", o);
      for (let c of u)
        c.isVariableDeclaration() && this.scope.registerDeclaration(c);
      return i;
    }
    buildCodeFrameError(t, r, n = SyntaxError) {
      let i = t?.loc;
      if (!i && t) {
        let a = {
          loc: null
        };
        (0, Xy().default)(t, lce, this.scope, a), i = a.loc;
        let o = "This is an error on an internal node. Probably an internal error.";
        i && (o += " Location has been estimated."), r += ` (${o})`;
      }
      if (i) {
        let {
          highlightCode: a = !0
        } = this.opts;
        r += `
` + (0, hC().codeFrameColumns)(this.code, {
          start: {
            line: i.start.line,
            column: i.start.column + 1
          },
          end: i.end && i.start.line === i.end.line ? {
            line: i.end.line,
            column: i.end.column + 1
          } : void 0
        }, {
          highlightCode: a
        });
      }
      return new n(r);
    }
  };
  tc.default = Gi;
  Gi.prototype.addImport = /* @__PURE__ */ s(function() {
    throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-mo\
dule-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
  }, "addImport"), Gi.prototype.addTemplateObject = /* @__PURE__ */ s(function() {
    throw new Error("This function has been moved into the template literal transform itself.");
  }, "addTemplateObject"), Gi.prototype.getModuleName = /* @__PURE__ */ s(function() {
    return sce.getModuleName()(this.opts, this.opts);
  }, "getModuleName");
});

// ../node_modules/@babel/core/lib/tools/build-external-helpers.js
var TC = T((i0) => {
  "use strict";
  Object.defineProperty(i0, "__esModule", {
    value: !0
  });
  i0.default = Pce;
  function Zy() {
    let e = om();
    return Zy = /* @__PURE__ */ s(function() {
      return e;
    }, "helpers"), e;
  }
  s(Zy, "helpers");
  function gC() {
    let e = fo();
    return gC = /* @__PURE__ */ s(function() {
      return e;
    }, "_generator"), e;
  }
  s(gC, "_generator");
  function bC() {
    let e = Ni();
    return bC = /* @__PURE__ */ s(function() {
      return e;
    }, "_template"), e;
  }
  s(bC, "_template");
  function EC() {
    let e = Pe();
    return EC = /* @__PURE__ */ s(function() {
      return e;
    }, "_t"), e;
  }
  s(EC, "_t");
  var {
    arrayExpression: uce,
    assignmentExpression: rc,
    binaryExpression: cce,
    blockStatement: fce,
    callExpression: pce,
    cloneNode: dce,
    conditionalExpression: hce,
    exportNamedDeclaration: mce,
    exportSpecifier: yce,
    expressionStatement: e0,
    functionExpression: gce,
    identifier: Kt,
    memberExpression: t0,
    objectExpression: r0,
    program: nc,
    stringLiteral: vC,
    unaryExpression: bce,
    variableDeclaration: n0,
    variableDeclarator: s0
  } = EC(), Ece = /* @__PURE__ */ s((e) => bC().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(e), "buildUmdWrapper");
  function vce(e) {
    let t = Kt("babelHelpers"), r = [], n = gce(null, [Kt("global")], fce(r)), i = nc([e0(pce(n, [hce(cce("===", bce("typeof", Kt("global")),
    vC("undefined")), Kt("self"), Kt("global"))]))]);
    return r.push(n0("var", [s0(t, rc("=", t0(Kt("global"), t), r0([])))])), sc(r, t, e), i;
  }
  s(vce, "buildGlobal");
  function Tce(e) {
    let t = [], r = sc(t, null, e);
    return t.unshift(mce(null, Object.keys(r).map((n) => yce(dce(r[n]), Kt(n))))), nc(t, [], "module");
  }
  s(Tce, "buildModule");
  function xce(e) {
    let t = Kt("babelHelpers"), r = [];
    return r.push(n0("var", [s0(t, Kt("global"))])), sc(r, t, e), nc([Ece({
      FACTORY_PARAMETERS: Kt("global"),
      BROWSER_ARGUMENTS: rc("=", t0(Kt("root"), t), r0([])),
      COMMON_ARGUMENTS: Kt("exports"),
      AMD_ARGUMENTS: uce([vC("exports")]),
      FACTORY_BODY: r,
      UMD_ROOT: Kt("this")
    })]);
  }
  s(xce, "buildUmd");
  function Sce(e) {
    let t = Kt("babelHelpers"), r = [];
    r.push(n0("var", [s0(t, r0([]))]));
    let n = nc(r);
    return sc(r, t, e), r.push(e0(t)), n;
  }
  s(Sce, "buildVar");
  function sc(e, t, r) {
    let n = /* @__PURE__ */ s((a) => t ? t0(t, Kt(a)) : Kt(`_${a}`), "getHelperReference"), i = {};
    return Zy().list.forEach(function(a) {
      if (r && !r.includes(a)) return;
      let o = i[a] = n(a), {
        nodes: l
      } = Zy().get(a, n, t ? null : `_${a}`, [], t ? (u, c, f) => {
        f((p) => rc("=", o, p)), u.body.push(e0(rc("=", o, Kt(c))));
      } : null);
      e.push(...l);
    }), i;
  }
  s(sc, "buildHelpers");
  function Pce(e, t = "global") {
    let r, n = {
      global: vce,
      module: Tce,
      umd: xce,
      var: Sce
    }[t];
    if (n)
      r = n(e);
    else
      throw new Error(`Unsupported output type ${t}`);
    return (0, gC().default)(r).code;
  }
  s(Pce, "_default");
});

// ../node_modules/gensync/index.js
var vr = T((_2e, IC) => {
  "use strict";
  var SC = Symbol.for("gensync:v1:start"), PC = Symbol.for("gensync:v1:suspend"), Ace = "GENSYNC_EXPECTED_START", Cce = "GENSYNC_EXPECTED_SU\
SPEND", AC = "GENSYNC_OPTIONS_ERROR", xC = "GENSYNC_RACE_NONEMPTY", wce = "GENSYNC_ERRBACK_NO_CALLBACK";
  IC.exports = Object.assign(
    /* @__PURE__ */ s(function(t) {
      let r = t;
      return typeof t != "function" ? r = Ice(t) : r = _ce(t), Object.assign(r, Dce(r));
    }, "gensync"),
    {
      all: a0({
        name: "all",
        arity: 1,
        sync: /* @__PURE__ */ s(function(e) {
          return Array.from(e[0]).map((r) => o0(r));
        }, "sync"),
        async: /* @__PURE__ */ s(function(e, t, r) {
          let n = Array.from(e[0]);
          if (n.length === 0) {
            Promise.resolve().then(() => t([]));
            return;
          }
          let i = 0, a = n.map(() => {
          });
          n.forEach((o, l) => {
            ic(
              o,
              (u) => {
                a[l] = u, i += 1, i === a.length && t(a);
              },
              r
            );
          });
        }, "async")
      }),
      race: a0({
        name: "race",
        arity: 1,
        sync: /* @__PURE__ */ s(function(e) {
          let t = Array.from(e[0]);
          if (t.length === 0)
            throw Zs("Must race at least 1 item", xC);
          return o0(t[0]);
        }, "sync"),
        async: /* @__PURE__ */ s(function(e, t, r) {
          let n = Array.from(e[0]);
          if (n.length === 0)
            throw Zs("Must race at least 1 item", xC);
          for (let i of n)
            ic(i, t, r);
        }, "async")
      })
    }
  );
  function Dce(e) {
    return {
      sync: /* @__PURE__ */ s(function(...r) {
        return o0(e.apply(this, r));
      }, "sync"),
      async: /* @__PURE__ */ s(function(...r) {
        return new Promise((n, i) => {
          ic(e.apply(this, r), n, i);
        });
      }, "async"),
      errback: /* @__PURE__ */ s(function(...r) {
        let n = r.pop();
        if (typeof n != "function")
          throw Zs(
            "Asynchronous function called without callback",
            wce
          );
        let i;
        try {
          i = e.apply(this, r);
        } catch (a) {
          n(a);
          return;
        }
        ic(i, (a) => n(void 0, a), (a) => n(a));
      }, "errback")
    };
  }
  s(Dce, "makeFunctionAPI");
  function Ao(e, t, r, n) {
    if (typeof r === e || n && typeof r > "u")
      return;
    let i;
    throw n ? i = `Expected opts.${t} to be either a ${e}, or undefined.` : i = `Expected opts.${t} to be a ${e}.`, Zs(i, AC);
  }
  s(Ao, "assertTypeof");
  function Zs(e, t) {
    return Object.assign(new Error(e), { code: t });
  }
  s(Zs, "makeError");
  function Ice({ name: e, arity: t, sync: r, async: n, errback: i }) {
    if (Ao(
      "string",
      "name",
      e,
      !0
      /* allowUndefined */
    ), Ao(
      "number",
      "arity",
      t,
      !0
      /* allowUndefined */
    ), Ao("function", "sync", r), Ao(
      "function",
      "async",
      n,
      !0
      /* allowUndefined */
    ), Ao(
      "function",
      "errback",
      i,
      !0
      /* allowUndefined */
    ), n && i)
      throw Zs(
        "Expected one of either opts.async or opts.errback, but got _both_.",
        AC
      );
    if (typeof e != "string") {
      let a;
      i && i.name && i.name !== "errback" && (a = i.name), n && n.name && n.name !== "async" && (a = n.name.replace(/Async$/, "")), r && r.name &&
      r.name !== "sync" && (a = r.name.replace(/Sync$/, "")), typeof a == "string" && (e = a);
    }
    return typeof t != "number" && (t = r.length), a0({
      name: e,
      arity: t,
      sync: /* @__PURE__ */ s(function(a) {
        return r.apply(this, a);
      }, "sync"),
      async: /* @__PURE__ */ s(function(a, o, l) {
        n ? n.apply(this, a).then(o, l) : i ? i.call(this, ...a, (u, c) => {
          u == null ? o(c) : l(u);
        }) : o(r.apply(this, a));
      }, "async")
    });
  }
  s(Ice, "newGenerator");
  function _ce(e) {
    return DC(e.name, e.length, function(...t) {
      return e.apply(this, t);
    });
  }
  s(_ce, "wrapGenerator");
  function a0({ name: e, arity: t, sync: r, async: n }) {
    return DC(e, t, function* (...i) {
      let a = yield SC;
      if (!a)
        return r.call(this, i);
      let o;
      try {
        n.call(
          this,
          i,
          (l) => {
            o || (o = { value: l }, a());
          },
          (l) => {
            o || (o = { err: l }, a());
          }
        );
      } catch (l) {
        o = { err: l }, a();
      }
      if (yield PC, o.hasOwnProperty("err"))
        throw o.err;
      return o.value;
    });
  }
  s(a0, "buildOperation");
  function o0(e) {
    let t;
    for (; !({ value: t } = e.next()).done; )
      CC(t, e);
    return t;
  }
  s(o0, "evaluateSync");
  function ic(e, t, r) {
    (/* @__PURE__ */ s(function n() {
      try {
        let i;
        for (; !({ value: i } = e.next()).done; ) {
          CC(i, e);
          let a = !0, o = !1, l = e.next(() => {
            a ? o = !0 : n();
          });
          if (a = !1, Oce(l, e), !o)
            return;
        }
        return t(i);
      } catch (i) {
        return r(i);
      }
    }, "step"))();
  }
  s(ic, "evaluateAsync");
  function CC(e, t) {
    e !== SC && wC(
      t,
      Zs(
        `Got unexpected yielded value in gensync generator: ${JSON.stringify(
          e
        )}. Did you perhaps mean to use 'yield*' instead of 'yield'?`,
        Ace
      )
    );
  }
  s(CC, "assertStart");
  function Oce({ value: e, done: t }, r) {
    !t && e === PC || wC(
      r,
      Zs(
        t ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(
          e
        )}. If you get this, it is probably a gensync bug.`,
        Cce
      )
    );
  }
  s(Oce, "assertSuspend");
  function wC(e, t) {
    throw e.throw && e.throw(t), t;
  }
  s(wC, "throwError");
  function DC(e, t, r) {
    if (typeof e == "string") {
      let n = Object.getOwnPropertyDescriptor(r, "name");
      (!n || n.configurable) && Object.defineProperty(
        r,
        "name",
        Object.assign(n || {}, {
          configurable: !0,
          value: e
        })
      );
    }
    if (typeof t == "number") {
      let n = Object.getOwnPropertyDescriptor(r, "length");
      (!n || n.configurable) && Object.defineProperty(
        r,
        "length",
        Object.assign(n || {}, {
          configurable: !0,
          value: t
        })
      );
    }
    return r;
  }
  s(DC, "setFunctionMetadata");
});

// ../node_modules/@babel/core/lib/gensync-utils/async.js
var Hi = T((zr) => {
  "use strict";
  Object.defineProperty(zr, "__esModule", {
    value: !0
  });
  zr.forwardAsync = kce;
  zr.isAsync = void 0;
  zr.isThenable = BC;
  zr.maybeAsync = Nce;
  zr.waitFor = zr.onFirstPause = void 0;
  function ys() {
    let e = vr();
    return ys = /* @__PURE__ */ s(function() {
      return e;
    }, "_gensync"), e;
  }
  s(ys, "_gensync");
  function _C(e, t, r, n, i, a, o) {
    try {
      var l = e[a](o), u = l.value;
    } catch (c) {
      r(c);
      return;
    }
    l.done ? t(u) : Promise.resolve(u).then(n, i);
  }
  s(_C, "asyncGeneratorStep");
  function NC(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(n, i) {
        var a = e.apply(t, r);
        function o(u) {
          _C(a, n, i, o, l, "next", u);
        }
        s(o, "_next");
        function l(u) {
          _C(a, n, i, o, l, "throw", u);
        }
        s(l, "_throw"), o(void 0);
      });
    };
  }
  s(NC, "_asyncToGenerator");
  var OC = ys()(function* (e) {
    return yield* e;
  }), N2e = zr.isAsync = ys()({
    sync: /* @__PURE__ */ s(() => !1, "sync"),
    errback: /* @__PURE__ */ s((e) => e(null, !0), "errback")
  });
  function Nce(e, t) {
    return ys()({
      sync(...r) {
        let n = e.apply(this, r);
        if (BC(n)) throw new Error(t);
        return n;
      },
      async(...r) {
        return Promise.resolve(e.apply(this, r));
      }
    });
  }
  s(Nce, "maybeAsync");
  var Bce = ys()({
    sync: /* @__PURE__ */ s((e) => e("sync"), "sync"),
    async: function() {
      var e = NC(function* (t) {
        return t("async");
      });
      return /* @__PURE__ */ s(function(r) {
        return e.apply(this, arguments);
      }, "async");
    }()
  });
  function kce(e, t) {
    let r = ys()(e);
    return Bce((n) => {
      let i = r[n];
      return t(i);
    });
  }
  s(kce, "forwardAsync");
  var B2e = zr.onFirstPause = ys()({
    name: "onFirstPause",
    arity: 2,
    sync: /* @__PURE__ */ s(function(e) {
      return OC.sync(e);
    }, "sync"),
    errback: /* @__PURE__ */ s(function(e, t, r) {
      let n = !1;
      OC.errback(e, (i, a) => {
        n = !0, r(i, a);
      }), n || t();
    }, "errback")
  }), k2e = zr.waitFor = ys()({
    sync: /* @__PURE__ */ s((e) => e, "sync"),
    async: function() {
      var e = NC(function* (t) {
        return t;
      });
      return /* @__PURE__ */ s(function(r) {
        return e.apply(this, arguments);
      }, "async");
    }()
  });
  function BC(e) {
    return !!e && (typeof e == "object" || typeof e == "function") && !!e.then && typeof e.then == "function";
  }
  s(BC, "isThenable");
});

// ../node_modules/@babel/core/lib/config/util.js
var oc = T((ac) => {
  "use strict";
  Object.defineProperty(ac, "__esModule", {
    value: !0
  });
  ac.isIterableIterator = Lce;
  ac.mergeOptions = Fce;
  function Fce(e, t) {
    for (let r of Object.keys(t))
      if ((r === "parserOpts" || r === "generatorOpts" || r === "assumptions") && t[r]) {
        let n = t[r], i = e[r] || (e[r] = {});
        jce(i, n);
      } else {
        let n = t[r];
        n !== void 0 && (e[r] = n);
      }
  }
  s(Fce, "mergeOptions");
  function jce(e, t) {
    for (let r of Object.keys(t)) {
      let n = t[r];
      n !== void 0 && (e[r] = n);
    }
  }
  s(jce, "mergeDefaultFields");
  function Lce(e) {
    return !!e && typeof e.next == "function" && typeof e[Symbol.iterator] == "function";
  }
  s(Lce, "isIterableIterator");
});

// ../node_modules/@babel/core/lib/config/caching.js
var ti = T((ei) => {
  "use strict";
  Object.defineProperty(ei, "__esModule", {
    value: !0
  });
  ei.assertSimpleType = lc;
  ei.makeStrongCache = MC;
  ei.makeStrongCacheSync = Uce;
  ei.makeWeakCache = LC;
  ei.makeWeakCacheSync = qce;
  function FC() {
    let e = vr();
    return FC = /* @__PURE__ */ s(function() {
      return e;
    }, "_gensync"), e;
  }
  s(FC, "_gensync");
  var Yi = Hi(), Mce = oc(), jC = /* @__PURE__ */ s((e) => FC()(e).sync, "synchronize");
  function* Rce() {
    return !0;
  }
  s(Rce, "genTrue");
  function LC(e) {
    return RC(WeakMap, e);
  }
  s(LC, "makeWeakCache");
  function qce(e) {
    return jC(LC(e));
  }
  s(qce, "makeWeakCacheSync");
  function MC(e) {
    return RC(Map, e);
  }
  s(MC, "makeStrongCache");
  function Uce(e) {
    return jC(MC(e));
  }
  s(Uce, "makeStrongCacheSync");
  function RC(e, t) {
    let r = new e(), n = new e(), i = new e();
    return /* @__PURE__ */ s(function* (o, l) {
      let u = yield* (0, Yi.isAsync)(), c = u ? n : r, f = yield* Vce(u, c, i, o, l);
      if (f.valid) return f.value;
      let p = new l0(l), h = t(o, p), y, v;
      return (0, Mce.isIterableIterator)(h) ? v = yield* (0, Yi.onFirstPause)(h, () => {
        y = $ce(p, i, o);
      }) : v = h, qC(c, p, o, v), y && (i.delete(o), y.release(v)), v;
    }, "cachedFunction");
  }
  s(RC, "makeCachedFunction");
  function* kC(e, t, r) {
    let n = e.get(t);
    if (n) {
      for (let {
        value: i,
        valid: a
      } of n)
        if (yield* a(r)) return {
          valid: !0,
          value: i
        };
    }
    return {
      valid: !1,
      value: null
    };
  }
  s(kC, "getCachedValue");
  function* Vce(e, t, r, n, i) {
    let a = yield* kC(t, n, i);
    if (a.valid)
      return a;
    if (e) {
      let o = yield* kC(r, n, i);
      if (o.valid)
        return {
          valid: !0,
          value: yield* (0, Yi.waitFor)(o.value.promise)
        };
    }
    return {
      valid: !1,
      value: null
    };
  }
  s(Vce, "getCachedValueOrWait");
  function $ce(e, t, r) {
    let n = new u0();
    return qC(t, e, r, n), n;
  }
  s($ce, "setupAsyncLocks");
  function qC(e, t, r, n) {
    t.configured() || t.forever();
    let i = e.get(r);
    switch (t.deactivate(), t.mode()) {
      case "forever":
        i = [{
          value: n,
          valid: Rce
        }], e.set(r, i);
        break;
      case "invalidate":
        i = [{
          value: n,
          valid: t.validator()
        }], e.set(r, i);
        break;
      case "valid":
        i ? i.push({
          value: n,
          valid: t.validator()
        }) : (i = [{
          value: n,
          valid: t.validator()
        }], e.set(r, i));
    }
  }
  s(qC, "updateFunctionCache");
  var l0 = class {
    static {
      s(this, "CacheConfigurator");
    }
    constructor(t) {
      this._active = !0, this._never = !1, this._forever = !1, this._invalidate = !1, this._configured = !1, this._pairs = [], this._data = void 0,
      this._data = t;
    }
    simple() {
      return Wce(this);
    }
    mode() {
      return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
    }
    forever() {
      if (!this._active)
        throw new Error("Cannot change caching after evaluation has completed.");
      if (this._never)
        throw new Error("Caching has already been configured with .never()");
      this._forever = !0, this._configured = !0;
    }
    never() {
      if (!this._active)
        throw new Error("Cannot change caching after evaluation has completed.");
      if (this._forever)
        throw new Error("Caching has already been configured with .forever()");
      this._never = !0, this._configured = !0;
    }
    using(t) {
      if (!this._active)
        throw new Error("Cannot change caching after evaluation has completed.");
      if (this._never || this._forever)
        throw new Error("Caching has already been configured with .never or .forever()");
      this._configured = !0;
      let r = t(this._data), n = (0, Yi.maybeAsync)(t, "You appear to be using an async cache handler, but Babel has been called synchronous\
ly");
      return (0, Yi.isThenable)(r) ? r.then((i) => (this._pairs.push([i, n]), i)) : (this._pairs.push([r, n]), r);
    }
    invalidate(t) {
      return this._invalidate = !0, this.using(t);
    }
    validator() {
      let t = this._pairs;
      return function* (r) {
        for (let [n, i] of t)
          if (n !== (yield* i(r))) return !1;
        return !0;
      };
    }
    deactivate() {
      this._active = !1;
    }
    configured() {
      return this._configured;
    }
  };
  function Wce(e) {
    function t(r) {
      if (typeof r == "boolean") {
        r ? e.forever() : e.never();
        return;
      }
      return e.using(() => lc(r()));
    }
    return s(t, "cacheFn"), t.forever = () => e.forever(), t.never = () => e.never(), t.using = (r) => e.using(() => lc(r())), t.invalidate =
    (r) => e.invalidate(() => lc(r())), t;
  }
  s(Wce, "makeSimpleConfigurator");
  function lc(e) {
    if ((0, Yi.isThenable)(e))
      throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add suppo\
rt for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchron\
ously handle your caching logic.");
    if (e != null && typeof e != "string" && typeof e != "boolean" && typeof e != "number")
      throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
    return e;
  }
  s(lc, "assertSimpleType");
  var u0 = class {
    static {
      s(this, "Lock");
    }
    constructor() {
      this.released = !1, this.promise = void 0, this._resolve = void 0, this.promise = new Promise((t) => {
        this._resolve = t;
      });
    }
    release(t) {
      this.released = !0, this._resolve(t);
    }
  };
});

// ../node_modules/@babel/core/lib/gensync-utils/fs.js
var uc = T((zi) => {
  "use strict";
  Object.defineProperty(zi, "__esModule", {
    value: !0
  });
  zi.stat = zi.readFile = void 0;
  function Co() {
    let e = ie("fs");
    return Co = /* @__PURE__ */ s(function() {
      return e;
    }, "_fs"), e;
  }
  s(Co, "_fs");
  function c0() {
    let e = vr();
    return c0 = /* @__PURE__ */ s(function() {
      return e;
    }, "_gensync"), e;
  }
  s(c0, "_gensync");
  var U2e = zi.readFile = c0()({
    sync: Co().readFileSync,
    errback: Co().readFile
  }), V2e = zi.stat = c0()({
    sync: Co().statSync,
    errback: Co().stat
  });
});

// ../node_modules/@babel/core/lib/config/files/utils.js
var d0 = T((p0) => {
  "use strict";
  Object.defineProperty(p0, "__esModule", {
    value: !0
  });
  p0.makeStaticFileCache = Hce;
  var Kce = ti(), Gce = uc();
  function f0() {
    let e = ie("fs");
    return f0 = /* @__PURE__ */ s(function() {
      return e;
    }, "_fs2"), e;
  }
  s(f0, "_fs2");
  function Hce(e) {
    return (0, Kce.makeStrongCache)(function* (t, r) {
      return r.invalidate(() => Yce(t)) === null ? null : e(t, yield* Gce.readFile(t, "utf8"));
    });
  }
  s(Hce, "makeStaticFileCache");
  function Yce(e) {
    if (!f0().existsSync(e)) return null;
    try {
      return +f0().statSync(e).mtime;
    } catch (t) {
      if (t.code !== "ENOENT" && t.code !== "ENOTDIR") throw t;
    }
    return null;
  }
  s(Yce, "fileMtime");
});

// ../node_modules/@babel/core/lib/errors/rewrite-stack-trace.js
var Fn = T((Ji) => {
  "use strict";
  Object.defineProperty(Ji, "__esModule", {
    value: !0
  });
  Ji.beginHiddenCallStack = Qce;
  Ji.endHiddenCallStack = Zce;
  Ji.expectedError = Xce;
  Ji.injectVirtualStackFrame = Jce;
  var UC, VC = Function.call.bind(Error.prototype.toString), fc = !!Error.captureStackTrace && ((UC = Object.getOwnPropertyDescriptor(Error,
  "stackTraceLimit")) == null ? void 0 : UC.writable) === !0, $C = "startHiding - secret - don't use this - v1", WC = "stopHiding - secret -\
 don't use this - v1", KC = /* @__PURE__ */ new WeakSet(), cc = /* @__PURE__ */ new WeakMap();
  function zce(e) {
    return /* @__PURE__ */ Object.create({
      isNative: /* @__PURE__ */ s(() => !1, "isNative"),
      isConstructor: /* @__PURE__ */ s(() => !1, "isConstructor"),
      isToplevel: /* @__PURE__ */ s(() => !0, "isToplevel"),
      getFileName: /* @__PURE__ */ s(() => e, "getFileName"),
      getLineNumber: /* @__PURE__ */ s(() => {
      }, "getLineNumber"),
      getColumnNumber: /* @__PURE__ */ s(() => {
      }, "getColumnNumber"),
      getFunctionName: /* @__PURE__ */ s(() => {
      }, "getFunctionName"),
      getMethodName: /* @__PURE__ */ s(() => {
      }, "getMethodName"),
      getTypeName: /* @__PURE__ */ s(() => {
      }, "getTypeName"),
      toString: /* @__PURE__ */ s(() => e, "toString")
    });
  }
  s(zce, "CallSite");
  function Jce(e, t) {
    if (!fc) return;
    let r = cc.get(e);
    return r || cc.set(e, r = []), r.push(zce(t)), e;
  }
  s(Jce, "injectVirtualStackFrame");
  function Xce(e) {
    if (fc)
      return KC.add(e), e;
  }
  s(Xce, "expectedError");
  function Qce(e) {
    return fc ? Object.defineProperty(function(...t) {
      return GC(), e(...t);
    }, "name", {
      value: WC
    }) : e;
  }
  s(Qce, "beginHiddenCallStack");
  function Zce(e) {
    return fc ? Object.defineProperty(function(...t) {
      return e(...t);
    }, "name", {
      value: $C
    }) : e;
  }
  s(Zce, "endHiddenCallStack");
  function GC() {
    GC = /* @__PURE__ */ s(() => {
    }, "setupPrepareStackTrace");
    let {
      prepareStackTrace: e = efe
    } = Error, t = 50;
    Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, t)), Error.prepareStackTrace = /* @__PURE__ */ s(function(n, i) {
      let a = [], l = KC.has(n) ? "hiding" : "unknown";
      for (let u = 0; u < i.length; u++) {
        let c = i[u].getFunctionName();
        if (c === $C)
          l = "hiding";
        else if (c === WC) {
          if (l === "hiding")
            l = "showing", cc.has(n) && a.unshift(...cc.get(n));
          else if (l === "unknown") {
            a = i;
            break;
          }
        } else l !== "hiding" && a.push(i[u]);
      }
      return e(n, a);
    }, "stackTraceRewriter");
  }
  s(GC, "setupPrepareStackTrace");
  function efe(e, t) {
    return t.length === 0 ? VC(e) : `${VC(e)}
    at ${t.join(`
    at `)}`;
  }
  s(efe, "defaultPrepareStackTrace");
});

// ../node_modules/@babel/core/lib/errors/config-error.js
var ri = T((pc) => {
  "use strict";
  Object.defineProperty(pc, "__esModule", {
    value: !0
  });
  pc.default = void 0;
  var HC = Fn(), h0 = class extends Error {
    static {
      s(this, "ConfigError");
    }
    constructor(t, r) {
      super(t), (0, HC.expectedError)(this), r && (0, HC.injectVirtualStackFrame)(this, r);
    }
  };
  pc.default = h0;
});

// ../node_modules/@babel/core/lib/config/files/package.js
var YC = T((y0) => {
  "use strict";
  Object.defineProperty(y0, "__esModule", {
    value: !0
  });
  y0.findPackageData = sfe;
  function Xi() {
    let e = ie("path");
    return Xi = /* @__PURE__ */ s(function() {
      return e;
    }, "_path"), e;
  }
  s(Xi, "_path");
  var tfe = d0(), m0 = ri(), rfe = "package.json", nfe = (0, tfe.makeStaticFileCache)((e, t) => {
    let r;
    try {
      r = JSON.parse(t);
    } catch (n) {
      throw new m0.default(`Error while parsing JSON - ${n.message}`, e);
    }
    if (!r) throw new Error(`${e}: No config detected`);
    if (typeof r != "object")
      throw new m0.default(`Config returned typeof ${typeof r}`, e);
    if (Array.isArray(r))
      throw new m0.default("Expected config object but found array", e);
    return {
      filepath: e,
      dirname: Xi().dirname(e),
      options: r
    };
  });
  function* sfe(e) {
    let t = null, r = [], n = !0, i = Xi().dirname(e);
    for (; !t && Xi().basename(i) !== "node_modules"; ) {
      r.push(i), t = yield* nfe(Xi().join(i, rfe));
      let a = Xi().dirname(i);
      if (i === a) {
        n = !1;
        break;
      }
      i = a;
    }
    return {
      filepath: e,
      directories: r,
      pkg: t,
      isPackage: n
    };
  }
  s(sfe, "findPackageData");
});

// ../node_modules/json5/lib/unicode.js
var zC = T((Z2e, dc) => {
  dc.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
  dc.exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
  dc.exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
});

// ../node_modules/json5/lib/util.js
var b0 = T((ewe, JC) => {
  var g0 = zC();
  JC.exports = {
    isSpaceSeparator(e) {
      return typeof e == "string" && g0.Space_Separator.test(e);
    },
    isIdStartChar(e) {
      return typeof e == "string" && (e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e === "$" || e === "_" || g0.ID_Start.test(e));
    },
    isIdContinueChar(e) {
      return typeof e == "string" && (e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e >= "0" && e <= "9" || e === "$" || e === "_" || e ===
      "\u200C" || e === "\u200D" || g0.ID_Continue.test(e));
    },
    isDigit(e) {
      return typeof e == "string" && /[0-9]/.test(e);
    },
    isHexDigit(e) {
      return typeof e == "string" && /[0-9A-Fa-f]/.test(e);
    }
  };
});

// ../node_modules/json5/lib/parse.js
var t2 = T((twe, e2) => {
  var Mt = b0(), v0, fr, Ln, mc, gs, Jr, Rt, S0, Do;
  e2.exports = /* @__PURE__ */ s(function(t, r) {
    v0 = String(t), fr = "start", Ln = [], mc = 0, gs = 1, Jr = 0, Rt = void 0, S0 = void 0, Do = void 0;
    do
      Rt = ife(), lfe[fr]();
    while (Rt.type !== "eof");
    return typeof r == "function" ? T0({ "": Do }, "", r) : Do;
  }, "parse");
  function T0(e, t, r) {
    let n = e[t];
    if (n != null && typeof n == "object")
      if (Array.isArray(n))
        for (let i = 0; i < n.length; i++) {
          let a = String(i), o = T0(n, a, r);
          o === void 0 ? delete n[a] : Object.defineProperty(n, a, {
            value: o,
            writable: !0,
            enumerable: !0,
            configurable: !0
          });
        }
      else
        for (let i in n) {
          let a = T0(n, i, r);
          a === void 0 ? delete n[i] : Object.defineProperty(n, i, {
            value: a,
            writable: !0,
            enumerable: !0,
            configurable: !0
          });
        }
    return r.call(e, t, n);
  }
  s(T0, "internalize");
  var Re, Le, wo, jn, Ge;
  function ife() {
    for (Re = "default", Le = "", wo = !1, jn = 1; ; ) {
      Ge = Mn();
      let e = QC[Re]();
      if (e)
        return e;
    }
  }
  s(ife, "lex");
  function Mn() {
    if (v0[mc])
      return String.fromCodePoint(v0.codePointAt(mc));
  }
  s(Mn, "peek");
  function Y() {
    let e = Mn();
    return e === `
` ? (gs++, Jr = 0) : e ? Jr += e.length : Jr++, e && (mc += e.length), e;
  }
  s(Y, "read");
  var QC = {
    default() {
      switch (Ge) {
        case "	":
        case "\v":
        case "\f":
        case " ":
        case "\xA0":
        case "\uFEFF":
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          Y();
          return;
        case "/":
          Y(), Re = "comment";
          return;
        case void 0:
          return Y(), dt("eof");
      }
      if (Mt.isSpaceSeparator(Ge)) {
        Y();
        return;
      }
      return QC[fr]();
    },
    comment() {
      switch (Ge) {
        case "*":
          Y(), Re = "multiLineComment";
          return;
        case "/":
          Y(), Re = "singleLineComment";
          return;
      }
      throw ht(Y());
    },
    multiLineComment() {
      switch (Ge) {
        case "*":
          Y(), Re = "multiLineCommentAsterisk";
          return;
        case void 0:
          throw ht(Y());
      }
      Y();
    },
    multiLineCommentAsterisk() {
      switch (Ge) {
        case "*":
          Y();
          return;
        case "/":
          Y(), Re = "default";
          return;
        case void 0:
          throw ht(Y());
      }
      Y(), Re = "multiLineComment";
    },
    singleLineComment() {
      switch (Ge) {
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          Y(), Re = "default";
          return;
        case void 0:
          return Y(), dt("eof");
      }
      Y();
    },
    value() {
      switch (Ge) {
        case "{":
        case "[":
          return dt("punctuator", Y());
        case "n":
          return Y(), ni("ull"), dt("null", null);
        case "t":
          return Y(), ni("rue"), dt("boolean", !0);
        case "f":
          return Y(), ni("alse"), dt("boolean", !1);
        case "-":
        case "+":
          Y() === "-" && (jn = -1), Re = "sign";
          return;
        case ".":
          Le = Y(), Re = "decimalPointLeading";
          return;
        case "0":
          Le = Y(), Re = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          Le = Y(), Re = "decimalInteger";
          return;
        case "I":
          return Y(), ni("nfinity"), dt("numeric", 1 / 0);
        case "N":
          return Y(), ni("aN"), dt("numeric", NaN);
        case '"':
        case "'":
          wo = Y() === '"', Le = "", Re = "string";
          return;
      }
      throw ht(Y());
    },
    identifierNameStartEscape() {
      if (Ge !== "u")
        throw ht(Y());
      Y();
      let e = x0();
      switch (e) {
        case "$":
        case "_":
          break;
        default:
          if (!Mt.isIdStartChar(e))
            throw XC();
          break;
      }
      Le += e, Re = "identifierName";
    },
    identifierName() {
      switch (Ge) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          Le += Y();
          return;
        case "\\":
          Y(), Re = "identifierNameEscape";
          return;
      }
      if (Mt.isIdContinueChar(Ge)) {
        Le += Y();
        return;
      }
      return dt("identifier", Le);
    },
    identifierNameEscape() {
      if (Ge !== "u")
        throw ht(Y());
      Y();
      let e = x0();
      switch (e) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          break;
        default:
          if (!Mt.isIdContinueChar(e))
            throw XC();
          break;
      }
      Le += e, Re = "identifierName";
    },
    sign() {
      switch (Ge) {
        case ".":
          Le = Y(), Re = "decimalPointLeading";
          return;
        case "0":
          Le = Y(), Re = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          Le = Y(), Re = "decimalInteger";
          return;
        case "I":
          return Y(), ni("nfinity"), dt("numeric", jn * (1 / 0));
        case "N":
          return Y(), ni("aN"), dt("numeric", NaN);
      }
      throw ht(Y());
    },
    zero() {
      switch (Ge) {
        case ".":
          Le += Y(), Re = "decimalPoint";
          return;
        case "e":
        case "E":
          Le += Y(), Re = "decimalExponent";
          return;
        case "x":
        case "X":
          Le += Y(), Re = "hexadecimal";
          return;
      }
      return dt("numeric", jn * 0);
    },
    decimalInteger() {
      switch (Ge) {
        case ".":
          Le += Y(), Re = "decimalPoint";
          return;
        case "e":
        case "E":
          Le += Y(), Re = "decimalExponent";
          return;
      }
      if (Mt.isDigit(Ge)) {
        Le += Y();
        return;
      }
      return dt("numeric", jn * Number(Le));
    },
    decimalPointLeading() {
      if (Mt.isDigit(Ge)) {
        Le += Y(), Re = "decimalFraction";
        return;
      }
      throw ht(Y());
    },
    decimalPoint() {
      switch (Ge) {
        case "e":
        case "E":
          Le += Y(), Re = "decimalExponent";
          return;
      }
      if (Mt.isDigit(Ge)) {
        Le += Y(), Re = "decimalFraction";
        return;
      }
      return dt("numeric", jn * Number(Le));
    },
    decimalFraction() {
      switch (Ge) {
        case "e":
        case "E":
          Le += Y(), Re = "decimalExponent";
          return;
      }
      if (Mt.isDigit(Ge)) {
        Le += Y();
        return;
      }
      return dt("numeric", jn * Number(Le));
    },
    decimalExponent() {
      switch (Ge) {
        case "+":
        case "-":
          Le += Y(), Re = "decimalExponentSign";
          return;
      }
      if (Mt.isDigit(Ge)) {
        Le += Y(), Re = "decimalExponentInteger";
        return;
      }
      throw ht(Y());
    },
    decimalExponentSign() {
      if (Mt.isDigit(Ge)) {
        Le += Y(), Re = "decimalExponentInteger";
        return;
      }
      throw ht(Y());
    },
    decimalExponentInteger() {
      if (Mt.isDigit(Ge)) {
        Le += Y();
        return;
      }
      return dt("numeric", jn * Number(Le));
    },
    hexadecimal() {
      if (Mt.isHexDigit(Ge)) {
        Le += Y(), Re = "hexadecimalInteger";
        return;
      }
      throw ht(Y());
    },
    hexadecimalInteger() {
      if (Mt.isHexDigit(Ge)) {
        Le += Y();
        return;
      }
      return dt("numeric", jn * Number(Le));
    },
    string() {
      switch (Ge) {
        case "\\":
          Y(), Le += afe();
          return;
        case '"':
          if (wo)
            return Y(), dt("string", Le);
          Le += Y();
          return;
        case "'":
          if (!wo)
            return Y(), dt("string", Le);
          Le += Y();
          return;
        case `
`:
        case "\r":
          throw ht(Y());
        case "\u2028":
        case "\u2029":
          ufe(Ge);
          break;
        case void 0:
          throw ht(Y());
      }
      Le += Y();
    },
    start() {
      switch (Ge) {
        case "{":
        case "[":
          return dt("punctuator", Y());
      }
      Re = "value";
    },
    beforePropertyName() {
      switch (Ge) {
        case "$":
        case "_":
          Le = Y(), Re = "identifierName";
          return;
        case "\\":
          Y(), Re = "identifierNameStartEscape";
          return;
        case "}":
          return dt("punctuator", Y());
        case '"':
        case "'":
          wo = Y() === '"', Re = "string";
          return;
      }
      if (Mt.isIdStartChar(Ge)) {
        Le += Y(), Re = "identifierName";
        return;
      }
      throw ht(Y());
    },
    afterPropertyName() {
      if (Ge === ":")
        return dt("punctuator", Y());
      throw ht(Y());
    },
    beforePropertyValue() {
      Re = "value";
    },
    afterPropertyValue() {
      switch (Ge) {
        case ",":
        case "}":
          return dt("punctuator", Y());
      }
      throw ht(Y());
    },
    beforeArrayValue() {
      if (Ge === "]")
        return dt("punctuator", Y());
      Re = "value";
    },
    afterArrayValue() {
      switch (Ge) {
        case ",":
        case "]":
          return dt("punctuator", Y());
      }
      throw ht(Y());
    },
    end() {
      throw ht(Y());
    }
  };
  function dt(e, t) {
    return {
      type: e,
      value: t,
      line: gs,
      column: Jr
    };
  }
  s(dt, "newToken");
  function ni(e) {
    for (let t of e) {
      if (Mn() !== t)
        throw ht(Y());
      Y();
    }
  }
  s(ni, "literal");
  function afe() {
    switch (Mn()) {
      case "b":
        return Y(), "\b";
      case "f":
        return Y(), "\f";
      case "n":
        return Y(), `
`;
      case "r":
        return Y(), "\r";
      case "t":
        return Y(), "	";
      case "v":
        return Y(), "\v";
      case "0":
        if (Y(), Mt.isDigit(Mn()))
          throw ht(Y());
        return "\0";
      case "x":
        return Y(), ofe();
      case "u":
        return Y(), x0();
      case `
`:
      case "\u2028":
      case "\u2029":
        return Y(), "";
      case "\r":
        return Y(), Mn() === `
` && Y(), "";
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        throw ht(Y());
      case void 0:
        throw ht(Y());
    }
    return Y();
  }
  s(afe, "escape");
  function ofe() {
    let e = "", t = Mn();
    if (!Mt.isHexDigit(t) || (e += Y(), t = Mn(), !Mt.isHexDigit(t)))
      throw ht(Y());
    return e += Y(), String.fromCodePoint(parseInt(e, 16));
  }
  s(ofe, "hexEscape");
  function x0() {
    let e = "", t = 4;
    for (; t-- > 0; ) {
      let r = Mn();
      if (!Mt.isHexDigit(r))
        throw ht(Y());
      e += Y();
    }
    return String.fromCodePoint(parseInt(e, 16));
  }
  s(x0, "unicodeEscape");
  var lfe = {
    start() {
      if (Rt.type === "eof")
        throw si();
      E0();
    },
    beforePropertyName() {
      switch (Rt.type) {
        case "identifier":
        case "string":
          S0 = Rt.value, fr = "afterPropertyName";
          return;
        case "punctuator":
          hc();
          return;
        case "eof":
          throw si();
      }
    },
    afterPropertyName() {
      if (Rt.type === "eof")
        throw si();
      fr = "beforePropertyValue";
    },
    beforePropertyValue() {
      if (Rt.type === "eof")
        throw si();
      E0();
    },
    beforeArrayValue() {
      if (Rt.type === "eof")
        throw si();
      if (Rt.type === "punctuator" && Rt.value === "]") {
        hc();
        return;
      }
      E0();
    },
    afterPropertyValue() {
      if (Rt.type === "eof")
        throw si();
      switch (Rt.value) {
        case ",":
          fr = "beforePropertyName";
          return;
        case "}":
          hc();
      }
    },
    afterArrayValue() {
      if (Rt.type === "eof")
        throw si();
      switch (Rt.value) {
        case ",":
          fr = "beforeArrayValue";
          return;
        case "]":
          hc();
      }
    },
    end() {
    }
  };
  function E0() {
    let e;
    switch (Rt.type) {
      case "punctuator":
        switch (Rt.value) {
          case "{":
            e = {};
            break;
          case "[":
            e = [];
            break;
        }
        break;
      case "null":
      case "boolean":
      case "numeric":
      case "string":
        e = Rt.value;
        break;
    }
    if (Do === void 0)
      Do = e;
    else {
      let t = Ln[Ln.length - 1];
      Array.isArray(t) ? t.push(e) : Object.defineProperty(t, S0, {
        value: e,
        writable: !0,
        enumerable: !0,
        configurable: !0
      });
    }
    if (e !== null && typeof e == "object")
      Ln.push(e), Array.isArray(e) ? fr = "beforeArrayValue" : fr = "beforePropertyName";
    else {
      let t = Ln[Ln.length - 1];
      t == null ? fr = "end" : Array.isArray(t) ? fr = "afterArrayValue" : fr = "afterPropertyValue";
    }
  }
  s(E0, "push");
  function hc() {
    Ln.pop();
    let e = Ln[Ln.length - 1];
    e == null ? fr = "end" : Array.isArray(e) ? fr = "afterArrayValue" : fr = "afterPropertyValue";
  }
  s(hc, "pop");
  function ht(e) {
    return yc(e === void 0 ? `JSON5: invalid end of input at ${gs}:${Jr}` : `JSON5: invalid character '${ZC(e)}' at ${gs}:${Jr}`);
  }
  s(ht, "invalidChar");
  function si() {
    return yc(`JSON5: invalid end of input at ${gs}:${Jr}`);
  }
  s(si, "invalidEOF");
  function XC() {
    return Jr -= 5, yc(`JSON5: invalid identifier character at ${gs}:${Jr}`);
  }
  s(XC, "invalidIdentifier");
  function ufe(e) {
    console.warn(`JSON5: '${ZC(e)}' in strings is not valid ECMAScript; consider escaping`);
  }
  s(ufe, "separatorChar");
  function ZC(e) {
    let t = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    if (t[e])
      return t[e];
    if (e < " ") {
      let r = e.charCodeAt(0).toString(16);
      return "\\x" + ("00" + r).substring(r.length);
    }
    return e;
  }
  s(ZC, "formatChar");
  function yc(e) {
    let t = new SyntaxError(e);
    return t.lineNumber = gs, t.columnNumber = Jr, t;
  }
  s(yc, "syntaxError");
});

// ../node_modules/json5/lib/stringify.js
var n2 = T((nwe, r2) => {
  var P0 = b0();
  r2.exports = /* @__PURE__ */ s(function(t, r, n) {
    let i = [], a = "", o, l, u = "", c;
    if (r != null && typeof r == "object" && !Array.isArray(r) && (n = r.space, c = r.quote, r = r.replacer), typeof r == "function")
      l = r;
    else if (Array.isArray(r)) {
      o = [];
      for (let d of r) {
        let b;
        typeof d == "string" ? b = d : (typeof d == "number" || d instanceof String || d instanceof Number) && (b = String(d)), b !== void 0 &&
        o.indexOf(b) < 0 && o.push(b);
      }
    }
    return n instanceof Number ? n = Number(n) : n instanceof String && (n = String(n)), typeof n == "number" ? n > 0 && (n = Math.min(10, Math.
    floor(n)), u = "          ".substr(0, n)) : typeof n == "string" && (u = n.substr(0, 10)), f("", { "": t });
    function f(d, b) {
      let E = b[d];
      switch (E != null && (typeof E.toJSON5 == "function" ? E = E.toJSON5(d) : typeof E.toJSON == "function" && (E = E.toJSON(d))), l && (E =
      l.call(b, d, E)), E instanceof Number ? E = Number(E) : E instanceof String ? E = String(E) : E instanceof Boolean && (E = E.valueOf()),
      E) {
        case null:
          return "null";
        case !0:
          return "true";
        case !1:
          return "false";
      }
      if (typeof E == "string")
        return p(E, !1);
      if (typeof E == "number")
        return String(E);
      if (typeof E == "object")
        return Array.isArray(E) ? v(E) : h(E);
    }
    s(f, "serializeProperty");
    function p(d) {
      let b = {
        "'": 0.1,
        '"': 0.2
      }, E = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      }, I = "";
      for (let k = 0; k < d.length; k++) {
        let j = d[k];
        switch (j) {
          case "'":
          case '"':
            b[j]++, I += j;
            continue;
          case "\0":
            if (P0.isDigit(d[k + 1])) {
              I += "\\x00";
              continue;
            }
        }
        if (E[j]) {
          I += E[j];
          continue;
        }
        if (j < " ") {
          let R = j.charCodeAt(0).toString(16);
          I += "\\x" + ("00" + R).substring(R.length);
          continue;
        }
        I += j;
      }
      let O = c || Object.keys(b).reduce((k, j) => b[k] < b[j] ? k : j);
      return I = I.replace(new RegExp(O, "g"), E[O]), O + I + O;
    }
    s(p, "quoteString");
    function h(d) {
      if (i.indexOf(d) >= 0)
        throw TypeError("Converting circular structure to JSON5");
      i.push(d);
      let b = a;
      a = a + u;
      let E = o || Object.keys(d), I = [];
      for (let k of E) {
        let j = f(k, d);
        if (j !== void 0) {
          let R = y(k) + ":";
          u !== "" && (R += " "), R += j, I.push(R);
        }
      }
      let O;
      if (I.length === 0)
        O = "{}";
      else {
        let k;
        if (u === "")
          k = I.join(","), O = "{" + k + "}";
        else {
          let j = `,
` + a;
          k = I.join(j), O = `{
` + a + k + `,
` + b + "}";
        }
      }
      return i.pop(), a = b, O;
    }
    s(h, "serializeObject");
    function y(d) {
      if (d.length === 0)
        return p(d, !0);
      let b = String.fromCodePoint(d.codePointAt(0));
      if (!P0.isIdStartChar(b))
        return p(d, !0);
      for (let E = b.length; E < d.length; E++)
        if (!P0.isIdContinueChar(String.fromCodePoint(d.codePointAt(E))))
          return p(d, !0);
      return d;
    }
    s(y, "serializeKey");
    function v(d) {
      if (i.indexOf(d) >= 0)
        throw TypeError("Converting circular structure to JSON5");
      i.push(d);
      let b = a;
      a = a + u;
      let E = [];
      for (let O = 0; O < d.length; O++) {
        let k = f(String(O), d);
        E.push(k !== void 0 ? k : "null");
      }
      let I;
      if (E.length === 0)
        I = "[]";
      else if (u === "")
        I = "[" + E.join(",") + "]";
      else {
        let O = `,
` + a, k = E.join(O);
        I = `[
` + a + k + `,
` + b + "]";
      }
      return i.pop(), a = b, I;
    }
    s(v, "serializeArray");
  }, "stringify");
});

// ../node_modules/json5/lib/index.js
var i2 = T((iwe, s2) => {
  var cfe = t2(), ffe = n2(), pfe = {
    parse: cfe,
    stringify: ffe
  };
  s2.exports = pfe;
});

// ../node_modules/@babel/core/lib/config/helpers/config-api.js
var A0 = T((Io) => {
  "use strict";
  Object.defineProperty(Io, "__esModule", {
    value: !0
  });
  Io.makeConfigAPI = l2;
  Io.makePluginAPI = dfe;
  Io.makePresetAPI = u2;
  function o2() {
    let e = ie("semver");
    return o2 = /* @__PURE__ */ s(function() {
      return e;
    }, "_semver"), e;
  }
  s(o2, "_semver");
  var gc = bt(), a2 = ti();
  function l2(e) {
    let t = /* @__PURE__ */ s((n) => e.using((i) => typeof n > "u" ? i.envName : typeof n == "function" ? (0, a2.assertSimpleType)(n(i.envName)) :
    (Array.isArray(n) ? n : [n]).some((a) => {
      if (typeof a != "string")
        throw new Error("Unexpected non-string value");
      return a === i.envName;
    })), "env"), r = /* @__PURE__ */ s((n) => e.using((i) => (0, a2.assertSimpleType)(n(i.caller))), "caller");
    return {
      version: gc.version,
      cache: e.simple(),
      env: t,
      async: /* @__PURE__ */ s(() => !1, "async"),
      caller: r,
      assertVersion: hfe
    };
  }
  s(l2, "makeConfigAPI");
  function u2(e, t) {
    let r = /* @__PURE__ */ s(() => JSON.parse(e.using((i) => JSON.stringify(i.targets))), "targets"), n = /* @__PURE__ */ s((i) => {
      t.push(i);
    }, "addExternalDependency");
    return Object.assign({}, l2(e), {
      targets: r,
      addExternalDependency: n
    });
  }
  s(u2, "makePresetAPI");
  function dfe(e, t) {
    let r = /* @__PURE__ */ s((n) => e.using((i) => i.assumptions[n]), "assumption");
    return Object.assign({}, u2(e, t), {
      assumption: r
    });
  }
  s(dfe, "makePluginAPI");
  function hfe(e) {
    if (typeof e == "number") {
      if (!Number.isInteger(e))
        throw new Error("Expected string or integer value.");
      e = `^${e}.0.0-0`;
    }
    if (typeof e != "string")
      throw new Error("Expected string or integer value.");
    if (e === "*" || o2().satisfies(gc.version, e)) return;
    let t = Error.stackTraceLimit;
    typeof t == "number" && t < 25 && (Error.stackTraceLimit = 25);
    let r = new Error(`Requires Babel "${e}", but was loaded with "${gc.version}". If you are sure you have a compatible version of @babel/c\
ore, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the f\
irst entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
    throw typeof t == "number" && (Error.stackTraceLimit = t), Object.assign(r, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: gc.version,
      range: e
    });
  }
  s(hfe, "assertVersion");
});

// ../node_modules/@babel/core/lib/config/helpers/deep-array.js
var Ec = T((bc) => {
  "use strict";
  Object.defineProperty(bc, "__esModule", {
    value: !0
  });
  bc.finalize = mfe;
  bc.flattenToSet = yfe;
  function mfe(e) {
    return Object.freeze(e);
  }
  s(mfe, "finalize");
  function yfe(e) {
    let t = /* @__PURE__ */ new Set(), r = [e];
    for (; r.length > 0; )
      for (let n of r.pop())
        Array.isArray(n) ? r.push(n) : t.add(n);
    return t;
  }
  s(yfe, "flattenToSet");
});

// ../node_modules/@babel/core/lib/config/plugin.js
var Tc = T((vc) => {
  "use strict";
  Object.defineProperty(vc, "__esModule", {
    value: !0
  });
  vc.default = void 0;
  var gfe = Ec(), C0 = class {
    static {
      s(this, "Plugin");
    }
    constructor(t, r, n, i = (0, gfe.finalize)([])) {
      this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride =
      void 0, this.generatorOverride = void 0, this.options = void 0, this.externalDependencies = void 0, this.key = t.name || n, this.manipulateOptions =
      t.manipulateOptions, this.post = t.post, this.pre = t.pre, this.visitor = t.visitor || {}, this.parserOverride = t.parserOverride, this.
      generatorOverride = t.generatorOverride, this.options = r, this.externalDependencies = i;
    }
  };
  vc.default = C0;
});

// ../node_modules/@babel/core/lib/gensync-utils/functional.js
var f2 = T((w0) => {
  "use strict";
  Object.defineProperty(w0, "__esModule", {
    value: !0
  });
  w0.once = bfe;
  var c2 = Hi();
  function bfe(e) {
    let t, r, n = !1;
    return function* () {
      if (!t) {
        if (r)
          return n = !0, yield* (0, c2.waitFor)(r);
        if (yield* (0, c2.isAsync)()) {
          let i, a;
          r = new Promise((o, l) => {
            i = o, a = l;
          });
          try {
            t = {
              ok: !0,
              value: yield* e()
            }, r = null, n && i(t.value);
          } catch (o) {
            t = {
              ok: !1,
              value: o
            }, r = null, n && a(o);
          }
        } else
          try {
            t = {
              ok: !0,
              value: yield* e()
            };
          } catch (i) {
            t = {
              ok: !1,
              value: i
            };
          }
      }
      if (t.ok) return t.value;
      throw t.value;
    };
  }
  s(bfe, "once");
});

// ../node_modules/node-releases/data/processed/envs.json
var p2 = T((hwe, Efe) => {
  Efe.exports = [{ name: "nodejs", version: "0.2.0", date: "2011-08-26", lts: !1, security: !1, v8: "2.3.8.0" }, { name: "nodejs", version: "\
0.3.0", date: "2011-08-26", lts: !1, security: !1, v8: "2.5.1.0" }, { name: "nodejs", version: "0.4.0", date: "2011-08-26", lts: !1, security: !1,
  v8: "3.1.2.0" }, { name: "nodejs", version: "0.5.0", date: "2011-08-26", lts: !1, security: !1, v8: "3.1.8.25" }, { name: "nodejs", version: "\
0.6.0", date: "2011-11-04", lts: !1, security: !1, v8: "3.6.6.6" }, { name: "nodejs", version: "0.7.0", date: "2012-01-17", lts: !1, security: !1,
  v8: "3.8.6.0" }, { name: "nodejs", version: "0.8.0", date: "2012-06-22", lts: !1, security: !1, v8: "3.11.10.10" }, { name: "nodejs", version: "\
0.9.0", date: "2012-07-20", lts: !1, security: !1, v8: "3.11.10.15" }, { name: "nodejs", version: "0.10.0", date: "2013-03-11", lts: !1, security: !1,
  v8: "3.14.5.8" }, { name: "nodejs", version: "0.11.0", date: "2013-03-28", lts: !1, security: !1, v8: "3.17.13.0" }, { name: "nodejs", version: "\
0.12.0", date: "2015-02-06", lts: !1, security: !1, v8: "3.28.73.0" }, { name: "nodejs", version: "4.0.0", date: "2015-09-08", lts: !1, security: !1,
  v8: "4.5.103.30" }, { name: "nodejs", version: "4.1.0", date: "2015-09-17", lts: !1, security: !1, v8: "4.5.103.33" }, { name: "nodejs", version: "\
4.2.0", date: "2015-10-12", lts: "Argon", security: !1, v8: "4.5.103.35" }, { name: "nodejs", version: "4.3.0", date: "2016-02-09", lts: "Ar\
gon", security: !1, v8: "4.5.103.35" }, { name: "nodejs", version: "4.4.0", date: "2016-03-08", lts: "Argon", security: !1, v8: "4.5.103.35" },
  { name: "nodejs", version: "4.5.0", date: "2016-08-16", lts: "Argon", security: !1, v8: "4.5.103.37" }, { name: "nodejs", version: "4.6.0",
  date: "2016-09-27", lts: "Argon", security: !0, v8: "4.5.103.37" }, { name: "nodejs", version: "4.7.0", date: "2016-12-06", lts: "Argon", security: !1,
  v8: "4.5.103.43" }, { name: "nodejs", version: "4.8.0", date: "2017-02-21", lts: "Argon", security: !1, v8: "4.5.103.45" }, { name: "nodej\
s", version: "4.9.0", date: "2018-03-28", lts: "Argon", security: !0, v8: "4.5.103.53" }, { name: "nodejs", version: "5.0.0", date: "2015-10\
-29", lts: !1, security: !1, v8: "4.6.85.28" }, { name: "nodejs", version: "5.1.0", date: "2015-11-17", lts: !1, security: !1, v8: "4.6.85.3\
1" }, { name: "nodejs", version: "5.2.0", date: "2015-12-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.3.0", date: "\
2015-12-15", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.4.0", date: "2016-01-06", lts: !1, security: !1, v8: "4\
.6.85.31" }, { name: "nodejs", version: "5.5.0", date: "2016-01-21", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5\
.6.0", date: "2016-02-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.7.0", date: "2016-02-23", lts: !1, security: !1,
  v8: "4.6.85.31" }, { name: "nodejs", version: "5.8.0", date: "2016-03-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "\
5.9.0", date: "2016-03-16", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.10.0", date: "2016-04-01", lts: !1, security: !1,
  v8: "4.6.85.31" }, { name: "nodejs", version: "5.11.0", date: "2016-04-21", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "\
5.12.0", date: "2016-06-23", lts: !1, security: !1, v8: "4.6.85.32" }, { name: "nodejs", version: "6.0.0", date: "2016-04-26", lts: !1, security: !1,
  v8: "5.0.71.35" }, { name: "nodejs", version: "6.1.0", date: "2016-05-05", lts: !1, security: !1, v8: "5.0.71.35" }, { name: "nodejs", version: "\
6.2.0", date: "2016-05-17", lts: !1, security: !1, v8: "5.0.71.47" }, { name: "nodejs", version: "6.3.0", date: "2016-07-06", lts: !1, security: !1,
  v8: "5.0.71.52" }, { name: "nodejs", version: "6.4.0", date: "2016-08-12", lts: !1, security: !1, v8: "5.0.71.60" }, { name: "nodejs", version: "\
6.5.0", date: "2016-08-26", lts: !1, security: !1, v8: "5.1.281.81" }, { name: "nodejs", version: "6.6.0", date: "2016-09-14", lts: !1, security: !1,
  v8: "5.1.281.83" }, { name: "nodejs", version: "6.7.0", date: "2016-09-27", lts: !1, security: !0, v8: "5.1.281.83" }, { name: "nodejs", version: "\
6.8.0", date: "2016-10-12", lts: !1, security: !1, v8: "5.1.281.84" }, { name: "nodejs", version: "6.9.0", date: "2016-10-18", lts: "Boron",
  security: !1, v8: "5.1.281.84" }, { name: "nodejs", version: "6.10.0", date: "2017-02-21", lts: "Boron", security: !1, v8: "5.1.281.93" },
  { name: "nodejs", version: "6.11.0", date: "2017-06-06", lts: "Boron", security: !1, v8: "5.1.281.102" }, { name: "nodejs", version: "6.12\
.0", date: "2017-11-06", lts: "Boron", security: !1, v8: "5.1.281.108" }, { name: "nodejs", version: "6.13.0", date: "2018-02-10", lts: "Bor\
on", security: !1, v8: "5.1.281.111" }, { name: "nodejs", version: "6.14.0", date: "2018-03-28", lts: "Boron", security: !0, v8: "5.1.281.11\
1" }, { name: "nodejs", version: "6.15.0", date: "2018-11-27", lts: "Boron", security: !0, v8: "5.1.281.111" }, { name: "nodejs", version: "\
6.16.0", date: "2018-12-26", lts: "Boron", security: !1, v8: "5.1.281.111" }, { name: "nodejs", version: "6.17.0", date: "2019-02-28", lts: "\
Boron", security: !0, v8: "5.1.281.111" }, { name: "nodejs", version: "7.0.0", date: "2016-10-25", lts: !1, security: !1, v8: "5.4.500.36" },
  { name: "nodejs", version: "7.1.0", date: "2016-11-08", lts: !1, security: !1, v8: "5.4.500.36" }, { name: "nodejs", version: "7.2.0", date: "\
2016-11-22", lts: !1, security: !1, v8: "5.4.500.43" }, { name: "nodejs", version: "7.3.0", date: "2016-12-20", lts: !1, security: !1, v8: "\
5.4.500.45" }, { name: "nodejs", version: "7.4.0", date: "2017-01-04", lts: !1, security: !1, v8: "5.4.500.45" }, { name: "nodejs", version: "\
7.5.0", date: "2017-01-31", lts: !1, security: !1, v8: "5.4.500.48" }, { name: "nodejs", version: "7.6.0", date: "2017-02-21", lts: !1, security: !1,
  v8: "5.5.372.40" }, { name: "nodejs", version: "7.7.0", date: "2017-02-28", lts: !1, security: !1, v8: "5.5.372.41" }, { name: "nodejs", version: "\
7.8.0", date: "2017-03-29", lts: !1, security: !1, v8: "5.5.372.43" }, { name: "nodejs", version: "7.9.0", date: "2017-04-11", lts: !1, security: !1,
  v8: "5.5.372.43" }, { name: "nodejs", version: "7.10.0", date: "2017-05-02", lts: !1, security: !1, v8: "5.5.372.43" }, { name: "nodejs", version: "\
8.0.0", date: "2017-05-30", lts: !1, security: !1, v8: "5.8.283.41" }, { name: "nodejs", version: "8.1.0", date: "2017-06-08", lts: !1, security: !1,
  v8: "5.8.283.41" }, { name: "nodejs", version: "8.2.0", date: "2017-07-19", lts: !1, security: !1, v8: "5.8.283.41" }, { name: "nodejs", version: "\
8.3.0", date: "2017-08-08", lts: !1, security: !1, v8: "6.0.286.52" }, { name: "nodejs", version: "8.4.0", date: "2017-08-15", lts: !1, security: !1,
  v8: "6.0.286.52" }, { name: "nodejs", version: "8.5.0", date: "2017-09-12", lts: !1, security: !1, v8: "6.0.287.53" }, { name: "nodejs", version: "\
8.6.0", date: "2017-09-26", lts: !1, security: !1, v8: "6.0.287.53" }, { name: "nodejs", version: "8.7.0", date: "2017-10-11", lts: !1, security: !1,
  v8: "6.1.534.42" }, { name: "nodejs", version: "8.8.0", date: "2017-10-24", lts: !1, security: !1, v8: "6.1.534.42" }, { name: "nodejs", version: "\
8.9.0", date: "2017-10-31", lts: "Carbon", security: !1, v8: "6.1.534.46" }, { name: "nodejs", version: "8.10.0", date: "2018-03-06", lts: "\
Carbon", security: !1, v8: "6.2.414.50" }, { name: "nodejs", version: "8.11.0", date: "2018-03-28", lts: "Carbon", security: !0, v8: "6.2.41\
4.50" }, { name: "nodejs", version: "8.12.0", date: "2018-09-10", lts: "Carbon", security: !1, v8: "6.2.414.66" }, { name: "nodejs", version: "\
8.13.0", date: "2018-11-20", lts: "Carbon", security: !1, v8: "6.2.414.72" }, { name: "nodejs", version: "8.14.0", date: "2018-11-27", lts: "\
Carbon", security: !0, v8: "6.2.414.72" }, { name: "nodejs", version: "8.15.0", date: "2018-12-26", lts: "Carbon", security: !1, v8: "6.2.41\
4.75" }, { name: "nodejs", version: "8.16.0", date: "2019-04-16", lts: "Carbon", security: !1, v8: "6.2.414.77" }, { name: "nodejs", version: "\
8.17.0", date: "2019-12-17", lts: "Carbon", security: !0, v8: "6.2.414.78" }, { name: "nodejs", version: "9.0.0", date: "2017-10-31", lts: !1,
  security: !1, v8: "6.2.414.32" }, { name: "nodejs", version: "9.1.0", date: "2017-11-07", lts: !1, security: !1, v8: "6.2.414.32" }, { name: "\
nodejs", version: "9.2.0", date: "2017-11-14", lts: !1, security: !1, v8: "6.2.414.44" }, { name: "nodejs", version: "9.3.0", date: "2017-12\
-12", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.4.0", date: "2018-01-10", lts: !1, security: !1, v8: "6.2.414\
.46" }, { name: "nodejs", version: "9.5.0", date: "2018-01-31", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.6.0",
  date: "2018-02-21", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.7.0", date: "2018-03-01", lts: !1, security: !1,
  v8: "6.2.414.46" }, { name: "nodejs", version: "9.8.0", date: "2018-03-07", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "\
9.9.0", date: "2018-03-21", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.10.0", date: "2018-03-28", lts: !1, security: !0,
  v8: "6.2.414.46" }, { name: "nodejs", version: "9.11.0", date: "2018-04-04", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "\
10.0.0", date: "2018-04-24", lts: !1, security: !1, v8: "6.6.346.24" }, { name: "nodejs", version: "10.1.0", date: "2018-05-08", lts: !1, security: !1,
  v8: "6.6.346.27" }, { name: "nodejs", version: "10.2.0", date: "2018-05-23", lts: !1, security: !1, v8: "6.6.346.32" }, { name: "nodejs", version: "\
10.3.0", date: "2018-05-29", lts: !1, security: !1, v8: "6.6.346.32" }, { name: "nodejs", version: "10.4.0", date: "2018-06-06", lts: !1, security: !1,
  v8: "6.7.288.43" }, { name: "nodejs", version: "10.5.0", date: "2018-06-20", lts: !1, security: !1, v8: "6.7.288.46" }, { name: "nodejs", version: "\
10.6.0", date: "2018-07-04", lts: !1, security: !1, v8: "6.7.288.46" }, { name: "nodejs", version: "10.7.0", date: "2018-07-18", lts: !1, security: !1,
  v8: "6.7.288.49" }, { name: "nodejs", version: "10.8.0", date: "2018-08-01", lts: !1, security: !1, v8: "6.7.288.49" }, { name: "nodejs", version: "\
10.9.0", date: "2018-08-15", lts: !1, security: !1, v8: "6.8.275.24" }, { name: "nodejs", version: "10.10.0", date: "2018-09-06", lts: !1, security: !1,
  v8: "6.8.275.30" }, { name: "nodejs", version: "10.11.0", date: "2018-09-19", lts: !1, security: !1, v8: "6.8.275.32" }, { name: "nodejs",
  version: "10.12.0", date: "2018-10-10", lts: !1, security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.13.0", date: "2018-10-30",
  lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.14.0", date: "2018-11-27", lts: "Dubnium", security: !0, v8: "\
6.8.275.32" }, { name: "nodejs", version: "10.15.0", date: "2018-12-26", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs",
  version: "10.16.0", date: "2019-05-28", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.17.0", date: "201\
9-10-22", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.18.0", date: "2019-12-17", lts: "Dubnium", security: !0,
  v8: "6.8.275.32" }, { name: "nodejs", version: "10.19.0", date: "2020-02-05", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "n\
odejs", version: "10.20.0", date: "2020-03-26", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.21.0", date: "\
2020-06-02", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "nodejs", version: "10.22.0", date: "2020-07-21", lts: "Dubnium", security: !1,
  v8: "6.8.275.32" }, { name: "nodejs", version: "10.23.0", date: "2020-10-27", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "n\
odejs", version: "10.24.0", date: "2021-02-23", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "nodejs", version: "11.0.0", date: "\
2018-10-23", lts: !1, security: !1, v8: "7.0.276.28" }, { name: "nodejs", version: "11.1.0", date: "2018-10-30", lts: !1, security: !1, v8: "\
7.0.276.32" }, { name: "nodejs", version: "11.2.0", date: "2018-11-15", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "\
11.3.0", date: "2018-11-27", lts: !1, security: !0, v8: "7.0.276.38" }, { name: "nodejs", version: "11.4.0", date: "2018-12-07", lts: !1, security: !1,
  v8: "7.0.276.38" }, { name: "nodejs", version: "11.5.0", date: "2018-12-18", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "\
11.6.0", date: "2018-12-26", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.7.0", date: "2019-01-17", lts: !1, security: !1,
  v8: "7.0.276.38" }, { name: "nodejs", version: "11.8.0", date: "2019-01-24", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "\
11.9.0", date: "2019-01-30", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.10.0", date: "2019-02-14", lts: !1, security: !1,
  v8: "7.0.276.38" }, { name: "nodejs", version: "11.11.0", date: "2019-03-05", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs",
  version: "11.12.0", date: "2019-03-14", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.13.0", date: "2019-03-28",
  lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.14.0", date: "2019-04-10", lts: !1, security: !1, v8: "7.0.276.3\
8" }, { name: "nodejs", version: "11.15.0", date: "2019-04-30", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "12.0.\
0", date: "2019-04-23", lts: !1, security: !1, v8: "7.4.288.21" }, { name: "nodejs", version: "12.1.0", date: "2019-04-29", lts: !1, security: !1,
  v8: "7.4.288.21" }, { name: "nodejs", version: "12.2.0", date: "2019-05-07", lts: !1, security: !1, v8: "7.4.288.21" }, { name: "nodejs", version: "\
12.3.0", date: "2019-05-21", lts: !1, security: !1, v8: "7.4.288.27" }, { name: "nodejs", version: "12.4.0", date: "2019-06-04", lts: !1, security: !1,
  v8: "7.4.288.27" }, { name: "nodejs", version: "12.5.0", date: "2019-06-26", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "\
12.6.0", date: "2019-07-03", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "12.7.0", date: "2019-07-23", lts: !1, security: !1,
  v8: "7.5.288.22" }, { name: "nodejs", version: "12.8.0", date: "2019-08-06", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "\
12.9.0", date: "2019-08-20", lts: !1, security: !1, v8: "7.6.303.29" }, { name: "nodejs", version: "12.10.0", date: "2019-09-04", lts: !1, security: !1,
  v8: "7.6.303.29" }, { name: "nodejs", version: "12.11.0", date: "2019-09-25", lts: !1, security: !1, v8: "7.7.299.11" }, { name: "nodejs",
  version: "12.12.0", date: "2019-10-11", lts: !1, security: !1, v8: "7.7.299.13" }, { name: "nodejs", version: "12.13.0", date: "2019-10-21",
  lts: "Erbium", security: !1, v8: "7.7.299.13" }, { name: "nodejs", version: "12.14.0", date: "2019-12-17", lts: "Erbium", security: !0, v8: "\
7.7.299.13" }, { name: "nodejs", version: "12.15.0", date: "2020-02-05", lts: "Erbium", security: !0, v8: "7.7.299.13" }, { name: "nodejs", version: "\
12.16.0", date: "2020-02-11", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.17.0", date: "2020-05-26", lts: "\
Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.18.0", date: "2020-06-02", lts: "Erbium", security: !0, v8: "7.8.2\
79.23" }, { name: "nodejs", version: "12.19.0", date: "2020-10-06", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "\
12.20.0", date: "2020-11-24", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.21.0", date: "2021-02-23", lts: "\
Erbium", security: !0, v8: "7.8.279.23" }, { name: "nodejs", version: "12.22.0", date: "2021-03-30", lts: "Erbium", security: !1, v8: "7.8.2\
79.23" }, { name: "nodejs", version: "13.0.0", date: "2019-10-22", lts: !1, security: !1, v8: "7.8.279.17" }, { name: "nodejs", version: "13\
.1.0", date: "2019-11-05", lts: !1, security: !1, v8: "7.8.279.17" }, { name: "nodejs", version: "13.2.0", date: "2019-11-21", lts: !1, security: !1,
  v8: "7.9.317.23" }, { name: "nodejs", version: "13.3.0", date: "2019-12-03", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "\
13.4.0", date: "2019-12-17", lts: !1, security: !0, v8: "7.9.317.25" }, { name: "nodejs", version: "13.5.0", date: "2019-12-18", lts: !1, security: !1,
  v8: "7.9.317.25" }, { name: "nodejs", version: "13.6.0", date: "2020-01-07", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "\
13.7.0", date: "2020-01-21", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.8.0", date: "2020-02-05", lts: !1, security: !0,
  v8: "7.9.317.25" }, { name: "nodejs", version: "13.9.0", date: "2020-02-18", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "\
13.10.0", date: "2020-03-04", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.11.0", date: "2020-03-12", lts: !1, security: !1,
  v8: "7.9.317.25" }, { name: "nodejs", version: "13.12.0", date: "2020-03-26", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs",
  version: "13.13.0", date: "2020-04-14", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.14.0", date: "2020-04-29",
  lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "14.0.0", date: "2020-04-21", lts: !1, security: !1, v8: "8.1.307.30" },
  { name: "nodejs", version: "14.1.0", date: "2020-04-29", lts: !1, security: !1, v8: "8.1.307.31" }, { name: "nodejs", version: "14.2.0", date: "\
2020-05-05", lts: !1, security: !1, v8: "8.1.307.31" }, { name: "nodejs", version: "14.3.0", date: "2020-05-19", lts: !1, security: !1, v8: "\
8.1.307.31" }, { name: "nodejs", version: "14.4.0", date: "2020-06-02", lts: !1, security: !0, v8: "8.1.307.31" }, { name: "nodejs", version: "\
14.5.0", date: "2020-06-30", lts: !1, security: !1, v8: "8.3.110.9" }, { name: "nodejs", version: "14.6.0", date: "2020-07-20", lts: !1, security: !1,
  v8: "8.4.371.19" }, { name: "nodejs", version: "14.7.0", date: "2020-07-29", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "\
14.8.0", date: "2020-08-11", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.9.0", date: "2020-08-27", lts: !1, security: !1,
  v8: "8.4.371.19" }, { name: "nodejs", version: "14.10.0", date: "2020-09-08", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs",
  version: "14.11.0", date: "2020-09-15", lts: !1, security: !0, v8: "8.4.371.19" }, { name: "nodejs", version: "14.12.0", date: "2020-09-22",
  lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.13.0", date: "2020-09-29", lts: !1, security: !1, v8: "8.4.371.1\
9" }, { name: "nodejs", version: "14.14.0", date: "2020-10-15", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.15\
.0", date: "2020-10-27", lts: "Fermium", security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.16.0", date: "2021-02-23", lts: "F\
ermium", security: !0, v8: "8.4.371.19" }, { name: "nodejs", version: "14.17.0", date: "2021-05-11", lts: "Fermium", security: !1, v8: "8.4.\
371.23" }, { name: "nodejs", version: "14.18.0", date: "2021-09-28", lts: "Fermium", security: !1, v8: "8.4.371.23" }, { name: "nodejs", version: "\
14.19.0", date: "2022-02-01", lts: "Fermium", security: !1, v8: "8.4.371.23" }, { name: "nodejs", version: "14.20.0", date: "2022-07-07", lts: "\
Fermium", security: !0, v8: "8.4.371.23" }, { name: "nodejs", version: "14.21.0", date: "2022-11-01", lts: "Fermium", security: !1, v8: "8.4\
.371.23" }, { name: "nodejs", version: "15.0.0", date: "2020-10-20", lts: !1, security: !1, v8: "8.6.395.16" }, { name: "nodejs", version: "\
15.1.0", date: "2020-11-04", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.2.0", date: "2020-11-10", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.3.0", date: "2020-11-24", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "\
15.4.0", date: "2020-12-09", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.5.0", date: "2020-12-22", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.6.0", date: "2021-01-14", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "\
15.7.0", date: "2021-01-25", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.8.0", date: "2021-02-02", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.9.0", date: "2021-02-18", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "\
15.10.0", date: "2021-02-23", lts: !1, security: !0, v8: "8.6.395.17" }, { name: "nodejs", version: "15.11.0", date: "2021-03-03", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.12.0", date: "2021-03-17", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs",
  version: "15.13.0", date: "2021-03-31", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.14.0", date: "2021-04-06",
  lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "16.0.0", date: "2021-04-20", lts: !1, security: !1, v8: "9.0.257.17" },
  { name: "nodejs", version: "16.1.0", date: "2021-05-04", lts: !1, security: !1, v8: "9.0.257.24" }, { name: "nodejs", version: "16.2.0", date: "\
2021-05-19", lts: !1, security: !1, v8: "9.0.257.25" }, { name: "nodejs", version: "16.3.0", date: "2021-06-03", lts: !1, security: !1, v8: "\
9.0.257.25" }, { name: "nodejs", version: "16.4.0", date: "2021-06-23", lts: !1, security: !1, v8: "9.1.269.36" }, { name: "nodejs", version: "\
16.5.0", date: "2021-07-14", lts: !1, security: !1, v8: "9.1.269.38" }, { name: "nodejs", version: "16.6.0", date: "2021-07-29", lts: !1, security: !0,
  v8: "9.2.230.21" }, { name: "nodejs", version: "16.7.0", date: "2021-08-18", lts: !1, security: !1, v8: "9.2.230.21" }, { name: "nodejs", version: "\
16.8.0", date: "2021-08-25", lts: !1, security: !1, v8: "9.2.230.21" }, { name: "nodejs", version: "16.9.0", date: "2021-09-07", lts: !1, security: !1,
  v8: "9.3.345.16" }, { name: "nodejs", version: "16.10.0", date: "2021-09-22", lts: !1, security: !1, v8: "9.3.345.19" }, { name: "nodejs",
  version: "16.11.0", date: "2021-10-08", lts: !1, security: !1, v8: "9.4.146.19" }, { name: "nodejs", version: "16.12.0", date: "2021-10-20",
  lts: !1, security: !1, v8: "9.4.146.19" }, { name: "nodejs", version: "16.13.0", date: "2021-10-26", lts: "Gallium", security: !1, v8: "9.\
4.146.19" }, { name: "nodejs", version: "16.14.0", date: "2022-02-08", lts: "Gallium", security: !1, v8: "9.4.146.24" }, { name: "nodejs", version: "\
16.15.0", date: "2022-04-26", lts: "Gallium", security: !1, v8: "9.4.146.24" }, { name: "nodejs", version: "16.16.0", date: "2022-07-07", lts: "\
Gallium", security: !0, v8: "9.4.146.24" }, { name: "nodejs", version: "16.17.0", date: "2022-08-16", lts: "Gallium", security: !1, v8: "9.4\
.146.26" }, { name: "nodejs", version: "16.18.0", date: "2022-10-12", lts: "Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "\
16.19.0", date: "2022-12-13", lts: "Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "16.20.0", date: "2023-03-28", lts: "\
Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "17.0.0", date: "2021-10-19", lts: !1, security: !1, v8: "9.5.172.21" },
  { name: "nodejs", version: "17.1.0", date: "2021-11-09", lts: !1, security: !1, v8: "9.5.172.25" }, { name: "nodejs", version: "17.2.0", date: "\
2021-11-30", lts: !1, security: !1, v8: "9.6.180.14" }, { name: "nodejs", version: "17.3.0", date: "2021-12-17", lts: !1, security: !1, v8: "\
9.6.180.15" }, { name: "nodejs", version: "17.4.0", date: "2022-01-18", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "\
17.5.0", date: "2022-02-10", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "17.6.0", date: "2022-02-22", lts: !1, security: !1,
  v8: "9.6.180.15" }, { name: "nodejs", version: "17.7.0", date: "2022-03-09", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "\
17.8.0", date: "2022-03-22", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "17.9.0", date: "2022-04-07", lts: !1, security: !1,
  v8: "9.6.180.15" }, { name: "nodejs", version: "18.0.0", date: "2022-04-18", lts: !1, security: !1, v8: "10.1.124.8" }, { name: "nodejs", version: "\
18.1.0", date: "2022-05-03", lts: !1, security: !1, v8: "10.1.124.8" }, { name: "nodejs", version: "18.2.0", date: "2022-05-17", lts: !1, security: !1,
  v8: "10.1.124.8" }, { name: "nodejs", version: "18.3.0", date: "2022-06-02", lts: !1, security: !1, v8: "10.2.154.4" }, { name: "nodejs", version: "\
18.4.0", date: "2022-06-16", lts: !1, security: !1, v8: "10.2.154.4" }, { name: "nodejs", version: "18.5.0", date: "2022-07-06", lts: !1, security: !0,
  v8: "10.2.154.4" }, { name: "nodejs", version: "18.6.0", date: "2022-07-13", lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs",
  version: "18.7.0", date: "2022-07-26", lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs", version: "18.8.0", date: "2022-08-24",
  lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs", version: "18.9.0", date: "2022-09-07", lts: !1, security: !1, v8: "10.2.154.\
15" }, { name: "nodejs", version: "18.10.0", date: "2022-09-28", lts: !1, security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.\
11.0", date: "2022-10-13", lts: !1, security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.12.0", date: "2022-10-25", lts: "Hydro\
gen", security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.13.0", date: "2023-01-05", lts: "Hydrogen", security: !1, v8: "10.2.\
154.23" }, { name: "nodejs", version: "18.14.0", date: "2023-02-01", lts: "Hydrogen", security: !1, v8: "10.2.154.23" }, { name: "nodejs", version: "\
18.15.0", date: "2023-03-05", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.16.0", date: "2023-04-12", lts: "\
Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.17.0", date: "2023-07-18", lts: "Hydrogen", security: !1, v8: "\
10.2.154.26" }, { name: "nodejs", version: "18.18.0", date: "2023-09-18", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodej\
s", version: "18.19.0", date: "2023-11-29", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.20.0", date: "\
2024-03-26", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "19.0.0", date: "2022-10-17", lts: !1, security: !1,
  v8: "10.7.193.13" }, { name: "nodejs", version: "19.1.0", date: "2022-11-14", lts: !1, security: !1, v8: "10.7.193.20" }, { name: "nodejs",
  version: "19.2.0", date: "2022-11-29", lts: !1, security: !1, v8: "10.8.168.20" }, { name: "nodejs", version: "19.3.0", date: "2022-12-14",
  lts: !1, security: !1, v8: "10.8.168.21" }, { name: "nodejs", version: "19.4.0", date: "2023-01-05", lts: !1, security: !1, v8: "10.8.168.\
25" }, { name: "nodejs", version: "19.5.0", date: "2023-01-24", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "19.6\
.0", date: "2023-02-01", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "19.7.0", date: "2023-02-21", lts: !1, security: !1,
  v8: "10.8.168.25" }, { name: "nodejs", version: "19.8.0", date: "2023-03-14", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs",
  version: "19.9.0", date: "2023-04-10", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "20.0.0", date: "2023-04-17",
  lts: !1, security: !1, v8: "11.3.244.4" }, { name: "nodejs", version: "20.1.0", date: "2023-05-03", lts: !1, security: !1, v8: "11.3.244.8" },
  { name: "nodejs", version: "20.2.0", date: "2023-05-16", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.3.0", date: "\
2023-06-08", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.4.0", date: "2023-07-04", lts: !1, security: !1, v8: "\
11.3.244.8" }, { name: "nodejs", version: "20.5.0", date: "2023-07-19", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "\
20.6.0", date: "2023-08-23", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.7.0", date: "2023-09-18", lts: !1, security: !1,
  v8: "11.3.244.8" }, { name: "nodejs", version: "20.8.0", date: "2023-09-28", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "\
20.9.0", date: "2023-10-24", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.10.0", date: "2023-11-22", lts: "\
Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.11.0", date: "2024-01-09", lts: "Iron", security: !1, v8: "11.3.244.\
8" }, { name: "nodejs", version: "20.12.0", date: "2024-03-26", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "2\
0.13.0", date: "2024-05-07", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.14.0", date: "2024-05-28", lts: "\
Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.15.0", date: "2024-06-20", lts: "Iron", security: !1, v8: "11.3.244.\
8" }, { name: "nodejs", version: "21.0.0", date: "2023-10-17", lts: !1, security: !1, v8: "11.8.172.13" }, { name: "nodejs", version: "21.1.\
0", date: "2023-10-24", lts: !1, security: !1, v8: "11.8.172.15" }, { name: "nodejs", version: "21.2.0", date: "2023-11-14", lts: !1, security: !1,
  v8: "11.8.172.17" }, { name: "nodejs", version: "21.3.0", date: "2023-11-30", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs",
  version: "21.4.0", date: "2023-12-05", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "21.5.0", date: "2023-12-19",
  lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "21.6.0", date: "2024-01-14", lts: !1, security: !1, v8: "11.8.172.\
17" }, { name: "nodejs", version: "21.7.0", date: "2024-03-06", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "22.0\
.0", date: "2024-04-24", lts: !1, security: !1, v8: "12.4.254.14" }, { name: "nodejs", version: "22.1.0", date: "2024-05-02", lts: !1, security: !1,
  v8: "12.4.254.14" }, { name: "nodejs", version: "22.2.0", date: "2024-05-15", lts: !1, security: !1, v8: "12.4.254.14" }, { name: "nodejs",
  version: "22.3.0", date: "2024-06-11", lts: !1, security: !1, v8: "12.4.254.20" }, { name: "nodejs", version: "22.4.0", date: "2024-07-02",
  lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.5.0", date: "2024-07-17", lts: !1, security: !1, v8: "12.4.254.\
21" }];
});

// ../node_modules/caniuse-lite/data/browsers.js
var h2 = T((mwe, d2) => {
  d2.exports = { A: "ie", B: "edge", C: "firefox", D: "chrome", E: "safari", F: "opera", G: "ios_saf", H: "op_mini", I: "android", J: "bb", K: "\
op_mob", L: "and_chr", M: "and_ff", N: "ie_mob", O: "and_uc", P: "samsung", Q: "and_qq", R: "baidu", S: "kaios" };
});

// ../node_modules/caniuse-lite/dist/unpacker/browsers.js
var xc = T((ywe, m2) => {
  m2.exports.browsers = h2();
});

// ../node_modules/caniuse-lite/data/browserVersions.js
var g2 = T((gwe, y2) => {
  y2.exports = { 0: "25", 1: "112", 2: "113", 3: "114", 4: "115", 5: "116", 6: "117", 7: "118", 8: "119", 9: "120", A: "10", B: "11", C: "12",
  D: "127", E: "7", F: "8", G: "9", H: "15", I: "80", J: "4", K: "6", L: "13", M: "14", N: "16", O: "17", P: "18", Q: "79", R: "81", S: "83",
  T: "84", U: "85", V: "86", W: "87", X: "88", Y: "89", Z: "90", a: "91", b: "92", c: "93", d: "94", e: "95", f: "96", g: "97", h: "98", i: "\
99", j: "100", k: "101", l: "102", m: "103", n: "104", o: "105", p: "106", q: "107", r: "108", s: "109", t: "110", u: "111", v: "20", w: "21",
  x: "22", y: "23", z: "24", AB: "121", BB: "122", CB: "123", DB: "124", EB: "125", FB: "126", GB: "5", HB: "19", IB: "26", JB: "27", KB: "2\
8", LB: "29", MB: "30", NB: "31", OB: "32", PB: "33", QB: "34", RB: "35", SB: "36", TB: "37", UB: "38", VB: "39", WB: "40", XB: "41", YB: "4\
2", ZB: "43", aB: "44", bB: "45", cB: "46", dB: "47", eB: "48", fB: "49", gB: "50", hB: "51", iB: "52", jB: "53", kB: "54", lB: "55", mB: "5\
6", nB: "57", oB: "58", pB: "60", qB: "62", rB: "63", sB: "64", tB: "65", uB: "66", vB: "67", wB: "68", xB: "69", yB: "70", zB: "71", "0B": "\
72", "1B": "73", "2B": "74", "3B": "75", "4B": "76", "5B": "77", "6B": "78", "7B": "11.1", "8B": "12.1", "9B": "15.5", AC: "16.0", BC: "17.0",
  CC: "18.0", DC: "3", EC: "59", FC: "61", GC: "82", HC: "128", IC: "129", JC: "130", KC: "3.2", LC: "10.1", MC: "15.2-15.3", NC: "15.4", OC: "\
16.1", PC: "16.2", QC: "16.3", RC: "16.4", SC: "16.5", TC: "17.1", UC: "17.2", VC: "17.3", WC: "17.4", XC: "17.5", YC: "17.6", ZC: "11.5", aC: "\
4.2-4.3", bC: "5.5", cC: "2", dC: "131", eC: "3.5", fC: "3.6", gC: "3.1", hC: "5.1", iC: "6.1", jC: "7.1", kC: "9.1", lC: "13.1", mC: "14.1",
  nC: "15.1", oC: "15.6", pC: "16.6", qC: "TP", rC: "9.5-9.6", sC: "10.0-10.1", tC: "10.5", uC: "10.6", vC: "11.6", wC: "4.0-4.1", xC: "5.0-\
5.1", yC: "6.0-6.1", zC: "7.0-7.1", "0C": "8.1-8.4", "1C": "9.0-9.2", "2C": "9.3", "3C": "10.0-10.2", "4C": "10.3", "5C": "11.0-11.2", "6C": "\
11.3-11.4", "7C": "12.0-12.1", "8C": "12.2-12.5", "9C": "13.0-13.1", AD: "13.2", BD: "13.3", CD: "13.4-13.7", DD: "14.0-14.4", ED: "14.5-14.\
8", FD: "15.0-15.1", GD: "15.6-15.8", HD: "16.6-16.7", ID: "all", JD: "2.1", KD: "2.2", LD: "2.3", MD: "4.1", ND: "4.4", OD: "4.4.3-4.4.4", PD: "\
5.0-5.4", QD: "6.2-6.4", RD: "7.2-7.4", SD: "8.2", TD: "9.2", UD: "11.1-11.2", VD: "12.0", WD: "13.0", XD: "14.0", YD: "15.0", ZD: "19.0", aD: "\
14.9", bD: "13.52", cD: "2.5", dD: "3.0-3.1" };
});

// ../node_modules/caniuse-lite/dist/unpacker/browserVersions.js
var D0 = T((bwe, b2) => {
  b2.exports.browserVersions = g2();
});

// ../node_modules/caniuse-lite/data/agents.js
var v2 = T((Ewe, E2) => {
  E2.exports = { A: { A: { K: 0, E: 0, F: 0.046943, G: 0.0625907, A: 0, B: 0.500725, bC: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "bC", "K", "E", "F", "G", "A", "B", "", "", ""], E: "IE", F: { bC: 962323200, K: 998870400, E: 1161129600,
  F: 1237420800, G: 1300060800, A: 1346716800, B: 1381968e3 } }, B: { A: { 1: 7222e-6, 2: 0.014444, 3: 0.010833, 4: 7222e-6, 5: 7222e-6, 6: 0.010833,
  7: 7222e-6, 8: 0.014444, 9: 0.03611, C: 0, L: 0, M: 0, H: 0, N: 0, O: 3611e-6, P: 0.043332, Q: 0, I: 0, R: 0, S: 0, T: 0, U: 0, V: 0, W: 0,
  X: 0, Y: 0, Z: 0, a: 0, b: 0.014444, c: 0, d: 0, e: 0, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 0, q: 7222e-6, r: 7222e-6,
  s: 0.064998, t: 7222e-6, u: 7222e-6, AB: 0.021666, BB: 0.032499, CB: 0.021666, DB: 0.039721, EB: 0.122774, FB: 3.94682, D: 0.512762 }, B: "\
webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "C", "L", "M", "H", "N", "O", "P", "Q", "I", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "\
e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB",
  "CB", "DB", "EB", "FB", "D", "", "", ""], E: "Edge", F: { 1: 1680825600, 2: 1683158400, 3: 1685664e3, 4: 1689897600, 5: 1692576e3, 6: 1694649600,
  7: 1697155200, 8: 1698969600, 9: 1701993600, C: 1438128e3, L: 1447286400, M: 1470096e3, H: 1491868800, N: 1508198400, O: 1525046400, P: 1542067200,
  Q: 1579046400, I: 1581033600, R: 1586736e3, S: 1590019200, T: 1594857600, U: 1598486400, V: 1602201600, W: 1605830400, X: 161136e4, Y: 1614816e3,
  Z: 1618358400, a: 1622073600, b: 1626912e3, c: 1630627200, d: 1632441600, e: 1634774400, f: 1637539200, g: 1641427200, h: 1643932800, i: 1646265600,
  j: 1649635200, k: 1651190400, l: 1653955200, m: 1655942400, n: 1659657600, o: 1661990400, p: 1664755200, q: 1666915200, r: 1670198400, s: 1673481600,
  t: 1675900800, u: 1678665600, AB: 1706227200, BB: 1708732800, CB: 1711152e3, DB: 1713398400, EB: 1715990400, FB: 1718841600, D: 1721865600 },
  D: { C: "ms", L: "ms", M: "ms", H: "ms", N: "ms", O: "ms", P: "ms" } }, C: { A: { 0: 0, 1: 0, 2: 7222e-6, 3: 0, 4: 0.346656, 5: 0, 6: 7222e-6,
  7: 0.07222, 8: 0, 9: 7222e-6, cC: 0, DC: 0, J: 0, GB: 0, K: 0, E: 0, F: 0, G: 0, A: 0, B: 0.018055, C: 0, L: 0, M: 0, H: 0, N: 0, O: 0, P: 0,
  HB: 0, v: 0, w: 0, x: 0, y: 0, z: 0, IB: 0, JB: 0, KB: 0, LB: 0, MB: 0, NB: 0, OB: 0, PB: 0, QB: 0, RB: 0, SB: 0, TB: 0, UB: 0, VB: 0, WB: 0,
  XB: 0, YB: 0, ZB: 7222e-6, aB: 7222e-6, bB: 7222e-6, cB: 0, dB: 0, eB: 0, fB: 0, gB: 3611e-6, hB: 0, iB: 0.043332, jB: 3611e-6, kB: 7222e-6,
  lB: 0, mB: 0.018055, nB: 0, oB: 0, EC: 3611e-6, pB: 0, FC: 0, qB: 0, rB: 0, sB: 0, tB: 0, uB: 0, vB: 0, wB: 0, xB: 0, yB: 0, zB: 0, "0B": 3611e-6,
  "1B": 0, "2B": 0, "3B": 0, "4B": 0, "5B": 0, "6B": 0.014444, Q: 0, I: 0, R: 0, GC: 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 7222e-6, Y: 0, Z: 0,
  a: 0, b: 0, c: 0, d: 3611e-6, e: 0, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 7222e-6, m: 7222e-6, n: 0, o: 3611e-6, p: 0, q: 3611e-6, r: 3611e-6,
  s: 0.010833, t: 0, u: 0, AB: 0.010833, BB: 7222e-6, CB: 0.028888, DB: 0.010833, EB: 0.018055, FB: 0.046943, D: 0.592204, HC: 0.953304, IC: 7222e-6,
  JC: 0, dC: 0, eC: 0, fC: 0 }, B: "moz", C: ["cC", "DC", "eC", "fC", "J", "GB", "K", "E", "F", "G", "A", "B", "C", "L", "M", "H", "N", "O",
  "P", "HB", "v", "w", "x", "y", "z", "0", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "\
YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "EC", "pB", "FC", "qB", "rB", "sB", "tB",
  "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "2B", "3B", "4B", "5B", "6B", "Q", "I", "R", "GC", "S", "T", "U", "V", "W", "X", "Y", "Z",
  "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "1", "2", "3", "4", "5", "6", "7",
  "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "D", "HC", "IC", "JC", "dC"], E: "Firefox", F: { 0: 1379376e3, 1: 1681171200, 2: 1683590400,
  3: 1686009600, 4: 1688428800, 5: 1690848e3, 6: 1693267200, 7: 1695686400, 8: 1698105600, 9: 1700524800, cC: 1161648e3, DC: 1213660800, eC: 124632e4,
  fC: 1264032e3, J: 1300752e3, GB: 1308614400, K: 1313452800, E: 1317081600, F: 1317081600, G: 1320710400, A: 1324339200, B: 1327968e3, C: 1331596800,
  L: 1335225600, M: 1338854400, H: 1342483200, N: 1346112e3, O: 1349740800, P: 1353628800, HB: 1357603200, v: 1361232e3, w: 1364860800, x: 1368489600,
  y: 1372118400, z: 1375747200, IB: 1386633600, JB: 1391472e3, KB: 1395100800, LB: 1398729600, MB: 1402358400, NB: 1405987200, OB: 1409616e3,
  PB: 1413244800, QB: 1417392e3, RB: 1421107200, SB: 1424736e3, TB: 1428278400, UB: 1431475200, VB: 1435881600, WB: 1439251200, XB: 144288e4,
  YB: 1446508800, ZB: 1450137600, aB: 1453852800, bB: 1457395200, cB: 1461628800, dB: 1465257600, eB: 1470096e3, fB: 1474329600, gB: 1479168e3,
  hB: 1485216e3, iB: 1488844800, jB: 149256e4, kB: 1497312e3, lB: 1502150400, mB: 1506556800, nB: 1510617600, oB: 1516665600, EC: 1520985600,
  pB: 1525824e3, FC: 1529971200, qB: 1536105600, rB: 1540252800, sB: 1544486400, tB: 154872e4, uB: 1552953600, vB: 1558396800, wB: 1562630400,
  xB: 1567468800, yB: 1571788800, zB: 1575331200, "0B": 1578355200, "1B": 1581379200, "2B": 1583798400, "3B": 1586304e3, "4B": 1588636800, "\
5B": 1591056e3, "6B": 1593475200, Q: 1595894400, I: 1598313600, R: 1600732800, GC: 1603152e3, S: 1605571200, T: 1607990400, U: 1611619200, V: 1614038400,
  W: 1616457600, X: 1618790400, Y: 1622505600, Z: 1626134400, a: 1628553600, b: 1630972800, c: 1633392e3, d: 1635811200, e: 1638835200, f: 1641859200,
  g: 1644364800, h: 1646697600, i: 1649116800, j: 1651536e3, k: 1653955200, l: 1656374400, m: 1658793600, n: 1661212800, o: 1663632e3, p: 1666051200,
  q: 1668470400, r: 1670889600, s: 1673913600, t: 1676332800, u: 1678752e3, AB: 1702944e3, BB: 1705968e3, CB: 1708387200, DB: 1710806400, EB: 1713225600,
  FB: 1715644800, D: 1718064e3, HC: 1720483200, IC: null, JC: null, dC: null } }, D: { A: { 0: 0, 1: 0.050554, 2: 0.093886, 3: 0.090275, 4: 0.03611,
  5: 0.158884, 6: 0.104719, 7: 0.075831, 8: 0.064998, 9: 0.111941, J: 0, GB: 0, K: 0, E: 0, F: 0, G: 0, A: 0, B: 0, C: 0, L: 0, M: 0, H: 0, N: 0,
  O: 0, P: 0, HB: 0, v: 0, w: 0, x: 0, y: 0, z: 0, IB: 0, JB: 0, KB: 0, LB: 0, MB: 0, NB: 0, OB: 0, PB: 0, QB: 0, RB: 0, SB: 0, TB: 0, UB: 0.010833,
  VB: 0, WB: 0, XB: 0, YB: 0, ZB: 0, aB: 0, bB: 3611e-6, cB: 0, dB: 3611e-6, eB: 0.021666, fB: 0.021666, gB: 0.018055, hB: 0, iB: 3611e-6, jB: 7222e-6,
  kB: 0, lB: 0, mB: 0.010833, nB: 0, oB: 7222e-6, EC: 0, pB: 0, FC: 3611e-6, qB: 0, rB: 0, sB: 0, tB: 0, uB: 0.025277, vB: 7222e-6, wB: 0, xB: 0.014444,
  yB: 0.097497, zB: 3611e-6, "0B": 0, "1B": 0.014444, "2B": 0.010833, "3B": 0.010833, "4B": 7222e-6, "5B": 0.010833, "6B": 0.018055, Q: 0.10833,
  I: 0.014444, R: 0.021666, S: 0.03611, T: 7222e-6, U: 0.014444, V: 0.028888, W: 0.075831, X: 0.014444, Y: 0.010833, Z: 0.014444, a: 0.050554,
  b: 0.025277, c: 0.021666, d: 0.050554, e: 0.014444, f: 0.014444, g: 0.021666, h: 0.054165, i: 0.032499, j: 0.021666, k: 0.021666, l: 0.014444,
  m: 0.126385, n: 0.064998, o: 0.018055, p: 0.032499, q: 0.03611, r: 0.054165, s: 1.46607, t: 0.028888, u: 0.043332, AB: 0.148051, BB: 0.184161,
  CB: 0.176939, DB: 0.278047, EB: 0.769143, FB: 14.4007, D: 1.68273, HC: 0.018055, IC: 0, JC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "\
J", "GB", "K", "E", "F", "G", "A", "B", "C", "L", "M", "H", "N", "O", "P", "HB", "v", "w", "x", "y", "z", "0", "IB", "JB", "KB", "LB", "MB",
  "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "\
kB", "lB", "mB", "nB", "oB", "EC", "pB", "FC", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "2B", "3B", "4B", "5B",
  "6B", "Q", "I", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p",
  "q", "r", "s", "t", "u", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "D", "HC", "IC", "JC"], E: "Chro\
me", F: { 0: 1357862400, 1: 1680566400, 2: 1682985600, 3: 1685404800, 4: 1689724800, 5: 1692057600, 6: 1694476800, 7: 1696896e3, 8: 1698710400,
  9: 1701993600, J: 1264377600, GB: 1274745600, K: 1283385600, E: 1287619200, F: 1291248e3, G: 1296777600, A: 1299542400, B: 1303862400, C: 1307404800,
  L: 1312243200, M: 1316131200, H: 1316131200, N: 1319500800, O: 1323734400, P: 1328659200, HB: 1332892800, v: 133704e4, w: 1340668800, x: 1343692800,
  y: 1348531200, z: 1352246400, IB: 1361404800, JB: 1364428800, KB: 1369094400, LB: 1374105600, MB: 1376956800, NB: 1384214400, OB: 1389657600,
  PB: 1392940800, QB: 1397001600, RB: 1400544e3, SB: 1405468800, TB: 1409011200, UB: 141264e4, VB: 1416268800, WB: 1421798400, XB: 1425513600,
  YB: 1429401600, ZB: 143208e4, aB: 1437523200, bB: 1441152e3, cB: 1444780800, dB: 1449014400, eB: 1453248e3, fB: 1456963200, gB: 1460592e3,
  hB: 1464134400, iB: 1469059200, jB: 1472601600, kB: 1476230400, lB: 1480550400, mB: 1485302400, nB: 1489017600, oB: 149256e4, EC: 1496707200,
  pB: 1500940800, FC: 1504569600, qB: 1508198400, rB: 1512518400, sB: 1516752e3, tB: 1520294400, uB: 1523923200, vB: 1527552e3, wB: 1532390400,
  xB: 1536019200, yB: 1539648e3, zB: 1543968e3, "0B": 154872e4, "1B": 1552348800, "2B": 1555977600, "3B": 1559606400, "4B": 1564444800, "5B": 1568073600,
  "6B": 1571702400, Q: 1575936e3, I: 1580860800, R: 1586304e3, S: 1589846400, T: 1594684800, U: 1598313600, V: 1601942400, W: 1605571200, X: 1611014400,
  Y: 1614556800, Z: 1618272e3, a: 1621987200, b: 1626739200, c: 1630368e3, d: 1632268800, e: 1634601600, f: 1637020800, g: 1641340800, h: 1643673600,
  i: 1646092800, j: 1648512e3, k: 1650931200, l: 1653350400, m: 1655769600, n: 1659398400, o: 1661817600, p: 1664236800, q: 1666656e3, r: 166968e4,
  s: 1673308800, t: 1675728e3, u: 1678147200, AB: 1705968e3, BB: 1708387200, CB: 1710806400, DB: 1713225600, EB: 1715644800, FB: 1718064e3, D: 1721174400,
  HC: null, IC: null, JC: null } }, E: { A: { J: 0, GB: 0, K: 0, E: 0, F: 0, G: 3611e-6, A: 0, B: 0, C: 0, L: 7222e-6, M: 0.032499, H: 7222e-6,
  gC: 0, KC: 0, hC: 0, iC: 0, jC: 0, kC: 0, LC: 0, "7B": 7222e-6, "8B": 0.010833, lC: 0.061387, mC: 0.086664, nC: 0.025277, MC: 0.010833, NC: 0.021666,
  "9B": 0.032499, oC: 0.227493, AC: 0.028888, OC: 0.043332, PC: 0.03611, QC: 0.10833, RC: 0.025277, SC: 0.043332, pC: 0.299713, BC: 0.021666,
  TC: 0.043332, UC: 0.043332, VC: 0.050554, WC: 0.133607, XC: 1.76578, YC: 0.010833, CC: 0.010833, qC: 0 }, B: "webkit", C: ["", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "gC", "KC", "J", "GB", "hC", "K", "iC", "E", "jC", "F", "G", "kC", "A", "LC", "B",
  "7B", "C", "8B", "L", "lC", "M", "mC", "H", "nC", "MC", "NC", "9B", "oC", "AC", "OC", "PC", "QC", "RC", "SC", "pC", "BC", "TC", "UC", "VC",
  "WC", "XC", "YC", "CC", "qC"], E: "Safari", F: { gC: 1205798400, KC: 1226534400, J: 1244419200, GB: 1275868800, hC: 131112e4, K: 1343174400,
  iC: 13824e5, E: 13824e5, jC: 1410998400, F: 1413417600, G: 1443657600, kC: 1458518400, A: 1474329600, LC: 1490572800, B: 1505779200, "7B": 1522281600,
  C: 1537142400, "8B": 1553472e3, L: 1568851200, lC: 1585008e3, M: 1600214400, mC: 1619395200, H: 1632096e3, nC: 1635292800, MC: 1639353600,
  NC: 1647216e3, "9B": 1652745600, oC: 1658275200, AC: 1662940800, OC: 1666569600, PC: 1670889600, QC: 1674432e3, RC: 1679875200, SC: 1684368e3,
  pC: 1690156800, BC: 1695686400, TC: 1698192e3, UC: 1702252800, VC: 1705881600, WC: 1709596800, XC: 1715558400, YC: null, CC: null, qC: null } },
  F: { A: { 0: 0, G: 0, B: 0, C: 0, H: 0, N: 0, O: 0, P: 0, HB: 0, v: 0, w: 0, x: 0, y: 0, z: 0, IB: 0, JB: 0, KB: 0, LB: 0, MB: 0, NB: 0, OB: 0,
  PB: 0, QB: 0, RB: 0, SB: 3611e-6, TB: 0, UB: 0, VB: 0, WB: 3611e-6, XB: 0, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 0.018055, dB: 0, eB: 0, fB: 0, gB: 0,
  hB: 0, iB: 0, jB: 0, kB: 0, lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0, sB: 0, tB: 0, uB: 0, vB: 0, wB: 0, xB: 0, yB: 0, zB: 0, "0B": 0,
  "1B": 0, "2B": 0, "3B": 0, "4B": 0, "5B": 0, "6B": 0, Q: 0, I: 0, R: 0, GC: 0, S: 0.028888, T: 0, U: 0, V: 0, W: 0, X: 0, Y: 0, Z: 0, a: 0,
  b: 0, c: 0, d: 0, e: 0.039721, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0.028888, m: 0, n: 0, o: 0, p: 0, q: 0, r: 0, s: 0.285269, t: 0.010833,
  u: 0.310546, rC: 0, sC: 0, tC: 0, uC: 0, "7B": 0, ZC: 0, vC: 0, "8B": 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "G", "rC", "sC", "tC", "uC", "B", "7B", "ZC", "vC", "C", "8B", "H", "N", "O", "P", "HB", "v", "\
w", "x", "y", "z", "0", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "b\
B", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB",
  "zB", "0B", "1B", "2B", "3B", "4B", "5B", "6B", "Q", "I", "R", "GC", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f",
  "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "", "", ""], E: "Opera", F: { 0: 1413331200, G: 1150761600, rC: 1223424e3,
  sC: 1251763200, tC: 1267488e3, uC: 1277942400, B: 1292457600, "7B": 1302566400, ZC: 1309219200, vC: 1323129600, C: 1323129600, "8B": 1352073600,
  H: 1372723200, N: 1377561600, O: 1381104e3, P: 1386288e3, HB: 1390867200, v: 1393891200, w: 1399334400, x: 1401753600, y: 1405987200, z: 1409616e3,
  IB: 1417132800, JB: 1422316800, KB: 1425945600, LB: 1430179200, MB: 1433808e3, NB: 1438646400, OB: 1442448e3, PB: 1445904e3, QB: 1449100800,
  RB: 1454371200, SB: 1457308800, TB: 146232e4, UB: 1465344e3, VB: 1470096e3, WB: 1474329600, XB: 1477267200, YB: 1481587200, ZB: 1486425600,
  aB: 1490054400, bB: 1494374400, cB: 1498003200, dB: 1502236800, eB: 1506470400, fB: 1510099200, gB: 1515024e3, hB: 1517961600, iB: 1521676800,
  jB: 1525910400, kB: 1530144e3, lB: 1534982400, mB: 1537833600, nB: 1543363200, oB: 1548201600, pB: 1554768e3, qB: 1561593600, rB: 1566259200,
  sB: 1570406400, tB: 1573689600, uB: 1578441600, vB: 1583971200, wB: 1587513600, xB: 1592956800, yB: 1595894400, zB: 1600128e3, "0B": 1603238400,
  "1B": 161352e4, "2B": 1612224e3, "3B": 1616544e3, "4B": 1619568e3, "5B": 1623715200, "6B": 1627948800, Q: 1631577600, I: 1633392e3, R: 1635984e3,
  GC: 1638403200, S: 1642550400, T: 1644969600, U: 1647993600, V: 1650412800, W: 1652745600, X: 1654646400, Y: 1657152e3, Z: 1660780800, a: 1663113600,
  b: 1668816e3, c: 1668643200, d: 1671062400, e: 1675209600, f: 1677024e3, g: 1679529600, h: 1681948800, i: 1684195200, j: 1687219200, k: 1690329600,
  l: 1692748800, m: 1696204800, n: 169992e4, o: 169992e4, p: 1702944e3, q: 1707264e3, r: 1710115200, s: 1711497600, t: 1716336e3, u: 1719273600 },
  D: { G: "o", B: "o", C: "o", rC: "o", sC: "o", tC: "o", uC: "o", "7B": "o", ZC: "o", vC: "o", "8B": "o" } }, G: { A: { F: 0, KC: 0, wC: 0,
  aC: 441539e-8, xC: 14718e-7, yC: 883077e-8, zC: 883077e-8, "0C": 0, "1C": 735898e-8, "2C": 0.0294359, "3C": 588718e-8, "4C": 0.0515128, "5\
C": 0.135405, "6C": 0.014718, "7C": 0.0103026, "8C": 0.189862, "9C": 294359e-8, AD: 0.0323795, BD: 0.0103026, CD: 0.0441539, DD: 0.13099, ED: 0.1148,
  FD: 0.0574, MC: 0.0618154, NC: 0.0706462, "9B": 0.0853641, GD: 0.780051, AC: 0.15601, OC: 0.334098, PC: 0.166313, QC: 0.279641, RC: 0.0662308,
  SC: 0.117744, HD: 0.974328, BC: 0.0883077, TC: 0.142764, UC: 0.139821, VC: 0.207523, WC: 0.518072, XC: 9.49014, YC: 0.0735898, CC: 0.0971385 },
  B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "KC", "wC", "aC", "xC", "yC", "zC", "F", "0C",
  "1C", "2C", "3C", "4C", "5C", "6C", "7C", "8C", "9C", "AD", "BD", "CD", "DD", "ED", "FD", "MC", "NC", "9B", "GD", "AC", "OC", "PC", "QC", "\
RC", "SC", "HD", "BC", "TC", "UC", "VC", "WC", "XC", "YC", "CC", ""], E: "Safari on iOS", F: { KC: 1270252800, wC: 1283904e3, aC: 1299628800,
  xC: 1331078400, yC: 1359331200, zC: 1394409600, F: 1410912e3, "0C": 1413763200, "1C": 1442361600, "2C": 1458518400, "3C": 1473724800, "4C": 1490572800,
  "5C": 1505779200, "6C": 1522281600, "7C": 1537142400, "8C": 1553472e3, "9C": 1568851200, AD: 1572220800, BD: 1580169600, CD: 1585008e3, DD: 1600214400,
  ED: 1619395200, FD: 1632096e3, MC: 1639353600, NC: 1647216e3, "9B": 1652659200, GD: 1658275200, AC: 1662940800, OC: 1666569600, PC: 1670889600,
  QC: 1674432e3, RC: 1679875200, SC: 1684368e3, HD: 1690156800, BC: 1694995200, TC: 1698192e3, UC: 1702252800, VC: 1705881600, WC: 1709596800,
  XC: 1715558400, YC: null, CC: null } }, H: { A: { ID: 0.05 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "ID", "", "", ""], E: "Opera Mini", F: { ID: 1426464e3 } }, I: { A: { DC: 0, J: 811276e-10, D: 0.808599, JD: 0, KD: 162255e-9,
  LD: 0, MD: 486766e-9, aC: 32451e-8, ND: 0, OD: 129804e-8 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "JD", "\
KD", "LD", "DC", "J", "MD", "aC", "ND", "OD", "D", "", "", ""], E: "Android Browser", F: { JD: 1256515200, KD: 1274313600, LD: 1291593600, DC: 1298332800,
  J: 1318896e3, MD: 1341792e3, aC: 1374624e3, ND: 1386547200, OD: 1401667200, D: 1721692800 } }, J: { A: { E: 0, A: 0 }, B: "webkit", C: ["",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "E", "A", "", "", ""], E: "Blackberry Browser", F: { E: 1325376e3,
  A: 1359504e3 } }, K: { A: { A: 0, B: 0, C: 0, I: 1.119, "7B": 0, ZC: 0, "8B": 0 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "A", "B", "7B", "ZC", "C", "8B", "I", "", "", ""], E: "Opera Mobile", F: { A: 1287100800, B: 1300752e3, "7B": 1314835200,
  ZC: 1318291200, C: 1330300800, "8B": 1349740800, I: 1709769600 }, D: { I: "webkit" } }, L: { A: { D: 44.0982 }, B: "webkit", C: ["", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "", "", ""], E: "Chrome for Android", F: { D: 1721692800 } },
  M: { A: { D: 0.35134 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "", "",
  ""], E: "Firefox for Android", F: { D: 1718064e3 } }, N: { A: { A: 0, B: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""], E: "IE Mobile", F: { A: 1340150400, B: 1353456e3 } }, O: { A: { "9B": 1.05402 },
  B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "9B", "", "", ""], E: "UC Brow\
ser for Android", F: { "9B": 1710115200 }, D: { "9B": "webkit" } }, P: { A: { 0: 1.65553, J: 0.0973844, v: 0.021641, w: 0.043282, x: 0.0649229,
  y: 0.0757434, z: 0.0757434, PD: 0.0108205, QD: 0.0108205, RD: 0.0324615, SD: 0, TD: 0, LC: 0, UD: 0, VD: 0, WD: 0.0108205, XD: 0, YD: 0, AC: 0,
  BC: 0.021641, CC: 0.0108205, ZD: 0.021641 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "J", "PD", "QD", "RD", "SD", "TD", "LC", "UD", "VD", "WD", "XD", "YD",
  "AC", "BC", "CC", "ZD", "v", "w", "x", "y", "z", "0", "", "", ""], E: "Samsung Internet", F: { 0: 1715126400, J: 1461024e3, PD: 1481846400,
  QD: 1509408e3, RD: 1528329600, SD: 1546128e3, TD: 1554163200, LC: 1567900800, UD: 1582588800, VD: 1593475200, WD: 1605657600, XD: 1618531200,
  YD: 1629072e3, AC: 1640736e3, BC: 1651708800, CC: 1659657600, ZD: 1667260800, v: 1677369600, w: 1684454400, x: 1689292800, y: 1697587200, z: 1711497600 } },
  Q: { A: { aD: 0.338564 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a\
D", "", "", ""], E: "QQ Browser", F: { aD: 1710288e3 } }, R: { A: { bD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "bD", "", "", ""], E: "Baidu Browser", F: { bD: 1710201600 } }, S: { A: { cD: 0.070268, dD: 0 },
  B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "cD", "dD", "", "", ""], E: "KaiOS Bro\
wser", F: { cD: 1527811200, dD: 1631664e3 } } };
});

// ../node_modules/caniuse-lite/dist/unpacker/agents.js
var P2 = T((vwe, S2) => {
  "use strict";
  var vfe = xc().browsers, I0 = D0().browserVersions, T2 = v2();
  function x2(e) {
    return Object.keys(e).reduce((t, r) => (t[I0[r]] = e[r], t), {});
  }
  s(x2, "unpackBrowserVersions");
  S2.exports.agents = Object.keys(T2).reduce((e, t) => {
    let r = T2[t];
    return e[vfe[t]] = Object.keys(r).reduce((n, i) => (i === "A" ? n.usage_global = x2(r[i]) : i === "C" ? n.versions = r[i].reduce((a, o) => (o ===
    "" ? a.push(null) : a.push(I0[o]), a), []) : i === "D" ? n.prefix_exceptions = x2(r[i]) : i === "E" ? n.browser = r[i] : i === "F" ? n.release_date =
    Object.keys(r[i]).reduce(
      (a, o) => (a[I0[o]] = r[i][o], a),
      {}
    ) : n.prefix = r[i], n), {}), e;
  }, {});
});

// ../node_modules/node-releases/data/release-schedule/release-schedule.json
var A2 = T((xwe, Tfe) => {
  Tfe.exports = { "v0.8": { start: "2012-06-25", end: "2014-07-31" }, "v0.10": { start: "2013-03-11", end: "2016-10-31" }, "v0.12": { start: "\
2015-02-06", end: "2016-12-31" }, v4: { start: "2015-09-08", lts: "2015-10-12", maintenance: "2017-04-01", end: "2018-04-30", codename: "Arg\
on" }, v5: { start: "2015-10-29", maintenance: "2016-04-30", end: "2016-06-30" }, v6: { start: "2016-04-26", lts: "2016-10-18", maintenance: "\
2018-04-30", end: "2019-04-30", codename: "Boron" }, v7: { start: "2016-10-25", maintenance: "2017-04-30", end: "2017-06-30" }, v8: { start: "\
2017-05-30", lts: "2017-10-31", maintenance: "2019-01-01", end: "2019-12-31", codename: "Carbon" }, v9: { start: "2017-10-01", maintenance: "\
2018-04-01", end: "2018-06-30" }, v10: { start: "2018-04-24", lts: "2018-10-30", maintenance: "2020-05-19", end: "2021-04-30", codename: "Du\
bnium" }, v11: { start: "2018-10-23", maintenance: "2019-04-22", end: "2019-06-01" }, v12: { start: "2019-04-23", lts: "2019-10-21", maintenance: "\
2020-11-30", end: "2022-04-30", codename: "Erbium" }, v13: { start: "2019-10-22", maintenance: "2020-04-01", end: "2020-06-01" }, v14: { start: "\
2020-04-21", lts: "2020-10-27", maintenance: "2021-10-19", end: "2023-04-30", codename: "Fermium" }, v15: { start: "2020-10-20", maintenance: "\
2021-04-01", end: "2021-06-01" }, v16: { start: "2021-04-20", lts: "2021-10-26", maintenance: "2022-10-18", end: "2023-09-11", codename: "Ga\
llium" }, v17: { start: "2021-10-19", maintenance: "2022-04-01", end: "2022-06-01" }, v18: { start: "2022-04-19", lts: "2022-10-25", maintenance: "\
2023-10-18", end: "2025-04-30", codename: "Hydrogen" }, v19: { start: "2022-10-18", maintenance: "2023-04-01", end: "2023-06-01" }, v20: { start: "\
2023-04-18", lts: "2023-10-24", maintenance: "2024-10-22", end: "2026-04-30", codename: "Iron" }, v21: { start: "2023-10-17", maintenance: "\
2024-04-01", end: "2024-06-01" }, v22: { start: "2024-04-24", lts: "2024-10-29", maintenance: "2025-10-21", end: "2027-04-30", codename: "" },
  v23: { start: "2024-10-15", maintenance: "2025-04-01", end: "2025-06-01" }, v24: { start: "2025-04-22", lts: "2025-10-28", maintenance: "2\
026-10-20", end: "2028-04-30", codename: "" } };
});

// ../node_modules/electron-to-chromium/versions.js
var w2 = T((Swe, C2) => {
  C2.exports = {
    "0.20": "39",
    "0.21": "41",
    "0.22": "41",
    "0.23": "41",
    "0.24": "41",
    "0.25": "42",
    "0.26": "42",
    "0.27": "43",
    "0.28": "43",
    "0.29": "43",
    "0.30": "44",
    "0.31": "45",
    "0.32": "45",
    "0.33": "45",
    "0.34": "45",
    "0.35": "45",
    "0.36": "47",
    "0.37": "49",
    "1.0": "49",
    "1.1": "50",
    "1.2": "51",
    "1.3": "52",
    "1.4": "53",
    "1.5": "54",
    "1.6": "56",
    "1.7": "58",
    "1.8": "59",
    "2.0": "61",
    "2.1": "61",
    "3.0": "66",
    "3.1": "66",
    "4.0": "69",
    "4.1": "69",
    "4.2": "69",
    "5.0": "73",
    "6.0": "76",
    "6.1": "76",
    "7.0": "78",
    "7.1": "78",
    "7.2": "78",
    "7.3": "78",
    "8.0": "80",
    "8.1": "80",
    "8.2": "80",
    "8.3": "80",
    "8.4": "80",
    "8.5": "80",
    "9.0": "83",
    "9.1": "83",
    "9.2": "83",
    "9.3": "83",
    "9.4": "83",
    "10.0": "85",
    "10.1": "85",
    "10.2": "85",
    "10.3": "85",
    "10.4": "85",
    "11.0": "87",
    "11.1": "87",
    "11.2": "87",
    "11.3": "87",
    "11.4": "87",
    "11.5": "87",
    "12.0": "89",
    "12.1": "89",
    "12.2": "89",
    "13.0": "91",
    "13.1": "91",
    "13.2": "91",
    "13.3": "91",
    "13.4": "91",
    "13.5": "91",
    "13.6": "91",
    "14.0": "93",
    "14.1": "93",
    "14.2": "93",
    "15.0": "94",
    "15.1": "94",
    "15.2": "94",
    "15.3": "94",
    "15.4": "94",
    "15.5": "94",
    "16.0": "96",
    "16.1": "96",
    "16.2": "96",
    "17.0": "98",
    "17.1": "98",
    "17.2": "98",
    "17.3": "98",
    "17.4": "98",
    "18.0": "100",
    "18.1": "100",
    "18.2": "100",
    "18.3": "100",
    "19.0": "102",
    "19.1": "102",
    "20.0": "104",
    "20.1": "104",
    "20.2": "104",
    "20.3": "104",
    "21.0": "106",
    "21.1": "106",
    "21.2": "106",
    "21.3": "106",
    "21.4": "106",
    "22.0": "108",
    "22.1": "108",
    "22.2": "108",
    "22.3": "108",
    "23.0": "110",
    "23.1": "110",
    "23.2": "110",
    "23.3": "110",
    "24.0": "112",
    "24.1": "112",
    "24.2": "112",
    "24.3": "112",
    "24.4": "112",
    "24.5": "112",
    "24.6": "112",
    "24.7": "112",
    "24.8": "112",
    "25.0": "114",
    "25.1": "114",
    "25.2": "114",
    "25.3": "114",
    "25.4": "114",
    "25.5": "114",
    "25.6": "114",
    "25.7": "114",
    "25.8": "114",
    "25.9": "114",
    "26.0": "116",
    "26.1": "116",
    "26.2": "116",
    "26.3": "116",
    "26.4": "116",
    "26.5": "116",
    "26.6": "116",
    "27.0": "118",
    "27.1": "118",
    "27.2": "118",
    "27.3": "118",
    "28.0": "120",
    "28.1": "120",
    "28.2": "120",
    "28.3": "120",
    "29.0": "122",
    "29.1": "122",
    "29.2": "122",
    "29.3": "122",
    "29.4": "122",
    "30.0": "124",
    "30.1": "124",
    "30.2": "124",
    "30.3": "124",
    "31.0": "126",
    "31.1": "126",
    "31.2": "126",
    "31.3": "126",
    "32.0": "128"
  };
});

// ../node_modules/browserslist/error.js
var O0 = T((Pwe, D2) => {
  function _0(e) {
    this.name = "BrowserslistError", this.message = e, this.browserslist = !0, Error.captureStackTrace && Error.captureStackTrace(this, _0);
  }
  s(_0, "BrowserslistError");
  _0.prototype = Error.prototype;
  D2.exports = _0;
});

// ../node_modules/browserslist/parse.js
var B2 = T((Cwe, N2) => {
  var I2 = /^\s+and\s+(.*)/i, _2 = /^(?:,\s*|\s+or\s+)(.*)/i;
  function O2(e) {
    return Array.isArray(e) ? e.reduce(function(t, r) {
      return t.concat(O2(r));
    }, []) : [e];
  }
  s(O2, "flatten");
  function xfe(e, t) {
    for (var r = 1, n = e.length; r <= n; r++) {
      var i = e.substr(-r, r);
      if (t(i, r, n))
        return e.slice(0, -r);
    }
    return "";
  }
  s(xfe, "find");
  function N0(e, t) {
    var r = { query: t };
    t.indexOf("not ") === 0 && (r.not = !0, t = t.slice(4));
    for (var n in e) {
      var i = e[n], a = t.match(i.regexp);
      if (a) {
        r.type = n;
        for (var o = 0; o < i.matches.length; o++)
          r[i.matches[o]] = a[o + 1];
        return r;
      }
    }
    return r.type = "unknown", r;
  }
  s(N0, "matchQuery");
  function Sfe(e, t, r) {
    var n;
    return xfe(t, function(i, a, o) {
      return I2.test(i) ? (n = N0(e, i.match(I2)[1]), n.compose = "and", r.unshift(n), !0) : _2.test(i) ? (n = N0(e, i.match(_2)[1]), n.compose =
      "or", r.unshift(n), !0) : a === o ? (n = N0(e, i.trim()), n.compose = "or", r.unshift(n), !0) : !1;
    });
  }
  s(Sfe, "matchBlock");
  N2.exports = /* @__PURE__ */ s(function(t, r) {
    return Array.isArray(r) || (r = [r]), O2(
      r.map(function(n) {
        var i = [];
        do
          n = Sfe(t, n, i);
        while (n);
        return i;
      })
    );
  }, "parse");
});

// ../node_modules/caniuse-lite/dist/lib/statuses.js
var F2 = T((Dwe, k2) => {
  k2.exports = {
    1: "ls",
    // WHATWG Living Standard
    2: "rec",
    // W3C Recommendation
    3: "pr",
    // W3C Proposed Recommendation
    4: "cr",
    // W3C Candidate Recommendation
    5: "wd",
    // W3C Working Draft
    6: "other",
    // Non-W3C, but reputable
    7: "unoff"
    // Unofficial, Editor's Draft or W3C "Note"
  };
});

// ../node_modules/caniuse-lite/dist/lib/supported.js
var L2 = T((Iwe, j2) => {
  j2.exports = {
    y: 1,
    n: 2,
    a: 4,
    p: 8,
    u: 16,
    x: 32,
    d: 64
  };
});

// ../node_modules/caniuse-lite/dist/unpacker/feature.js
var q2 = T((_we, B0) => {
  "use strict";
  var Pfe = F2(), M2 = L2(), Afe = xc().browsers, Cfe = D0().browserVersions, wfe = Math.log(2);
  function Dfe(e) {
    let t = Object.keys(M2).reduce((i, a) => (e & M2[a] && i.push(a), i), []), r = e >> 7, n = [];
    for (; r; ) {
      let i = Math.floor(Math.log(r) / wfe) + 1;
      n.unshift(`#${i}`), r -= Math.pow(2, i - 1);
    }
    return t.concat(n).join(" ");
  }
  s(Dfe, "unpackSupport");
  function R2(e) {
    let t = {
      status: Pfe[e.B],
      title: e.C,
      shown: e.D
    };
    return t.stats = Object.keys(e.A).reduce((r, n) => {
      let i = e.A[n];
      return r[Afe[n]] = Object.keys(i).reduce(
        (a, o) => {
          let l = i[o].split(" "), u = Dfe(o);
          return l.forEach((c) => a[Cfe[c]] = u), a;
        },
        {}
      ), r;
    }, {}), t;
  }
  s(R2, "unpackFeature");
  B0.exports = R2;
  B0.exports.default = R2;
});

// ../node_modules/caniuse-lite/dist/unpacker/region.js
var V2 = T((Nwe, k0) => {
  "use strict";
  var Ife = xc().browsers;
  function U2(e) {
    return Object.keys(e).reduce((t, r) => {
      let n = e[r];
      return t[Ife[r]] = Object.keys(n).reduce((i, a) => {
        let o = n[a];
        return a === "_" ? o.split(" ").forEach((l) => i[l] = null) : i[a] = o, i;
      }, {}), t;
    }, {});
  }
  s(U2, "unpackRegion");
  k0.exports = U2;
  k0.exports.default = U2;
});

// ../node_modules/browserslist/node.js
var z2 = T((kwe, ii) => {
  var _fe = q2().default, Ofe = V2().default, Tr = ie("path"), Qi = ie("fs"), zt = O0(), $2 = /^\s*\[(.+)]\s*$/, Nfe = /^browserslist-config-/,
  Bfe = /@[^/]+(?:\/[^/]+)?\/browserslist-config(?:-|$|\/)/, kfe = 6 * 30 * 24 * 60 * 60 * 1e3, W2 = "Browserslist config should be a string\
 or an array of strings with browser queries", F0 = !1, Ac = {}, Sc = {};
  function K2(e) {
    var t = " Use `dangerousExtend` option to disable.";
    if (!Nfe.test(e) && !Bfe.test(e))
      throw new zt(
        "Browserslist config needs `browserslist-config-` prefix. " + t
      );
    if (e.replace(/^@[^/]+\//, "").indexOf(".") !== -1)
      throw new zt(
        "`.` not allowed in Browserslist config name. " + t
      );
    if (e.indexOf("node_modules") !== -1)
      throw new zt(
        "`node_modules` not allowed in Browserslist config." + t
      );
  }
  s(K2, "checkExtend");
  function yn(e) {
    if (e in Ac)
      return Ac[e];
    var t = Qi.existsSync(e) && Qi.statSync(e).isFile();
    return process.env.BROWSERSLIST_DISABLE_CACHE || (Ac[e] = t), t;
  }
  s(yn, "isFile");
  function G2(e, t) {
    var r = yn(e) ? Tr.dirname(e) : e, n = Tr.resolve(r);
    do {
      if (!Ffe(n)) break;
      var i = t(n);
      if (typeof i < "u") return i;
    } while (n !== (n = Tr.dirname(n)));
  }
  s(G2, "eachParent");
  function Ffe(e) {
    if (!process.env.BROWSERSLIST_ROOT_PATH) return !0;
    var t = Tr.resolve(process.env.BROWSERSLIST_ROOT_PATH);
    return Tr.relative(t, e).substring(0, 2) !== "..";
  }
  s(Ffe, "pathInRoot");
  function jfe(e) {
    if (Array.isArray(e)) {
      for (var t = 0; t < e.length; t++)
        if (typeof e[t] != "string")
          throw new zt(W2);
    } else if (typeof e != "string")
      throw new zt(W2);
  }
  s(jfe, "check");
  function Pc(e, t) {
    if (typeof e != "object") return e;
    var r;
    if (typeof t.env == "string" ? r = t.env : process.env.BROWSERSLIST_ENV ? r = process.env.BROWSERSLIST_ENV : process.env.NODE_ENV ? r = process.
    env.NODE_ENV : r = "production", t.throwOnMissing && r && r !== "defaults" && !e[r])
      throw new zt(
        "Missing config for Browserslist environment `" + r + "`"
      );
    return e[r] || e.defaults;
  }
  s(Pc, "pickEnv");
  function H2(e) {
    var t = JSON.parse(
      Qi.readFileSync(e).toString().replace(/^\uFEFF/m, "")
    );
    if (t.browserlist && !t.browserslist)
      throw new zt(
        "`browserlist` key instead of `browserslist` in " + e
      );
    var r = t.browserslist;
    (Array.isArray(r) || typeof r == "string") && (r = { defaults: r });
    for (var n in r)
      jfe(r[n]);
    return r;
  }
  s(H2, "parsePackage");
  function Lfe(e) {
    var t = 0;
    for (var r in e) {
      var n = e[r].releaseDate || {};
      for (var i in n)
        t < n[i] && (t = n[i]);
    }
    return t * 1e3;
  }
  s(Lfe, "latestReleaseTime");
  function Y2(e, t) {
    if (e || (e = {}), t && "dataByBrowser" in t && (t = t.dataByBrowser), typeof t == "object") {
      var r = {};
      for (var n in t) {
        var i = Object.keys(t[n]);
        if (i.length === 1 && e[n] && e[n].versions.length === 1) {
          var a = e[n].versions[0];
          r[n] = {}, r[n][a] = t[n][i[0]];
        } else
          r[n] = t[n];
      }
      return r;
    }
  }
  s(Y2, "normalizeStats");
  function Mfe(e, t) {
    for (var r in e) {
      var n = e[r];
      if ("0" in n) {
        var i = t[r].versions;
        n[i[i.length - 1]] = n[0], delete n[0];
      }
    }
  }
  s(Mfe, "normalizeUsageData");
  ii.exports = {
    loadQueries: /* @__PURE__ */ s(function(t, r) {
      !t.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND && K2(r);
      var n = ie(ie.resolve(r, { paths: [".", t.path] }));
      if (n) {
        if (Array.isArray(n))
          return n;
        if (typeof n == "object")
          return n.defaults || (n.defaults = []), Pc(n, t, r);
      }
      throw new zt(
        "`" + r + "` config exports not an array of queries or an object of envs"
      );
    }, "loadQueries"),
    loadStat: /* @__PURE__ */ s(function(t, r, n) {
      !t.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND && K2(r);
      var i = ie(ie.resolve(
        Tr.join(r, "browserslist-stats.json"),
        { paths: ["."] }
      ));
      return Y2(n, i);
    }, "loadStat"),
    getStat: /* @__PURE__ */ s(function(t, r) {
      var n;
      if (t.stats ? n = t.stats : process.env.BROWSERSLIST_STATS ? n = process.env.BROWSERSLIST_STATS : t.path && Tr.resolve && Qi.existsSync &&
      (n = G2(t.path, function(i) {
        var a = Tr.join(i, "browserslist-stats.json");
        return yn(a) ? a : void 0;
      })), typeof n == "string")
        try {
          n = JSON.parse(Qi.readFileSync(n));
        } catch {
          throw new zt("Can't read " + n);
        }
      return Y2(r, n);
    }, "getStat"),
    loadConfig: /* @__PURE__ */ s(function(t) {
      if (process.env.BROWSERSLIST)
        return process.env.BROWSERSLIST;
      if (t.config || process.env.BROWSERSLIST_CONFIG) {
        var r = t.config || process.env.BROWSERSLIST_CONFIG;
        return Tr.basename(r) === "package.json" ? Pc(H2(r), t) : Pc(ii.exports.readConfig(r), t);
      } else return t.path ? Pc(ii.exports.findConfig(t.path), t) : void 0;
    }, "loadConfig"),
    loadCountry: /* @__PURE__ */ s(function(t, r, n) {
      var i = r.replace(/[^\w-]/g, "");
      if (!t[i]) {
        var a;
        try {
          a = ie("caniuse-lite/data/regions/" + i + ".js");
        } catch {
          throw new zt("Unknown region name `" + i + "`.");
        }
        var o = Ofe(a);
        Mfe(o, n), t[r] = {};
        for (var l in o)
          for (var u in o[l])
            t[r][l + " " + u] = o[l][u];
      }
    }, "loadCountry"),
    loadFeature: /* @__PURE__ */ s(function(t, r) {
      if (r = r.replace(/[^\w-]/g, ""), !t[r]) {
        var n;
        try {
          n = ie("caniuse-lite/data/features/" + r + ".js");
        } catch {
          throw new zt("Unknown feature name `" + r + "`.");
        }
        var i = _fe(n).stats;
        t[r] = {};
        for (var a in i) {
          t[r][a] = {};
          for (var o in i[a])
            t[r][a][o] = i[a][o];
        }
      }
    }, "loadFeature"),
    parseConfig: /* @__PURE__ */ s(function(t) {
      var r = { defaults: [] }, n = ["defaults"];
      return t.toString().replace(/#[^\n]*/g, "").split(/\n|,/).map(function(i) {
        return i.trim();
      }).filter(function(i) {
        return i !== "";
      }).forEach(function(i) {
        $2.test(i) ? (n = i.match($2)[1].trim().split(" "), n.forEach(function(a) {
          if (r[a])
            throw new zt(
              "Duplicate section " + a + " in Browserslist config"
            );
          r[a] = [];
        })) : n.forEach(function(a) {
          r[a].push(i);
        });
      }), r;
    }, "parseConfig"),
    readConfig: /* @__PURE__ */ s(function(t) {
      if (!yn(t))
        throw new zt("Can't read " + t + " config");
      return ii.exports.parseConfig(Qi.readFileSync(t));
    }, "readConfig"),
    findConfig: /* @__PURE__ */ s(function(t) {
      t = Tr.resolve(t);
      var r = [], n = G2(t, function(i) {
        if (i in Sc)
          return Sc[i];
        r.push(i);
        var a = Tr.join(i, "browserslist"), o = Tr.join(i, "package.json"), l = Tr.join(i, ".browserslistrc"), u;
        if (yn(o))
          try {
            u = H2(o);
          } catch (c) {
            if (c.name === "BrowserslistError") throw c;
            console.warn(
              "[Browserslist] Could not parse " + o + ". Ignoring it."
            );
          }
        if (yn(a) && u)
          throw new zt(
            i + " contains both browserslist and package.json with browsers"
          );
        if (yn(l) && u)
          throw new zt(
            i + " contains both .browserslistrc and package.json with browsers"
          );
        if (yn(a) && yn(l))
          throw new zt(
            i + " contains both .browserslistrc and browserslist"
          );
        return yn(a) ? ii.exports.readConfig(a) : yn(l) ? ii.exports.readConfig(l) : u;
      });
      return process.env.BROWSERSLIST_DISABLE_CACHE || r.forEach(function(i) {
        Sc[i] = n;
      }), n;
    }, "findConfig"),
    clearCaches: /* @__PURE__ */ s(function() {
      F0 = !1, Ac = {}, Sc = {}, this.cache = {};
    }, "clearCaches"),
    oldDataWarning: /* @__PURE__ */ s(function(t) {
      if (!F0 && (F0 = !0, !process.env.BROWSERSLIST_IGNORE_OLD_DATA)) {
        var r = Lfe(t), n = Date.now() - kfe;
        r !== 0 && r < n && console.warn(
          `Browserslist: caniuse-lite is outdated. Please run:
  npx update-browserslist-db@latest
  Why you should do it regularly: https://github.com/browserslist/update-db#readme`
        );
      }
    }, "oldDataWarning"),
    currentNode: /* @__PURE__ */ s(function() {
      return "node " + process.versions.node;
    }, "currentNode"),
    env: process.env
  };
});

// ../node_modules/browserslist/index.js
var dw = T((jwe, pw) => {
  var Rfe = p2(), Rn = P2().agents, j0 = A2(), Oc = ie("path"), Xr = w2(), yr = O0(), sw = B2(), Jt = z2(), qfe = 365.259641 * 24 * 60 * 60 *
  1e3, iw = "37", Ufe = 14;
  function aw(e, t) {
    return (e + ".").indexOf(t + ".") === 0;
  }
  s(aw, "isVersionsMatch");
  function Vfe(e) {
    var t = e.slice(1);
    return ve.nodeVersions.some(function(r) {
      return aw(r, t);
    });
  }
  s(Vfe, "isEolReleased");
  function J2(e) {
    return e.filter(function(t) {
      return typeof t == "string";
    });
  }
  s(J2, "normalize");
  function Cc(e) {
    var t = e;
    return e.split(".").length === 3 && (t = e.split(".").slice(0, -1).join(".")), t;
  }
  s(Cc, "normalizeElectron");
  function bs(e) {
    return /* @__PURE__ */ s(function(r) {
      return e + " " + r;
    }, "mapName");
  }
  s(bs, "nameMapper");
  function q0(e) {
    return parseInt(e.split(".")[0]);
  }
  s(q0, "getMajor");
  function wc(e, t) {
    if (e.length === 0) return [];
    var r = ow(e.map(q0)), n = r[r.length - t];
    if (!n)
      return e;
    for (var i = [], a = e.length - 1; a >= 0 && !(n > q0(e[a])); a--)
      i.unshift(e[a]);
    return i;
  }
  s(wc, "getMajorVersions");
  function ow(e) {
    for (var t = [], r = 0; r < e.length; r++)
      t.indexOf(e[r]) === -1 && t.push(e[r]);
    return t;
  }
  s(ow, "uniq");
  function Nc(e, t, r) {
    for (var n in r)
      e[t + " " + n] = r[n];
  }
  s(Nc, "fillUsage");
  function X2(e, t) {
    if (t = parseFloat(t), e === ">")
      return function(n) {
        return r(n) > t;
      };
    return e === ">=" ? function(n) {
      return r(n) >= t;
    } : e === "<" ? function(n) {
      return parseFloat(n) < t;
    } : function(n) {
      return parseFloat(n) <= t;
    };
    function r(n) {
      return parseFloat(n.split("-")[1] || n);
    }
  }
  s(X2, "generateFilter");
  function $fe(e, t) {
    return t = t.split(".").map(Es), t[1] = t[1] || 0, t[2] = t[2] || 0, e === ">" ? function(r) {
      return r = r.split(".").map(Es), _o(r, t) > 0;
    } : e === ">=" ? function(r) {
      return r = r.split(".").map(Es), _o(r, t) >= 0;
    } : e === "<" ? function(r) {
      return r = r.split(".").map(Es), _o(t, r) > 0;
    } : function(r) {
      return r = r.split(".").map(Es), _o(t, r) >= 0;
    };
  }
  s($fe, "generateSemverFilter");
  function Es(e) {
    return parseInt(e);
  }
  s(Es, "parseSimpleInt");
  function _c(e, t) {
    return e < t ? -1 : e > t ? 1 : 0;
  }
  s(_c, "compare");
  function _o(e, t) {
    return _c(parseInt(e[0]), parseInt(t[0])) || _c(parseInt(e[1] || "0"), parseInt(t[1] || "0")) || _c(parseInt(e[2] || "0"), parseInt(t[2] ||
    "0"));
  }
  s(_o, "compareSemver");
  function Q2(e, t) {
    switch (t = t.split(".").map(Es), typeof t[1] > "u" && (t[1] = "x"), e) {
      case "<=":
        return function(r) {
          return r = r.split(".").map(Es), Z2(r, t) <= 0;
        };
      case ">=":
      default:
        return function(r) {
          return r = r.split(".").map(Es), Z2(r, t) >= 0;
        };
    }
  }
  s(Q2, "semverFilterLoose");
  function Z2(e, t) {
    return e[0] !== t[0] ? e[0] < t[0] ? -1 : 1 : t[1] === "x" ? 0 : e[1] !== t[1] ? e[1] < t[1] ? -1 : 1 : 0;
  }
  s(Z2, "compareSemverLoose");
  function Wfe(e, t) {
    return e.versions.indexOf(t) !== -1 ? t : ve.versionAliases[e.name][t] ? ve.versionAliases[e.name][t] : !1;
  }
  s(Wfe, "resolveVersion");
  function Dc(e, t) {
    var r = Wfe(e, t);
    return r || (e.versions.length === 1 ? e.versions[0] : !1);
  }
  s(Dc, "normalizeVersion");
  function lw(e, t) {
    return e = e / 1e3, Object.keys(Rn).reduce(function(r, n) {
      var i = vs(n, t);
      if (!i) return r;
      var a = Object.keys(i.releaseDate).filter(function(o) {
        var l = i.releaseDate[o];
        return l !== null && l >= e;
      });
      return r.concat(a.map(bs(i.name)));
    }, []);
  }
  s(lw, "filterByYear");
  function ew(e) {
    return {
      name: e.name,
      versions: e.versions,
      released: e.released,
      releaseDate: e.releaseDate
    };
  }
  s(ew, "cloneData");
  function vs(e, t) {
    if (e = e.toLowerCase(), e = ve.aliases[e] || e, t.mobileToDesktop && ve.desktopNames[e]) {
      var r = ve.data[ve.desktopNames[e]];
      if (e === "android")
        return Gfe(ew(ve.data[e]), r);
      var n = ew(r);
      return n.name = e, n;
    }
    return ve.data[e];
  }
  s(vs, "byName");
  function tw(e, t) {
    var r = t.indexOf(iw);
    return e.filter(function(n) {
      return /^(?:[2-4]\.|[34]$)/.test(n);
    }).concat(t.slice(r));
  }
  s(tw, "normalizeAndroidVersions");
  function Kfe(e) {
    var t = {};
    for (var r in e)
      t[r] = e[r];
    return t;
  }
  s(Kfe, "copyObject");
  function Gfe(e, t) {
    return e.released = tw(e.released, t.released), e.versions = tw(e.versions, t.versions), e.releaseDate = Kfe(e.releaseDate), e.released.
    forEach(function(r) {
      e.releaseDate[r] === void 0 && (e.releaseDate[r] = t.releaseDate[r]);
    }), e;
  }
  s(Gfe, "normalizeAndroidData");
  function Zi(e, t) {
    var r = vs(e, t);
    if (!r) throw new yr("Unknown browser " + e);
    return r;
  }
  s(Zi, "checkName");
  function Hfe(e) {
    return new yr(
      "Unknown browser query `" + e + "`. Maybe you are using old Browserslist or made typo in query."
    );
  }
  s(Hfe, "unknownQuery");
  function Ic(e, t, r, n) {
    var i = 1;
    switch (t) {
      case "android":
        if (n.mobileToDesktop) return e;
        var a = ve.data.chrome.released;
        i = a.length - a.indexOf(iw);
        break;
      case "op_mob":
        var o = ve.data.op_mob.released.slice(-1)[0];
        i = q0(o) - Ufe + 1;
        break;
      default:
        return e;
    }
    return r <= i ? e.slice(-1) : e.slice(i - 1 - r);
  }
  s(Ic, "filterJumps");
  function rw(e, t) {
    return typeof e == "string" && (e.indexOf("y") >= 0 || t && e.indexOf("a") >= 0);
  }
  s(rw, "isSupported");
  function ea(e, t) {
    return sw(U0, e).reduce(function(r, n, i) {
      if (n.not && i === 0)
        throw new yr(
          "Write any browsers query (for instance, `defaults`) before `" + n.query + "`"
        );
      var a = U0[n.type], o = a.select.call(ve, t, n).map(function(u) {
        var c = u.split(" ");
        return c[1] === "0" ? c[0] + " " + vs(c[0], t).versions[0] : u;
      });
      if (n.compose === "and")
        return n.not ? r.filter(function(u) {
          return o.indexOf(u) === -1;
        }) : r.filter(function(u) {
          return o.indexOf(u) !== -1;
        });
      if (n.not) {
        var l = {};
        return o.forEach(function(u) {
          l[u] = !0;
        }), r.filter(function(u) {
          return !l[u];
        });
      }
      return r.concat(o);
    }, []);
  }
  s(ea, "resolve");
  function uw(e) {
    return typeof e > "u" && (e = {}), typeof e.path > "u" && (e.path = Oc.resolve ? Oc.resolve(".") : "."), e;
  }
  s(uw, "prepareOpts");
  function cw(e, t) {
    if (typeof e > "u" || e === null) {
      var r = ve.loadConfig(t);
      r ? e = r : e = ve.defaults;
    }
    return e;
  }
  s(cw, "prepareQueries");
  function fw(e) {
    if (!(typeof e == "string" || Array.isArray(e)))
      throw new yr(
        "Browser queries must be an array or string. Got " + typeof e + "."
      );
  }
  s(fw, "checkQueries");
  var L0 = {};
  function ve(e, t) {
    t = uw(t), e = cw(e, t), fw(e);
    var r = {
      ignoreUnknownVersions: t.ignoreUnknownVersions,
      dangerousExtend: t.dangerousExtend,
      mobileToDesktop: t.mobileToDesktop,
      path: t.path,
      env: t.env
    };
    Jt.oldDataWarning(ve.data);
    var n = Jt.getStat(t, ve.data);
    if (n) {
      r.customUsage = {};
      for (var i in n)
        Nc(r.customUsage, i, n[i]);
    }
    var a = JSON.stringify([e, r]);
    if (L0[a]) return L0[a];
    var o = ow(ea(e, r)).sort(function(l, u) {
      if (l = l.split(" "), u = u.split(" "), l[0] === u[0]) {
        var c = l[1].split("-")[0], f = u[1].split("-")[0];
        return _o(f.split("."), c.split("."));
      } else
        return _c(l[0], u[0]);
    });
    return Jt.env.BROWSERSLIST_DISABLE_CACHE || (L0[a] = o), o;
  }
  s(ve, "browserslist");
  ve.parse = function(e, t) {
    return t = uw(t), e = cw(e, t), fw(e), sw(U0, e);
  };
  ve.cache = {};
  ve.data = {};
  ve.usage = {
    global: {},
    custom: null
  };
  ve.defaults = ["> 0.5%", "last 2 versions", "Firefox ESR", "not dead"];
  ve.aliases = {
    fx: "firefox",
    ff: "firefox",
    ios: "ios_saf",
    explorer: "ie",
    blackberry: "bb",
    explorermobile: "ie_mob",
    operamini: "op_mini",
    operamobile: "op_mob",
    chromeandroid: "and_chr",
    firefoxandroid: "and_ff",
    ucandroid: "and_uc",
    qqandroid: "and_qq"
  };
  ve.desktopNames = {
    and_chr: "chrome",
    and_ff: "firefox",
    ie_mob: "ie",
    android: "chrome"
    // has extra processing logic
  };
  ve.versionAliases = {};
  ve.clearCaches = Jt.clearCaches;
  ve.parseConfig = Jt.parseConfig;
  ve.readConfig = Jt.readConfig;
  ve.findConfig = Jt.findConfig;
  ve.loadConfig = Jt.loadConfig;
  ve.coverage = function(e, t) {
    var r;
    if (typeof t > "u")
      r = ve.usage.global;
    else if (t === "my stats") {
      var n = {};
      n.path = Oc.resolve ? Oc.resolve(".") : ".";
      var i = Jt.getStat(n);
      if (!i)
        throw new yr("Custom usage statistics was not provided");
      r = {};
      for (var a in i)
        Nc(r, a, i[a]);
    } else if (typeof t == "string")
      t.length > 2 ? t = t.toLowerCase() : t = t.toUpperCase(), Jt.loadCountry(ve.usage, t, ve.data), r = ve.usage[t];
    else {
      "dataByBrowser" in t && (t = t.dataByBrowser), r = {};
      for (var o in t)
        for (var l in t[o])
          r[o + " " + l] = t[o][l];
    }
    return e.reduce(function(u, c) {
      var f = r[c];
      return f === void 0 && (f = r[c.replace(/ \S+$/, " 0")]), u + (f || 0);
    }, 0);
  };
  function M0(e, t) {
    var r = ve.nodeVersions.filter(function(n) {
      return aw(n, t.version);
    });
    if (r.length === 0) {
      if (e.ignoreUnknownVersions)
        return [];
      throw new yr(
        "Unknown version " + t.version + " of Node.js"
      );
    }
    return ["node " + r[r.length - 1]];
  }
  s(M0, "nodeQuery");
  function R0(e, t) {
    var r = parseInt(t.year), n = parseInt(t.month || "01") - 1, i = parseInt(t.day || "01");
    return lw(Date.UTC(r, n, i, 0, 0, 0), e);
  }
  s(R0, "sinceQuery");
  function nw(e, t) {
    var r = parseFloat(t.coverage), n = ve.usage.global;
    if (t.place)
      if (t.place.match(/^my\s+stats$/i)) {
        if (!e.customUsage)
          throw new yr("Custom usage statistics was not provided");
        n = e.customUsage;
      } else {
        var i;
        t.place.length === 2 ? i = t.place.toUpperCase() : i = t.place.toLowerCase(), Jt.loadCountry(ve.usage, i, ve.data), n = ve.usage[i];
      }
    for (var a = Object.keys(n).sort(function(f, p) {
      return n[p] - n[f];
    }), o = 0, l = [], u, c = 0; c < a.length && (u = a[c], !(n[u] === 0 || (o += n[u], l.push(u), o >= r))); c++)
      ;
    return l;
  }
  s(nw, "coverQuery");
  var U0 = {
    last_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        return Object.keys(Rn).reduce(function(r, n) {
          var i = vs(n, e);
          if (!i) return r;
          var a = wc(i.released, t.versions);
          return a = a.map(bs(i.name)), a = Ic(a, i.name, t.versions, e), r.concat(a);
        }, []);
      }, "select")
    },
    last_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+versions?$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        return Object.keys(Rn).reduce(function(r, n) {
          var i = vs(n, e);
          if (!i) return r;
          var a = i.released.slice(-t.versions);
          return a = a.map(bs(i.name)), a = Ic(a, i.name, t.versions, e), r.concat(a);
        }, []);
      }, "select")
    },
    last_electron_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        var r = wc(Object.keys(Xr), t.versions);
        return r.map(function(n) {
          return "chrome " + Xr[n];
        });
      }, "select")
    },
    last_node_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        return wc(ve.nodeVersions, t.versions).map(
          function(r) {
            return "node " + r;
          }
        );
      }, "select")
    },
    last_browser_major_versions: {
      matches: ["versions", "browser"],
      regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        var r = Zi(t.browser, e), n = wc(r.released, t.versions), i = n.map(bs(r.name));
        return i = Ic(i, r.name, t.versions, e), i;
      }, "select")
    },
    last_electron_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        return Object.keys(Xr).slice(-t.versions).map(function(r) {
          return "chrome " + Xr[r];
        });
      }, "select")
    },
    last_node_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+node\s+versions?$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        return ve.nodeVersions.slice(-t.versions).map(function(r) {
          return "node " + r;
        });
      }, "select")
    },
    last_browser_versions: {
      matches: ["versions", "browser"],
      regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        var r = Zi(t.browser, e), n = r.released.slice(-t.versions).map(bs(r.name));
        return n = Ic(n, r.name, t.versions, e), n;
      }, "select")
    },
    unreleased_versions: {
      matches: [],
      regexp: /^unreleased\s+versions$/i,
      select: /* @__PURE__ */ s(function(e) {
        return Object.keys(Rn).reduce(function(t, r) {
          var n = vs(r, e);
          if (!n) return t;
          var i = n.versions.filter(function(a) {
            return n.released.indexOf(a) === -1;
          });
          return i = i.map(bs(n.name)), t.concat(i);
        }, []);
      }, "select")
    },
    unreleased_electron_versions: {
      matches: [],
      regexp: /^unreleased\s+electron\s+versions?$/i,
      select: /* @__PURE__ */ s(function() {
        return [];
      }, "select")
    },
    unreleased_browser_versions: {
      matches: ["browser"],
      regexp: /^unreleased\s+(\w+)\s+versions?$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        var r = Zi(t.browser, e);
        return r.versions.filter(function(n) {
          return r.released.indexOf(n) === -1;
        }).map(bs(r.name));
      }, "select")
    },
    last_years: {
      matches: ["years"],
      regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        return lw(Date.now() - qfe * t.years, e);
      }, "select")
    },
    since_y: {
      matches: ["year"],
      regexp: /^since (\d+)$/i,
      select: R0
    },
    since_y_m: {
      matches: ["year", "month"],
      regexp: /^since (\d+)-(\d+)$/i,
      select: R0
    },
    since_y_m_d: {
      matches: ["year", "month", "day"],
      regexp: /^since (\d+)-(\d+)-(\d+)$/i,
      select: R0
    },
    popularity: {
      matches: ["sign", "popularity"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
      select: /* @__PURE__ */ s(function(e, t) {
        var r = parseFloat(t.popularity), n = ve.usage.global;
        return Object.keys(n).reduce(function(i, a) {
          return t.sign === ">" ? n[a] > r && i.push(a) : t.sign === "<" ? n[a] < r && i.push(a) : t.sign === "<=" ? n[a] <= r && i.push(a) :
          n[a] >= r && i.push(a), i;
        }, []);
      }, "select")
    },
    popularity_in_my_stats: {
      matches: ["sign", "popularity"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
      select: /* @__PURE__ */ s(function(e, t) {
        var r = parseFloat(t.popularity);
        if (!e.customUsage)
          throw new yr("Custom usage statistics was not provided");
        var n = e.customUsage;
        return Object.keys(n).reduce(function(i, a) {
          var o = n[a];
          return o == null || (t.sign === ">" ? o > r && i.push(a) : t.sign === "<" ? o < r && i.push(a) : t.sign === "<=" ? o <= r && i.push(
          a) : o >= r && i.push(a)), i;
        }, []);
      }, "select")
    },
    popularity_in_config_stats: {
      matches: ["sign", "popularity", "config"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
      select: /* @__PURE__ */ s(function(e, t) {
        var r = parseFloat(t.popularity), n = Jt.loadStat(e, t.config, ve.data);
        if (n) {
          e.customUsage = {};
          for (var i in n)
            Nc(e.customUsage, i, n[i]);
        }
        if (!e.customUsage)
          throw new yr("Custom usage statistics was not provided");
        var a = e.customUsage;
        return Object.keys(a).reduce(function(o, l) {
          var u = a[l];
          return u == null || (t.sign === ">" ? u > r && o.push(l) : t.sign === "<" ? u < r && o.push(l) : t.sign === "<=" ? u <= r && o.push(
          l) : u >= r && o.push(l)), o;
        }, []);
      }, "select")
    },
    popularity_in_place: {
      matches: ["sign", "popularity", "place"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
      select: /* @__PURE__ */ s(function(e, t) {
        var r = parseFloat(t.popularity), n = t.place;
        n.length === 2 ? n = n.toUpperCase() : n = n.toLowerCase(), Jt.loadCountry(ve.usage, n, ve.data);
        var i = ve.usage[n];
        return Object.keys(i).reduce(function(a, o) {
          var l = i[o];
          return l == null || (t.sign === ">" ? l > r && a.push(o) : t.sign === "<" ? l < r && a.push(o) : t.sign === "<=" ? l <= r && a.push(
          o) : l >= r && a.push(o)), a;
        }, []);
      }, "select")
    },
    cover: {
      matches: ["coverage"],
      regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i,
      select: nw
    },
    cover_in: {
      matches: ["coverage", "place"],
      regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i,
      select: nw
    },
    supports: {
      matches: ["supportType", "feature"],
      regexp: /^(?:(fully|partially)\s+)?supports\s+([\w-]+)$/,
      select: /* @__PURE__ */ s(function(e, t) {
        Jt.loadFeature(ve.cache, t.feature);
        var r = t.supportType !== "fully", n = ve.cache[t.feature], i = [];
        for (var a in n) {
          for (var o = vs(a, e), l = o.released.length - 1; l >= 0 && !(o.released[l] in n[a]); )
            l--;
          var u = e.mobileToDesktop && a in ve.desktopNames && rw(n[a][o.released[l]], r);
          o.versions.forEach(function(c) {
            var f = n[a][c];
            f === void 0 && u && (f = n[ve.desktopNames[a]][c]), rw(f, r) && i.push(a + " " + c);
          });
        }
        return i;
      }, "select")
    },
    electron_range: {
      matches: ["from", "to"],
      regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        var r = Cc(t.from), n = Cc(t.to), i = parseFloat(t.from), a = parseFloat(t.to);
        if (!Xr[r])
          throw new yr("Unknown version " + i + " of electron");
        if (!Xr[n])
          throw new yr("Unknown version " + a + " of electron");
        return Object.keys(Xr).filter(function(o) {
          var l = parseFloat(o);
          return l >= i && l <= a;
        }).map(function(o) {
          return "chrome " + Xr[o];
        });
      }, "select")
    },
    node_range: {
      matches: ["from", "to"],
      regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        return ve.nodeVersions.filter(Q2(">=", t.from)).filter(Q2("<=", t.to)).map(function(r) {
          return "node " + r;
        });
      }, "select")
    },
    browser_range: {
      matches: ["browser", "from", "to"],
      regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        var r = Zi(t.browser, e), n = parseFloat(Dc(r, t.from) || t.from), i = parseFloat(Dc(r, t.to) || t.to);
        function a(o) {
          var l = parseFloat(o);
          return l >= n && l <= i;
        }
        return s(a, "filter"), r.released.filter(a).map(bs(r.name));
      }, "select")
    },
    electron_ray: {
      matches: ["sign", "version"],
      regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        var r = Cc(t.version);
        return Object.keys(Xr).filter(X2(t.sign, r)).map(function(n) {
          return "chrome " + Xr[n];
        });
      }, "select")
    },
    node_ray: {
      matches: ["sign", "version"],
      regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        return ve.nodeVersions.filter($fe(t.sign, t.version)).map(function(r) {
          return "node " + r;
        });
      }, "select")
    },
    browser_ray: {
      matches: ["browser", "sign", "version"],
      regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
      select: /* @__PURE__ */ s(function(e, t) {
        var r = t.version, n = Zi(t.browser, e), i = ve.versionAliases[n.name][r];
        return i && (r = i), n.released.filter(X2(t.sign, r)).map(function(a) {
          return n.name + " " + a;
        });
      }, "select")
    },
    firefox_esr: {
      matches: [],
      regexp: /^(firefox|ff|fx)\s+esr$/i,
      select: /* @__PURE__ */ s(function() {
        return ["firefox 115", "firefox 128"];
      }, "select")
    },
    opera_mini_all: {
      matches: [],
      regexp: /(operamini|op_mini)\s+all/i,
      select: /* @__PURE__ */ s(function() {
        return ["op_mini all"];
      }, "select")
    },
    electron_version: {
      matches: ["version"],
      regexp: /^electron\s+([\d.]+)$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        var r = Cc(t.version), n = Xr[r];
        if (!n)
          throw new yr(
            "Unknown version " + t.version + " of electron"
          );
        return ["chrome " + n];
      }, "select")
    },
    node_major_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+)$/i,
      select: M0
    },
    node_minor_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+\.\d+)$/i,
      select: M0
    },
    node_patch_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
      select: M0
    },
    current_node: {
      matches: [],
      regexp: /^current\s+node$/i,
      select: /* @__PURE__ */ s(function(e) {
        return [Jt.currentNode(ea, e)];
      }, "select")
    },
    maintained_node: {
      matches: [],
      regexp: /^maintained\s+node\s+versions$/i,
      select: /* @__PURE__ */ s(function(e) {
        var t = Date.now(), r = Object.keys(j0).filter(function(n) {
          return t < Date.parse(j0[n].end) && t > Date.parse(j0[n].start) && Vfe(n);
        }).map(function(n) {
          return "node " + n.slice(1);
        });
        return ea(r, e);
      }, "select")
    },
    phantomjs_1_9: {
      matches: [],
      regexp: /^phantomjs\s+1.9$/i,
      select: /* @__PURE__ */ s(function() {
        return ["safari 5"];
      }, "select")
    },
    phantomjs_2_1: {
      matches: [],
      regexp: /^phantomjs\s+2.1$/i,
      select: /* @__PURE__ */ s(function() {
        return ["safari 6"];
      }, "select")
    },
    browser_version: {
      matches: ["browser", "version"],
      regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        var r = t.version;
        /^tp$/i.test(r) && (r = "TP");
        var n = Zi(t.browser, e), i = Dc(n, r);
        if (i)
          r = i;
        else if (r.indexOf(".") === -1 ? i = r + ".0" : i = r.replace(/\.0$/, ""), i = Dc(n, i), i)
          r = i;
        else {
          if (e.ignoreUnknownVersions)
            return [];
          throw new yr(
            "Unknown version " + r + " of " + t.browser
          );
        }
        return [n.name + " " + r];
      }, "select")
    },
    browserslist_config: {
      matches: [],
      regexp: /^browserslist config$/i,
      select: /* @__PURE__ */ s(function(e) {
        return ve(void 0, e);
      }, "select")
    },
    extends: {
      matches: ["config"],
      regexp: /^extends (.+)$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        return ea(Jt.loadQueries(e, t.config), e);
      }, "select")
    },
    defaults: {
      matches: [],
      regexp: /^defaults$/i,
      select: /* @__PURE__ */ s(function(e) {
        return ea(ve.defaults, e);
      }, "select")
    },
    dead: {
      matches: [],
      regexp: /^dead$/i,
      select: /* @__PURE__ */ s(function(e) {
        var t = [
          "Baidu >= 0",
          "ie <= 11",
          "ie_mob <= 11",
          "bb <= 10",
          "op_mob <= 12.1",
          "samsung 4"
        ];
        return ea(t, e);
      }, "select")
    },
    unknown: {
      matches: [],
      regexp: /^(\w+)$/i,
      select: /* @__PURE__ */ s(function(e, t) {
        throw vs(t.query, e) ? new yr(
          "Specify versions in Browserslist query for browser " + t.query
        ) : Hfe(t.query);
      }, "select")
    }
  };
  (function() {
    for (var e in Rn) {
      var t = Rn[e];
      ve.data[e] = {
        name: e,
        versions: J2(Rn[e].versions),
        released: J2(Rn[e].versions.slice(0, -3)),
        releaseDate: Rn[e].release_date
      }, Nc(ve.usage.global, e, t.usage_global), ve.versionAliases[e] = {};
      for (var r = 0; r < t.versions.length; r++) {
        var n = t.versions[r];
        if (n && n.indexOf("-") !== -1)
          for (var i = n.split("-"), a = 0; a < i.length; a++)
            ve.versionAliases[e][i[a]] = n;
      }
    }
    ve.nodeVersions = Rfe.map(function(o) {
      return o.version;
    });
  })();
  pw.exports = ve;
});

// ../node_modules/@babel/helper-validator-option/lib/find-suggestion.js
var $0 = T((V0) => {
  "use strict";
  Object.defineProperty(V0, "__esModule", {
    value: !0
  });
  V0.findSuggestion = zfe;
  var {
    min: hw
  } = Math;
  function Yfe(e, t) {
    let r = [], n = [], i, a, o = e.length, l = t.length;
    if (!o)
      return l;
    if (!l)
      return o;
    for (a = 0; a <= l; a++)
      r[a] = a;
    for (i = 1; i <= o; i++) {
      for (n = [i], a = 1; a <= l; a++)
        n[a] = e[i - 1] === t[a - 1] ? r[a - 1] : hw(r[a - 1], r[a], n[a - 1]) + 1;
      r = n;
    }
    return n[l];
  }
  s(Yfe, "levenshtein");
  function zfe(e, t) {
    let r = t.map((n) => Yfe(n, e));
    return t[r.indexOf(hw(...r))];
  }
  s(zfe, "findSuggestion");
});

// ../node_modules/@babel/helper-validator-option/lib/validator.js
var mw = T((Bc) => {
  "use strict";
  Object.defineProperty(Bc, "__esModule", {
    value: !0
  });
  Bc.OptionValidator = void 0;
  var Jfe = $0(), W0 = class {
    static {
      s(this, "OptionValidator");
    }
    constructor(t) {
      this.descriptor = t;
    }
    validateTopLevelOptions(t, r) {
      let n = Object.keys(r);
      for (let i of Object.keys(t))
        if (!n.includes(i))
          throw new Error(this.formatMessage(`'${i}' is not a valid top-level option.
- Did you mean '${(0, Jfe.findSuggestion)(i, n)}'?`));
    }
    validateBooleanOption(t, r, n) {
      return r === void 0 ? n : (this.invariant(typeof r == "boolean", `'${t}' option must be a boolean.`), r);
    }
    validateStringOption(t, r, n) {
      return r === void 0 ? n : (this.invariant(typeof r == "string", `'${t}' option must be a string.`), r);
    }
    invariant(t, r) {
      if (!t)
        throw new Error(this.formatMessage(r));
    }
    formatMessage(t) {
      return `${this.descriptor}: ${t}`;
    }
  };
  Bc.OptionValidator = W0;
});

// ../node_modules/@babel/helper-validator-option/lib/index.js
var Fc = T((kc) => {
  "use strict";
  Object.defineProperty(kc, "__esModule", {
    value: !0
  });
  Object.defineProperty(kc, "OptionValidator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Xfe.OptionValidator;
    }, "get")
  });
  Object.defineProperty(kc, "findSuggestion", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Qfe.findSuggestion;
    }, "get")
  });
  var Xfe = mw(), Qfe = $0();
});

// ../node_modules/@babel/compat-data/data/native-modules.json
var yw = T((Wwe, Zfe) => {
  Zfe.exports = {
    "es6.module": {
      chrome: "61",
      and_chr: "61",
      edge: "16",
      firefox: "60",
      and_ff: "60",
      node: "13.2.0",
      opera: "48",
      op_mob: "45",
      safari: "10.1",
      ios: "10.3",
      samsung: "8.2",
      android: "61",
      electron: "2.0",
      ios_saf: "10.3"
    }
  };
});

// ../node_modules/@babel/compat-data/native-modules.js
var bw = T((Kwe, gw) => {
  gw.exports = yw();
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/yallist/iterator.js
var vw = T((Gwe, Ew) => {
  "use strict";
  Ew.exports = function(e) {
    e.prototype[Symbol.iterator] = function* () {
      for (let t = this.head; t; t = t.next)
        yield t.value;
    };
  };
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/yallist/yallist.js
var xw = T((Hwe, Tw) => {
  "use strict";
  Tw.exports = st;
  st.Node = ai;
  st.create = st;
  function st(e) {
    var t = this;
    if (t instanceof st || (t = new st()), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function")
      e.forEach(function(i) {
        t.push(i);
      });
    else if (arguments.length > 0)
      for (var r = 0, n = arguments.length; r < n; r++)
        t.push(arguments[r]);
    return t;
  }
  s(st, "Yallist");
  st.prototype.removeNode = function(e) {
    if (e.list !== this)
      throw new Error("removing node which does not belong to this list");
    var t = e.next, r = e.prev;
    return t && (t.prev = r), r && (r.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = r), e.list.length--, e.
    next = null, e.prev = null, e.list = null, t;
  };
  st.prototype.unshiftNode = function(e) {
    if (e !== this.head) {
      e.list && e.list.removeNode(e);
      var t = this.head;
      e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
    }
  };
  st.prototype.pushNode = function(e) {
    if (e !== this.tail) {
      e.list && e.list.removeNode(e);
      var t = this.tail;
      e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
    }
  };
  st.prototype.push = function() {
    for (var e = 0, t = arguments.length; e < t; e++)
      tpe(this, arguments[e]);
    return this.length;
  };
  st.prototype.unshift = function() {
    for (var e = 0, t = arguments.length; e < t; e++)
      rpe(this, arguments[e]);
    return this.length;
  };
  st.prototype.pop = function() {
    if (this.tail) {
      var e = this.tail.value;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
    }
  };
  st.prototype.shift = function() {
    if (this.head) {
      var e = this.head.value;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
    }
  };
  st.prototype.forEach = function(e, t) {
    t = t || this;
    for (var r = this.head, n = 0; r !== null; n++)
      e.call(t, r.value, n, this), r = r.next;
  };
  st.prototype.forEachReverse = function(e, t) {
    t = t || this;
    for (var r = this.tail, n = this.length - 1; r !== null; n--)
      e.call(t, r.value, n, this), r = r.prev;
  };
  st.prototype.get = function(e) {
    for (var t = 0, r = this.head; r !== null && t < e; t++)
      r = r.next;
    if (t === e && r !== null)
      return r.value;
  };
  st.prototype.getReverse = function(e) {
    for (var t = 0, r = this.tail; r !== null && t < e; t++)
      r = r.prev;
    if (t === e && r !== null)
      return r.value;
  };
  st.prototype.map = function(e, t) {
    t = t || this;
    for (var r = new st(), n = this.head; n !== null; )
      r.push(e.call(t, n.value, this)), n = n.next;
    return r;
  };
  st.prototype.mapReverse = function(e, t) {
    t = t || this;
    for (var r = new st(), n = this.tail; n !== null; )
      r.push(e.call(t, n.value, this)), n = n.prev;
    return r;
  };
  st.prototype.reduce = function(e, t) {
    var r, n = this.head;
    if (arguments.length > 1)
      r = t;
    else if (this.head)
      n = this.head.next, r = this.head.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var i = 0; n !== null; i++)
      r = e(r, n.value, i), n = n.next;
    return r;
  };
  st.prototype.reduceReverse = function(e, t) {
    var r, n = this.tail;
    if (arguments.length > 1)
      r = t;
    else if (this.tail)
      n = this.tail.prev, r = this.tail.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var i = this.length - 1; n !== null; i--)
      r = e(r, n.value, i), n = n.prev;
    return r;
  };
  st.prototype.toArray = function() {
    for (var e = new Array(this.length), t = 0, r = this.head; r !== null; t++)
      e[t] = r.value, r = r.next;
    return e;
  };
  st.prototype.toArrayReverse = function() {
    for (var e = new Array(this.length), t = 0, r = this.tail; r !== null; t++)
      e[t] = r.value, r = r.prev;
    return e;
  };
  st.prototype.slice = function(e, t) {
    t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
    var r = new st();
    if (t < e || t < 0)
      return r;
    e < 0 && (e = 0), t > this.length && (t = this.length);
    for (var n = 0, i = this.head; i !== null && n < e; n++)
      i = i.next;
    for (; i !== null && n < t; n++, i = i.next)
      r.push(i.value);
    return r;
  };
  st.prototype.sliceReverse = function(e, t) {
    t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
    var r = new st();
    if (t < e || t < 0)
      return r;
    e < 0 && (e = 0), t > this.length && (t = this.length);
    for (var n = this.length, i = this.tail; i !== null && n > t; n--)
      i = i.prev;
    for (; i !== null && n > e; n--, i = i.prev)
      r.push(i.value);
    return r;
  };
  st.prototype.splice = function(e, t) {
    e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
    for (var r = 0, n = this.head; n !== null && r < e; r++)
      n = n.next;
    for (var i = [], r = 0; n && r < t; r++)
      i.push(n.value), n = this.removeNode(n);
    n === null && (n = this.tail), n !== this.head && n !== this.tail && (n = n.prev);
    for (var r = 2; r < arguments.length; r++)
      n = epe(this, n, arguments[r]);
    return i;
  };
  st.prototype.reverse = function() {
    for (var e = this.head, t = this.tail, r = e; r !== null; r = r.prev) {
      var n = r.prev;
      r.prev = r.next, r.next = n;
    }
    return this.head = t, this.tail = e, this;
  };
  function epe(e, t, r) {
    var n = t === e.head ? new ai(r, null, t, e) : new ai(r, t, t.next, e);
    return n.next === null && (e.tail = n), n.prev === null && (e.head = n), e.length++, n;
  }
  s(epe, "insert");
  function tpe(e, t) {
    e.tail = new ai(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
  }
  s(tpe, "push");
  function rpe(e, t) {
    e.head = new ai(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
  }
  s(rpe, "unshift");
  function ai(e, t, r, n) {
    if (!(this instanceof ai))
      return new ai(e, t, r, n);
    this.list = n, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null;
  }
  s(ai, "Node");
  try {
    vw()(st);
  } catch {
  }
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/lru-cache/index.js
var ww = T((zwe, Cw) => {
  "use strict";
  var npe = xw(), oi = Symbol("max"), Un = Symbol("length"), ta = Symbol("lengthCalculator"), No = Symbol("allowStale"), li = Symbol("maxAge"),
  qn = Symbol("dispose"), Sw = Symbol("noDisposeOnSet"), qt = Symbol("lruList"), Qr = Symbol("cache"), Aw = Symbol("updateAgeOnGet"), K0 = /* @__PURE__ */ s(
  () => 1, "naiveLength"), H0 = class {
    static {
      s(this, "LRUCache");
    }
    constructor(t) {
      if (typeof t == "number" && (t = { max: t }), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0))
        throw new TypeError("max must be a non-negative number");
      let r = this[oi] = t.max || 1 / 0, n = t.length || K0;
      if (this[ta] = typeof n != "function" ? K0 : n, this[No] = t.stale || !1, t.maxAge && typeof t.maxAge != "number")
        throw new TypeError("maxAge must be a number");
      this[li] = t.maxAge || 0, this[qn] = t.dispose, this[Sw] = t.noDisposeOnSet || !1, this[Aw] = t.updateAgeOnGet || !1, this.reset();
    }
    // resize the cache when the max changes.
    set max(t) {
      if (typeof t != "number" || t < 0)
        throw new TypeError("max must be a non-negative number");
      this[oi] = t || 1 / 0, Oo(this);
    }
    get max() {
      return this[oi];
    }
    set allowStale(t) {
      this[No] = !!t;
    }
    get allowStale() {
      return this[No];
    }
    set maxAge(t) {
      if (typeof t != "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[li] = t, Oo(this);
    }
    get maxAge() {
      return this[li];
    }
    // resize the cache when the lengthCalculator changes.
    set lengthCalculator(t) {
      typeof t != "function" && (t = K0), t !== this[ta] && (this[ta] = t, this[Un] = 0, this[qt].forEach((r) => {
        r.length = this[ta](r.value, r.key), this[Un] += r.length;
      })), Oo(this);
    }
    get lengthCalculator() {
      return this[ta];
    }
    get length() {
      return this[Un];
    }
    get itemCount() {
      return this[qt].length;
    }
    rforEach(t, r) {
      r = r || this;
      for (let n = this[qt].tail; n !== null; ) {
        let i = n.prev;
        Pw(this, t, n, r), n = i;
      }
    }
    forEach(t, r) {
      r = r || this;
      for (let n = this[qt].head; n !== null; ) {
        let i = n.next;
        Pw(this, t, n, r), n = i;
      }
    }
    keys() {
      return this[qt].toArray().map((t) => t.key);
    }
    values() {
      return this[qt].toArray().map((t) => t.value);
    }
    reset() {
      this[qn] && this[qt] && this[qt].length && this[qt].forEach((t) => this[qn](t.key, t.value)), this[Qr] = /* @__PURE__ */ new Map(), this[qt] =
      new npe(), this[Un] = 0;
    }
    dump() {
      return this[qt].map((t) => jc(this, t) ? !1 : {
        k: t.key,
        v: t.value,
        e: t.now + (t.maxAge || 0)
      }).toArray().filter((t) => t);
    }
    dumpLru() {
      return this[qt];
    }
    set(t, r, n) {
      if (n = n || this[li], n && typeof n != "number")
        throw new TypeError("maxAge must be a number");
      let i = n ? Date.now() : 0, a = this[ta](r, t);
      if (this[Qr].has(t)) {
        if (a > this[oi])
          return ra(this, this[Qr].get(t)), !1;
        let u = this[Qr].get(t).value;
        return this[qn] && (this[Sw] || this[qn](t, u.value)), u.now = i, u.maxAge = n, u.value = r, this[Un] += a - u.length, u.length = a,
        this.get(t), Oo(this), !0;
      }
      let o = new Y0(t, r, a, i, n);
      return o.length > this[oi] ? (this[qn] && this[qn](t, r), !1) : (this[Un] += o.length, this[qt].unshift(o), this[Qr].set(t, this[qt].head),
      Oo(this), !0);
    }
    has(t) {
      if (!this[Qr].has(t)) return !1;
      let r = this[Qr].get(t).value;
      return !jc(this, r);
    }
    get(t) {
      return G0(this, t, !0);
    }
    peek(t) {
      return G0(this, t, !1);
    }
    pop() {
      let t = this[qt].tail;
      return t ? (ra(this, t), t.value) : null;
    }
    del(t) {
      ra(this, this[Qr].get(t));
    }
    load(t) {
      this.reset();
      let r = Date.now();
      for (let n = t.length - 1; n >= 0; n--) {
        let i = t[n], a = i.e || 0;
        if (a === 0)
          this.set(i.k, i.v);
        else {
          let o = a - r;
          o > 0 && this.set(i.k, i.v, o);
        }
      }
    }
    prune() {
      this[Qr].forEach((t, r) => G0(this, r, !1));
    }
  }, G0 = /* @__PURE__ */ s((e, t, r) => {
    let n = e[Qr].get(t);
    if (n) {
      let i = n.value;
      if (jc(e, i)) {
        if (ra(e, n), !e[No])
          return;
      } else
        r && (e[Aw] && (n.value.now = Date.now()), e[qt].unshiftNode(n));
      return i.value;
    }
  }, "get"), jc = /* @__PURE__ */ s((e, t) => {
    if (!t || !t.maxAge && !e[li])
      return !1;
    let r = Date.now() - t.now;
    return t.maxAge ? r > t.maxAge : e[li] && r > e[li];
  }, "isStale"), Oo = /* @__PURE__ */ s((e) => {
    if (e[Un] > e[oi])
      for (let t = e[qt].tail; e[Un] > e[oi] && t !== null; ) {
        let r = t.prev;
        ra(e, t), t = r;
      }
  }, "trim"), ra = /* @__PURE__ */ s((e, t) => {
    if (t) {
      let r = t.value;
      e[qn] && e[qn](r.key, r.value), e[Un] -= r.length, e[Qr].delete(r.key), e[qt].removeNode(t);
    }
  }, "del"), Y0 = class {
    static {
      s(this, "Entry");
    }
    constructor(t, r, n, i, a) {
      this.key = t, this.value = r, this.length = n, this.now = i, this.maxAge = a || 0;
    }
  }, Pw = /* @__PURE__ */ s((e, t, r, n) => {
    let i = r.value;
    jc(e, i) && (ra(e, r), e[No] || (i = void 0)), i && t.call(n, i.value, i.key, e);
  }, "forEachStep");
  Cw.exports = H0;
});

// ../node_modules/@babel/helper-compilation-targets/lib/targets.js
var Lc = T((na) => {
  "use strict";
  Object.defineProperty(na, "__esModule", {
    value: !0
  });
  na.unreleasedLabels = na.browserNameMap = void 0;
  var Xwe = na.unreleasedLabels = {
    safari: "tp"
  }, Qwe = na.browserNameMap = {
    and_chr: "chrome",
    and_ff: "firefox",
    android: "android",
    chrome: "chrome",
    edge: "edge",
    firefox: "firefox",
    ie: "ie",
    ie_mob: "ie",
    ios_saf: "ios",
    node: "node",
    deno: "deno",
    op_mob: "opera_mobile",
    opera: "opera",
    safari: "safari",
    samsung: "samsung"
  };
});

// ../node_modules/@babel/helper-compilation-targets/lib/utils.js
var Mc = T((Ts) => {
  "use strict";
  Object.defineProperty(Ts, "__esModule", {
    value: !0
  });
  Ts.getHighestUnreleased = upe;
  Ts.getLowestImplementedVersion = cpe;
  Ts.getLowestUnreleased = Ow;
  Ts.isUnreleasedVersion = lpe;
  Ts.semverMin = _w;
  Ts.semverify = ope;
  var Dw = ie("semver"), spe = Fc(), Iw = Lc(), ipe = /^(?:\d+|\d(?:\d?[^\d\n\r\u2028\u2029]\d+|\d{2,}(?:[^\d\n\r\u2028\u2029]\d+)?))$/, ape = new spe.
  OptionValidator("@babel/helper-compilation-targets");
  function _w(e, t) {
    return e && Dw.lt(e, t) ? e : t;
  }
  s(_w, "semverMin");
  function ope(e) {
    if (typeof e == "string" && Dw.valid(e))
      return e;
    ape.invariant(typeof e == "number" || typeof e == "string" && ipe.test(e), `'${e}' is not a valid version`), e = e.toString();
    let t = 0, r = 0;
    for (; (t = e.indexOf(".", t + 1)) > 0; )
      r++;
    return e + ".0".repeat(2 - r);
  }
  s(ope, "semverify");
  function lpe(e, t) {
    let r = Iw.unreleasedLabels[t];
    return !!r && r === e.toString().toLowerCase();
  }
  s(lpe, "isUnreleasedVersion");
  function Ow(e, t, r) {
    let n = Iw.unreleasedLabels[r];
    return e === n ? t : t === n ? e : _w(e, t);
  }
  s(Ow, "getLowestUnreleased");
  function upe(e, t, r) {
    return Ow(e, t, r) === e ? t : e;
  }
  s(upe, "getHighestUnreleased");
  function cpe(e, t) {
    let r = e[t];
    return !r && t === "android" ? e.chrome : r;
  }
  s(cpe, "getLowestImplementedVersion");
});

// ../node_modules/@babel/helper-compilation-targets/lib/options.js
var Nw = T((Rc) => {
  "use strict";
  Object.defineProperty(Rc, "__esModule", {
    value: !0
  });
  Rc.TargetNames = void 0;
  var rDe = Rc.TargetNames = {
    node: "node",
    deno: "deno",
    chrome: "chrome",
    opera: "opera",
    edge: "edge",
    firefox: "firefox",
    safari: "safari",
    ie: "ie",
    ios: "ios",
    android: "android",
    electron: "electron",
    samsung: "samsung",
    rhino: "rhino",
    opera_mobile: "opera_mobile"
  };
});

// ../node_modules/@babel/helper-compilation-targets/lib/pretty.js
var z0 = T((qc) => {
  "use strict";
  Object.defineProperty(qc, "__esModule", {
    value: !0
  });
  qc.prettifyTargets = dpe;
  qc.prettifyVersion = Bw;
  var fpe = ie("semver"), ppe = Lc();
  function Bw(e) {
    if (typeof e != "string")
      return e;
    let {
      major: t,
      minor: r,
      patch: n
    } = fpe.parse(e), i = [t];
    return (r || n) && i.push(r), n && i.push(n), i.join(".");
  }
  s(Bw, "prettifyVersion");
  function dpe(e) {
    return Object.keys(e).reduce((t, r) => {
      let n = e[r], i = ppe.unreleasedLabels[r];
      return typeof n == "string" && i !== n && (n = Bw(n)), t[r] = n, t;
    }, {});
  }
  s(dpe, "prettifyTargets");
});

// ../node_modules/@babel/helper-compilation-targets/lib/debug.js
var Fw = T((J0) => {
  "use strict";
  Object.defineProperty(J0, "__esModule", {
    value: !0
  });
  J0.getInclusionReasons = mpe;
  var hpe = ie("semver"), kw = z0(), Uc = Mc();
  function mpe(e, t, r) {
    let n = r[e] || {};
    return Object.keys(t).reduce((i, a) => {
      let o = (0, Uc.getLowestImplementedVersion)(n, a), l = t[a];
      if (!o)
        i[a] = (0, kw.prettifyVersion)(l);
      else {
        let u = (0, Uc.isUnreleasedVersion)(o, a);
        !(0, Uc.isUnreleasedVersion)(l, a) && (u || hpe.lt(l.toString(), (0, Uc.semverify)(o))) && (i[a] = (0, kw.prettifyVersion)(l));
      }
      return i;
    }, {});
  }
  s(mpe, "getInclusionReasons");
});

// ../node_modules/@babel/compat-data/data/plugins.json
var jw = T((lDe, ype) => {
  ype.exports = {
    "transform-duplicate-named-capturing-groups-regex": {
      chrome: "126",
      edge: "126",
      firefox: "129",
      safari: "17.4",
      electron: "31.0"
    },
    "transform-unicode-sets-regex": {
      chrome: "112",
      opera: "98",
      edge: "112",
      firefox: "116",
      safari: "17",
      node: "20",
      deno: "1.32",
      ios: "17",
      opera_mobile: "75",
      electron: "24.0"
    },
    "bugfix/transform-v8-static-class-fields-redefine-readonly": {
      chrome: "98",
      opera: "84",
      edge: "98",
      firefox: "95",
      safari: "15",
      node: "12",
      deno: "1.18",
      ios: "15",
      samsung: "11",
      opera_mobile: "52",
      electron: "17.0"
    },
    "bugfix/transform-firefox-class-in-computed-class-key": {
      chrome: "74",
      opera: "62",
      edge: "79",
      safari: "16",
      node: "12",
      deno: "1",
      ios: "16",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "bugfix/transform-safari-class-field-initializer-scope": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "69",
      safari: "16",
      node: "12",
      deno: "1",
      ios: "16",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "transform-class-static-block": {
      chrome: "94",
      opera: "80",
      edge: "94",
      firefox: "93",
      safari: "16.4",
      node: "16.11",
      deno: "1.14",
      ios: "16.4",
      samsung: "17",
      opera_mobile: "66",
      electron: "15.0"
    },
    "proposal-class-static-block": {
      chrome: "94",
      opera: "80",
      edge: "94",
      firefox: "93",
      safari: "16.4",
      node: "16.11",
      deno: "1.14",
      ios: "16.4",
      samsung: "17",
      opera_mobile: "66",
      electron: "15.0"
    },
    "transform-private-property-in-object": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "90",
      safari: "15",
      node: "16.9",
      deno: "1.9",
      ios: "15",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "proposal-private-property-in-object": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "90",
      safari: "15",
      node: "16.9",
      deno: "1.9",
      ios: "15",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "transform-class-properties": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "90",
      safari: "14.1",
      node: "12",
      deno: "1",
      ios: "14.5",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "proposal-class-properties": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "90",
      safari: "14.1",
      node: "12",
      deno: "1",
      ios: "14.5",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "transform-private-methods": {
      chrome: "84",
      opera: "70",
      edge: "84",
      firefox: "90",
      safari: "15",
      node: "14.6",
      deno: "1",
      ios: "15",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "proposal-private-methods": {
      chrome: "84",
      opera: "70",
      edge: "84",
      firefox: "90",
      safari: "15",
      node: "14.6",
      deno: "1",
      ios: "15",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "transform-numeric-separator": {
      chrome: "75",
      opera: "62",
      edge: "79",
      firefox: "70",
      safari: "13",
      node: "12.5",
      deno: "1",
      ios: "13",
      samsung: "11",
      rhino: "1.7.14",
      opera_mobile: "54",
      electron: "6.0"
    },
    "proposal-numeric-separator": {
      chrome: "75",
      opera: "62",
      edge: "79",
      firefox: "70",
      safari: "13",
      node: "12.5",
      deno: "1",
      ios: "13",
      samsung: "11",
      rhino: "1.7.14",
      opera_mobile: "54",
      electron: "6.0"
    },
    "transform-logical-assignment-operators": {
      chrome: "85",
      opera: "71",
      edge: "85",
      firefox: "79",
      safari: "14",
      node: "15",
      deno: "1.2",
      ios: "14",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "proposal-logical-assignment-operators": {
      chrome: "85",
      opera: "71",
      edge: "85",
      firefox: "79",
      safari: "14",
      node: "15",
      deno: "1.2",
      ios: "14",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "transform-nullish-coalescing-operator": {
      chrome: "80",
      opera: "67",
      edge: "80",
      firefox: "72",
      safari: "13.1",
      node: "14",
      deno: "1",
      ios: "13.4",
      samsung: "13",
      opera_mobile: "57",
      electron: "8.0"
    },
    "proposal-nullish-coalescing-operator": {
      chrome: "80",
      opera: "67",
      edge: "80",
      firefox: "72",
      safari: "13.1",
      node: "14",
      deno: "1",
      ios: "13.4",
      samsung: "13",
      opera_mobile: "57",
      electron: "8.0"
    },
    "transform-optional-chaining": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "74",
      safari: "13.1",
      node: "16.9",
      deno: "1.9",
      ios: "13.4",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "proposal-optional-chaining": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "74",
      safari: "13.1",
      node: "16.9",
      deno: "1.9",
      ios: "13.4",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "transform-json-strings": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "62",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "9",
      rhino: "1.7.14",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-json-strings": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "62",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "9",
      rhino: "1.7.14",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-optional-catch-binding": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "58",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-optional-catch-binding": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "58",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-parameters": {
      chrome: "49",
      opera: "36",
      edge: "18",
      firefox: "53",
      safari: "16.3",
      node: "6",
      deno: "1",
      ios: "16.3",
      samsung: "5",
      opera_mobile: "36",
      electron: "0.37"
    },
    "transform-async-generator-functions": {
      chrome: "63",
      opera: "50",
      edge: "79",
      firefox: "57",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "8",
      opera_mobile: "46",
      electron: "3.0"
    },
    "proposal-async-generator-functions": {
      chrome: "63",
      opera: "50",
      edge: "79",
      firefox: "57",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "8",
      opera_mobile: "46",
      electron: "3.0"
    },
    "transform-object-rest-spread": {
      chrome: "60",
      opera: "47",
      edge: "79",
      firefox: "55",
      safari: "11.1",
      node: "8.3",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      opera_mobile: "44",
      electron: "2.0"
    },
    "proposal-object-rest-spread": {
      chrome: "60",
      opera: "47",
      edge: "79",
      firefox: "55",
      safari: "11.1",
      node: "8.3",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      opera_mobile: "44",
      electron: "2.0"
    },
    "transform-dotall-regex": {
      chrome: "62",
      opera: "49",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "8.10",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      rhino: "1.7.15",
      opera_mobile: "46",
      electron: "3.0"
    },
    "transform-unicode-property-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-unicode-property-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-named-capturing-groups-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-async-to-generator": {
      chrome: "55",
      opera: "42",
      edge: "15",
      firefox: "52",
      safari: "11",
      node: "7.6",
      deno: "1",
      ios: "11",
      samsung: "6",
      opera_mobile: "42",
      electron: "1.6"
    },
    "transform-exponentiation-operator": {
      chrome: "52",
      opera: "39",
      edge: "14",
      firefox: "52",
      safari: "10.1",
      node: "7",
      deno: "1",
      ios: "10.3",
      samsung: "6",
      rhino: "1.7.14",
      opera_mobile: "41",
      electron: "1.3"
    },
    "transform-template-literals": {
      chrome: "41",
      opera: "28",
      edge: "13",
      firefox: "34",
      safari: "13",
      node: "4",
      deno: "1",
      ios: "13",
      samsung: "3.4",
      opera_mobile: "28",
      electron: "0.21"
    },
    "transform-literals": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "53",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      rhino: "1.7.15",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-function-name": {
      chrome: "51",
      opera: "38",
      edge: "79",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-arrow-functions": {
      chrome: "47",
      opera: "34",
      edge: "13",
      firefox: "43",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      rhino: "1.7.13",
      opera_mobile: "34",
      electron: "0.36"
    },
    "transform-block-scoped-functions": {
      chrome: "41",
      opera: "28",
      edge: "12",
      firefox: "46",
      safari: "10",
      node: "4",
      deno: "1",
      ie: "11",
      ios: "10",
      samsung: "3.4",
      opera_mobile: "28",
      electron: "0.21"
    },
    "transform-classes": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-object-super": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-shorthand-properties": {
      chrome: "43",
      opera: "30",
      edge: "12",
      firefox: "33",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      rhino: "1.7.14",
      opera_mobile: "30",
      electron: "0.27"
    },
    "transform-duplicate-keys": {
      chrome: "42",
      opera: "29",
      edge: "12",
      firefox: "34",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "3.4",
      opera_mobile: "29",
      electron: "0.25"
    },
    "transform-computed-properties": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "34",
      safari: "7.1",
      node: "4",
      deno: "1",
      ios: "8",
      samsung: "4",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-for-of": {
      chrome: "51",
      opera: "38",
      edge: "15",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-sticky-regex": {
      chrome: "49",
      opera: "36",
      edge: "13",
      firefox: "3",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      rhino: "1.7.15",
      opera_mobile: "36",
      electron: "0.37"
    },
    "transform-unicode-escapes": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "53",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      rhino: "1.7.15",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-unicode-regex": {
      chrome: "50",
      opera: "37",
      edge: "13",
      firefox: "46",
      safari: "12",
      node: "6",
      deno: "1",
      ios: "12",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-spread": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-destructuring": {
      chrome: "51",
      opera: "38",
      edge: "15",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-block-scoping": {
      chrome: "50",
      opera: "37",
      edge: "14",
      firefox: "53",
      safari: "11",
      node: "6",
      deno: "1",
      ios: "11",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-typeof-symbol": {
      chrome: "38",
      opera: "25",
      edge: "12",
      firefox: "36",
      safari: "9",
      node: "0.12",
      deno: "1",
      ios: "9",
      samsung: "3",
      rhino: "1.7.13",
      opera_mobile: "25",
      electron: "0.20"
    },
    "transform-new-target": {
      chrome: "46",
      opera: "33",
      edge: "14",
      firefox: "41",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-regenerator": {
      chrome: "50",
      opera: "37",
      edge: "13",
      firefox: "53",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-member-expression-literals": {
      chrome: "7",
      opera: "12",
      edge: "12",
      firefox: "2",
      safari: "5.1",
      node: "0.4",
      deno: "1",
      ie: "9",
      android: "4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "12",
      electron: "0.20"
    },
    "transform-property-literals": {
      chrome: "7",
      opera: "12",
      edge: "12",
      firefox: "2",
      safari: "5.1",
      node: "0.4",
      deno: "1",
      ie: "9",
      android: "4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "12",
      electron: "0.20"
    },
    "transform-reserved-words": {
      chrome: "13",
      opera: "10.50",
      edge: "12",
      firefox: "2",
      safari: "3.1",
      node: "0.6",
      deno: "1",
      ie: "9",
      android: "4.4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "10.1",
      electron: "0.20"
    },
    "transform-export-namespace-from": {
      chrome: "72",
      deno: "1.0",
      edge: "79",
      firefox: "80",
      node: "13.2",
      opera: "60",
      opera_mobile: "51",
      safari: "14.1",
      ios: "14.5",
      samsung: "11.0",
      android: "72",
      electron: "5.0"
    },
    "proposal-export-namespace-from": {
      chrome: "72",
      deno: "1.0",
      edge: "79",
      firefox: "80",
      node: "13.2",
      opera: "60",
      opera_mobile: "51",
      safari: "14.1",
      ios: "14.5",
      samsung: "11.0",
      android: "72",
      electron: "5.0"
    }
  };
});

// ../node_modules/@babel/compat-data/plugins.js
var Mw = T((uDe, Lw) => {
  Lw.exports = jw();
});

// ../node_modules/@babel/helper-compilation-targets/lib/filter-items.js
var Vw = T((Bo) => {
  "use strict";
  Object.defineProperty(Bo, "__esModule", {
    value: !0
  });
  Bo.default = bpe;
  Bo.isRequired = Uw;
  Bo.targetsSupported = qw;
  var Rw = ie("semver"), gpe = Mw(), Vc = Mc();
  function qw(e, t) {
    let r = Object.keys(e);
    return r.length === 0 ? !1 : r.filter((i) => {
      let a = (0, Vc.getLowestImplementedVersion)(t, i);
      if (!a)
        return !0;
      let o = e[i];
      if ((0, Vc.isUnreleasedVersion)(o, i))
        return !1;
      if ((0, Vc.isUnreleasedVersion)(a, i))
        return !0;
      if (!Rw.valid(o.toString()))
        throw new Error(`Invalid version passed for target "${i}": "${o}". Versions must be in semver format (major.minor.patch)`);
      return Rw.gt((0, Vc.semverify)(a), o.toString());
    }).length === 0;
  }
  s(qw, "targetsSupported");
  function Uw(e, t, {
    compatData: r = gpe,
    includes: n,
    excludes: i
  } = {}) {
    return i != null && i.has(e) ? !1 : n != null && n.has(e) ? !0 : !qw(t, r[e]);
  }
  s(Uw, "isRequired");
  function bpe(e, t, r, n, i, a, o) {
    let l = /* @__PURE__ */ new Set(), u = {
      compatData: e,
      includes: t,
      excludes: r
    };
    for (let c in e)
      if (Uw(c, n, u))
        l.add(c);
      else if (o) {
        let f = o.get(c);
        f && l.add(f);
      }
    return i?.forEach((c) => !r.has(c) && l.add(c)), a?.forEach((c) => !t.has(c) && l.delete(c)), l;
  }
  s(bpe, "filterItems");
});

// ../node_modules/@babel/helper-compilation-targets/lib/index.js
var eg = T((gn) => {
  "use strict";
  Object.defineProperty(gn, "__esModule", {
    value: !0
  });
  Object.defineProperty(gn, "TargetNames", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Q0.TargetNames;
    }, "get")
  });
  gn.default = Npe;
  Object.defineProperty(gn, "filterItems", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Hw.default;
    }, "get")
  });
  Object.defineProperty(gn, "getInclusionReasons", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return xpe.getInclusionReasons;
    }, "get")
  });
  gn.isBrowsersQueryValid = Yw;
  Object.defineProperty(gn, "isRequired", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Hw.isRequired;
    }, "get")
  });
  Object.defineProperty(gn, "prettifyTargets", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Tpe.prettifyTargets;
    }, "get")
  });
  Object.defineProperty(gn, "unreleasedLabels", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Gw.unreleasedLabels;
    }, "get")
  });
  var Ww = dw(), Kw = Fc(), Epe = bw(), vpe = ww(), Zr = Mc(), Gw = Lc(), Q0 = Nw(), Tpe = z0(), xpe = Fw(), Hw = Vw(), X0 = Epe["es6.module"],
  Z0 = new Kw.OptionValidator("@babel/helper-compilation-targets");
  function Spe(e) {
    let t = Object.keys(Q0.TargetNames);
    for (let r of Object.keys(e))
      if (!(r in Q0.TargetNames))
        throw new Error(Z0.formatMessage(`'${r}' is not a valid target
- Did you mean '${(0, Kw.findSuggestion)(r, t)}'?`));
    return e;
  }
  s(Spe, "validateTargetNames");
  function Yw(e) {
    return typeof e == "string" || Array.isArray(e) && e.every((t) => typeof t == "string");
  }
  s(Yw, "isBrowsersQueryValid");
  function Ppe(e) {
    return Z0.invariant(e === void 0 || Yw(e), `'${String(e)}' is not a valid browserslist query`), e;
  }
  s(Ppe, "validateBrowsers");
  function Ape(e) {
    return e.reduce((t, r) => {
      let [n, i] = r.split(" "), a = Gw.browserNameMap[n];
      if (!a)
        return t;
      try {
        let o = i.split("-")[0].toLowerCase(), l = (0, Zr.isUnreleasedVersion)(o, a);
        if (!t[a])
          return t[a] = l ? o : (0, Zr.semverify)(o), t;
        let u = t[a], c = (0, Zr.isUnreleasedVersion)(u, a);
        if (c && l)
          t[a] = (0, Zr.getLowestUnreleased)(u, o, a);
        else if (c)
          t[a] = (0, Zr.semverify)(o);
        else if (!c && !l) {
          let f = (0, Zr.semverify)(o);
          t[a] = (0, Zr.semverMin)(u, f);
        }
      } catch {
      }
      return t;
    }, {});
  }
  s(Ape, "getLowestVersions");
  function Cpe(e) {
    e.length && (console.warn(`Warning, the following targets are using a decimal version:
`), e.forEach(({
      target: t,
      value: r
    }) => console.warn(`  ${t}: ${r}`)), console.warn(`
We recommend using a string for minor/patch versions to avoid numbers like 6.10
getting parsed as 6.1, which can lead to unexpected behavior.
`));
  }
  s(Cpe, "outputDecimalWarning");
  function zw(e, t) {
    try {
      return (0, Zr.semverify)(t);
    } catch {
      throw new Error(Z0.formatMessage(`'${t}' is not a valid value for 'targets.${e}'.`));
    }
  }
  s(zw, "semverifyTarget");
  function wpe(e) {
    return ["node", e === !0 || e === "current" ? process.versions.node : zw("node", e)];
  }
  s(wpe, "nodeTargetParser");
  function Dpe(e, t) {
    let r = (0, Zr.isUnreleasedVersion)(t, e) ? t.toLowerCase() : zw(e, t);
    return [e, r];
  }
  s(Dpe, "defaultTargetParser");
  function Ipe(e) {
    let t = Object.assign({}, e);
    return delete t.esmodules, delete t.browsers, t;
  }
  s(Ipe, "generateTargets");
  function _pe(e, t) {
    let r = Ww(e, {
      mobileToDesktop: !0,
      env: t
    });
    return Ape(r);
  }
  s(_pe, "resolveTargets");
  var $w = new vpe({
    max: 64
  });
  function Ope(e, t) {
    let r = typeof e == "string" ? e : e.join() + t, n = $w.get(r);
    return n || (n = _pe(e, t), $w.set(r, n)), Object.assign({}, n);
  }
  s(Ope, "resolveTargetsCached");
  function Npe(e = {}, t = {}) {
    var r, n;
    let {
      browsers: i,
      esmodules: a
    } = e, {
      configPath: o = "."
    } = t;
    Ppe(i);
    let l = Ipe(e), u = Spe(l), f = !!i || Object.keys(u).length > 0, p = !t.ignoreBrowserslistConfig && !f;
    if (!i && p && (i = Ww.loadConfig({
      config: t.configFile,
      path: o,
      env: t.browserslistEnv
    }), i == null && (i = [])), a && (a !== "intersect" || !((r = i) != null && r.length)) && (i = Object.keys(X0).map((v) => `${v} >= ${X0[v]}`).
    join(", "), a = !1), (n = i) != null && n.length) {
      let v = Ope(i, t.browserslistEnv);
      if (a === "intersect")
        for (let d of Object.keys(v))
          if (d !== "deno" && d !== "ie") {
            let b = X0[d === "opera_mobile" ? "op_mob" : d];
            if (b) {
              let E = v[d];
              v[d] = (0, Zr.getHighestUnreleased)(E, (0, Zr.semverify)(b), d);
            } else
              delete v[d];
          } else
            delete v[d];
      u = Object.assign(v, u);
    }
    let h = {}, y = [];
    for (let v of Object.keys(u).sort()) {
      let d = u[v];
      typeof d == "number" && d % 1 !== 0 && y.push({
        target: v,
        value: d
      });
      let [b, E] = v === "node" ? wpe(d) : Dpe(v, d);
      E && (h[b] = E);
    }
    return Cpe(y), h;
  }
  s(Npe, "getTargets");
});

// ../node_modules/@babel/core/lib/config/resolve-targets.js
var tg = T(($c) => {
  "use strict";
  Object.defineProperty($c, "__esModule", {
    value: !0
  });
  $c.resolveBrowserslistConfigFile = Bpe;
  $c.resolveTargets = kpe;
  function Jw() {
    let e = ie("path");
    return Jw = /* @__PURE__ */ s(function() {
      return e;
    }, "_path"), e;
  }
  s(Jw, "_path");
  function Xw() {
    let e = eg();
    return Xw = /* @__PURE__ */ s(function() {
      return e;
    }, "_helperCompilationTargets"), e;
  }
  s(Xw, "_helperCompilationTargets");
  function Bpe(e, t) {
    return Jw().resolve(t, e);
  }
  s(Bpe, "resolveBrowserslistConfigFile");
  function kpe(e, t) {
    let r = e.targets, n;
    typeof r == "string" || Array.isArray(r) ? n = {
      browsers: r
    } : r && ("esmodules" in r ? n = Object.assign({}, r, {
      esmodules: "intersect"
    }) : n = r);
    let {
      browserslistConfigFile: i
    } = e, a, o = !1;
    return typeof i == "string" ? a = i : o = i === !1, (0, Xw().default)(n, {
      ignoreBrowserslistConfig: o,
      configFile: a,
      configPath: t,
      browserslistEnv: e.browserslistEnv
    });
  }
  s(kpe, "resolveTargets");
});

// ../node_modules/@babel/core/lib/config/config-descriptors.js
var rg = T((Fo) => {
  "use strict";
  Object.defineProperty(Fo, "__esModule", {
    value: !0
  });
  Fo.createCachedDescriptors = Mpe;
  Fo.createDescriptor = oD;
  Fo.createUncachedDescriptors = Rpe;
  function tD() {
    let e = vr();
    return tD = /* @__PURE__ */ s(function() {
      return e;
    }, "_gensync"), e;
  }
  s(tD, "_gensync");
  var Qw = f2(), Zw = Lo(), Fpe = jo(), ko = ti(), jpe = tg();
  function Lpe(e, t) {
    var r, n, i, a;
    return e.name === t.name && e.value === t.value && e.options === t.options && e.dirname === t.dirname && e.alias === t.alias && e.ownPass ===
    t.ownPass && ((r = e.file) == null ? void 0 : r.request) === ((n = t.file) == null ? void 0 : n.request) && ((i = e.file) == null ? void 0 :
    i.resolved) === ((a = t.file) == null ? void 0 : a.resolved);
  }
  s(Lpe, "isEqualDescriptor");
  function* eD(e) {
    return e;
  }
  s(eD, "handlerOf");
  function rD(e, t) {
    return typeof e.browserslistConfigFile == "string" && (e.browserslistConfigFile = (0, jpe.resolveBrowserslistConfigFile)(e.browserslistConfigFile,
    t)), e;
  }
  s(rD, "optionsWithResolvedBrowserslistConfigFile");
  function Mpe(e, t, r) {
    let {
      plugins: n,
      presets: i,
      passPerPreset: a
    } = t;
    return {
      options: rD(t, e),
      plugins: n ? () => $pe(n, e)(r) : () => eD([]),
      presets: i ? () => Upe(i, e)(r)(!!a) : () => eD([])
    };
  }
  s(Mpe, "createCachedDescriptors");
  function Rpe(e, t, r) {
    return {
      options: rD(t, e),
      plugins: (0, Qw.once)(() => iD(t.plugins || [], e, r)),
      presets: (0, Qw.once)(() => sD(t.presets || [], e, r, !!t.passPerPreset))
    };
  }
  s(Rpe, "createUncachedDescriptors");
  var qpe = /* @__PURE__ */ new WeakMap(), Upe = (0, ko.makeWeakCacheSync)((e, t) => {
    let r = t.using((n) => n);
    return (0, ko.makeStrongCacheSync)((n) => (0, ko.makeStrongCache)(function* (i) {
      return (yield* sD(e, r, n, i)).map((o) => nD(qpe, o));
    }));
  }), Vpe = /* @__PURE__ */ new WeakMap(), $pe = (0, ko.makeWeakCacheSync)((e, t) => {
    let r = t.using((n) => n);
    return (0, ko.makeStrongCache)(function* (n) {
      return (yield* iD(e, r, n)).map((a) => nD(Vpe, a));
    });
  }), Wpe = {};
  function nD(e, t) {
    let {
      value: r,
      options: n = Wpe
    } = t;
    if (n === !1) return t;
    let i = e.get(r);
    i || (i = /* @__PURE__ */ new WeakMap(), e.set(r, i));
    let a = i.get(n);
    if (a || (a = [], i.set(n, a)), !a.includes(t)) {
      let o = a.filter((l) => Lpe(l, t));
      if (o.length > 0)
        return o[0];
      a.push(t);
    }
    return t;
  }
  s(nD, "loadCachedDescriptor");
  function* sD(e, t, r, n) {
    return yield* aD("preset", e, t, r, n);
  }
  s(sD, "createPresetDescriptors");
  function* iD(e, t, r) {
    return yield* aD("plugin", e, t, r);
  }
  s(iD, "createPluginDescriptors");
  function* aD(e, t, r, n, i) {
    let a = yield* tD().all(t.map((o, l) => oD(o, r, {
      type: e,
      alias: `${n}$${l}`,
      ownPass: !!i
    })));
    return Kpe(a), a;
  }
  s(aD, "createDescriptors");
  function* oD(e, t, {
    type: r,
    alias: n,
    ownPass: i
  }) {
    let a = (0, Fpe.getItemDescriptor)(e);
    if (a)
      return a;
    let o, l, u = e;
    Array.isArray(u) && (u.length === 3 ? [u, l, o] = u : [u, l] = u);
    let c, f = null;
    if (typeof u == "string") {
      if (typeof r != "string")
        throw new Error("To resolve a string-based item, the type of item must be given");
      let p = r === "plugin" ? Zw.loadPlugin : Zw.loadPreset, h = u;
      ({
        filepath: f,
        value: u
      } = yield* p(u, t)), c = {
        request: h,
        resolved: f
      };
    }
    if (!u)
      throw new Error(`Unexpected falsy value: ${String(u)}`);
    if (typeof u == "object" && u.__esModule)
      if (u.default)
        u = u.default;
      else
        throw new Error("Must export a default export when using ES6 modules.");
    if (typeof u != "object" && typeof u != "function")
      throw new Error(`Unsupported format: ${typeof u}. Expected an object or a function.`);
    if (f !== null && typeof u == "object" && u)
      throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${f}`);
    return {
      name: o,
      alias: f || n,
      value: u,
      options: l,
      dirname: t,
      ownPass: i,
      file: c
    };
  }
  s(oD, "createDescriptor");
  function Kpe(e) {
    let t = /* @__PURE__ */ new Map();
    for (let r of e) {
      if (typeof r.value != "function") continue;
      let n = t.get(r.value);
      if (n || (n = /* @__PURE__ */ new Set(), t.set(r.value, n)), n.has(r.name)) {
        let i = e.filter((a) => a.value === r.value);
        throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separat\
e names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detec\
ted are:", `${JSON.stringify(i, null, 2)}`].join(`
`));
      }
      n.add(r.name);
    }
  }
  s(Kpe, "assertNoDuplicates");
});

// ../node_modules/@babel/core/lib/config/item.js
var jo = T((Mo) => {
  "use strict";
  Object.defineProperty(Mo, "__esModule", {
    value: !0
  });
  Mo.createConfigItem = Hpe;
  Mo.createItemFromDescriptor = uD;
  Mo.getItemDescriptor = Ype;
  function lD() {
    let e = ie("path");
    return lD = /* @__PURE__ */ s(function() {
      return e;
    }, "_path"), e;
  }
  s(lD, "_path");
  var Gpe = rg();
  function uD(e) {
    return new Wc(e);
  }
  s(uD, "createItemFromDescriptor");
  function* Hpe(e, {
    dirname: t = ".",
    type: r
  } = {}) {
    let n = yield* (0, Gpe.createDescriptor)(e, lD().resolve(t), {
      type: r,
      alias: "programmatic item"
    });
    return uD(n);
  }
  s(Hpe, "createConfigItem");
  var ng = Symbol.for("@babel/core@7 - ConfigItem");
  function Ype(e) {
    if (e != null && e[ng])
      return e._descriptor;
  }
  s(Ype, "getItemDescriptor");
  var Wc = class {
    static {
      s(this, "ConfigItem");
    }
    constructor(t) {
      this._descriptor = void 0, this[ng] = !0, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.
      file = void 0, this._descriptor = t, Object.defineProperty(this, "_descriptor", {
        enumerable: !1
      }), Object.defineProperty(this, ng, {
        enumerable: !1
      }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name =
      this._descriptor.name, this.file = this._descriptor.file ? {
        request: this._descriptor.file.request,
        resolved: this._descriptor.file.resolved
      } : void 0, Object.freeze(this);
    }
  };
  Object.freeze(Wc.prototype);
});

// ../node_modules/@babel/core/lib/config/validation/removed.js
var cD = T((Kc) => {
  "use strict";
  Object.defineProperty(Kc, "__esModule", {
    value: !0
  });
  Kc.default = void 0;
  var vDe = Kc.default = {
    auxiliaryComment: {
      message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
    },
    blacklist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    breakConfig: {
      message: "This is not a necessary option in Babel 6"
    },
    experimental: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    externalHelpers: {
      message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"
    },
    extra: {
      message: ""
    },
    jsxPragma: {
      message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
    },
    loose: {
      message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."
    },
    metadataUsedHelpers: {
      message: "Not required anymore as this is enabled by default"
    },
    modules: {
      message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"
    },
    nonStandard: {
      message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.i\
o/docs/plugins/preset-react/"
    },
    optional: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    sourceMapName: {
      message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file\
` themselves."
    },
    stage: {
      message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
    },
    whitelist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    resolveModuleSource: {
      version: 6,
      message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
    },
    metadata: {
      version: 6,
      message: "Generated plugin metadata is always included in the output result"
    },
    sourceMapTarget: {
      version: 6,
      message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.fi\
le` themselves."
    }
  };
});

// ../node_modules/@babel/core/lib/config/validation/option-assertions.js
var ag = T((Pt) => {
  "use strict";
  Object.defineProperty(Pt, "__esModule", {
    value: !0
  });
  Pt.access = xr;
  Pt.assertArray = ig;
  Pt.assertAssumptions = dde;
  Pt.assertBabelrcSearch = lde;
  Pt.assertBoolean = sg;
  Pt.assertCallerMetadata = ede;
  Pt.assertCompact = Qpe;
  Pt.assertConfigApplicableTest = ade;
  Pt.assertConfigFileSearch = ode;
  Pt.assertFunction = nde;
  Pt.assertIgnoreList = sde;
  Pt.assertInputSourceMap = tde;
  Pt.assertObject = dD;
  Pt.assertPluginList = ude;
  Pt.assertRootMode = Jpe;
  Pt.assertSourceMaps = Xpe;
  Pt.assertSourceType = Zpe;
  Pt.assertString = rde;
  Pt.assertTargets = fde;
  Pt.msg = He;
  function Ro() {
    let e = eg();
    return Ro = /* @__PURE__ */ s(function() {
      return e;
    }, "_helperCompilationTargets"), e;
  }
  s(Ro, "_helperCompilationTargets");
  var zpe = qo();
  function He(e) {
    switch (e.type) {
      case "root":
        return "";
      case "env":
        return `${He(e.parent)}.env["${e.name}"]`;
      case "overrides":
        return `${He(e.parent)}.overrides[${e.index}]`;
      case "option":
        return `${He(e.parent)}.${e.name}`;
      case "access":
        return `${He(e.parent)}[${JSON.stringify(e.name)}]`;
      default:
        throw new Error(`Assertion failure: Unknown type ${e.type}`);
    }
  }
  s(He, "msg");
  function xr(e, t) {
    return {
      type: "access",
      name: t,
      parent: e
    };
  }
  s(xr, "access");
  function Jpe(e, t) {
    if (t !== void 0 && t !== "root" && t !== "upward" && t !== "upward-optional")
      throw new Error(`${He(e)} must be a "root", "upward", "upward-optional" or undefined`);
    return t;
  }
  s(Jpe, "assertRootMode");
  function Xpe(e, t) {
    if (t !== void 0 && typeof t != "boolean" && t !== "inline" && t !== "both")
      throw new Error(`${He(e)} must be a boolean, "inline", "both", or undefined`);
    return t;
  }
  s(Xpe, "assertSourceMaps");
  function Qpe(e, t) {
    if (t !== void 0 && typeof t != "boolean" && t !== "auto")
      throw new Error(`${He(e)} must be a boolean, "auto", or undefined`);
    return t;
  }
  s(Qpe, "assertCompact");
  function Zpe(e, t) {
    if (t !== void 0 && t !== "module" && t !== "script" && t !== "unambiguous")
      throw new Error(`${He(e)} must be "module", "script", "unambiguous", or undefined`);
    return t;
  }
  s(Zpe, "assertSourceType");
  function ede(e, t) {
    let r = dD(e, t);
    if (r) {
      if (typeof r.name != "string")
        throw new Error(`${He(e)} set but does not contain "name" property string`);
      for (let n of Object.keys(r)) {
        let i = xr(e, n), a = r[n];
        if (a != null && typeof a != "boolean" && typeof a != "string" && typeof a != "number")
          throw new Error(`${He(i)} must be null, undefined, a boolean, a string, or a number.`);
      }
    }
    return t;
  }
  s(ede, "assertCallerMetadata");
  function tde(e, t) {
    if (t !== void 0 && typeof t != "boolean" && (typeof t != "object" || !t))
      throw new Error(`${He(e)} must be a boolean, object, or undefined`);
    return t;
  }
  s(tde, "assertInputSourceMap");
  function rde(e, t) {
    if (t !== void 0 && typeof t != "string")
      throw new Error(`${He(e)} must be a string, or undefined`);
    return t;
  }
  s(rde, "assertString");
  function nde(e, t) {
    if (t !== void 0 && typeof t != "function")
      throw new Error(`${He(e)} must be a function, or undefined`);
    return t;
  }
  s(nde, "assertFunction");
  function sg(e, t) {
    if (t !== void 0 && typeof t != "boolean")
      throw new Error(`${He(e)} must be a boolean, or undefined`);
    return t;
  }
  s(sg, "assertBoolean");
  function dD(e, t) {
    if (t !== void 0 && (typeof t != "object" || Array.isArray(t) || !t))
      throw new Error(`${He(e)} must be an object, or undefined`);
    return t;
  }
  s(dD, "assertObject");
  function ig(e, t) {
    if (t != null && !Array.isArray(t))
      throw new Error(`${He(e)} must be an array, or undefined`);
    return t;
  }
  s(ig, "assertArray");
  function sde(e, t) {
    let r = ig(e, t);
    return r?.forEach((n, i) => ide(xr(e, i), n)), r;
  }
  s(sde, "assertIgnoreList");
  function ide(e, t) {
    if (typeof t != "string" && typeof t != "function" && !(t instanceof RegExp))
      throw new Error(`${He(e)} must be an array of string/Function/RegExp values, or undefined`);
    return t;
  }
  s(ide, "assertIgnoreItem");
  function ade(e, t) {
    if (t === void 0)
      return t;
    if (Array.isArray(t))
      t.forEach((r, n) => {
        if (!Gc(r))
          throw new Error(`${He(xr(e, n))} must be a string/Function/RegExp.`);
      });
    else if (!Gc(t))
      throw new Error(`${He(e)} must be a string/Function/RegExp, or an array of those`);
    return t;
  }
  s(ade, "assertConfigApplicableTest");
  function Gc(e) {
    return typeof e == "string" || typeof e == "function" || e instanceof RegExp;
  }
  s(Gc, "checkValidTest");
  function ode(e, t) {
    if (t !== void 0 && typeof t != "boolean" && typeof t != "string")
      throw new Error(`${He(e)} must be a undefined, a boolean, a string, got ${JSON.stringify(t)}`);
    return t;
  }
  s(ode, "assertConfigFileSearch");
  function lde(e, t) {
    if (t === void 0 || typeof t == "boolean")
      return t;
    if (Array.isArray(t))
      t.forEach((r, n) => {
        if (!Gc(r))
          throw new Error(`${He(xr(e, n))} must be a string/Function/RegExp.`);
      });
    else if (!Gc(t))
      throw new Error(`${He(e)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(t)}`);
    return t;
  }
  s(lde, "assertBabelrcSearch");
  function ude(e, t) {
    let r = ig(e, t);
    return r && r.forEach((n, i) => cde(xr(e, i), n)), r;
  }
  s(ude, "assertPluginList");
  function cde(e, t) {
    if (Array.isArray(t)) {
      if (t.length === 0)
        throw new Error(`${He(e)} must include an object`);
      if (t.length > 3)
        throw new Error(`${He(e)} may only be a two-tuple or three-tuple`);
      if (fD(xr(e, 0), t[0]), t.length > 1) {
        let r = t[1];
        if (r !== void 0 && r !== !1 && (typeof r != "object" || Array.isArray(r) || r === null))
          throw new Error(`${He(xr(e, 1))} must be an object, false, or undefined`);
      }
      if (t.length === 3) {
        let r = t[2];
        if (r !== void 0 && typeof r != "string")
          throw new Error(`${He(xr(e, 2))} must be a string, or undefined`);
      }
    } else
      fD(e, t);
    return t;
  }
  s(cde, "assertPluginItem");
  function fD(e, t) {
    if ((typeof t != "object" || !t) && typeof t != "string" && typeof t != "function")
      throw new Error(`${He(e)} must be a string, object, function`);
    return t;
  }
  s(fD, "assertPluginTarget");
  function fde(e, t) {
    if ((0, Ro().isBrowsersQueryValid)(t)) return t;
    if (typeof t != "object" || !t || Array.isArray(t))
      throw new Error(`${He(e)} must be a string, an array of strings or an object`);
    let r = xr(e, "browsers"), n = xr(e, "esmodules");
    pD(r, t.browsers), sg(n, t.esmodules);
    for (let i of Object.keys(t)) {
      let a = t[i], o = xr(e, i);
      if (i === "esmodules") sg(o, a);
      else if (i === "browsers") pD(o, a);
      else if (hasOwnProperty.call(Ro().TargetNames, i))
        pde(o, a);
      else {
        let l = Object.keys(Ro().TargetNames).join(", ");
        throw new Error(`${He(o)} is not a valid target. Supported targets are ${l}`);
      }
    }
    return t;
  }
  s(fde, "assertTargets");
  function pD(e, t) {
    if (t !== void 0 && !(0, Ro().isBrowsersQueryValid)(t))
      throw new Error(`${He(e)} must be undefined, a string or an array of strings`);
  }
  s(pD, "assertBrowsersList");
  function pde(e, t) {
    if (!(typeof t == "number" && Math.round(t) === t) && typeof t != "string")
      throw new Error(`${He(e)} must be a string or an integer number`);
  }
  s(pde, "assertBrowserVersion");
  function dde(e, t) {
    if (t === void 0) return;
    if (typeof t != "object" || t === null)
      throw new Error(`${He(e)} must be an object or undefined.`);
    let r = e;
    do
      r = r.parent;
    while (r.type !== "root");
    let n = r.source === "preset";
    for (let i of Object.keys(t)) {
      let a = xr(e, i);
      if (!zpe.assumptionsNames.has(i))
        throw new Error(`${He(a)} is not a supported assumption.`);
      if (typeof t[i] != "boolean")
        throw new Error(`${He(a)} must be a boolean.`);
      if (n && t[i] === !1)
        throw new Error(`${He(a)} cannot be set to 'false' inside presets.`);
    }
    return t;
  }
  s(dde, "assertAssumptions");
});

// ../node_modules/@babel/core/lib/config/validation/options.js
var qo = T((sa) => {
  "use strict";
  Object.defineProperty(sa, "__esModule", {
    value: !0
  });
  sa.assumptionsNames = void 0;
  sa.checkNoUnwrappedItemOptionPairs = Tde;
  sa.validate = yde;
  var hD = cD(), ge = ag(), hde = ri(), mD = {
    cwd: ge.assertString,
    root: ge.assertString,
    rootMode: ge.assertRootMode,
    configFile: ge.assertConfigFileSearch,
    caller: ge.assertCallerMetadata,
    filename: ge.assertString,
    filenameRelative: ge.assertString,
    code: ge.assertBoolean,
    ast: ge.assertBoolean,
    cloneInputAst: ge.assertBoolean,
    envName: ge.assertString
  }, yD = {
    babelrc: ge.assertBoolean,
    babelrcRoots: ge.assertBabelrcSearch
  }, gD = {
    extends: ge.assertString,
    ignore: ge.assertIgnoreList,
    only: ge.assertIgnoreList,
    targets: ge.assertTargets,
    browserslistConfigFile: ge.assertConfigFileSearch,
    browserslistEnv: ge.assertString
  }, bD = {
    inputSourceMap: ge.assertInputSourceMap,
    presets: ge.assertPluginList,
    plugins: ge.assertPluginList,
    passPerPreset: ge.assertBoolean,
    assumptions: ge.assertAssumptions,
    env: Ede,
    overrides: vde,
    test: ge.assertConfigApplicableTest,
    include: ge.assertConfigApplicableTest,
    exclude: ge.assertConfigApplicableTest,
    retainLines: ge.assertBoolean,
    comments: ge.assertBoolean,
    shouldPrintComment: ge.assertFunction,
    compact: ge.assertCompact,
    minified: ge.assertBoolean,
    auxiliaryCommentBefore: ge.assertString,
    auxiliaryCommentAfter: ge.assertString,
    sourceType: ge.assertSourceType,
    wrapPluginVisitorMethod: ge.assertFunction,
    highlightCode: ge.assertBoolean,
    sourceMaps: ge.assertSourceMaps,
    sourceMap: ge.assertSourceMaps,
    sourceFileName: ge.assertString,
    sourceRoot: ge.assertString,
    parserOpts: ge.assertObject,
    generatorOpts: ge.assertObject
  };
  Object.assign(bD, {
    getModuleId: ge.assertFunction,
    moduleRoot: ge.assertString,
    moduleIds: ge.assertBoolean,
    moduleId: ge.assertString
  });
  var mde = ["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitive\
Hint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "noUnini\
tializedPrivateFieldAccess", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods",
  "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"], PDe = sa.
  assumptionsNames = new Set(mde);
  function ED(e) {
    return e.type === "root" ? e.source : ED(e.parent);
  }
  s(ED, "getSource");
  function yde(e, t, r) {
    try {
      return og({
        type: "root",
        source: e
      }, t);
    } catch (n) {
      let i = new hde.default(n.message, r);
      throw n.code && (i.code = n.code), i;
    }
  }
  s(yde, "validate");
  function og(e, t) {
    let r = ED(e);
    return bde(t), Object.keys(t).forEach((n) => {
      let i = {
        type: "option",
        name: n,
        parent: e
      };
      if (r === "preset" && gD[n])
        throw new Error(`${(0, ge.msg)(i)} is not allowed in preset options`);
      if (r !== "arguments" && mD[n])
        throw new Error(`${(0, ge.msg)(i)} is only allowed in root programmatic options`);
      if (r !== "arguments" && r !== "configfile" && yD[n])
        throw r === "babelrcfile" || r === "extendsfile" ? new Error(`${(0, ge.msg)(i)} is not allowed in .babelrc or "extends"ed files, onl\
y in root programmatic options, or babel.config.js/config file options`) : new Error(`${(0, ge.msg)(i)} is only allowed in root programmatic\
 options, or babel.config.js/config file options`);
      (bD[n] || gD[n] || yD[n] || mD[n] || gde)(i, t[n]);
    }), t;
  }
  s(og, "validateNested");
  function gde(e) {
    let t = e.name;
    if (hD.default[t]) {
      let {
        message: r,
        version: n = 5
      } = hD.default[t];
      throw new Error(`Using removed Babel ${n} option: ${(0, ge.msg)(e)} - ${r}`);
    } else {
      let r = new Error(`Unknown option: ${(0, ge.msg)(e)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information ab\
out options.`);
      throw r.code = "BABEL_UNKNOWN_OPTION", r;
    }
  }
  s(gde, "throwUnknownError");
  function bde(e) {
    if (hasOwnProperty.call(e, "sourceMap") && hasOwnProperty.call(e, "sourceMaps"))
      throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
  }
  s(bde, "assertNoDuplicateSourcemap");
  function Ede(e, t) {
    if (e.parent.type === "env")
      throw new Error(`${(0, ge.msg)(e)} is not allowed inside of another .env block`);
    let r = e.parent, n = (0, ge.assertObject)(e, t);
    if (n)
      for (let i of Object.keys(n)) {
        let a = (0, ge.assertObject)((0, ge.access)(e, i), n[i]);
        if (!a) continue;
        og({
          type: "env",
          name: i,
          parent: r
        }, a);
      }
    return n;
  }
  s(Ede, "assertEnvSet");
  function vde(e, t) {
    if (e.parent.type === "env")
      throw new Error(`${(0, ge.msg)(e)} is not allowed inside an .env block`);
    if (e.parent.type === "overrides")
      throw new Error(`${(0, ge.msg)(e)} is not allowed inside an .overrides block`);
    let r = e.parent, n = (0, ge.assertArray)(e, t);
    if (n)
      for (let [i, a] of n.entries()) {
        let o = (0, ge.access)(e, i), l = (0, ge.assertObject)(o, a);
        if (!l) throw new Error(`${(0, ge.msg)(o)} must be an object`);
        og({
          type: "overrides",
          index: i,
          parent: r
        }, l);
      }
    return n;
  }
  s(vde, "assertOverridesList");
  function Tde(e, t, r, n) {
    if (t === 0) return;
    let i = e[t - 1], a = e[t];
    i.file && i.options === void 0 && typeof a.value == "object" && (n.message += `
- Maybe you meant to use
"${r}s": [
  ["${i.file.request}", ${JSON.stringify(a.value, void 0, 2)}]
]
To be a valid ${r}, its name and options should be wrapped in a pair of brackets`);
  }
  s(Tde, "checkNoUnwrappedItemOptionPairs");
});

// ../node_modules/@babel/core/lib/config/pattern-to-regex.js
var pg = T((fg) => {
  "use strict";
  Object.defineProperty(fg, "__esModule", {
    value: !0
  });
  fg.default = Pde;
  function Hc() {
    let e = ie("path");
    return Hc = /* @__PURE__ */ s(function() {
      return e;
    }, "_path"), e;
  }
  s(Hc, "_path");
  var Uo = `\\${Hc().sep}`, lg = `(?:${Uo}|$)`, ug = `[^${Uo}]+`, cg = `(?:${ug}${Uo})`, TD = `(?:${ug}${lg})`, xde = `${cg}*?`, Sde = `${cg}\
*?${TD}?`;
  function vD(e) {
    return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
  }
  s(vD, "escapeRegExp");
  function Pde(e, t) {
    let r = Hc().resolve(t, e).split(Hc().sep);
    return new RegExp(["^", ...r.map((n, i) => {
      let a = i === r.length - 1;
      return n === "**" ? a ? Sde : xde : n === "*" ? a ? TD : cg : n.indexOf("*.") === 0 ? ug + vD(n.slice(1)) + (a ? lg : Uo) : vD(n) + (a ?
      lg : Uo);
    })].join(""));
  }
  s(Pde, "pathToPattern");
});

// ../node_modules/@babel/core/lib/config/printer.js
var PD = T((ia) => {
  "use strict";
  Object.defineProperty(ia, "__esModule", {
    value: !0
  });
  ia.ConfigPrinter = ia.ChainFormatter = void 0;
  function SD() {
    let e = vr();
    return SD = /* @__PURE__ */ s(function() {
      return e;
    }, "_gensync"), e;
  }
  s(SD, "_gensync");
  var Ade = ia.ChainFormatter = {
    Programmatic: 0,
    Config: 1
  }, dg = {
    title(e, t, r) {
      let n = "";
      return e === Ade.Programmatic ? (n = "programmatic options", t && (n += " from " + t)) : n = "config " + r, n;
    },
    loc(e, t) {
      let r = "";
      return e != null && (r += `.overrides[${e}]`), t != null && (r += `.env["${t}"]`), r;
    },
    *optionsAndDescriptors(e) {
      let t = Object.assign({}, e.options);
      delete t.overrides, delete t.env;
      let r = [...yield* e.plugins()];
      r.length && (t.plugins = r.map((i) => xD(i)));
      let n = [...yield* e.presets()];
      return n.length && (t.presets = [...n].map((i) => xD(i))), JSON.stringify(t, void 0, 2);
    }
  };
  function xD(e) {
    var t;
    let r = (t = e.file) == null ? void 0 : t.request;
    return r == null && (typeof e.value == "object" ? r = e.value : typeof e.value == "function" && (r = `[Function: ${e.value.toString().slice(
    0, 50)} ... ]`)), r == null && (r = "[Unknown]"), e.options === void 0 ? r : e.name == null ? [r, e.options] : [r, e.options, e.name];
  }
  s(xD, "descriptorToConfig");
  var hg = class e {
    static {
      s(this, "ConfigPrinter");
    }
    constructor() {
      this._stack = [];
    }
    configure(t, r, {
      callerName: n,
      filepath: i
    }) {
      return t ? (a, o, l) => {
        this._stack.push({
          type: r,
          callerName: n,
          filepath: i,
          content: a,
          index: o,
          envName: l
        });
      } : () => {
      };
    }
    static *format(t) {
      let r = dg.title(t.type, t.callerName, t.filepath), n = dg.loc(t.index, t.envName);
      n && (r += ` ${n}`);
      let i = yield* dg.optionsAndDescriptors(t.content);
      return `${r}
${i}`;
    }
    *output() {
      return this._stack.length === 0 ? "" : (yield* SD().all(this._stack.map((r) => e.format(r)))).join(`

`);
    }
  };
  ia.ConfigPrinter = hg;
});

// ../node_modules/@babel/core/lib/config/config-chain.js
var Pg = T((oa) => {
  "use strict";
  Object.defineProperty(oa, "__esModule", {
    value: !0
  });
  oa.buildPresetChain = Dde;
  oa.buildPresetChainWalker = void 0;
  oa.buildRootChain = kde;
  function wD() {
    let e = ie("path");
    return wD = /* @__PURE__ */ s(function() {
      return e;
    }, "_path"), e;
  }
  s(wD, "_path");
  function DD() {
    let e = qs();
    return DD = /* @__PURE__ */ s(function() {
      return e;
    }, "_debug"), e;
  }
  s(DD, "_debug");
  var bg = qo(), ID = pg(), $o = PD(), Cde = Fn(), wde = ri(), Vo = Lo(), Ot = ti(), jr = rg(), AD = DD()("babel:config:config-chain");
  function* Dde(e, t) {
    let r = yield* Ide(e, t);
    return r ? {
      plugins: Jc(r.plugins),
      presets: Jc(r.presets),
      options: r.options.map((n) => _D(n)),
      files: /* @__PURE__ */ new Set()
    } : null;
  }
  s(Dde, "buildPresetChain");
  var Ide = oa.buildPresetChainWalker = Sg({
    root: /* @__PURE__ */ s((e) => _de(e), "root"),
    env: /* @__PURE__ */ s((e, t) => Ode(e)(t), "env"),
    overrides: /* @__PURE__ */ s((e, t) => Nde(e)(t), "overrides"),
    overridesEnv: /* @__PURE__ */ s((e, t, r) => Bde(e)(t)(r), "overridesEnv"),
    createLogger: /* @__PURE__ */ s(() => () => {
    }, "createLogger")
  }), _de = (0, Ot.makeWeakCacheSync)((e) => Eg(e, e.alias, jr.createUncachedDescriptors)), Ode = (0, Ot.makeWeakCacheSync)((e) => (0, Ot.makeStrongCacheSync)(
  (t) => vg(e, e.alias, jr.createUncachedDescriptors, t))), Nde = (0, Ot.makeWeakCacheSync)((e) => (0, Ot.makeStrongCacheSync)((t) => Tg(e, e.
  alias, jr.createUncachedDescriptors, t))), Bde = (0, Ot.makeWeakCacheSync)((e) => (0, Ot.makeStrongCacheSync)((t) => (0, Ot.makeStrongCacheSync)(
  (r) => xg(e, e.alias, jr.createUncachedDescriptors, t, r))));
  function* kde(e, t) {
    let r, n, i = new $o.ConfigPrinter(), a = yield* Rde({
      options: e,
      dirname: t.cwd
    }, t, void 0, i);
    if (!a) return null;
    let o = yield* i.output(), l;
    typeof e.configFile == "string" ? l = yield* (0, Vo.loadConfig)(e.configFile, t.cwd, t.envName, t.caller) : e.configFile !== !1 && (l = yield* (0, Vo.
    findRootConfig)(t.root, t.envName, t.caller));
    let {
      babelrc: u,
      babelrcRoots: c
    } = e, f = t.cwd, p = zc(), h = new $o.ConfigPrinter();
    if (l) {
      let I = jde(l), O = yield* yg(I, t, void 0, h);
      if (!O) return null;
      r = yield* h.output(), u === void 0 && (u = I.options.babelrc), c === void 0 && (f = I.dirname, c = I.options.babelrcRoots), aa(p, O);
    }
    let y, v, d = !1, b = zc();
    if ((u === !0 || u === void 0) && typeof t.filename == "string") {
      let I = yield* (0, Vo.findPackageData)(t.filename);
      if (I && Fde(t, I, c, f)) {
        if ({
          ignore: y,
          config: v
        } = yield* (0, Vo.findRelativeConfig)(I, t.envName, t.caller), y && b.files.add(y.filepath), y && OD(t, y.ignore, null, y.dirname) &&
        (d = !0), v && !d) {
          let O = Lde(v), k = new $o.ConfigPrinter(), j = yield* yg(O, t, void 0, k);
          j ? (n = yield* k.output(), aa(b, j)) : d = !0;
        }
        v && d && b.files.add(v.filepath);
      }
    }
    t.showConfig && console.log(`Babel configs on "${t.filename}" (ascending priority):
` + [r, n, o].filter((I) => !!I).join(`

`) + `
-----End Babel configs-----`);
    let E = aa(aa(aa(zc(), p), b), a);
    return {
      plugins: d ? [] : Jc(E.plugins),
      presets: d ? [] : Jc(E.presets),
      options: d ? [] : E.options.map((I) => _D(I)),
      fileHandling: d ? "ignored" : "transpile",
      ignore: y || void 0,
      babelrc: v || void 0,
      config: l || void 0,
      files: E.files
    };
  }
  s(kde, "buildRootChain");
  function Fde(e, t, r, n) {
    if (typeof r == "boolean") return r;
    let i = e.root;
    if (r === void 0)
      return t.directories.includes(i);
    let a = r;
    return Array.isArray(a) || (a = [a]), a = a.map((o) => typeof o == "string" ? wD().resolve(n, o) : o), a.length === 1 && a[0] === i ? t.
    directories.includes(i) : a.some((o) => (typeof o == "string" && (o = (0, ID.default)(o, n)), t.directories.some((l) => ND(o, n, l, e))));
  }
  s(Fde, "babelrcLoadEnabled");
  var jde = (0, Ot.makeWeakCacheSync)((e) => ({
    filepath: e.filepath,
    dirname: e.dirname,
    options: (0, bg.validate)("configfile", e.options, e.filepath)
  })), Lde = (0, Ot.makeWeakCacheSync)((e) => ({
    filepath: e.filepath,
    dirname: e.dirname,
    options: (0, bg.validate)("babelrcfile", e.options, e.filepath)
  })), Mde = (0, Ot.makeWeakCacheSync)((e) => ({
    filepath: e.filepath,
    dirname: e.dirname,
    options: (0, bg.validate)("extendsfile", e.options, e.filepath)
  })), Rde = Sg({
    root: /* @__PURE__ */ s((e) => Eg(e, "base", jr.createCachedDescriptors), "root"),
    env: /* @__PURE__ */ s((e, t) => vg(e, "base", jr.createCachedDescriptors, t), "env"),
    overrides: /* @__PURE__ */ s((e, t) => Tg(e, "base", jr.createCachedDescriptors, t), "overrides"),
    overridesEnv: /* @__PURE__ */ s((e, t, r) => xg(e, "base", jr.createCachedDescriptors, t, r), "overridesEnv"),
    createLogger: /* @__PURE__ */ s((e, t, r) => Gde(e, t, r), "createLogger")
  }), qde = Sg({
    root: /* @__PURE__ */ s((e) => Ude(e), "root"),
    env: /* @__PURE__ */ s((e, t) => Vde(e)(t), "env"),
    overrides: /* @__PURE__ */ s((e, t) => $de(e)(t), "overrides"),
    overridesEnv: /* @__PURE__ */ s((e, t, r) => Wde(e)(t)(r), "overridesEnv"),
    createLogger: /* @__PURE__ */ s((e, t, r) => Kde(e.filepath, t, r), "createLogger")
  });
  function* yg(e, t, r, n) {
    let i = yield* qde(e, t, r, n);
    return i?.files.add(e.filepath), i;
  }
  s(yg, "loadFileChain");
  var Ude = (0, Ot.makeWeakCacheSync)((e) => Eg(e, e.filepath, jr.createUncachedDescriptors)), Vde = (0, Ot.makeWeakCacheSync)((e) => (0, Ot.
  makeStrongCacheSync)((t) => vg(e, e.filepath, jr.createUncachedDescriptors, t))), $de = (0, Ot.makeWeakCacheSync)((e) => (0, Ot.makeStrongCacheSync)(
  (t) => Tg(e, e.filepath, jr.createUncachedDescriptors, t))), Wde = (0, Ot.makeWeakCacheSync)((e) => (0, Ot.makeStrongCacheSync)((t) => (0, Ot.
  makeStrongCacheSync)((r) => xg(e, e.filepath, jr.createUncachedDescriptors, t, r))));
  function Kde(e, t, r) {
    return r ? r.configure(t.showConfig, $o.ChainFormatter.Config, {
      filepath: e
    }) : () => {
    };
  }
  s(Kde, "buildFileLogger");
  function Eg({
    dirname: e,
    options: t
  }, r, n) {
    return n(e, t, r);
  }
  s(Eg, "buildRootDescriptors");
  function Gde(e, t, r) {
    var n;
    return r ? r.configure(t.showConfig, $o.ChainFormatter.Programmatic, {
      callerName: (n = t.caller) == null ? void 0 : n.name
    }) : () => {
    };
  }
  s(Gde, "buildProgrammaticLogger");
  function vg({
    dirname: e,
    options: t
  }, r, n, i) {
    var a;
    let o = (a = t.env) == null ? void 0 : a[i];
    return o ? n(e, o, `${r}.env["${i}"]`) : null;
  }
  s(vg, "buildEnvDescriptors");
  function Tg({
    dirname: e,
    options: t
  }, r, n, i) {
    var a;
    let o = (a = t.overrides) == null ? void 0 : a[i];
    if (!o) throw new Error("Assertion failure - missing override");
    return n(e, o, `${r}.overrides[${i}]`);
  }
  s(Tg, "buildOverrideDescriptors");
  function xg({
    dirname: e,
    options: t
  }, r, n, i, a) {
    var o, l;
    let u = (o = t.overrides) == null ? void 0 : o[i];
    if (!u) throw new Error("Assertion failure - missing override");
    let c = (l = u.env) == null ? void 0 : l[a];
    return c ? n(e, c, `${r}.overrides[${i}].env["${a}"]`) : null;
  }
  s(xg, "buildOverrideEnvDescriptors");
  function Sg({
    root: e,
    env: t,
    overrides: r,
    overridesEnv: n,
    createLogger: i
  }) {
    return /* @__PURE__ */ s(function* (o, l, u = /* @__PURE__ */ new Set(), c) {
      let {
        dirname: f
      } = o, p = [], h = e(o);
      if (Yc(h, f, l, o.filepath)) {
        p.push({
          config: h,
          envName: void 0,
          index: void 0
        });
        let d = t(o, l.envName);
        d && Yc(d, f, l, o.filepath) && p.push({
          config: d,
          envName: l.envName,
          index: void 0
        }), (h.options.overrides || []).forEach((b, E) => {
          let I = r(o, E);
          if (Yc(I, f, l, o.filepath)) {
            p.push({
              config: I,
              index: E,
              envName: void 0
            });
            let O = n(o, E, l.envName);
            O && Yc(O, f, l, o.filepath) && p.push({
              config: O,
              index: E,
              envName: l.envName
            });
          }
        });
      }
      if (p.some(({
        config: {
          options: {
            ignore: d,
            only: b
          }
        }
      }) => OD(l, d, b, f)))
        return null;
      let y = zc(), v = i(o, l, c);
      for (let {
        config: d,
        index: b,
        envName: E
      } of p) {
        if (!(yield* Hde(y, d.options, f, l, u, c)))
          return null;
        v(d, b, E), yield* Yde(y, d);
      }
      return y;
    }, "chainWalker");
  }
  s(Sg, "makeChainWalker");
  function* Hde(e, t, r, n, i, a) {
    if (t.extends === void 0) return !0;
    let o = yield* (0, Vo.loadConfig)(t.extends, r, n.envName, n.caller);
    if (i.has(o))
      throw new Error(`Configuration cycle detected loading ${o.filepath}.
File already loaded following the config chain:
` + Array.from(i, (u) => ` - ${u.filepath}`).join(`
`));
    i.add(o);
    let l = yield* yg(Mde(o), n, i, a);
    return i.delete(o), l ? (aa(e, l), !0) : !1;
  }
  s(Hde, "mergeExtendsChain");
  function aa(e, t) {
    e.options.push(...t.options), e.plugins.push(...t.plugins), e.presets.push(...t.presets);
    for (let r of t.files)
      e.files.add(r);
    return e;
  }
  s(aa, "mergeChain");
  function* Yde(e, {
    options: t,
    plugins: r,
    presets: n
  }) {
    return e.options.push(t), e.plugins.push(...yield* r()), e.presets.push(...yield* n()), e;
  }
  s(Yde, "mergeChainOpts");
  function zc() {
    return {
      options: [],
      presets: [],
      plugins: [],
      files: /* @__PURE__ */ new Set()
    };
  }
  s(zc, "emptyChain");
  function _D(e) {
    let t = Object.assign({}, e);
    return delete t.extends, delete t.env, delete t.overrides, delete t.plugins, delete t.presets, delete t.passPerPreset, delete t.ignore, delete t.
    only, delete t.test, delete t.include, delete t.exclude, hasOwnProperty.call(t, "sourceMap") && (t.sourceMaps = t.sourceMap, delete t.sourceMap),
    t;
  }
  s(_D, "normalizeOptions");
  function Jc(e) {
    let t = /* @__PURE__ */ new Map(), r = [];
    for (let n of e)
      if (typeof n.value == "function") {
        let i = n.value, a = t.get(i);
        a || (a = /* @__PURE__ */ new Map(), t.set(i, a));
        let o = a.get(n.name);
        o ? o.value = n : (o = {
          value: n
        }, r.push(o), n.ownPass || a.set(n.name, o));
      } else
        r.push({
          value: n
        });
    return r.reduce((n, i) => (n.push(i.value), n), []);
  }
  s(Jc, "dedupDescriptors");
  function Yc({
    options: e
  }, t, r, n) {
    return (e.test === void 0 || mg(r, e.test, t, n)) && (e.include === void 0 || mg(r, e.include, t, n)) && (e.exclude === void 0 || !mg(r,
    e.exclude, t, n));
  }
  s(Yc, "configIsApplicable");
  function mg(e, t, r, n) {
    let i = Array.isArray(t) ? t : [t];
    return gg(e, i, r, n);
  }
  s(mg, "configFieldIsApplicable");
  function CD(e, t) {
    return t instanceof RegExp ? String(t) : t;
  }
  s(CD, "ignoreListReplacer");
  function OD(e, t, r, n) {
    if (t && gg(e, t, n)) {
      var i;
      let o = `No config is applied to "${(i = e.filename) != null ? i : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(
      t, CD)}\` from "${n}"`;
      return AD(o), e.showConfig && console.log(o), !0;
    }
    if (r && !gg(e, r, n)) {
      var a;
      let o = `No config is applied to "${(a = e.filename) != null ? a : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(
      r, CD)}\` from "${n}"`;
      return AD(o), e.showConfig && console.log(o), !0;
    }
    return !1;
  }
  s(OD, "shouldIgnore");
  function gg(e, t, r, n) {
    return t.some((i) => ND(i, r, e.filename, e, n));
  }
  s(gg, "matchesPatterns");
  function ND(e, t, r, n, i) {
    if (typeof e == "function")
      return !!(0, Cde.endHiddenCallStack)(e)(r, {
        dirname: t,
        envName: n.envName,
        caller: n.caller
      });
    if (typeof r != "string")
      throw new wde.default("Configuration contains string/RegExp pattern, but no filename was passed to Babel", i);
    return typeof e == "string" && (e = (0, ID.default)(e, t)), e.test(r);
  }
  s(ND, "matchPattern");
});

// ../node_modules/@babel/core/lib/config/validation/plugins.js
var BD = T((Ag) => {
  "use strict";
  Object.defineProperty(Ag, "__esModule", {
    value: !0
  });
  Ag.validatePluginObject = Qde;
  var Vn = ag(), zde = {
    name: Vn.assertString,
    manipulateOptions: Vn.assertFunction,
    pre: Vn.assertFunction,
    post: Vn.assertFunction,
    inherits: Vn.assertFunction,
    visitor: Jde,
    parserOverride: Vn.assertFunction,
    generatorOverride: Vn.assertFunction
  };
  function Jde(e, t) {
    let r = (0, Vn.assertObject)(e, t);
    if (r && (Object.keys(r).forEach((n) => {
      n !== "_exploded" && n !== "_verified" && Xde(n, r[n]);
    }), r.enter || r.exit))
      throw new Error(`${(0, Vn.msg)(e)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
    return r;
  }
  s(Jde, "assertVisitorMap");
  function Xde(e, t) {
    if (t && typeof t == "object")
      Object.keys(t).forEach((r) => {
        if (r !== "enter" && r !== "exit")
          throw new Error(`.visitor["${e}"] may only have .enter and/or .exit handlers.`);
      });
    else if (typeof t != "function")
      throw new Error(`.visitor["${e}"] must be a function`);
  }
  s(Xde, "assertVisitorHandler");
  function Qde(e) {
    let t = {
      type: "root",
      source: "plugin"
    };
    return Object.keys(e).forEach((r) => {
      let n = zde[r];
      if (n)
        n({
          type: "option",
          name: r,
          parent: t
        }, e[r]);
      else {
        let i = new Error(`.${r} is not a valid Plugin property`);
        throw i.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", i;
      }
    }), e;
  }
  s(Qde, "validatePluginObject");
});

// ../node_modules/@babel/core/lib/config/helpers/environment.js
var wg = T((Cg) => {
  "use strict";
  Object.defineProperty(Cg, "__esModule", {
    value: !0
  });
  Cg.getEnv = Zde;
  function Zde(e = "development") {
    return process.env.BABEL_ENV || process.env.NODE_ENV || e;
  }
  s(Zde, "getEnv");
});

// ../node_modules/@babel/core/lib/config/partial.js
var Dg = T((ef) => {
  "use strict";
  Object.defineProperty(ef, "__esModule", {
    value: !0
  });
  ef.default = FD;
  ef.loadPartialConfig = uhe;
  function Xc() {
    let e = ie("path");
    return Xc = /* @__PURE__ */ s(function() {
      return e;
    }, "_path"), e;
  }
  s(Xc, "_path");
  var ehe = Tc(), the = oc(), kD = jo(), rhe = Pg(), nhe = wg(), she = qo(), Qc = Lo(), ihe = tg(), ahe = ["showIgnoredFiles"];
  function ohe(e, t) {
    if (e == null) return {};
    var r = {}, n = Object.keys(e), i, a;
    for (a = 0; a < n.length; a++)
      i = n[a], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
    return r;
  }
  s(ohe, "_objectWithoutPropertiesLoose");
  function lhe(e, t) {
    switch (t) {
      case "root":
        return e;
      case "upward-optional": {
        let r = (0, Qc.findConfigUpwards)(e);
        return r === null ? e : r;
      }
      case "upward": {
        let r = (0, Qc.findConfigUpwards)(e);
        if (r !== null) return r;
        throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${e}".\

One of the following config files must be in the directory tree: "${Qc.ROOT_CONFIG_FILENAMES.join(", ")}".`), {
          code: "BABEL_ROOT_NOT_FOUND",
          dirname: e
        });
      }
      default:
        throw new Error("Assertion failure - unknown rootMode value.");
    }
  }
  s(lhe, "resolveRootMode");
  function* FD(e) {
    if (e != null && (typeof e != "object" || Array.isArray(e)))
      throw new Error("Babel options must be an object, null, or undefined");
    let t = e ? (0, she.validate)("arguments", e) : {}, {
      envName: r = (0, nhe.getEnv)(),
      cwd: n = ".",
      root: i = ".",
      rootMode: a = "root",
      caller: o,
      cloneInputAst: l = !0
    } = t, u = Xc().resolve(n), c = lhe(Xc().resolve(u, i), a), f = typeof t.filename == "string" ? Xc().resolve(n, t.filename) : void 0, p = yield* (0, Qc.
    resolveShowConfigPath)(u), h = {
      filename: f,
      cwd: u,
      root: c,
      envName: r,
      caller: o,
      showConfig: p === f
    }, y = yield* (0, rhe.buildRootChain)(t, h);
    if (!y) return null;
    let v = {
      assumptions: {}
    };
    return y.options.forEach((b) => {
      (0, the.mergeOptions)(v, b);
    }), {
      options: Object.assign({}, v, {
        targets: (0, ihe.resolveTargets)(v, c),
        cloneInputAst: l,
        babelrc: !1,
        configFile: !1,
        browserslistConfigFile: !1,
        passPerPreset: !1,
        envName: h.envName,
        cwd: h.cwd,
        root: h.root,
        rootMode: "root",
        filename: typeof h.filename == "string" ? h.filename : void 0,
        plugins: y.plugins.map((b) => (0, kD.createItemFromDescriptor)(b)),
        presets: y.presets.map((b) => (0, kD.createItemFromDescriptor)(b))
      }),
      context: h,
      fileHandling: y.fileHandling,
      ignore: y.ignore,
      babelrc: y.babelrc,
      config: y.config,
      files: y.files
    };
  }
  s(FD, "loadPrivatePartialConfig");
  function* uhe(e) {
    let t = !1;
    if (typeof e == "object" && e !== null && !Array.isArray(e)) {
      var r = e;
      ({
        showIgnoredFiles: t
      } = r), e = ohe(r, ahe);
    }
    let n = yield* FD(e);
    if (!n) return null;
    let {
      options: i,
      babelrc: a,
      ignore: o,
      config: l,
      fileHandling: u,
      files: c
    } = n;
    return u === "ignored" && !t ? null : ((i.plugins || []).forEach((f) => {
      if (f.value instanceof ehe.default)
        throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
    }), new Zc(i, a ? a.filepath : void 0, o ? o.filepath : void 0, l ? l.filepath : void 0, u, c));
  }
  s(uhe, "loadPartialConfig");
  var Zc = class {
    static {
      s(this, "PartialConfig");
    }
    constructor(t, r, n, i, a, o) {
      this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files =
      void 0, this.options = t, this.babelignore = n, this.babelrc = r, this.config = i, this.fileHandling = a, this.files = o, Object.freeze(
      this);
    }
    hasFilesystemConfig() {
      return this.babelrc !== void 0 || this.config !== void 0;
    }
  };
  Object.freeze(Zc.prototype);
});

// ../node_modules/@babel/core/lib/config/full.js
var WD = T((tf) => {
  "use strict";
  Object.defineProperty(tf, "__esModule", {
    value: !0
  });
  tf.default = void 0;
  function RD() {
    let e = vr();
    return RD = /* @__PURE__ */ s(function() {
      return e;
    }, "_gensync"), e;
  }
  s(RD, "_gensync");
  var Og = Hi(), jD = oc(), che = bt(), qD = Tc(), fhe = jo(), phe = Pg(), kg = Ec();
  function Ng() {
    let e = _r();
    return Ng = /* @__PURE__ */ s(function() {
      return e;
    }, "_traverse"), e;
  }
  s(Ng, "_traverse");
  var Fg = ti(), Bg = qo(), dhe = BD(), UD = A0(), hhe = Dg(), mhe = ri(), RDe = tf.default = RD()(/* @__PURE__ */ s(function* (t) {
    var r;
    let n = yield* (0, hhe.default)(t);
    if (!n)
      return null;
    let {
      options: i,
      context: a,
      fileHandling: o
    } = n;
    if (o === "ignored")
      return null;
    let l = {}, {
      plugins: u,
      presets: c
    } = i;
    if (!u || !c)
      throw new Error("Assertion failure - plugins and presets exist");
    let f = Object.assign({}, a, {
      targets: i.targets
    }), p = /* @__PURE__ */ s((k) => {
      let j = (0, fhe.getItemDescriptor)(k);
      if (!j)
        throw new Error("Assertion failure - must be config item");
      return j;
    }, "toDescriptor"), h = c.map(p), y = u.map(p), v = [[]], d = [], b = [];
    if (yield* LD(a, /* @__PURE__ */ s(function* k(j, R) {
      let U = [];
      for (let W = 0; W < j.length; W++) {
        let q = j[W];
        if (q.options !== !1) {
          try {
            var Q = yield* The(q, f);
          } catch (M) {
            throw M.code === "BABEL_UNKNOWN_OPTION" && (0, Bg.checkNoUnwrappedItemOptionPairs)(j, W, "preset", M), M;
          }
          b.push(Q.externalDependencies), q.ownPass ? U.push({
            preset: Q.chain,
            pass: []
          }) : U.unshift({
            preset: Q.chain,
            pass: R
          });
        }
      }
      if (U.length > 0) {
        v.splice(1, 0, ...U.map((W) => W.pass).filter((W) => W !== R));
        for (let {
          preset: W,
          pass: q
        } of U) {
          if (!W || (q.push(...W.plugins), yield* k(W.presets, q))) return !0;
          W.options.forEach((K) => {
            (0, jD.mergeOptions)(l, K);
          });
        }
      }
    }, "recursePresetDescriptors"))(h, v[0])) return null;
    let I = l;
    (0, jD.mergeOptions)(I, i);
    let O = Object.assign({}, f, {
      assumptions: (r = I.assumptions) != null ? r : {}
    });
    return yield* LD(a, /* @__PURE__ */ s(function* () {
      v[0].unshift(...y);
      for (let R of v) {
        let U = [];
        d.push(U);
        for (let Q = 0; Q < R.length; Q++) {
          let W = R[Q];
          if (W.options !== !1) {
            try {
              var j = yield* $D(W, O);
            } catch (q) {
              throw q.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY" && (0, Bg.checkNoUnwrappedItemOptionPairs)(R, Q, "plugin", q), q;
            }
            U.push(j), b.push(j.externalDependencies);
          }
        }
      }
    }, "loadPluginDescriptors"))(), I.plugins = d[0], I.presets = d.slice(1).filter((k) => k.length > 0).map((k) => ({
      plugins: k
    })), I.passPerPreset = I.presets.length > 0, {
      options: I,
      passes: d,
      externalDependencies: (0, kg.finalize)(b)
    };
  }, "loadFullConfig"));
  function LD(e, t) {
    return function* (r, n) {
      try {
        return yield* t(r, n);
      } catch (a) {
        if (!/^\[BABEL\]/.test(a.message)) {
          var i;
          a.message = `[BABEL] ${(i = e.filename) != null ? i : "unknown file"}: ${a.message}`;
        }
        throw a;
      }
    };
  }
  s(LD, "enhanceError");
  var VD = /* @__PURE__ */ s((e) => (0, Fg.makeWeakCache)(function* ({
    value: t,
    options: r,
    dirname: n,
    alias: i
  }, a) {
    if (r === !1) throw new Error("Assertion failure");
    r = r || {};
    let o = [], l = t;
    if (typeof t == "function") {
      let u = (0, Og.maybeAsync)(t, "You appear to be using an async plugin/preset, but Babel has been called synchronously"), c = Object.assign(
      {}, che, e(a, o));
      try {
        l = yield* u(c, r, n);
      } catch (f) {
        throw i && (f.message += ` (While processing: ${JSON.stringify(i)})`), f;
      }
    }
    if (!l || typeof l != "object")
      throw new Error("Plugin/Preset did not return an object.");
    if ((0, Og.isThenable)(l))
      throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you\
're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". \
(While processing: ${JSON.stringify(i)})`);
    if (o.length > 0 && (!a.configured() || a.mode() === "forever")) {
      let u = `A plugin/preset has external untracked dependencies (${o[0]}), but the cache `;
      throw a.configured() ? u += " has been configured to never be invalidated. " : u += "has not been configured to be invalidated when th\
e external dependencies change. ", u += `Plugins/presets should configure their cache to be invalidated when the external dependencies chang\
e, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(i)})`, new Error(u);
    }
    return {
      value: l,
      options: r,
      dirname: n,
      alias: i,
      externalDependencies: (0, kg.finalize)(o)
    };
  }), "makeDescriptorLoader"), yhe = VD(UD.makePluginAPI), ghe = VD(UD.makePresetAPI), bhe = (0, Fg.makeWeakCache)(function* ({
    value: e,
    options: t,
    dirname: r,
    alias: n,
    externalDependencies: i
  }, a) {
    let o = (0, dhe.validatePluginObject)(e), l = Object.assign({}, o);
    if (l.visitor && (l.visitor = Ng().default.explode(Object.assign({}, l.visitor))), l.inherits) {
      let u = {
        name: void 0,
        alias: `${n}$inherits`,
        value: l.inherits,
        options: t,
        dirname: r
      }, c = yield* (0, Og.forwardAsync)($D, (f) => a.invalidate((p) => f(u, p)));
      l.pre = _g(c.pre, l.pre), l.post = _g(c.post, l.post), l.manipulateOptions = _g(c.manipulateOptions, l.manipulateOptions), l.visitor =
      Ng().default.visitors.merge([c.visitor || {}, l.visitor || {}]), c.externalDependencies.length > 0 && (i.length === 0 ? i = c.externalDependencies :
      i = (0, kg.finalize)([i, c.externalDependencies]));
    }
    return new qD.default(l, t, n, i);
  });
  function* $D(e, t) {
    if (e.value instanceof qD.default) {
      if (e.options)
        throw new Error("Passed options to an existing Plugin instance will not work.");
      return e.value;
    }
    return yield* bhe(yield* yhe(e, t), t);
  }
  s($D, "loadPluginDescriptor");
  var Ig = /* @__PURE__ */ s((e) => e && typeof e != "function", "needsFilename"), MD = /* @__PURE__ */ s((e, t) => {
    if (Ig(e.test) || Ig(e.include) || Ig(e.exclude)) {
      let r = t.name ? `"${t.name}"` : "/* your preset */";
      throw new mhe.default([`Preset ${r} requires a filename to be set when babel is called directly,`, "```", `babel.transformSync(code, {\
 filename: 'file.ts', presets: [${r}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join(`
`));
    }
  }, "validateIfOptionNeedsFilename"), Ehe = /* @__PURE__ */ s((e, t, r) => {
    if (!t.filename) {
      var n;
      let {
        options: i
      } = e;
      MD(i, r), (n = i.overrides) == null || n.forEach((a) => MD(a, r));
    }
  }, "validatePreset"), vhe = (0, Fg.makeWeakCacheSync)(({
    value: e,
    dirname: t,
    alias: r,
    externalDependencies: n
  }) => ({
    options: (0, Bg.validate)("preset", e),
    alias: r,
    dirname: t,
    externalDependencies: n
  }));
  function* The(e, t) {
    let r = vhe(yield* ghe(e, t));
    return Ehe(r, t, e), {
      chain: yield* (0, phe.buildPresetChain)(r, t),
      externalDependencies: r.externalDependencies
    };
  }
  s(The, "loadPresetDescriptor");
  function _g(e, t) {
    let r = [e, t].filter(Boolean);
    return r.length <= 1 ? r[0] : function(...n) {
      for (let i of r)
        i.apply(this, n);
    };
  }
  s(_g, "chain");
});

// ../node_modules/@babel/core/lib/config/index.js
var la = T((Mr) => {
  "use strict";
  Object.defineProperty(Mr, "__esModule", {
    value: !0
  });
  Mr.createConfigItem = _he;
  Mr.createConfigItemAsync = Ihe;
  Mr.createConfigItemSync = YD;
  Object.defineProperty(Mr, "default", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return KD.default;
    }, "get")
  });
  Mr.loadOptions = Dhe;
  Mr.loadOptionsAsync = whe;
  Mr.loadOptionsSync = HD;
  Mr.loadPartialConfig = Ahe;
  Mr.loadPartialConfigAsync = Phe;
  Mr.loadPartialConfigSync = GD;
  function af() {
    let e = vr();
    return af = /* @__PURE__ */ s(function() {
      return e;
    }, "_gensync"), e;
  }
  s(af, "_gensync");
  var KD = WD(), xhe = Dg(), She = jo(), Lr = Fn(), rf = af()(xhe.loadPartialConfig);
  function Phe(...e) {
    return (0, Lr.beginHiddenCallStack)(rf.async)(...e);
  }
  s(Phe, "loadPartialConfigAsync");
  function GD(...e) {
    return (0, Lr.beginHiddenCallStack)(rf.sync)(...e);
  }
  s(GD, "loadPartialConfigSync");
  function Ahe(e, t) {
    if (t !== void 0)
      (0, Lr.beginHiddenCallStack)(rf.errback)(e, t);
    else if (typeof e == "function")
      (0, Lr.beginHiddenCallStack)(rf.errback)(void 0, e);
    else
      return GD(e);
  }
  s(Ahe, "loadPartialConfig");
  function* Che(e) {
    var t;
    let r = yield* (0, KD.default)(e);
    return (t = r?.options) != null ? t : null;
  }
  s(Che, "loadOptionsImpl");
  var nf = af()(Che);
  function whe(...e) {
    return (0, Lr.beginHiddenCallStack)(nf.async)(...e);
  }
  s(whe, "loadOptionsAsync");
  function HD(...e) {
    return (0, Lr.beginHiddenCallStack)(nf.sync)(...e);
  }
  s(HD, "loadOptionsSync");
  function Dhe(e, t) {
    if (t !== void 0)
      (0, Lr.beginHiddenCallStack)(nf.errback)(e, t);
    else if (typeof e == "function")
      (0, Lr.beginHiddenCallStack)(nf.errback)(void 0, e);
    else
      return HD(e);
  }
  s(Dhe, "loadOptions");
  var sf = af()(She.createConfigItem);
  function Ihe(...e) {
    return (0, Lr.beginHiddenCallStack)(sf.async)(...e);
  }
  s(Ihe, "createConfigItemAsync");
  function YD(...e) {
    return (0, Lr.beginHiddenCallStack)(sf.sync)(...e);
  }
  s(YD, "createConfigItemSync");
  function _he(e, t, r) {
    if (r !== void 0)
      (0, Lr.beginHiddenCallStack)(sf.errback)(e, t, r);
    else if (typeof t == "function")
      (0, Lr.beginHiddenCallStack)(sf.errback)(e, void 0, r);
    else
      return YD(e, t);
  }
  s(_he, "createConfigItem");
});

// ../node_modules/@babel/core/lib/transformation/plugin-pass.js
var zD = T((of) => {
  "use strict";
  Object.defineProperty(of, "__esModule", {
    value: !0
  });
  of.default = void 0;
  var Wo = class {
    static {
      s(this, "PluginPass");
    }
    constructor(t, r, n) {
      this._map = /* @__PURE__ */ new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0,
      this.key = r, this.file = t, this.opts = n || {}, this.cwd = t.opts.cwd, this.filename = t.opts.filename;
    }
    set(t, r) {
      this._map.set(t, r);
    }
    get(t) {
      return this._map.get(t);
    }
    availableHelper(t, r) {
      return this.file.availableHelper(t, r);
    }
    addHelper(t) {
      return this.file.addHelper(t);
    }
    buildCodeFrameError(t, r, n) {
      return this.file.buildCodeFrameError(t, r, n);
    }
  };
  of.default = Wo;
  Wo.prototype.getModuleName = /* @__PURE__ */ s(function() {
    return this.file.getModuleName();
  }, "getModuleName"), Wo.prototype.addImport = /* @__PURE__ */ s(function() {
    this.file.addImport();
  }, "addImport");
});

// ../node_modules/@babel/core/lib/transformation/block-hoist-plugin.js
var eI = T((Lg) => {
  "use strict";
  Object.defineProperty(Lg, "__esModule", {
    value: !0
  });
  Lg.default = Nhe;
  function QD() {
    let e = _r();
    return QD = /* @__PURE__ */ s(function() {
      return e;
    }, "_traverse"), e;
  }
  s(QD, "_traverse");
  var Ohe = Tc(), jg, JD = {
    name: "internal.blockHoist",
    visitor: {
      Block: {
        exit({
          node: e
        }) {
          e.body = XD(e.body);
        }
      },
      SwitchCase: {
        exit({
          node: e
        }) {
          e.consequent = XD(e.consequent);
        }
      }
    }
  };
  function XD(e) {
    let t = Math.pow(2, 30) - 1, r = !1;
    for (let n = 0; n < e.length; n++) {
      let i = e[n], a = ZD(i);
      if (a > t) {
        r = !0;
        break;
      }
      t = a;
    }
    return r ? Bhe(e.slice()) : e;
  }
  s(XD, "performHoisting");
  function Nhe() {
    return jg || (jg = new Ohe.default(Object.assign({}, JD, {
      visitor: QD().default.explode(JD.visitor)
    }), {})), jg;
  }
  s(Nhe, "loadBlockHoistPlugin");
  function ZD(e) {
    let t = e?._blockHoist;
    return t == null ? 1 : t === !0 ? 2 : t;
  }
  s(ZD, "priority");
  function Bhe(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i = 0; i < e.length; i++) {
      let a = e[i], o = ZD(a);
      (t[o] || (t[o] = [])).push(a);
    }
    let r = Object.keys(t).map((i) => +i).sort((i, a) => a - i), n = 0;
    for (let i of r) {
      let a = t[i];
      for (let o of a)
        e[n++] = o;
    }
    return e;
  }
  s(Bhe, "stableSort");
});

// ../node_modules/@babel/core/lib/transformation/normalize-opts.js
var Rg = T((Mg) => {
  "use strict";
  Object.defineProperty(Mg, "__esModule", {
    value: !0
  });
  Mg.default = khe;
  function lf() {
    let e = ie("path");
    return lf = /* @__PURE__ */ s(function() {
      return e;
    }, "_path"), e;
  }
  s(lf, "_path");
  function khe(e) {
    let {
      filename: t,
      cwd: r,
      filenameRelative: n = typeof t == "string" ? lf().relative(r, t) : "unknown",
      sourceType: i = "module",
      inputSourceMap: a,
      sourceMaps: o = !!a,
      sourceRoot: l = e.options.moduleRoot,
      sourceFileName: u = lf().basename(n),
      comments: c = !0,
      compact: f = "auto"
    } = e.options, p = e.options, h = Object.assign({}, p, {
      parserOpts: Object.assign({
        sourceType: lf().extname(n) === ".mjs" ? "module" : i,
        sourceFileName: t,
        plugins: []
      }, p.parserOpts),
      generatorOpts: Object.assign({
        filename: t,
        auxiliaryCommentBefore: p.auxiliaryCommentBefore,
        auxiliaryCommentAfter: p.auxiliaryCommentAfter,
        retainLines: p.retainLines,
        comments: c,
        shouldPrintComment: p.shouldPrintComment,
        compact: f,
        minified: p.minified,
        sourceMaps: o,
        sourceRoot: l,
        sourceFileName: u
      }, p.generatorOpts)
    });
    for (let y of e.passes)
      for (let v of y)
        v.manipulateOptions && v.manipulateOptions(h, h.parserOpts);
    return h;
  }
  s(khe, "normalizeOptions");
});

// ../node_modules/convert-source-map/index.js
var qg = T((At) => {
  "use strict";
  Object.defineProperty(At, "commentRegex", {
    get: /* @__PURE__ */ s(function() {
      return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;
    }, "getCommentRegex")
  });
  Object.defineProperty(At, "mapFileCommentRegex", {
    get: /* @__PURE__ */ s(function() {
      return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg;
    }, "getMapFileCommentRegex")
  });
  var uf;
  typeof Buffer < "u" ? typeof Buffer.from == "function" ? uf = Fhe : uf = jhe : uf = Lhe;
  function Fhe(e) {
    return Buffer.from(e, "base64").toString();
  }
  s(Fhe, "decodeBase64WithBufferFrom");
  function jhe(e) {
    if (typeof value == "number")
      throw new TypeError("The value to decode must not be of type number.");
    return new Buffer(e, "base64").toString();
  }
  s(jhe, "decodeBase64WithNewBuffer");
  function Lhe(e) {
    return decodeURIComponent(escape(atob(e)));
  }
  s(Lhe, "decodeBase64WithAtob");
  function Mhe(e) {
    return e.split(",").pop();
  }
  s(Mhe, "stripComment");
  function Rhe(e, t) {
    var r = At.mapFileCommentRegex.exec(e), n = r[1] || r[2];
    try {
      var e = t(n);
      return e != null && typeof e.catch == "function" ? e.catch(i) : e;
    } catch (a) {
      i(a);
    }
    function i(a) {
      throw new Error("An error occurred while trying to read the map file at " + n + `
` + a.stack);
    }
    s(i, "throwError");
  }
  s(Rhe, "readFromFileMap");
  function Xt(e, t) {
    t = t || {}, t.hasComment && (e = Mhe(e)), t.encoding === "base64" ? e = uf(e) : t.encoding === "uri" && (e = decodeURIComponent(e)), (t.
    isJSON || t.encoding) && (e = JSON.parse(e)), this.sourcemap = e;
  }
  s(Xt, "Converter");
  Xt.prototype.toJSON = function(e) {
    return JSON.stringify(this.sourcemap, null, e);
  };
  typeof Buffer < "u" ? typeof Buffer.from == "function" ? Xt.prototype.toBase64 = qhe : Xt.prototype.toBase64 = Uhe : Xt.prototype.toBase64 =
  Vhe;
  function qhe() {
    var e = this.toJSON();
    return Buffer.from(e, "utf8").toString("base64");
  }
  s(qhe, "encodeBase64WithBufferFrom");
  function Uhe() {
    var e = this.toJSON();
    if (typeof e == "number")
      throw new TypeError("The json to encode must not be of type number.");
    return new Buffer(e, "utf8").toString("base64");
  }
  s(Uhe, "encodeBase64WithNewBuffer");
  function Vhe() {
    var e = this.toJSON();
    return btoa(unescape(encodeURIComponent(e)));
  }
  s(Vhe, "encodeBase64WithBtoa");
  Xt.prototype.toURI = function() {
    var e = this.toJSON();
    return encodeURIComponent(e);
  };
  Xt.prototype.toComment = function(e) {
    var t, r, n;
    return e != null && e.encoding === "uri" ? (t = "", r = this.toURI()) : (t = ";base64", r = this.toBase64()), n = "sourceMappingURL=data\
:application/json;charset=utf-8" + t + "," + r, e != null && e.multiline ? "/*# " + n + " */" : "//# " + n;
  };
  Xt.prototype.toObject = function() {
    return JSON.parse(this.toJSON());
  };
  Xt.prototype.addProperty = function(e, t) {
    if (this.sourcemap.hasOwnProperty(e)) throw new Error('property "' + e + '" already exists on the sourcemap, use set property instead');
    return this.setProperty(e, t);
  };
  Xt.prototype.setProperty = function(e, t) {
    return this.sourcemap[e] = t, this;
  };
  Xt.prototype.getProperty = function(e) {
    return this.sourcemap[e];
  };
  At.fromObject = function(e) {
    return new Xt(e);
  };
  At.fromJSON = function(e) {
    return new Xt(e, { isJSON: !0 });
  };
  At.fromURI = function(e) {
    return new Xt(e, { encoding: "uri" });
  };
  At.fromBase64 = function(e) {
    return new Xt(e, { encoding: "base64" });
  };
  At.fromComment = function(e) {
    var t, r;
    return e = e.replace(/^\/\*/g, "//").replace(/\*\/$/g, ""), t = At.commentRegex.exec(e), r = t && t[4] || "uri", new Xt(e, { encoding: r,
    hasComment: !0 });
  };
  function tI(e) {
    return new Xt(e, { isJSON: !0 });
  }
  s(tI, "makeConverter");
  At.fromMapFileComment = function(e, t) {
    if (typeof t == "string")
      throw new Error(
        "String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://githu\
b.com/thlorenz/convert-source-map#upgrading"
      );
    var r = Rhe(e, t);
    return r != null && typeof r.then == "function" ? r.then(tI) : tI(r);
  };
  At.fromSource = function(e) {
    var t = e.match(At.commentRegex);
    return t ? At.fromComment(t.pop()) : null;
  };
  At.fromMapFileSource = function(e, t) {
    if (typeof t == "string")
      throw new Error(
        "String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github\
.com/thlorenz/convert-source-map#upgrading"
      );
    var r = e.match(At.mapFileCommentRegex);
    return r ? At.fromMapFileComment(r.pop(), t) : null;
  };
  At.removeComments = function(e) {
    return e.replace(At.commentRegex, "");
  };
  At.removeMapFileComments = function(e) {
    return e.replace(At.mapFileCommentRegex, "");
  };
  At.generateMapFileComment = function(e, t) {
    var r = "sourceMappingURL=" + e;
    return t && t.multiline ? "/*# " + r + " */" : "//# " + r;
  };
});

// ../node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js
var sI = T((Ug) => {
  "use strict";
  Object.defineProperty(Ug, "__esModule", {
    value: !0
  });
  Ug.default = $he;
  var nI = {
    asyncDoExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-async-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions"
      }
    },
    decimal: {
      syntax: {
        name: "@babel/plugin-syntax-decimal",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal"
      }
    },
    decorators: {
      syntax: {
        name: "@babel/plugin-syntax-decorators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators"
      },
      transform: {
        name: "@babel/plugin-proposal-decorators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators"
      }
    },
    doExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions"
      },
      transform: {
        name: "@babel/plugin-proposal-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions"
      }
    },
    exportDefaultFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-default-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from"
      },
      transform: {
        name: "@babel/plugin-proposal-export-default-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from"
      }
    },
    flow: {
      syntax: {
        name: "@babel/plugin-syntax-flow",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow"
      },
      transform: {
        name: "@babel/preset-flow",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow"
      }
    },
    functionBind: {
      syntax: {
        name: "@babel/plugin-syntax-function-bind",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind"
      },
      transform: {
        name: "@babel/plugin-proposal-function-bind",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind"
      }
    },
    functionSent: {
      syntax: {
        name: "@babel/plugin-syntax-function-sent",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent"
      },
      transform: {
        name: "@babel/plugin-proposal-function-sent",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent"
      }
    },
    jsx: {
      syntax: {
        name: "@babel/plugin-syntax-jsx",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx"
      },
      transform: {
        name: "@babel/preset-react",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react"
      }
    },
    importAttributes: {
      syntax: {
        name: "@babel/plugin-syntax-import-attributes",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes"
      }
    },
    pipelineOperator: {
      syntax: {
        name: "@babel/plugin-syntax-pipeline-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator"
      },
      transform: {
        name: "@babel/plugin-proposal-pipeline-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator"
      }
    },
    recordAndTuple: {
      syntax: {
        name: "@babel/plugin-syntax-record-and-tuple",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple"
      }
    },
    throwExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-throw-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions"
      },
      transform: {
        name: "@babel/plugin-proposal-throw-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions"
      }
    },
    typescript: {
      syntax: {
        name: "@babel/plugin-syntax-typescript",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript"
      },
      transform: {
        name: "@babel/preset-typescript",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript"
      }
    }
  };
  Object.assign(nI, {
    asyncGenerators: {
      syntax: {
        name: "@babel/plugin-syntax-async-generators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators"
      },
      transform: {
        name: "@babel/plugin-transform-async-generator-functions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions"
      }
    },
    classProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-transform-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
      }
    },
    classPrivateProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-transform-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
      }
    },
    classPrivateMethods: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-transform-private-methods",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods"
      }
    },
    classStaticBlock: {
      syntax: {
        name: "@babel/plugin-syntax-class-static-block",
        url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block"
      },
      transform: {
        name: "@babel/plugin-transform-class-static-block",
        url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block"
      }
    },
    dynamicImport: {
      syntax: {
        name: "@babel/plugin-syntax-dynamic-import",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import"
      }
    },
    exportNamespaceFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-namespace-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from"
      },
      transform: {
        name: "@babel/plugin-transform-export-namespace-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from"
      }
    },
    importAssertions: {
      syntax: {
        name: "@babel/plugin-syntax-import-assertions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions"
      }
    },
    importMeta: {
      syntax: {
        name: "@babel/plugin-syntax-import-meta",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta"
      }
    },
    logicalAssignment: {
      syntax: {
        name: "@babel/plugin-syntax-logical-assignment-operators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators"
      },
      transform: {
        name: "@babel/plugin-transform-logical-assignment-operators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators"
      }
    },
    moduleStringNames: {
      syntax: {
        name: "@babel/plugin-syntax-module-string-names",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names"
      }
    },
    numericSeparator: {
      syntax: {
        name: "@babel/plugin-syntax-numeric-separator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator"
      },
      transform: {
        name: "@babel/plugin-transform-numeric-separator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator"
      }
    },
    nullishCoalescingOperator: {
      syntax: {
        name: "@babel/plugin-syntax-nullish-coalescing-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator"
      },
      transform: {
        name: "@babel/plugin-transform-nullish-coalescing-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator"
      }
    },
    objectRestSpread: {
      syntax: {
        name: "@babel/plugin-syntax-object-rest-spread",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread"
      },
      transform: {
        name: "@babel/plugin-transform-object-rest-spread",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread"
      }
    },
    optionalCatchBinding: {
      syntax: {
        name: "@babel/plugin-syntax-optional-catch-binding",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding"
      },
      transform: {
        name: "@babel/plugin-transform-optional-catch-binding",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding"
      }
    },
    optionalChaining: {
      syntax: {
        name: "@babel/plugin-syntax-optional-chaining",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining"
      },
      transform: {
        name: "@babel/plugin-transform-optional-chaining",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining"
      }
    },
    privateIn: {
      syntax: {
        name: "@babel/plugin-syntax-private-property-in-object",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object"
      },
      transform: {
        name: "@babel/plugin-transform-private-property-in-object",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object"
      }
    },
    regexpUnicodeSets: {
      syntax: {
        name: "@babel/plugin-syntax-unicode-sets-regex",
        url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md"
      },
      transform: {
        name: "@babel/plugin-transform-unicode-sets-regex",
        url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md"
      }
    }
  });
  var rI = /* @__PURE__ */ s(({
    name: e,
    url: t
  }) => `${e} (${t})`, "getNameURLCombination");
  function $he(e, t, r, n) {
    let i = `Support for the experimental syntax '${e}' isn't currently enabled (${t.line}:${t.column + 1}):

` + r, a = nI[e];
    if (a) {
      let {
        syntax: l,
        transform: u
      } = a;
      if (l) {
        let c = rI(l);
        if (u) {
          let f = rI(u), p = u.name.startsWith("@babel/plugin") ? "plugins" : "presets";
          i += `

Add ${f} to the '${p}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${c} to the 'plugins' section to enable parsing.`;
        } else
          i += `

Add ${c} to the 'plugins' section of your Babel config to enable parsing.`;
      }
    }
    return i += `

If you already added the plugin for this syntax to your config, it's possible that your config isn't being loaded.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${n === "unknown" ? "<name of the input file>" : n} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.
`, i;
  }
  s($he, "generateMissingPluginMessage");
});

// ../node_modules/@babel/core/lib/parser/index.js
var Wg = T(($g) => {
  "use strict";
  Object.defineProperty($g, "__esModule", {
    value: !0
  });
  $g.default = Khe;
  function Vg() {
    let e = Ls();
    return Vg = /* @__PURE__ */ s(function() {
      return e;
    }, "_parser"), e;
  }
  s(Vg, "_parser");
  function iI() {
    let e = to();
    return iI = /* @__PURE__ */ s(function() {
      return e;
    }, "_codeFrame"), e;
  }
  s(iI, "_codeFrame");
  var Whe = sI();
  function* Khe(e, {
    parserOpts: t,
    highlightCode: r = !0,
    filename: n = "unknown"
  }, i) {
    try {
      let a = [];
      for (let o of e)
        for (let l of o) {
          let {
            parserOverride: u
          } = l;
          if (u) {
            let c = u(i, t, Vg().parse);
            c !== void 0 && a.push(c);
          }
        }
      if (a.length === 0)
        return (0, Vg().parse)(i, t);
      if (a.length === 1) {
        if (yield* [], typeof a[0].then == "function")
          throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're us\
ing a published plugin, you may need to upgrade your @babel/core version.");
        return a[0];
      }
      throw new Error("More than one plugin attempted to override parsing.");
    } catch (a) {
      a.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" && (a.message += `
Consider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.`);
      let {
        loc: o,
        missingPlugin: l
      } = a;
      if (o) {
        let u = (0, iI().codeFrameColumns)(i, {
          start: {
            line: o.line,
            column: o.column + 1
          }
        }, {
          highlightCode: r
        });
        l ? a.message = `${n}: ` + (0, Whe.default)(l[0], o, u, n) : a.message = `${n}: ${a.message}

` + u, a.code = "BABEL_PARSE_ERROR";
      }
      throw a;
    }
  }
  s(Khe, "parser");
});

// ../node_modules/@babel/core/lib/transformation/util/clone-deep.js
var aI = T((Gg) => {
  "use strict";
  Object.defineProperty(Gg, "__esModule", {
    value: !0
  });
  Gg.default = Ghe;
  function Kg(e, t) {
    if (e !== null) {
      if (t.has(e)) return t.get(e);
      let r;
      if (Array.isArray(e)) {
        r = new Array(e.length), t.set(e, r);
        for (let n = 0; n < e.length; n++)
          r[n] = typeof e[n] != "object" ? e[n] : Kg(e[n], t);
      } else {
        r = {}, t.set(e, r);
        let n = Object.keys(e);
        for (let i = 0; i < n.length; i++) {
          let a = n[i];
          r[a] = typeof e[a] != "object" ? e[a] : Kg(e[a], t);
        }
      }
      return r;
    }
    return e;
  }
  s(Kg, "deepClone");
  function Ghe(e) {
    return typeof e != "object" ? e : Kg(e, /* @__PURE__ */ new Map());
  }
  s(Ghe, "_default");
});

// ../node_modules/@babel/core/lib/transformation/normalize-file.js
var pI = T((Jg) => {
  "use strict";
  Object.defineProperty(Jg, "__esModule", {
    value: !0
  });
  Jg.default = Zhe;
  function uI() {
    let e = ie("fs");
    return uI = /* @__PURE__ */ s(function() {
      return e;
    }, "_fs"), e;
  }
  s(uI, "_fs");
  function zg() {
    let e = ie("path");
    return zg = /* @__PURE__ */ s(function() {
      return e;
    }, "_path"), e;
  }
  s(zg, "_path");
  function cI() {
    let e = qs();
    return cI = /* @__PURE__ */ s(function() {
      return e;
    }, "_debug"), e;
  }
  s(cI, "_debug");
  function fI() {
    let e = Pe();
    return fI = /* @__PURE__ */ s(function() {
      return e;
    }, "_t"), e;
  }
  s(fI, "_t");
  function cf() {
    let e = qg();
    return cf = /* @__PURE__ */ s(function() {
      return e;
    }, "_convertSourceMap"), e;
  }
  s(cf, "_convertSourceMap");
  var Hhe = Qy(), Yhe = Wg(), zhe = aI(), {
    file: Jhe,
    traverseFast: Xhe
  } = fI(), Hg = cI()("babel:transform:file"), Qhe = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,.*$/,
  oI = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
  function* Zhe(e, t, r, n) {
    if (r = `${r || ""}`, n) {
      if (n.type === "Program")
        n = Jhe(n, [], []);
      else if (n.type !== "File")
        throw new Error("AST root must be a Program or File node");
      t.cloneInputAst && (n = (0, zhe.default)(n));
    } else
      n = yield* (0, Yhe.default)(e, t, r);
    let i = null;
    if (t.inputSourceMap !== !1) {
      if (typeof t.inputSourceMap == "object" && (i = cf().fromObject(t.inputSourceMap)), !i) {
        let a = lI(Qhe, n);
        if (a)
          try {
            i = cf().fromComment("//" + a);
          } catch {
            Hg("discarding unknown inline input sourcemap");
          }
      }
      if (!i) {
        let a = lI(oI, n);
        if (typeof t.filename == "string" && a)
          try {
            let o = oI.exec(a), l = uI().readFileSync(zg().resolve(zg().dirname(t.filename), o[1]), "utf8");
            i = cf().fromJSON(l);
          } catch (o) {
            Hg("discarding unknown file input sourcemap", o);
          }
        else a && Hg("discarding un-loadable file input sourcemap");
      }
    }
    return new Hhe.default(t, {
      code: r,
      ast: n,
      inputMap: i
    });
  }
  s(Zhe, "normalizeFile");
  function Yg(e, t, r) {
    return t && (t = t.filter(({
      value: n
    }) => e.test(n) ? (r = n, !1) : !0)), [t, r];
  }
  s(Yg, "extractCommentsFromList");
  function lI(e, t) {
    let r = null;
    return Xhe(t, (n) => {
      [n.leadingComments, r] = Yg(e, n.leadingComments, r), [n.innerComments, r] = Yg(e, n.innerComments, r), [n.trailingComments, r] = Yg(e,
      n.trailingComments, r);
    }), r;
  }
  s(lI, "extractComments");
});

// ../node_modules/@ampproject/remapping/dist/remapping.umd.js
var dI = T((Xg, Qg) => {
  (function(e, t) {
    typeof Xg == "object" && typeof Qg < "u" ? Qg.exports = t(bu(), Am()) : typeof define == "function" && define.amd ? define(["@jridgewell\
/trace-mapping", "@jridgewell/gen-mapping"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, e.remapping = t(e.traceMapping, e.genMapping));
  })(Xg, function(e, t) {
    "use strict";
    let r = /* @__PURE__ */ i("", -1, -1, "", null, !1), n = [];
    function i(d, b, E, I, O, k) {
      return { source: d, line: b, column: E, name: I, content: O, ignore: k };
    }
    s(i, "SegmentObject");
    function a(d, b, E, I, O) {
      return {
        map: d,
        sources: b,
        source: E,
        content: I,
        ignore: O
      };
    }
    s(a, "Source");
    function o(d, b) {
      return a(d, b, "", null, !1);
    }
    s(o, "MapSource");
    function l(d, b, E) {
      return a(null, n, d, b, E);
    }
    s(l, "OriginalSource");
    function u(d) {
      let b = new t.GenMapping({ file: d.map.file }), { sources: E, map: I } = d, O = I.names, k = e.decodedMappings(I);
      for (let j = 0; j < k.length; j++) {
        let R = k[j];
        for (let U = 0; U < R.length; U++) {
          let Q = R[U], W = Q[0], q = r;
          if (Q.length !== 1) {
            let ne = E[Q[1]];
            if (q = c(ne, Q[2], Q[3], Q.length === 5 ? O[Q[4]] : ""), q == null)
              continue;
          }
          let { column: M, line: K, name: pe, content: ae, source: X, ignore: J } = q;
          t.maybeAddSegment(b, j, W, X, K, M, pe), X && ae != null && t.setSourceContent(b, X, ae), J && t.setIgnore(b, X, !0);
        }
      }
      return b;
    }
    s(u, "traceMappings");
    function c(d, b, E, I) {
      if (!d.map)
        return i(d.source, b, E, I, d.content, d.ignore);
      let O = e.traceSegment(d.map, b, E);
      return O == null ? null : O.length === 1 ? r : c(d.sources[O[1]], O[2], O[3], O.length === 5 ? d.map.names[O[4]] : I);
    }
    s(c, "originalPositionFor");
    function f(d) {
      return Array.isArray(d) ? d : [d];
    }
    s(f, "asArray");
    function p(d, b) {
      let E = f(d).map((k) => new e.TraceMap(k, "")), I = E.pop();
      for (let k = 0; k < E.length; k++)
        if (E[k].sources.length > 1)
          throw new Error(`Transformation map ${k} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
      let O = h(I, b, "", 0);
      for (let k = E.length - 1; k >= 0; k--)
        O = o(E[k], [O]);
      return O;
    }
    s(p, "buildSourceMapTree");
    function h(d, b, E, I) {
      let { resolvedSources: O, sourcesContent: k, ignoreList: j } = d, R = I + 1, U = O.map((Q, W) => {
        let q = {
          importer: E,
          depth: R,
          source: Q || "",
          content: void 0,
          ignore: void 0
        }, M = b(q.source, q), { source: K, content: pe, ignore: ae } = q;
        if (M)
          return h(new e.TraceMap(M, K), b, K, R);
        let X = pe !== void 0 ? pe : k ? k[W] : null, J = ae !== void 0 ? ae : j ? j.includes(W) : !1;
        return l(K, X, J);
      });
      return o(d, U);
    }
    s(h, "build");
    class y {
      static {
        s(this, "SourceMap");
      }
      constructor(b, E) {
        let I = E.decodedMappings ? t.toDecodedMap(b) : t.toEncodedMap(b);
        this.version = I.version, this.file = I.file, this.mappings = I.mappings, this.names = I.names, this.ignoreList = I.ignoreList, this.
        sourceRoot = I.sourceRoot, this.sources = I.sources, E.excludeContent || (this.sourcesContent = I.sourcesContent);
      }
      toString() {
        return JSON.stringify(this);
      }
    }
    function v(d, b, E) {
      let I = typeof E == "object" ? E : { excludeContent: !!E, decodedMappings: !1 }, O = p(d, b);
      return new y(u(O), I);
    }
    return s(v, "remapping"), v;
  });
});

// ../node_modules/@babel/core/lib/transformation/file/merge-map.js
var yI = T((Zg) => {
  "use strict";
  Object.defineProperty(Zg, "__esModule", {
    value: !0
  });
  Zg.default = eme;
  function mI() {
    let e = dI();
    return mI = /* @__PURE__ */ s(function() {
      return e;
    }, "_remapping"), e;
  }
  s(mI, "_remapping");
  function eme(e, t, r) {
    let n = r.replace(/\\/g, "/"), i = !1, a = mI()(hI(t), (o, l) => o === n && !i ? (i = !0, l.source = "", hI(e)) : null);
    return typeof e.sourceRoot == "string" && (a.sourceRoot = e.sourceRoot), Object.assign({}, a);
  }
  s(eme, "mergeSourceMap");
  function hI(e) {
    return Object.assign({}, e, {
      sourceRoot: null
    });
  }
  s(hI, "rootless");
});

// ../node_modules/@babel/core/lib/transformation/file/generate.js
var bI = T((tb) => {
  "use strict";
  Object.defineProperty(tb, "__esModule", {
    value: !0
  });
  tb.default = rme;
  function gI() {
    let e = qg();
    return gI = /* @__PURE__ */ s(function() {
      return e;
    }, "_convertSourceMap"), e;
  }
  s(gI, "_convertSourceMap");
  function eb() {
    let e = fo();
    return eb = /* @__PURE__ */ s(function() {
      return e;
    }, "_generator"), e;
  }
  s(eb, "_generator");
  var tme = yI();
  function rme(e, t) {
    let {
      opts: r,
      ast: n,
      code: i,
      inputMap: a
    } = t, {
      generatorOpts: o
    } = r;
    o.inputSourceMap = a?.toObject();
    let l = [];
    for (let p of e)
      for (let h of p) {
        let {
          generatorOverride: y
        } = h;
        if (y) {
          let v = y(n, o, i, eb().default);
          v !== void 0 && l.push(v);
        }
      }
    let u;
    if (l.length === 0)
      u = (0, eb().default)(n, o, i);
    else if (l.length === 1) {
      if (u = l[0], typeof u.then == "function")
        throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're usi\
ng a published plugin, you may need to upgrade your @babel/core version.");
    } else
      throw new Error("More than one plugin attempted to override codegen.");
    let {
      code: c,
      decodedMap: f = u.map
    } = u;
    return u.__mergedMap ? f = Object.assign({}, u.map) : f && (a ? f = (0, tme.default)(a.toObject(), f, o.sourceFileName) : f = u.map), (r.
    sourceMaps === "inline" || r.sourceMaps === "both") && (c += `
` + gI().fromObject(f).toComment()), r.sourceMaps === "inline" && (f = null), {
      outputCode: c,
      outputMap: f
    };
  }
  s(rme, "generateCode");
});

// ../node_modules/@babel/core/lib/transformation/index.js
var ff = T((nb) => {
  "use strict";
  Object.defineProperty(nb, "__esModule", {
    value: !0
  });
  nb.run = ume;
  function rb() {
    let e = _r();
    return rb = /* @__PURE__ */ s(function() {
      return e;
    }, "_traverse"), e;
  }
  s(rb, "_traverse");
  var nme = zD(), sme = eI(), ime = Rg(), ame = pI(), ome = bI(), lme = Ec();
  function* ume(e, t, r) {
    let n = yield* (0, ame.default)(e.passes, (0, ime.default)(e), t, r), i = n.opts;
    try {
      yield* cme(n, e.passes);
    } catch (c) {
      var a;
      throw c.message = `${(a = i.filename) != null ? a : "unknown file"}: ${c.message}`, c.code || (c.code = "BABEL_TRANSFORM_ERROR"), c;
    }
    let o, l;
    try {
      i.code !== !1 && ({
        outputCode: o,
        outputMap: l
      } = (0, ome.default)(e.passes, n));
    } catch (c) {
      var u;
      throw c.message = `${(u = i.filename) != null ? u : "unknown file"}: ${c.message}`, c.code || (c.code = "BABEL_GENERATE_ERROR"), c;
    }
    return {
      metadata: n.metadata,
      options: i,
      ast: i.ast === !0 ? n.ast : null,
      code: o === void 0 ? null : o,
      map: l === void 0 ? null : l,
      sourceType: n.ast.program.sourceType,
      externalDependencies: (0, lme.flattenToSet)(e.externalDependencies)
    };
  }
  s(ume, "run");
  function* cme(e, t) {
    for (let r of t) {
      let n = [], i = [], a = [];
      for (let l of r.concat([(0, sme.default)()])) {
        let u = new nme.default(e, l.key, l.options);
        n.push([l, u]), i.push(u), a.push(l.visitor);
      }
      for (let [l, u] of n) {
        let c = l.pre;
        if (c) {
          let f = c.call(u, e);
          if (yield* [], EI(f))
            throw new Error("You appear to be using an plugin with an async .pre, which your current version of Babel does not support. If y\
ou're using a published plugin, you may need to upgrade your @babel/core version.");
        }
      }
      let o = rb().default.visitors.merge(a, i, e.opts.wrapPluginVisitorMethod);
      (0, rb().default)(e.ast, o, e.scope);
      for (let [l, u] of n) {
        let c = l.post;
        if (c) {
          let f = c.call(u, e);
          if (yield* [], EI(f))
            throw new Error("You appear to be using an plugin with an async .post, which your current version of Babel does not support. If \
you're using a published plugin, you may need to upgrade your @babel/core version.");
        }
      }
    }
  }
  s(cme, "transformFile");
  function EI(e) {
    return !!e && (typeof e == "object" || typeof e == "function") && !!e.then && typeof e.then == "function";
  }
  s(EI, "isThenable");
});

// ../node_modules/@babel/core/lib/transform-file.js
var ib = T((Ko) => {
  "use strict";
  Object.defineProperty(Ko, "__esModule", {
    value: !0
  });
  Ko.transformFile = hme;
  Ko.transformFileAsync = yme;
  Ko.transformFileSync = mme;
  function vI() {
    let e = vr();
    return vI = /* @__PURE__ */ s(function() {
      return e;
    }, "_gensync"), e;
  }
  s(vI, "_gensync");
  var fme = la(), pme = ff(), dme = uc(), sb = vI()(function* (e, t) {
    let r = Object.assign({}, t, {
      filename: e
    }), n = yield* (0, fme.default)(r);
    if (n === null) return null;
    let i = yield* dme.readFile(e, "utf8");
    return yield* (0, pme.run)(n, i);
  });
  function hme(...e) {
    sb.errback(...e);
  }
  s(hme, "transformFile");
  function mme(...e) {
    return sb.sync(...e);
  }
  s(mme, "transformFileSync");
  function yme(...e) {
    return sb.async(...e);
  }
  s(yme, "transformFileAsync");
});

// ../node_modules/@babel/core/lib/config/files/import.cjs
var xI = T((mIe, TI) => {
  TI.exports = /* @__PURE__ */ s(function(t) {
    return import(t);
  }, "import_");
});

// ../node_modules/@babel/preset-typescript/package.json
var SI = T((gIe, gme) => {
  gme.exports = {
    name: "@babel/preset-typescript",
    version: "7.24.1",
    description: "Babel preset for TypeScript.",
    repository: {
      type: "git",
      url: "https://github.com/babel/babel.git",
      directory: "packages/babel-preset-typescript"
    },
    license: "MIT",
    publishConfig: {
      access: "public"
    },
    main: "./lib/index.js",
    keywords: [
      "babel-preset",
      "typescript"
    ],
    dependencies: {
      "@babel/helper-plugin-utils": "^7.24.0",
      "@babel/helper-validator-option": "^7.23.5",
      "@babel/plugin-syntax-jsx": "^7.24.1",
      "@babel/plugin-transform-modules-commonjs": "^7.24.1",
      "@babel/plugin-transform-typescript": "^7.24.1"
    },
    peerDependencies: {
      "@babel/core": "^7.0.0-0"
    },
    devDependencies: {
      "@babel/core": "^7.24.1",
      "@babel/helper-plugin-test-runner": "^7.24.1"
    },
    homepage: "https://babel.dev/docs/en/next/babel-preset-typescript",
    bugs: "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen",
    engines: {
      node: ">=6.9.0"
    },
    author: "The Babel Team (https://babel.dev/team)",
    type: "commonjs"
  };
});

// ../node_modules/@babel/helper-plugin-utils/lib/index.js
var ua = T((Go) => {
  "use strict";
  Object.defineProperty(Go, "__esModule", {
    value: !0
  });
  Go.declare = PI;
  Go.declarePreset = void 0;
  var ab = {
    assertVersion: /* @__PURE__ */ s((e) => (t) => {
      Eme(t, e.version);
    }, "assertVersion")
  };
  Object.assign(ab, {
    targets: /* @__PURE__ */ s(() => () => ({}), "targets"),
    assumption: /* @__PURE__ */ s(() => () => {
    }, "assumption")
  });
  function PI(e) {
    return (t, r, n) => {
      var i;
      let a;
      for (let l of Object.keys(ab)) {
        var o;
        t[l] || ((o = a) != null || (a = bme(t)), a[l] = ab[l](a));
      }
      return e((i = a) != null ? i : t, r || {}, n);
    };
  }
  s(PI, "declare");
  var bIe = Go.declarePreset = PI;
  function bme(e) {
    let t = null;
    return typeof e.version == "string" && /^7\./.test(e.version) && (t = Object.getPrototypeOf(e), t && (!hasOwnProperty.call(t, "version") ||
    !hasOwnProperty.call(t, "transform") || !hasOwnProperty.call(t, "template") || !hasOwnProperty.call(t, "types")) && (t = null)), Object.
    assign({}, t, e);
  }
  s(bme, "copyApiObject");
  function Eme(e, t) {
    if (typeof e == "number") {
      if (!Number.isInteger(e))
        throw new Error("Expected string or integer value.");
      e = `^${e}.0.0-0`;
    }
    if (typeof e != "string")
      throw new Error("Expected string or integer value.");
    let r = Error.stackTraceLimit;
    typeof r == "number" && r < 25 && (Error.stackTraceLimit = 25);
    let n;
    throw t.slice(0, 2) === "7." ? n = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${t}". You'll need to update your @b\
abel/core version.`) : n = new Error(`Requires Babel "${e}", but was loaded with "${t}". If you are sure you have a compatible version of @b\
abel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for\
 the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`), typeof r == "number" && (Error.stackTraceLimit =
    r), Object.assign(n, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: t,
      range: e
    });
  }
  s(Eme, "throwVersionError");
});

// ../node_modules/@babel/plugin-syntax-typescript/lib/index.js
var AI = T((pf) => {
  "use strict";
  Object.defineProperty(pf, "__esModule", {
    value: !0
  });
  pf.default = void 0;
  var vme = ua();
  ob = /* @__PURE__ */ s(function(e, t) {
    let r = [];
    e.forEach((n, i) => {
      (Array.isArray(n) ? n[0] : n) === t && r.unshift(i);
    });
    for (let n of r)
      e.splice(n, 1);
  }, "removePlugin");
  var ob, TIe = pf.default = (0, vme.declare)((e, t) => {
    e.assertVersion(7);
    let {
      disallowAmbiguousJSXLike: r,
      dts: n
    } = t;
    var {
      isTSX: i
    } = t;
    return {
      name: "syntax-typescript",
      manipulateOptions(a, o) {
        {
          let {
            plugins: l
          } = o;
          ob(l, "flow"), ob(l, "jsx"), l.push("objectRestSpread", "classProperties"), i && l.push("jsx");
        }
        o.plugins.push(["typescript", {
          disallowAmbiguousJSXLike: r,
          dts: n
        }]);
      }
    };
  });
});

// ../node_modules/@babel/helper-function-name/lib/index.js
var ub = T((lb) => {
  "use strict";
  Object.defineProperty(lb, "__esModule", {
    value: !0
  });
  lb.default = Ume;
  var II = Ni(), Tme = Pe(), {
    NOT_LOCAL_BINDING: CI,
    cloneNode: xme,
    identifier: Sme,
    isAssignmentExpression: Pme,
    isAssignmentPattern: Ame,
    isFunction: _I,
    isIdentifier: wI,
    isLiteral: DI,
    isNullLiteral: Cme,
    isObjectMethod: wme,
    isObjectProperty: Dme,
    isRegExpLiteral: Ime,
    isRestElement: _me,
    isTemplateLiteral: Ome,
    isVariableDeclarator: Nme,
    toBindingIdentifierName: Bme
  } = Tme;
  function kme(e) {
    let t = e.params.findIndex((r) => Ame(r) || _me(r));
    return t === -1 ? e.params.length : t;
  }
  s(kme, "getFunctionArity");
  var Fme = II.default.statement(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`), jme = II.default.statement(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`), Lme = {
    "ReferencedIdentifier|BindingIdentifier"(e, t) {
      e.node.name !== t.name || e.scope.getBindingIdentifier(t.name) !== t.outerDeclar || (t.selfReference = !0, e.stop());
    }
  };
  function Mme(e) {
    return Cme(e) ? "null" : Ime(e) ? `_${e.pattern}_${e.flags}` : Ome(e) ? e.quasis.map((t) => t.value.raw).join("") : e.value !== void 0 ?
    e.value + "" : "";
  }
  s(Mme, "getNameFromLiteralId");
  function Rme(e, t, r, n) {
    if (e.selfReference)
      if (n.hasBinding(r.name) && !n.hasGlobal(r.name))
        n.rename(r.name);
      else {
        if (!_I(t)) return;
        let i = Fme;
        t.generator && (i = jme);
        let a = i({
          FUNCTION: t,
          FUNCTION_ID: r,
          FUNCTION_KEY: n.generateUidIdentifier(r.name)
        }).expression, o = a.callee.body.body[0].params;
        for (let l = 0, u = kme(t); l < u; l++)
          o.push(n.generateUidIdentifier("x"));
        return a;
      }
    t.id = r, n.getProgramParent().references[r.name] = !0;
  }
  s(Rme, "wrap");
  function qme(e, t, r) {
    let n = {
      selfAssignment: !1,
      selfReference: !1,
      outerDeclar: r.getBindingIdentifier(t),
      name: t
    }, i = r.getOwnBinding(t);
    return i ? i.kind === "param" && (n.selfReference = !0) : (n.outerDeclar || r.hasGlobal(t)) && r.traverse(e, Lme, n), n;
  }
  s(qme, "visit");
  function Ume({
    node: e,
    parent: t,
    scope: r,
    id: n
  }, i = !1, a = !1) {
    if (e.id) return;
    if ((Dme(t) || wme(t, {
      kind: "method"
    })) && (!t.computed || DI(t.key)))
      n = t.key;
    else if (Nme(t)) {
      if (n = t.id, wI(n) && !i) {
        let c = r.parent.getBinding(n.name);
        if (c && c.constant && r.getBinding(n.name) === c) {
          e.id = xme(n), e.id[CI] = !0;
          return;
        }
      }
    } else if (Pme(t, {
      operator: "="
    }))
      n = t.left;
    else if (!n)
      return;
    let o;
    if (n && DI(n) ? o = Mme(n) : n && wI(n) && (o = n.name), o === void 0 || !a && _I(e) && /[\uD800-\uDFFF]/.test(o))
      return;
    o = Bme(o);
    let l = Sme(o);
    l[CI] = !0;
    let u = qme(e, o, r);
    return Rme(u, e, l, r) || e;
  }
  s(Ume, "_default");
});

// ../node_modules/@babel/helper-split-export-declaration/lib/index.js
var db = T((pb) => {
  "use strict";
  Object.defineProperty(pb, "__esModule", {
    value: !0
  });
  pb.default = Kme;
  var Vme = Pe(), {
    cloneNode: cb,
    exportNamedDeclaration: OI,
    exportSpecifier: NI,
    identifier: fb,
    variableDeclaration: $me,
    variableDeclarator: Wme
  } = Vme;
  function Kme(e) {
    if (!e.isExportDeclaration() || e.isExportAllDeclaration())
      throw new Error("Only default and named export declarations can be split.");
    if (e.isExportDefaultDeclaration()) {
      let a = e.get("declaration"), o = a.isFunctionDeclaration() || a.isClassDeclaration(), l = a.isFunctionExpression() || a.isClassExpression(),
      u = a.isScope() ? a.scope.parent : a.scope, c = a.node.id, f = !1;
      c ? l && u.hasBinding(c.name) && (f = !0, c = u.generateUidIdentifier(c.name)) : (f = !0, c = u.generateUidIdentifier("default"), (o ||
      l) && (a.node.id = cb(c)));
      let p = o ? a.node : $me("var", [Wme(cb(c), a.node)]), h = OI(null, [NI(cb(c), fb("default"))]);
      return e.insertAfter(h), e.replaceWith(p), f && u.registerDeclaration(e), e;
    } else if (e.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    let t = e.get("declaration"), r = t.getOuterBindingIdentifiers(), n = Object.keys(r).map((a) => NI(fb(a), fb(a))), i = OI(null, n);
    return e.insertAfter(i), e.replaceWith(t.node), e;
  }
  s(Kme, "splitExportDeclaration");
});

// ../node_modules/@babel/helper-environment-visitor/lib/index.js
var Ho = T((ca) => {
  "use strict";
  Object.defineProperty(ca, "__esModule", {
    value: !0
  });
  ca.default = void 0;
  ca.requeueComputedKeyAndDecorators = hb;
  ca.skipAllButComputedKey = /* @__PURE__ */ s(function(t) {
    t.skip(), t.node.computed && t.context.maybeQueue(t.get("key"));
  }, "skipAllButComputedKey");
  function hb(e) {
    let {
      context: t,
      node: r
    } = e;
    if (r.computed && t.maybeQueue(e.get("key")), r.decorators)
      for (let n of e.get("decorators"))
        t.maybeQueue(n);
  }
  s(hb, "requeueComputedKeyAndDecorators");
  var Gme = {
    FunctionParent(e) {
      e.isArrowFunctionExpression() || (e.skip(), e.isMethod() && hb(e));
    },
    Property(e) {
      e.isObjectProperty() || (e.skip(), hb(e));
    }
  }, DIe = ca.default = Gme;
});

// ../node_modules/@babel/helper-member-expression-to-functions/lib/index.js
var Eb = T((bb) => {
  "use strict";
  Object.defineProperty(bb, "__esModule", { value: !0 });
  var Hme = Pe();
  function Yme(e) {
    if (e && e.__esModule) return e;
    var t = /* @__PURE__ */ Object.create(null);
    return e && Object.keys(e).forEach(function(r) {
      if (r !== "default") {
        var n = Object.getOwnPropertyDescriptor(e, r);
        Object.defineProperty(t, r, n.get ? n : {
          enumerable: !0,
          get: /* @__PURE__ */ s(function() {
            return e[r];
          }, "get")
        });
      }
    }), t.default = e, Object.freeze(t);
  }
  s(Yme, "_interopNamespace");
  var zme = /* @__PURE__ */ Yme(Hme);
  function yb(e) {
    let t = e, {
      node: r,
      parentPath: n
    } = t;
    if (n.isLogicalExpression()) {
      let {
        operator: i,
        right: a
      } = n.node;
      if (i === "&&" || i === "||" || i === "??" && r === a)
        return yb(n);
    }
    if (n.isSequenceExpression()) {
      let {
        expressions: i
      } = n.node;
      return i[i.length - 1] === r ? yb(n) : !0;
    }
    return n.isConditional({
      test: r
    }) || n.isUnaryExpression({
      operator: "!"
    }) || n.isLoop({
      test: r
    });
  }
  s(yb, "willPathCastToBoolean");
  var {
    LOGICAL_OPERATORS: Jme,
    arrowFunctionExpression: BI,
    assignmentExpression: fa,
    binaryExpression: ui,
    booleanLiteral: Xme,
    callExpression: mf,
    cloneNode: Rr,
    conditionalExpression: Qme,
    identifier: MI,
    isMemberExpression: Zme,
    isOptionalCallExpression: eye,
    isOptionalMemberExpression: RI,
    isUpdateExpression: tye,
    logicalExpression: hf,
    memberExpression: kI,
    nullLiteral: df,
    optionalCallExpression: rye,
    optionalMemberExpression: nye,
    sequenceExpression: mb,
    updateExpression: FI
  } = zme, gb = class {
    static {
      s(this, "AssignmentMemoiser");
    }
    constructor() {
      this._map = void 0, this._map = /* @__PURE__ */ new WeakMap();
    }
    has(t) {
      return this._map.has(t);
    }
    get(t) {
      if (!this.has(t)) return;
      let r = this._map.get(t), {
        value: n
      } = r;
      return r.count--, r.count === 0 ? fa("=", n, t) : n;
    }
    set(t, r, n) {
      return this._map.set(t, {
        count: n,
        value: r
      });
    }
  };
  function jI(e, t) {
    let {
      node: r
    } = e;
    if (RI(r))
      return kI(t, r.property, r.computed);
    if (e.isOptionalCallExpression()) {
      let n = e.get("callee");
      if (e.node.optional && n.isOptionalMemberExpression()) {
        let i = n.node.object, a = e.scope.maybeGenerateMemoised(i);
        return n.get("object").replaceWith(fa("=", a, i)), mf(kI(t, MI("call")), [a, ...e.node.arguments]);
      }
      return mf(t, e.node.arguments);
    }
    return e.node;
  }
  s(jI, "toNonOptional");
  function sye(e) {
    for (; e && !e.isProgram(); ) {
      let {
        parentPath: t,
        container: r,
        listKey: n
      } = e, i = t.node;
      if (n) {
        if (r !== i[n])
          return !0;
      } else if (r !== i) return !0;
      e = t;
    }
    return !1;
  }
  s(sye, "isInDetachedTree");
  var iye = {
    memoise() {
    },
    handle(e, t) {
      let {
        node: r,
        parent: n,
        parentPath: i,
        scope: a
      } = e;
      if (e.isOptionalMemberExpression()) {
        if (sye(e)) return;
        let o = e.find(({
          node: U,
          parent: Q
        }) => RI(Q) ? Q.optional || Q.object !== U : eye(Q) ? U !== e.node && Q.optional || Q.callee !== U : !0);
        if (a.path.isPattern()) {
          o.replaceWith(mf(BI([], o.node), []));
          return;
        }
        let l = yb(o), u = o.parentPath;
        if (u.isUpdateExpression({
          argument: r
        }))
          throw e.buildCodeFrameError("can't handle update expression");
        let c = u.isAssignmentExpression({
          left: o.node
        }), f = u.isUnaryExpression({
          operator: "delete"
        });
        if (f && o.isOptionalMemberExpression() && o.get("property").isPrivateName())
          throw e.buildCodeFrameError("can't delete a private class element");
        let p = e;
        for (; ; ) {
          if (p.isOptionalMemberExpression()) {
            if (p.node.optional) break;
            p = p.get("object");
            continue;
          } else if (p.isOptionalCallExpression()) {
            if (p.node.optional) break;
            p = p.get("callee");
            continue;
          }
          throw new Error(`Internal error: unexpected ${p.node.type}`);
        }
        let h = p.isOptionalMemberExpression() ? p.node.object : p.node.callee, y = a.maybeGenerateMemoised(h), v = y ?? h, d = i.isOptionalCallExpression(
        {
          callee: r
        }), b = /* @__PURE__ */ s((U) => d, "isOptionalCall"), E = i.isCallExpression({
          callee: r
        });
        p.replaceWith(jI(p, v)), b() ? n.optional ? i.replaceWith(this.optionalCall(e, n.arguments)) : i.replaceWith(this.call(e, n.arguments)) :
        E ? e.replaceWith(this.boundGet(e)) : this.delete && i.isUnaryExpression({
          operator: "delete"
        }) ? i.replaceWith(this.delete(e)) : i.isAssignmentExpression() ? LI(this, e, i) : e.replaceWith(this.get(e));
        let I = e.node;
        for (let U = e; U !== o; ) {
          let Q = U.parentPath;
          if (Q === o && b() && n.optional) {
            I = Q.node;
            break;
          }
          I = jI(Q, I), U = Q;
        }
        let O, k = o.parentPath;
        if (Zme(I) && k.isOptionalCallExpression({
          callee: o.node,
          optional: !0
        })) {
          let {
            object: U
          } = I;
          O = e.scope.maybeGenerateMemoised(U), O && (I.object = fa("=", O, U));
        }
        let j = o;
        (f || c) && (j = k, I = k.node);
        let R = y ? fa("=", Rr(v), Rr(h)) : Rr(v);
        if (l) {
          let U;
          t ? U = ui("!=", R, df()) : U = hf("&&", ui("!==", R, df()), ui("!==", Rr(v), a.buildUndefinedNode())), j.replaceWith(hf("&&", U, I));
        } else {
          let U;
          t ? U = ui("==", R, df()) : U = hf("||", ui("===", R, df()), ui("===", Rr(v), a.buildUndefinedNode())), j.replaceWith(Qme(U, f ? Xme(
          !0) : a.buildUndefinedNode(), I));
        }
        if (O) {
          let U = k.node;
          k.replaceWith(rye(nye(U.callee, MI("call"), !1, !0), [Rr(O), ...U.arguments], !1));
        }
        return;
      }
      if (tye(n, {
        argument: r
      })) {
        if (this.simpleSet) {
          e.replaceWith(this.simpleSet(e));
          return;
        }
        let {
          operator: o,
          prefix: l
        } = n;
        this.memoise(e, 2);
        let u = a.generateUidIdentifierBasedOnNode(r);
        a.push({
          id: u
        });
        let c = [fa("=", Rr(u), this.get(e))];
        if (l) {
          c.push(FI(o, Rr(u), l));
          let f = mb(c);
          i.replaceWith(this.set(e, f));
          return;
        } else {
          let f = a.generateUidIdentifierBasedOnNode(r);
          a.push({
            id: f
          }), c.push(fa("=", Rr(f), FI(o, Rr(u), l)), Rr(u));
          let p = mb(c);
          i.replaceWith(mb([this.set(e, p), Rr(f)]));
          return;
        }
      }
      if (i.isAssignmentExpression({
        left: r
      })) {
        LI(this, e, i);
        return;
      }
      if (i.isCallExpression({
        callee: r
      })) {
        i.replaceWith(this.call(e, i.node.arguments));
        return;
      }
      if (i.isOptionalCallExpression({
        callee: r
      })) {
        if (a.path.isPattern()) {
          i.replaceWith(mf(BI([], i.node), []));
          return;
        }
        i.replaceWith(this.optionalCall(e, i.node.arguments));
        return;
      }
      if (this.delete && i.isUnaryExpression({
        operator: "delete"
      })) {
        i.replaceWith(this.delete(e));
        return;
      }
      if (i.isForXStatement({
        left: r
      }) || i.isObjectProperty({
        value: r
      }) && i.parentPath.isObjectPattern() || i.isAssignmentPattern({
        left: r
      }) && i.parentPath.isObjectProperty({
        value: n
      }) && i.parentPath.parentPath.isObjectPattern() || i.isArrayPattern() || i.isAssignmentPattern({
        left: r
      }) && i.parentPath.isArrayPattern() || i.isRestElement()) {
        e.replaceWith(this.destructureSet(e));
        return;
      }
      i.isTaggedTemplateExpression() ? e.replaceWith(this.boundGet(e)) : e.replaceWith(this.get(e));
    }
  };
  function LI(e, t, r) {
    if (e.simpleSet) {
      t.replaceWith(e.simpleSet(t));
      return;
    }
    let {
      operator: n,
      right: i
    } = r.node;
    if (n === "=")
      r.replaceWith(e.set(t, i));
    else {
      let a = n.slice(0, -1);
      Jme.includes(a) ? (e.memoise(t, 1), r.replaceWith(hf(a, e.get(t), e.set(t, i)))) : (e.memoise(t, 2), r.replaceWith(e.set(t, ui(a, e.get(
      t), i))));
    }
  }
  s(LI, "handleAssignment");
  function aye(e, t, r) {
    e.traverse(t, Object.assign({}, iye, r, {
      memoiser: new gb()
    }));
  }
  s(aye, "memberExpressionToFunctions");
  bb.default = aye;
});

// ../node_modules/@babel/helper-optimise-call-expression/lib/index.js
var Tb = T((vb) => {
  "use strict";
  Object.defineProperty(vb, "__esModule", {
    value: !0
  });
  vb.default = cye;
  var oye = Pe(), {
    callExpression: qI,
    identifier: yf,
    isIdentifier: lye,
    isSpreadElement: uye,
    memberExpression: UI,
    optionalCallExpression: VI,
    optionalMemberExpression: $I
  } = oye;
  function cye(e, t, r, n) {
    return r.length === 1 && uye(r[0]) && lye(r[0].argument, {
      name: "arguments"
    }) ? n ? VI($I(e, yf("apply"), !1, !0), [t, r[0].argument], !1) : qI(UI(e, yf("apply")), [t, r[0].argument]) : n ? VI($I(e, yf("call"), !1,
    !0), [t, ...r], !1) : qI(UI(e, yf("call")), [t, ...r]);
  }
  s(cye, "optimiseCallExpression");
});

// ../node_modules/@babel/helper-replace-supers/lib/index.js
var Ef = T((da) => {
  "use strict";
  Object.defineProperty(da, "__esModule", {
    value: !0
  });
  da.default = void 0;
  var GI = Ho(), fye = Eb(), bf = Tb(), Jo = bt(), {
    assignmentExpression: pye,
    booleanLiteral: dye,
    callExpression: gf,
    cloneNode: en,
    identifier: Yo,
    memberExpression: pa,
    sequenceExpression: xb,
    stringLiteral: hye,
    thisExpression: zo
  } = Jo.types;
  {
    let e = Ho();
    da.environmentVisitor = e.default, da.skipAllButComputedKey = e.skipAllButComputedKey;
  }
  function WI(e, t, r, n) {
    e = en(e);
    let i = t || n ? e : pa(e, Yo("prototype"));
    return gf(r.addHelper("getPrototypeOf"), [i]);
  }
  s(WI, "getPrototypeOfExpression");
  var KI = Jo.traverse.visitors.merge([GI.default, {
    Super(e, t) {
      let {
        node: r,
        parentPath: n
      } = e;
      n.isMemberExpression({
        object: r
      }) && t.handle(n);
    }
  }]), mye = Jo.traverse.visitors.merge([GI.default, {
    Scopable(e, {
      refName: t
    }) {
      let r = e.scope.getOwnBinding(t);
      r && r.identifier.name === t && e.scope.rename(t);
    }
  }]), HI = {
    memoise(e, t) {
      let {
        scope: r,
        node: n
      } = e, {
        computed: i,
        property: a
      } = n;
      if (!i)
        return;
      let o = r.maybeGenerateMemoised(a);
      o && this.memoiser.set(a, o, t);
    },
    prop(e) {
      let {
        computed: t,
        property: r
      } = e.node;
      return this.memoiser.has(r) ? en(this.memoiser.get(r)) : t ? en(r) : hye(r.name);
    },
    get(e) {
      return this._get(e, this._getThisRefs());
    },
    _get(e, t) {
      let r = WI(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
      return gf(this.file.addHelper("get"), [t.needAccessFirst ? xb([t.this, r]) : r, this.prop(e), t.this]);
    },
    _getThisRefs() {
      return {
        needAccessFirst: this.isDerivedConstructor,
        this: zo()
      };
    },
    set(e, t) {
      let r = this._getThisRefs(), n = WI(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
      return gf(this.file.addHelper("set"), [r.needAccessFirst ? xb([r.this, n]) : n, this.prop(e), t, r.this, dye(e.isInStrictMode())]);
    },
    destructureSet(e) {
      throw e.buildCodeFrameError("Destructuring to a super field is not supported yet.");
    },
    call(e, t) {
      let r = this._getThisRefs();
      return (0, bf.default)(this._get(e, r), en(r.this), t, !1);
    },
    optionalCall(e, t) {
      let r = this._getThisRefs();
      return (0, bf.default)(this._get(e, r), en(r.this), t, !0);
    },
    delete(e) {
      return e.node.computed ? xb([gf(this.file.addHelper("toPropertyKey"), [en(e.node.property)]), Jo.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : Jo.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
    }
  }, yye = Object.assign({}, HI, {
    prop(e) {
      let {
        property: t
      } = e.node;
      return this.memoiser.has(t) ? en(this.memoiser.get(t)) : en(t);
    },
    get(e) {
      let {
        isStatic: t,
        getSuperRef: r
      } = this, {
        computed: n
      } = e.node, i = this.prop(e), a;
      if (t) {
        var o;
        a = (o = r()) != null ? o : pa(Yo("Function"), Yo("prototype"));
      } else {
        var l;
        a = pa((l = r()) != null ? l : Yo("Object"), Yo("prototype"));
      }
      return pa(a, i, n);
    },
    set(e, t) {
      let {
        computed: r
      } = e.node, n = this.prop(e);
      return pye("=", pa(zo(), n, r), t);
    },
    destructureSet(e) {
      let {
        computed: t
      } = e.node, r = this.prop(e);
      return pa(zo(), r, t);
    },
    call(e, t) {
      return (0, bf.default)(this.get(e), zo(), t, !1);
    },
    optionalCall(e, t) {
      return (0, bf.default)(this.get(e), zo(), t, !0);
    }
  }), Sb = class {
    static {
      s(this, "ReplaceSupers");
    }
    constructor(t) {
      var r;
      let n = t.methodPath;
      this.methodPath = n, this.isDerivedConstructor = n.isClassMethod({
        kind: "constructor"
      }) && !!t.superRef, this.isStatic = n.isObjectMethod() || n.node.static || (n.isStaticBlock == null ? void 0 : n.isStaticBlock()), this.
      isPrivateMethod = n.isPrivate() && n.isMethod(), this.file = t.file, this.constantSuper = (r = t.constantSuper) != null ? r : t.isLoose,
      this.opts = t;
    }
    getObjectRef() {
      return en(this.opts.objectRef || this.opts.getObjectRef());
    }
    getSuperRef() {
      if (this.opts.superRef) return en(this.opts.superRef);
      if (this.opts.getSuperRef)
        return en(this.opts.getSuperRef());
    }
    replace() {
      let {
        methodPath: t
      } = this;
      this.opts.refToPreserve && t.traverse(mye, {
        refName: this.opts.refToPreserve.name
      });
      let r = this.constantSuper ? yye : HI;
      KI.shouldSkip = (n) => {
        if (n.parentPath === t && (n.parentKey === "decorators" || n.parentKey === "key"))
          return !0;
      }, (0, fye.default)(t, KI, Object.assign({
        file: this.file,
        scope: this.methodPath.scope,
        isDerivedConstructor: this.isDerivedConstructor,
        isStatic: this.isStatic,
        isPrivateMethod: this.isPrivateMethod,
        getObjectRef: this.getObjectRef.bind(this),
        getSuperRef: this.getSuperRef.bind(this),
        boundGet: r.get
      }, r));
    }
  };
  da.default = Sb;
});

// ../node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js
var Ab = T((Xo) => {
  "use strict";
  Object.defineProperty(Xo, "__esModule", {
    value: !0
  });
  Xo.isTransparentExprWrapper = Pb;
  Xo.skipTransparentExprWrapperNodes = Aye;
  Xo.skipTransparentExprWrappers = Pye;
  var gye = Pe(), {
    isParenthesizedExpression: bye,
    isTSAsExpression: Eye,
    isTSNonNullExpression: vye,
    isTSSatisfiesExpression: Tye,
    isTSTypeAssertion: xye,
    isTypeCastExpression: Sye
  } = gye;
  function Pb(e) {
    return Eye(e) || Tye(e) || xye(e) || vye(e) || Sye(e) || bye(e);
  }
  s(Pb, "isTransparentExprWrapper");
  function Pye(e) {
    for (; Pb(e.node); )
      e = e.get("expression");
    return e;
  }
  s(Pye, "skipTransparentExprWrappers");
  function Aye(e) {
    for (; Pb(e); )
      e = e.expression;
    return e;
  }
  s(Aye, "skipTransparentExprWrapperNodes");
});

// ../node_modules/@babel/helper-annotate-as-pure/lib/index.js
var wb = T((Cb) => {
  "use strict";
  Object.defineProperty(Cb, "__esModule", {
    value: !0
  });
  Cb.default = _ye;
  var Cye = Pe(), {
    addComment: wye
  } = Cye, Dye = "#__PURE__", Iye = /* @__PURE__ */ s(({
    leadingComments: e
  }) => !!e && e.some((t) => /[@#]__PURE__/.test(t.value)), "isPureAnnotated");
  function _ye(e) {
    let t = e.node || e;
    Iye(t) || wye(t, "leading", Dye);
  }
  s(_ye, "annotateAsPure");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js
var Ib = T((Db) => {
  "use strict";
  Object.defineProperty(Db, "__esModule", {
    value: !0
  });
  Db.assertFieldTransformed = Oye;
  function Oye(e) {
    if (e.node.declare)
      throw e.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.
If you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional clas\
s features:
 - @babel/plugin-transform-class-properties
 - @babel/plugin-transform-private-methods
 - @babel/plugin-proposal-decorators`);
  }
  s(Oye, "assertFieldTransformed");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/fields.js
var kb = T((xs) => {
  "use strict";
  Object.defineProperty(xs, "__esModule", {
    value: !0
  });
  xs.buildCheckInRHS = xf;
  xs.buildFieldsInitNodes = t0e;
  xs.buildPrivateNamesMap = Lye;
  xs.buildPrivateNamesNodes = Mye;
  xs.privateNameVisitorFactory = Bb;
  xs.transformPrivateNamesUsage = Wye;
  var B = bt(), Nye = Ef(), ZI = Ho(), Bye = Eb(), YI = Tb(), kye = wb(), Fye = Ab(), jye = Ib();
  Qt = /* @__PURE__ */ s((e) => e.availableHelper("classPrivateFieldGet2"), "newHelpers");
  var Qt;
  function Lye(e, t, r, n) {
    let i = /* @__PURE__ */ new Map(), a;
    for (let l of r)
      if (l.isPrivate()) {
        let {
          name: u
        } = l.node.key.id, c = i.get(u);
        if (!c) {
          let f = !l.isProperty(), p = l.node.static, h = !1, y;
          if (!t && Qt(n) && f && !p) {
            var o;
            h = !!a, (o = a) != null || (a = l.scope.generateUidIdentifier(`${e}_brand`)), y = a;
          } else
            y = l.scope.generateUidIdentifier(u);
          c = {
            id: y,
            static: p,
            method: f,
            initAdded: h
          }, i.set(u, c);
        }
        if (l.isClassPrivateMethod())
          if (l.node.kind === "get") {
            let {
              body: f
            } = l.node.body, p;
            f.length === 1 && B.types.isReturnStatement(p = f[0]) && B.types.isCallExpression(p = p.argument) && p.arguments.length === 1 &&
            B.types.isThisExpression(p.arguments[0]) && B.types.isIdentifier(p = p.callee) ? (c.getId = B.types.cloneNode(p), c.getterDeclared =
            !0) : c.getId = l.scope.generateUidIdentifier(`get_${u}`);
          } else if (l.node.kind === "set") {
            let {
              params: f
            } = l.node, {
              body: p
            } = l.node.body, h;
            p.length === 1 && B.types.isExpressionStatement(h = p[0]) && B.types.isCallExpression(h = h.expression) && h.arguments.length ===
            2 && B.types.isThisExpression(h.arguments[0]) && B.types.isIdentifier(h.arguments[1], {
              name: f[0].name
            }) && B.types.isIdentifier(h = h.callee) ? (c.setId = B.types.cloneNode(h), c.setterDeclared = !0) : c.setId = l.scope.generateUidIdentifier(
            `set_${u}`);
          } else l.node.kind === "method" && (c.methodId = l.scope.generateUidIdentifier(u));
        i.set(u, c);
      }
    return i;
  }
  s(Lye, "buildPrivateNamesMap");
  function Mye(e, t, r, n) {
    let i = [], a = /* @__PURE__ */ new Set();
    for (let [o, l] of e) {
      let {
        static: u,
        method: c,
        getId: f,
        setId: p
      } = l, h = f || p, y = B.types.cloneNode(l.id), v;
      if (t)
        v = B.types.callExpression(n.addHelper("classPrivateFieldLooseKey"), [B.types.stringLiteral(o)]);
      else if (r)
        v = B.types.callExpression(B.types.identifier("Symbol"), [B.types.stringLiteral(o)]);
      else if (!u) {
        if (a.has(y.name)) continue;
        a.add(y.name), v = B.types.newExpression(B.types.identifier(c && (!h || Qt(n)) ? "WeakSet" : "WeakMap"), []);
      }
      v && (r || (0, kye.default)(v), i.push(B.template.statement.ast`var ${y} = ${v}`));
    }
    return i;
  }
  s(Mye, "buildPrivateNamesNodes");
  function Bb(e) {
    let t = B.traverse.visitors.merge([Object.assign({}, e), ZI.default]), r = Object.assign({}, e, {
      Class(n) {
        let {
          privateNamesMap: i
        } = this, a = n.get("body.body"), o = new Map(i), l = [];
        for (let u of a) {
          if (!u.isPrivate()) continue;
          let {
            name: c
          } = u.node.key.id;
          o.delete(c), l.push(c);
        }
        l.length && (n.get("body").traverse(t, Object.assign({}, this, {
          redeclared: l
        })), n.traverse(r, Object.assign({}, this, {
          privateNamesMap: o
        })), n.skipKey("body"));
      }
    });
    return r;
  }
  s(Bb, "privateNameVisitorFactory");
  var Rye = Bb({
    PrivateName(e, {
      noDocumentAll: t
    }) {
      let {
        privateNamesMap: r,
        redeclared: n
      } = this, {
        node: i,
        parentPath: a
      } = e;
      if (!a.isMemberExpression({
        property: i
      }) && !a.isOptionalMemberExpression({
        property: i
      }))
        return;
      let {
        name: o
      } = i.id;
      r.has(o) && (n != null && n.includes(o) || this.handle(a, t));
    }
  });
  function e_(e, t, r) {
    for (; (n = t) != null && n.hasBinding(e) && !t.bindingIdentifierEquals(e, r); ) {
      var n;
      t.rename(e), t = t.parent;
    }
  }
  s(e_, "unshadow");
  function xf(e, t, r) {
    return r || !(t.availableHelper != null && t.availableHelper("checkInRHS")) ? e : B.types.callExpression(t.addHelper("checkInRHS"), [e]);
  }
  s(xf, "buildCheckInRHS");
  var qye = Bb({
    BinaryExpression(e, {
      file: t
    }) {
      let {
        operator: r,
        left: n,
        right: i
      } = e.node;
      if (r !== "in" || !B.types.isPrivateName(n)) return;
      let {
        privateFieldsAsProperties: a,
        privateNamesMap: o,
        redeclared: l
      } = this, {
        name: u
      } = n.id;
      if (!o.has(u) || l != null && l.includes(u)) return;
      if (e_(this.classRef.name, e.scope, this.innerBinding), a) {
        let {
          id: p
        } = o.get(u);
        e.replaceWith(B.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${xf(i, t)}, ${B.types.cloneNode(p)})
      `);
        return;
      }
      let {
        id: c,
        static: f
      } = o.get(u);
      if (f) {
        e.replaceWith(B.template.expression.ast`${xf(i, t)} === ${B.types.cloneNode(this.classRef)}`);
        return;
      }
      e.replaceWith(B.template.expression.ast`${B.types.cloneNode(c)}.has(${xf(i, t)})`);
    }
  });
  function vf(e, t) {
    return B.types.callExpression(e.addHelper("readOnlyError"), [B.types.stringLiteral(`#${t}`)]);
  }
  s(vf, "readOnlyError");
  function Uye(e, t) {
    return e.availableHelper("writeOnlyError") ? B.types.callExpression(e.addHelper("writeOnlyError"), [B.types.stringLiteral(`#${t}`)]) : (console.
    warn("@babel/helpers is outdated, update it to silence this warning."), B.types.buildUndefinedNode());
  }
  s(Uye, "writeOnlyError");
  function _b(e, t) {
    return t ? e : B.types.memberExpression(e, B.types.identifier("_"));
  }
  s(_b, "buildStaticPrivateFieldAccess");
  function zI(e) {
    return function(t) {
      return B.types.inherits(e.apply(this, arguments), t.node);
    };
  }
  s(zI, "autoInherits");
  var Vye = {
    memoise(e, t) {
      let {
        scope: r
      } = e, {
        object: n
      } = e.node, i = r.maybeGenerateMemoised(n);
      i && this.memoiser.set(n, i, t);
    },
    receiver(e) {
      let {
        object: t
      } = e.node;
      return this.memoiser.has(t) ? B.types.cloneNode(this.memoiser.get(t)) : B.types.cloneNode(t);
    },
    get: zI(function(e) {
      let {
        classRef: t,
        privateNamesMap: r,
        file: n,
        innerBinding: i,
        noUninitializedPrivateFieldAccess: a
      } = this, o = e.node.property, {
        name: l
      } = o.id, {
        id: u,
        static: c,
        method: f,
        methodId: p,
        getId: h,
        setId: y
      } = r.get(l), v = h || y, d = /* @__PURE__ */ s((b) => B.types.inherits(B.types.cloneNode(b), o), "cloneId");
      if (c) {
        if (e_(t.name, e.scope, i), !Qt(n)) {
          let I = f && !v ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
          return B.types.callExpression(n.addHelper(I), [this.receiver(e), B.types.cloneNode(t), d(u)]);
        }
        let b = this.receiver(e), E = B.types.isIdentifier(b) && b.name === t.name;
        if (!f)
          return _b(E ? d(u) : B.types.callExpression(n.addHelper("assertClassBrand"), [B.types.cloneNode(t), b, d(u)]), a);
        if (h)
          return E ? B.types.callExpression(d(h), [b]) : B.types.callExpression(n.addHelper("classPrivateGetter"), [B.types.cloneNode(t), b,
          d(h)]);
        if (y) {
          let I = B.types.buildUndefinedNode();
          return E ? I : B.types.sequenceExpression([B.types.callExpression(n.addHelper("assertClassBrand"), [B.types.cloneNode(t), b]), I]);
        }
        return E ? d(u) : B.types.callExpression(n.addHelper("assertClassBrand"), [B.types.cloneNode(t), b, d(u)]);
      }
      return f ? v ? h ? Qt(n) ? B.types.callExpression(n.addHelper("classPrivateGetter"), [B.types.cloneNode(u), this.receiver(e), d(h)]) :
      B.types.callExpression(n.addHelper("classPrivateFieldGet"), [this.receiver(e), d(u)]) : B.types.sequenceExpression([this.receiver(e), Uye(
      n, l)]) : Qt(n) ? B.types.callExpression(n.addHelper("assertClassBrand"), [B.types.cloneNode(u), this.receiver(e), d(p)]) : B.types.callExpression(
      n.addHelper("classPrivateMethodGet"), [this.receiver(e), B.types.cloneNode(u), d(p)]) : Qt(n) ? B.types.callExpression(n.addHelper("cl\
assPrivateFieldGet2"), [d(u), this.receiver(e)]) : B.types.callExpression(n.addHelper("classPrivateFieldGet"), [this.receiver(e), d(u)]);
    }),
    boundGet(e) {
      return this.memoise(e, 1), B.types.callExpression(B.types.memberExpression(this.get(e), B.types.identifier("bind")), [this.receiver(e)]);
    },
    set: zI(function(e, t) {
      let {
        classRef: r,
        privateNamesMap: n,
        file: i,
        noUninitializedPrivateFieldAccess: a
      } = this, o = e.node.property, {
        name: l
      } = o.id, {
        id: u,
        static: c,
        method: f,
        setId: p,
        getId: h
      } = n.get(l), y = h || p, v = /* @__PURE__ */ s((d) => B.types.inherits(B.types.cloneNode(d), o), "cloneId");
      if (c) {
        if (!Qt(i)) {
          let E = f && !y ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
          return B.types.callExpression(i.addHelper(E), [this.receiver(e), B.types.cloneNode(r), v(u), t]);
        }
        let d = this.receiver(e), b = B.types.isIdentifier(d) && d.name === r.name;
        if (f && !p) {
          let E = vf(i, l);
          return b ? B.types.sequenceExpression([t, E]) : B.types.sequenceExpression([t, B.types.callExpression(i.addHelper("assertClassBran\
d"), [B.types.cloneNode(r), d]), vf(i, l)]);
        }
        return p ? b ? B.types.callExpression(B.types.cloneNode(p), [d, t]) : B.types.callExpression(i.addHelper("classPrivateSetter"), [B.types.
        cloneNode(r), v(p), d, t]) : B.types.assignmentExpression("=", _b(v(u), a), b ? t : B.types.callExpression(i.addHelper("assertClassB\
rand"), [B.types.cloneNode(r), d, t]));
      }
      return f ? p ? Qt(i) ? B.types.callExpression(i.addHelper("classPrivateSetter"), [B.types.cloneNode(u), v(p), this.receiver(e), t]) : B.
      types.callExpression(i.addHelper("classPrivateFieldSet"), [this.receiver(e), v(u), t]) : B.types.sequenceExpression([this.receiver(e),
      t, vf(i, l)]) : Qt(i) ? B.types.callExpression(i.addHelper("classPrivateFieldSet2"), [v(u), this.receiver(e), t]) : B.types.callExpression(
      i.addHelper("classPrivateFieldSet"), [this.receiver(e), v(u), t]);
    }),
    destructureSet(e) {
      let {
        classRef: t,
        privateNamesMap: r,
        file: n,
        noUninitializedPrivateFieldAccess: i
      } = this, a = e.node.property, {
        name: o
      } = a.id, {
        id: l,
        static: u,
        method: c,
        setId: f
      } = r.get(o), p = /* @__PURE__ */ s((d) => B.types.inherits(B.types.cloneNode(d), a), "cloneId");
      if (!Qt(n)) {
        if (u) {
          try {
            var h = n.addHelper("classStaticPrivateFieldDestructureSet");
          } catch {
            throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the late\
st version.");
          }
          return B.types.memberExpression(B.types.callExpression(h, [this.receiver(e), B.types.cloneNode(t), p(l)]), B.types.identifier("val\
ue"));
        }
        return B.types.memberExpression(B.types.callExpression(n.addHelper("classPrivateFieldDestructureSet"), [this.receiver(e), p(l)]), B.
        types.identifier("value"));
      }
      if (c && !f)
        return B.types.memberExpression(B.types.sequenceExpression([e.node.object, vf(n, o)]), B.types.identifier("_"));
      if (u && !c) {
        let d = this.get(e);
        if (!i || !B.types.isCallExpression(d))
          return d;
        let b = d.arguments.pop();
        return d.arguments.push(B.template.expression.ast`(_) => ${b} = _`), B.types.memberExpression(B.types.callExpression(n.addHelper("to\
Setter"), [d]), B.types.identifier("_"));
      }
      let y = this.set(e, B.types.identifier("_"));
      if (!B.types.isCallExpression(y) || !B.types.isIdentifier(y.arguments[y.arguments.length - 1], {
        name: "_"
      }))
        throw e.buildCodeFrameError("Internal Babel error while compiling this code. This is a Babel bug. Please report it at https://github\
.com/babel/babel/issues.");
      let v;
      return B.types.isMemberExpression(y.callee, {
        computed: !1
      }) && B.types.isIdentifier(y.callee.property) && y.callee.property.name === "call" ? v = [y.callee.object, B.types.arrayExpression(y.arguments.
      slice(1, -1)), y.arguments[0]] : v = [y.callee, B.types.arrayExpression(y.arguments.slice(0, -1))], B.types.memberExpression(B.types.callExpression(
      n.addHelper("toSetter"), v), B.types.identifier("_"));
    },
    call(e, t) {
      return this.memoise(e, 1), (0, YI.default)(this.get(e), this.receiver(e), t, !1);
    },
    optionalCall(e, t) {
      return this.memoise(e, 1), (0, YI.default)(this.get(e), this.receiver(e), t, !0);
    },
    delete() {
      throw new Error("Internal Babel error: deleting private elements is a parsing error.");
    }
  }, $ye = {
    get(e) {
      let {
        privateNamesMap: t,
        file: r
      } = this, {
        object: n
      } = e.node, {
        name: i
      } = e.node.property.id;
      return B.template.expression`BASE(REF, PROP)[PROP]`({
        BASE: r.addHelper("classPrivateFieldLooseBase"),
        REF: B.types.cloneNode(n),
        PROP: B.types.cloneNode(t.get(i).id)
      });
    },
    set() {
      throw new Error("private name handler with loose = true don't need set()");
    },
    boundGet(e) {
      return B.types.callExpression(B.types.memberExpression(this.get(e), B.types.identifier("bind")), [B.types.cloneNode(e.node.object)]);
    },
    simpleSet(e) {
      return this.get(e);
    },
    destructureSet(e) {
      return this.get(e);
    },
    call(e, t) {
      return B.types.callExpression(this.get(e), t);
    },
    optionalCall(e, t) {
      return B.types.optionalCallExpression(this.get(e), t, !0);
    },
    delete() {
      throw new Error("Internal Babel error: deleting private elements is a parsing error.");
    }
  };
  function Wye(e, t, r, {
    privateFieldsAsProperties: n,
    noUninitializedPrivateFieldAccess: i,
    noDocumentAll: a,
    innerBinding: o
  }, l) {
    if (!r.size) return;
    let u = t.get("body"), c = n ? $ye : Vye;
    (0, Bye.default)(u, Rye, Object.assign({
      privateNamesMap: r,
      classRef: e,
      file: l
    }, c, {
      noDocumentAll: a,
      noUninitializedPrivateFieldAccess: i,
      innerBinding: o
    })), u.traverse(qye, {
      privateNamesMap: r,
      classRef: e,
      file: l,
      privateFieldsAsProperties: n,
      innerBinding: o
    });
  }
  s(Wye, "transformPrivateNamesUsage");
  function JI(e, t, r) {
    let {
      id: n
    } = r.get(t.node.key.id.name), i = t.node.value || t.scope.buildUndefinedNode();
    return Ut(B.template.statement.ast`
      Object.defineProperty(${e}, ${B.types.cloneNode(n)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${i}
      });
    `, t);
  }
  s(JI, "buildPrivateFieldInitLoose");
  function Kye(e, t, r, n) {
    let {
      id: i
    } = r.get(t.node.key.id.name), a = t.node.value || t.scope.buildUndefinedNode();
    if (!n.availableHelper("classPrivateFieldInitSpec"))
      return Ut(B.template.statement.ast`${B.types.cloneNode(i)}.set(${e}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${a},
        })`, t);
    let o = n.addHelper("classPrivateFieldInitSpec");
    return Nb(Ut(B.types.expressionStatement(B.types.callExpression(o, [B.types.thisExpression(), Nb(B.types.cloneNode(i), t.node.key), Qt(n) ?
    a : B.template.expression.ast`{ writable: true, value: ${a} }`])), t), t.node);
  }
  s(Kye, "buildPrivateInstanceFieldInitSpec");
  function Gye(e, t, r) {
    let n = t.get(e.node.key.id.name), i = r ? e.node.value : B.template.expression.ast`{
        _: ${e.node.value || B.types.buildUndefinedNode()}
      }`;
    return Ut(B.types.variableDeclaration("var", [B.types.variableDeclarator(B.types.cloneNode(n.id), i)]), e);
  }
  s(Gye, "buildPrivateStaticFieldInitSpec");
  Ob = /* @__PURE__ */ s(function(e, t) {
    let r = t.get(e.node.key.id.name), {
      id: n,
      getId: i,
      setId: a,
      initAdded: o
    } = r, l = i || a;
    if (!e.isProperty() && (o || !l)) return;
    if (l)
      return t.set(e.node.key.id.name, Object.assign({}, r, {
        initAdded: !0
      })), Ut(B.template.statement.ast`
          var ${B.types.cloneNode(n)} = {
            // configurable is false by default
            // enumerable is false by default
            // writable is false by default
            get: ${i ? i.name : e.scope.buildUndefinedNode()},
            set: ${a ? a.name : e.scope.buildUndefinedNode()}
          }
        `, e);
    let u = e.node.value || e.scope.buildUndefinedNode();
    return Ut(B.template.statement.ast`
        var ${B.types.cloneNode(n)} = {
          // configurable is false by default
          // enumerable is false by default
          writable: true,
          value: ${u}
        };
      `, e);
  }, "buildPrivateStaticFieldInitSpecOld");
  var Ob;
  function Hye(e, t, r) {
    let n = r.get(t.node.key.id.name), {
      methodId: i,
      id: a,
      getId: o,
      setId: l,
      initAdded: u
    } = n;
    if (u) return;
    if (i)
      return Ut(B.template.statement.ast`
        Object.defineProperty(${e}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${i.name}
        });
      `, t);
    if (o || l)
      return r.set(t.node.key.id.name, Object.assign({}, n, {
        initAdded: !0
      })), Ut(B.template.statement.ast`
        Object.defineProperty(${e}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${o ? o.name : t.scope.buildUndefinedNode()},
          set: ${l ? l.name : t.scope.buildUndefinedNode()}
        });
      `, t);
  }
  s(Hye, "buildPrivateMethodInitLoose");
  function Yye(e, t, r, n) {
    let i = r.get(t.node.key.id.name);
    if (!i.initAdded)
      return !Qt(n) && (i.getId || i.setId) ? zye(e, t, r, n) : Jye(e, t, r, n);
  }
  s(Yye, "buildPrivateInstanceMethodInitSpec");
  function zye(e, t, r, n) {
    let i = r.get(t.node.key.id.name), {
      id: a,
      getId: o,
      setId: l
    } = i;
    if (r.set(t.node.key.id.name, Object.assign({}, i, {
      initAdded: !0
    })), !n.availableHelper("classPrivateFieldInitSpec"))
      return Ut(B.template.statement.ast`
          ${a}.set(${e}, {
            get: ${o ? o.name : t.scope.buildUndefinedNode()},
            set: ${l ? l.name : t.scope.buildUndefinedNode()}
          });
        `, t);
    let u = n.addHelper("classPrivateFieldInitSpec");
    return Nb(Ut(B.template.statement.ast`${u}(
      ${B.types.thisExpression()},
      ${B.types.cloneNode(a)},
      {
        get: ${o ? o.name : t.scope.buildUndefinedNode()},
        set: ${l ? l.name : t.scope.buildUndefinedNode()}
      },
    )`, t), t.node);
  }
  s(zye, "buildPrivateAccessorInitialization");
  function Jye(e, t, r, n) {
    let i = r.get(t.node.key.id.name), {
      id: a
    } = i;
    if (!n.availableHelper("classPrivateMethodInitSpec"))
      return Ut(B.template.statement.ast`${a}.add(${e})`, t);
    let o = n.addHelper("classPrivateMethodInitSpec");
    return Ut(B.template.statement.ast`${o}(
      ${B.types.thisExpression()},
      ${B.types.cloneNode(a)}
    )`, t);
  }
  s(Jye, "buildPrivateInstanceMethodInitialization");
  function XI(e, t) {
    let {
      key: r,
      computed: n
    } = t.node, i = t.node.value || t.scope.buildUndefinedNode();
    return Ut(B.types.expressionStatement(B.types.assignmentExpression("=", B.types.memberExpression(e, r, n || B.types.isLiteral(r)), i)), t);
  }
  s(XI, "buildPublicFieldInitLoose");
  function QI(e, t, r) {
    let {
      key: n,
      computed: i
    } = t.node, a = t.node.value || t.scope.buildUndefinedNode();
    return Ut(B.types.expressionStatement(B.types.callExpression(r.addHelper("defineProperty"), [e, i || B.types.isLiteral(n) ? n : B.types.
    stringLiteral(n.name), a])), t);
  }
  s(QI, "buildPublicFieldInitSpec");
  function Xye(e, t, r, n) {
    let i = n.get(t.node.key.id.name), {
      id: a,
      methodId: o,
      getId: l,
      setId: u,
      initAdded: c
    } = i;
    return c ? void 0 : l || u ? (n.set(t.node.key.id.name, Object.assign({}, i, {
      initAdded: !0
    })), Ut(B.template.statement.ast`
        Object.defineProperty(${e}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${l ? l.name : t.scope.buildUndefinedNode()},
          set: ${u ? u.name : t.scope.buildUndefinedNode()}
        })
      `, t)) : Ut(B.template.statement.ast`
      Object.defineProperty(${e}, ${a}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${o.name}
      });
    `, t);
  }
  s(Xye, "buildPrivateStaticMethodInitLoose");
  function Tf(e, t, r, n = !1) {
    let i = r.get(t.node.key.id.name), {
      id: a,
      methodId: o,
      getId: l,
      setId: u,
      getterDeclared: c,
      setterDeclared: f,
      static: p
    } = i, {
      params: h,
      body: y,
      generator: v,
      async: d
    } = t.node, b = l && h.length === 0, E = u && h.length > 0;
    if (b && c || E && f)
      return r.set(t.node.key.id.name, Object.assign({}, i, {
        initAdded: !0
      })), null;
    if (Qt(e) && (b || E) && !n) {
      let O = t.get("body").scope, k = O.generateUidIdentifier("this"), j = {
        thisRef: k,
        argumentsPath: []
      };
      if (t.traverse(t_, j), j.argumentsPath.length) {
        let R = O.generateUidIdentifier("arguments");
        O.push({
          id: R,
          init: B.template.expression.ast`[].slice.call(arguments, 1)`
        });
        for (let U of j.argumentsPath)
          U.replaceWith(B.types.cloneNode(R));
      }
      h.unshift(B.types.cloneNode(k));
    }
    let I = o;
    return b ? (r.set(t.node.key.id.name, Object.assign({}, i, {
      getterDeclared: !0,
      initAdded: !0
    })), I = l) : E ? (r.set(t.node.key.id.name, Object.assign({}, i, {
      setterDeclared: !0,
      initAdded: !0
    })), I = u) : p && !n && (I = a), Ut(B.types.functionDeclaration(B.types.cloneNode(I), h, y, v, d), t);
  }
  s(Tf, "buildPrivateMethodDeclaration");
  var t_ = B.traverse.visitors.merge([{
    Identifier(e, t) {
      t.argumentsPath && e.node.name === "arguments" && t.argumentsPath.push(e);
    },
    UnaryExpression(e) {
      let {
        node: t
      } = e;
      if (t.operator === "delete") {
        let r = (0, Fye.skipTransparentExprWrapperNodes)(t.argument);
        B.types.isThisExpression(r) && e.replaceWith(B.types.booleanLiteral(!0));
      }
    },
    ThisExpression(e, t) {
      t.needsClassRef = !0, e.replaceWith(B.types.cloneNode(t.thisRef));
    },
    MetaProperty(e) {
      let {
        node: t,
        scope: r
      } = e;
      t.meta.name === "new" && t.property.name === "target" && e.replaceWith(r.buildUndefinedNode());
    }
  }, ZI.default]), Qye = {
    ReferencedIdentifier(e, t) {
      e.scope.bindingIdentifierEquals(e.node.name, t.innerBinding) && (t.needsClassRef = !0, e.node.name = t.thisRef.name);
    }
  };
  function Zye(e, t, r) {
    var n;
    let i = {
      thisRef: t,
      needsClassRef: !1,
      innerBinding: r
    };
    return e.isMethod() || e.traverse(t_, i), r != null && (n = i.thisRef) != null && n.name && i.thisRef.name !== r.name && e.traverse(Qye,
    i), i.needsClassRef;
  }
  s(Zye, "replaceThisContext");
  function e0e({
    key: e,
    computed: t
  }) {
    return e.type === "Identifier" ? !t && (e.name === "name" || e.name === "length") : e.type === "StringLiteral" ? e.value === "name" || e.
    value === "length" : !1;
  }
  s(e0e, "isNameOrLength");
  function Ut(e, t) {
    return B.types.inheritLeadingComments(e, t.node), B.types.inheritInnerComments(e, t.node), e;
  }
  s(Ut, "inheritPropComments");
  function Nb(e, t) {
    return e.start = t.start, e.end = t.end, e.loc = t.loc, e;
  }
  s(Nb, "inheritLoc");
  function t0e(e, t, r, n, i, a, o, l, u, c) {
    var f, p;
    let h = 0, y, v = [], d = [], b = !1, E = [], I = null, O = B.types.isIdentifier(t) ? () => t : () => {
      var j;
      return (j = y) != null || (y = r[0].scope.generateUidIdentifierBasedOnNode(t)), y;
    }, k = (f = e) != null ? f : r[0].scope.generateUidIdentifier(c?.name || "Class");
    (p = e) != null || (e = B.types.cloneNode(c));
    for (let j of r) {
      j.isClassProperty() && jye.assertFieldTransformed(j);
      let R = !(B.types.isStaticBlock != null && B.types.isStaticBlock(j.node)) && j.node.static, U = !R, Q = j.isPrivate(), W = !Q, q = j.isProperty(),
      M = !q, K = j.isStaticBlock == null ? void 0 : j.isStaticBlock();
      switch (R && (h |= 1), (R || M && Q || K) && (new Nye.default({
        methodPath: j,
        constantSuper: u,
        file: i,
        refToPreserve: c,
        getSuperRef: O,
        getObjectRef() {
          return h |= 2, R || K ? k : B.types.memberExpression(k, B.types.identifier("prototype"));
        }
      }).replace(), Zye(j, k, c) && (h |= 2)), b = !1, !0) {
        case K: {
          let pe = j.node.body;
          pe.length === 1 && B.types.isExpressionStatement(pe[0]) ? v.push(Ut(pe[0], j)) : v.push(B.types.inheritsComments(B.template.statement.
          ast`(() => { ${pe} })()`, j.node));
          break;
        }
        case (R && Q && q && o):
          v.push(JI(B.types.cloneNode(e), j, n));
          break;
        case (R && Q && q && !o):
          Qt(i) ? v.push(Gye(j, n, l)) : v.push(Ob(j, n));
          break;
        case (R && W && q && a):
          if (!e0e(j.node)) {
            v.push(XI(B.types.cloneNode(e), j));
            break;
          }
        case (R && W && q && !a):
          v.push(QI(B.types.cloneNode(e), j, i));
          break;
        case (U && Q && q && o):
          d.push(JI(B.types.thisExpression(), j, n));
          break;
        case (U && Q && q && !o):
          d.push(Kye(B.types.thisExpression(), j, n, i));
          break;
        case (U && Q && M && o):
          d.unshift(Hye(B.types.thisExpression(), j, n)), E.push(Tf(i, j, n, o));
          break;
        case (U && Q && M && !o):
          d.unshift(Yye(B.types.thisExpression(), j, n, i)), E.push(Tf(i, j, n, o));
          break;
        case (R && Q && M && !o):
          Qt(i) || v.unshift(Ob(j, n)), E.push(Tf(i, j, n, o));
          break;
        case (R && Q && M && o):
          v.unshift(Xye(B.types.cloneNode(e), j, i, n)), E.push(Tf(i, j, n, o));
          break;
        case (U && W && q && a):
          d.push(XI(B.types.thisExpression(), j));
          break;
        case (U && W && q && !a):
          b = !0, d.push(QI(B.types.thisExpression(), j, i));
          break;
        default:
          throw new Error("Unreachable.");
      }
    }
    return h & 2 && c != null && (I = B.types.expressionStatement(B.types.assignmentExpression("=", B.types.cloneNode(k), B.types.cloneNode(
    c)))), {
      staticNodes: v.filter(Boolean),
      instanceNodes: d.filter(Boolean),
      lastInstanceNodeReturnsThis: b,
      pureStaticNodes: E.filter(Boolean),
      classBindingNode: I,
      wrapClass(j) {
        for (let R of r)
          R.node.leadingComments = null, R.remove();
        return y && (j.scope.push({
          id: B.types.cloneNode(y)
        }), j.set("superClass", B.types.assignmentExpression("=", y, j.node.superClass))), h !== 0 && (j.isClassExpression() ? (j.scope.push(
        {
          id: e
        }), j.replaceWith(B.types.assignmentExpression("=", B.types.cloneNode(e), j.node))) : (c == null && (j.node.id = e), I != null && j.
        scope.push({
          id: k
        }))), j;
      }
    };
  }
  s(t0e, "buildFieldsInitNodes");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/misc.js
var Fb = T((Qo) => {
  "use strict";
  Object.defineProperty(Qo, "__esModule", {
    value: !0
  });
  Qo.extractComputedKeys = o0e;
  Qo.injectInitialization = a0e;
  Qo.memoiseComputedKey = n_;
  var Et = bt(), r0e = Ho(), n0e = Et.traverse.visitors.merge([{
    Super(e) {
      let {
        node: t,
        parentPath: r
      } = e;
      r.isCallExpression({
        callee: t
      }) && this.push(r);
    }
  }, r0e.default]), s0e = {
    "TSTypeAnnotation|TypeAnnotation"(e) {
      e.skip();
    },
    ReferencedIdentifier(e, {
      scope: t
    }) {
      t.hasOwnBinding(e.node.name) && (t.rename(e.node.name), e.skip());
    }
  };
  function r_(e, t) {
    if (t.classBinding && t.classBinding === e.scope.getBinding(e.node.name)) {
      let r = t.file.addHelper("classNameTDZError"), n = Et.types.callExpression(r, [Et.types.stringLiteral(e.node.name)]);
      e.replaceWith(Et.types.sequenceExpression([n, e.node])), e.skip();
    }
  }
  s(r_, "handleClassTDZ");
  var i0e = {
    ReferencedIdentifier: r_
  };
  function a0e(e, t, r, n, i) {
    if (!r.length) return;
    let a = !!e.node.superClass;
    if (!t) {
      let o = Et.types.classMethod("constructor", Et.types.identifier("constructor"), [], Et.types.blockStatement([]));
      a && (o.params = [Et.types.restElement(Et.types.identifier("args"))], o.body.body.push(Et.template.statement.ast`super(...args)`)), [t] =
      e.get("body").unshiftContainer("body", o);
    }
    if (n && n(s0e, {
      scope: t.scope
    }), a) {
      let o = [];
      t.traverse(n0e, o);
      let l = !0;
      for (let u of o)
        if (l ? l = !1 : r = r.map((c) => Et.types.cloneNode(c)), u.parentPath.isExpressionStatement())
          u.insertAfter(r);
        else {
          let c = [u.node, ...r.map((f) => Et.types.toExpression(f))];
          i || c.push(Et.types.thisExpression()), u.replaceWith(Et.types.sequenceExpression(c));
        }
    } else
      t.get("body").unshiftContainer("body", r);
  }
  s(a0e, "injectInitialization");
  function n_(e, t, r) {
    if (Et.types.isIdentifier(e) && t.hasUid(e.name))
      return;
    if (Et.types.isAssignmentExpression(e, {
      operator: "="
    }) && Et.types.isIdentifier(e.left) && t.hasUid(e.left.name))
      return Et.types.cloneNode(e);
    {
      let a = Et.types.identifier(r);
      return t.push({
        id: a,
        kind: "let"
      }), Et.types.assignmentExpression("=", Et.types.cloneNode(a), e);
    }
  }
  s(n_, "memoiseComputedKey");
  function o0e(e, t, r) {
    let {
      scope: n
    } = e, i = [], a = {
      classBinding: e.node.id && n.getBinding(e.node.id.name),
      file: r
    };
    for (let o of t) {
      let l = o.get("key");
      l.isReferencedIdentifier() ? r_(l, a) : l.traverse(i0e, a);
      let u = o.node;
      if (!l.isConstantExpression()) {
        let c = n_(l.node, n, n.generateUidBasedOnNode(l.node));
        c && (i.push(Et.types.expressionStatement(c)), u.key = Et.types.cloneNode(c.left));
      }
    }
    return i;
  }
  s(o0e, "extractComputedKeys");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js
var E_ = T((Vb) => {
  "use strict";
  Object.defineProperty(Vb, "__esModule", {
    value: !0
  });
  Vb.default = q0e;
  var C = bt(), s_ = Ef(), i_ = db(), Ss = Ab(), m_ = kb(), Sf = Fb();
  function y_(e, t = e.length - 1) {
    if (t === -1) {
      e.unshift(65);
      return;
    }
    let r = e[t];
    r === 90 ? e[t] = 97 : r === 122 ? (e[t] = 65, y_(e, t - 1)) : e[t] = r + 1;
  }
  s(y_, "incrementId");
  function l0e(e) {
    let t = [], r = /* @__PURE__ */ new Set();
    return e.traverse({
      PrivateName(n) {
        r.add(n.node.id.name);
      }
    }), () => {
      let n;
      do
        y_(t), n = String.fromCharCode(...t);
      while (r.has(n));
      return C.types.privateName(C.types.identifier(n));
    };
  }
  s(l0e, "createPrivateUidGeneratorForClass");
  function u0e(e) {
    let t;
    return () => (t || (t = l0e(e)), t());
  }
  s(u0e, "createLazyPrivateUidGeneratorForClass");
  function c0e(e, t) {
    let r = e.node.id, n = e.scope;
    if (e.type === "ClassDeclaration") {
      let i = r.name, a = n.generateUidIdentifierBasedOnNode(r), o = C.types.identifier(i);
      return n.rename(i, a.name), e.get("id").replaceWith(o), {
        id: C.types.cloneNode(a),
        path: e
      };
    } else {
      let i;
      r ? (t = r.name, i = Sr(n.parent, t), n.rename(t, i.name)) : i = Sr(n.parent, typeof t == "string" ? t : "decorated_class");
      let a = C.types.classExpression(typeof t == "string" ? C.types.identifier(t) : null, e.node.superClass, e.node.body), [o] = e.replaceWith(
      C.types.sequenceExpression([a, i]));
      return {
        id: C.types.cloneNode(i),
        path: o.get("expressions.0")
      };
    }
  }
  s(c0e, "replaceClassWithVar");
  function a_(e, t, r) {
    return e.type === "PrivateName" ? C.types.classPrivateProperty(e, t, void 0, r) : C.types.classProperty(e, t, void 0, void 0, r);
  }
  s(a_, "generateClassProperty");
  function jb(e, t) {
    e.node.id || (e.node.id = typeof t == "string" ? C.types.identifier(t) : e.scope.generateUidIdentifier("Class"));
  }
  s(jb, "assignIdForAnonymousClass");
  function o_(e, t, r, n, i, a, o, l) {
    let u = (l === "2023-11" || l === "2023-05") && o ? e : C.types.thisExpression(), c = C.types.blockStatement([C.types.returnStatement(C.
    types.memberExpression(C.types.cloneNode(u), C.types.cloneNode(i)))]), f = C.types.blockStatement([C.types.expressionStatement(C.types.assignmentExpression(
    "=", C.types.memberExpression(C.types.cloneNode(u), C.types.cloneNode(i)), C.types.identifier("v")))]), p, h;
    r.type === "PrivateName" ? (p = C.types.classPrivateMethod("get", r, [], c, o), h = C.types.classPrivateMethod("set", n, [C.types.identifier(
    "v")], f, o)) : (p = C.types.classMethod("get", r, [], c, a, o), h = C.types.classMethod("set", n, [C.types.identifier("v")], f, a, o)),
    t.insertAfter(h), t.insertAfter(p);
  }
  s(o_, "addProxyAccessorsFor");
  function l_(e, t) {
    return t !== "2023-11" && t !== "2023-05" && t !== "2023-01" ? [C.template.expression.ast`
        function () {
          return this.${C.types.cloneNode(e)};
        }
      `, C.template.expression.ast`
        function (value) {
          this.${C.types.cloneNode(e)} = value;
        }
      `] : [C.template.expression.ast`
      o => o.${C.types.cloneNode(e)}
    `, C.template.expression.ast`
      (o, v) => o.${C.types.cloneNode(e)} = v
    `];
  }
  s(l_, "extractProxyAccessorsFor");
  function Ub(e) {
    if (e = (0, Ss.skipTransparentExprWrappers)(e), e.isSequenceExpression()) {
      let t = e.get("expressions");
      return Ub(t[t.length - 1]);
    }
    return e;
  }
  s(Ub, "getComputedKeyLastElement");
  function f0e(e) {
    let t = Ub(e);
    if (t.isConstantExpression())
      return C.types.cloneNode(e.node);
    if (t.isIdentifier() && e.scope.hasUid(t.node.name))
      return C.types.cloneNode(e.node);
    if (t.isAssignmentExpression() && t.get("left").isIdentifier())
      return C.types.cloneNode(t.node.left);
    throw new Error(`Internal Error: the computed key ${e.toString()} has not yet been memoised.`);
  }
  s(f0e, "getComputedKeyMemoiser");
  function Zo(e, t) {
    let r = t.get("key");
    r.isSequenceExpression() ? e.push(...r.node.expressions) : e.push(r.node), r.replaceWith(As(e));
  }
  s(Zo, "prependExpressionsToComputedKey");
  function p0e(e, t) {
    let r = t.get("key"), n = Ub(r);
    if (n.isConstantExpression())
      Zo(e, t);
    else {
      let i = r.scope.parent, a = (0, Sf.memoiseComputedKey)(n.node, i, i.generateUid("computedKey"));
      if (!a)
        Zo(e, t);
      else {
        let o = [...e, C.types.cloneNode(a.left)], l = n.parentPath;
        l.isSequenceExpression() ? l.pushContainer("expressions", o) : n.replaceWith(As([C.types.cloneNode(a), ...o]));
      }
    }
  }
  s(p0e, "appendExpressionsToComputedKey");
  function Lb(e, t) {
    let r = t.get("value");
    r.node ? e.push(r.node) : e.length > 0 && (e[e.length - 1] = C.types.unaryExpression("void", e[e.length - 1])), r.replaceWith(As(e));
  }
  s(Lb, "prependExpressionsToFieldInitializer");
  function d0e(e, t) {
    t.unshiftContainer("body", C.types.expressionStatement(As(e)));
  }
  s(d0e, "prependExpressionsToStaticBlock");
  function h0e(e, t) {
    t.node.body.body.unshift(C.types.expressionStatement(As(e)));
  }
  s(h0e, "prependExpressionsToConstructor");
  function u_(e, t) {
    return C.types.isCallExpression(e) && C.types.isIdentifier(e.callee, {
      name: t.name
    });
  }
  s(u_, "isProtoInitCallExpression");
  function m0e(e, t) {
    if (t) {
      if (e.length >= 2 && u_(e[1], t)) {
        let r = C.types.callExpression(C.types.cloneNode(t), [e[0]]);
        e.splice(0, 2, r);
      }
      e.length >= 2 && C.types.isThisExpression(e[e.length - 1]) && u_(e[e.length - 2], t) && e.splice(e.length - 1, 1);
    }
    return As(e);
  }
  s(m0e, "optimizeSuperCallAndExpressions");
  function y0e(e, t, r) {
    t.traverse({
      CallExpression: {
        exit(n) {
          if (!n.get("callee").isSuper()) return;
          let i = [n.node, ...e.map((a) => C.types.cloneNode(a))];
          n.isCompletionRecord() && i.push(C.types.thisExpression()), n.replaceWith(m0e(i, r)), n.skip();
        }
      },
      ClassMethod(n) {
        n.node.kind === "constructor" && n.skip();
      }
    });
  }
  s(y0e, "insertExpressionsAfterSuperCallAndOptimize");
  function c_(e, t) {
    let r = [C.types.expressionStatement(As(e))];
    return t && r.unshift(C.types.expressionStatement(C.types.callExpression(C.types.super(), [C.types.spreadElement(C.types.identifier("arg\
s"))]))), C.types.classMethod("constructor", C.types.identifier("constructor"), t ? [C.types.restElement(C.types.identifier("args"))] : [], C.
    types.blockStatement(r));
  }
  s(c_, "createConstructorFromExpressions");
  function f_(e) {
    return C.types.staticBlock([C.types.expressionStatement(As(e))]);
  }
  s(f_, "createStaticBlockFromExpressions");
  var ci = 0, Ps = 1, g0e = 2, g_ = 3, Pf = 4, b0e = 5, E0e = 8, v0e = 16;
  function T0e(e) {
    switch (e.node.type) {
      case "ClassProperty":
      case "ClassPrivateProperty":
        return ci;
      case "ClassAccessorProperty":
        return Ps;
      case "ClassMethod":
      case "ClassPrivateMethod":
        return e.node.kind === "get" ? g_ : e.node.kind === "set" ? Pf : g0e;
    }
  }
  s(T0e, "getElementKind");
  function x0e(e) {
    return [...e.filter((t) => t.isStatic && t.kind >= Ps && t.kind <= Pf), ...e.filter((t) => !t.isStatic && t.kind >= Ps && t.kind <= Pf),
    ...e.filter((t) => t.isStatic && t.kind === ci), ...e.filter((t) => !t.isStatic && t.kind === ci)];
  }
  s(x0e, "toSortedDecoratorInfo");
  function p_(e, t, r) {
    let n = e.length, i = t.some(Boolean), a = [];
    for (let o = 0; o < n; o++)
      (r === "2023-11" || r === "2023-05") && i && a.push(t[o] || C.types.unaryExpression("void", C.types.numericLiteral(0))), a.push(e[o].expression);
    return {
      haveThis: i,
      decs: a
    };
  }
  s(p_, "generateDecorationList");
  function S0e(e, t) {
    return C.types.arrayExpression(e.map((r) => {
      let n = r.kind;
      return r.isStatic && (n += t === "2023-11" || t === "2023-05" ? E0e : b0e), r.decoratorsHaveThis && (n += v0e), C.types.arrayExpression(
      [r.decoratorsArray, C.types.numericLiteral(n), r.name, ...r.privateMethods || []]);
    }));
  }
  s(S0e, "generateDecorationExprs");
  function P0e(e) {
    let t = [];
    for (let r of e) {
      let {
        locals: n
      } = r;
      Array.isArray(n) ? t.push(...n) : n !== void 0 && t.push(n);
    }
    return t;
  }
  s(P0e, "extractElementLocalAssignments");
  function A0e(e, t, r, n, i, a) {
    t.insertAfter(C.types.classPrivateMethod("get", C.types.cloneNode(r), [], C.types.blockStatement([C.types.returnStatement(C.types.callExpression(
    C.types.cloneNode(n), e === "2023-11" && a ? [] : [C.types.thisExpression()]))]), a)), t.insertAfter(C.types.classPrivateMethod("set", C.
    types.cloneNode(r), [C.types.identifier("v")], C.types.blockStatement([C.types.expressionStatement(C.types.callExpression(C.types.cloneNode(
    i), e === "2023-11" && a ? [C.types.identifier("v")] : [C.types.thisExpression(), C.types.identifier("v")]))]), a));
  }
  s(A0e, "addCallAccessorsFor");
  function C0e(e, t, r, n) {
    let i, a;
    e.node.kind === "set" ? (i = [C.types.identifier("v")], a = [C.types.expressionStatement(C.types.callExpression(r, [C.types.thisExpression(),
    C.types.identifier("v")]))]) : (i = [], a = [C.types.returnStatement(C.types.callExpression(r, [C.types.thisExpression()]))]), e.replaceWith(
    C.types.classPrivateMethod(e.node.kind, C.types.cloneNode(t), i, C.types.blockStatement(a), n));
  }
  s(C0e, "movePrivateAccessor");
  function d_(e) {
    let {
      type: t
    } = e;
    return t !== "TSDeclareMethod" && t !== "TSIndexSignature" && t !== "StaticBlock";
  }
  s(d_, "isClassDecoratableElementPath");
  function w0e(e) {
    return C.types.callExpression(C.types.arrowFunctionExpression([], C.types.blockStatement(e.body)), []);
  }
  s(w0e, "staticBlockToIIFE");
  function D0e(e) {
    return C.types.functionExpression(null, [], C.types.blockStatement(e.body));
  }
  s(D0e, "staticBlockToFunctionClosure");
  function I0e(e) {
    return C.types.functionExpression(null, [], C.types.blockStatement([C.types.returnStatement(e)]));
  }
  s(I0e, "fieldInitializerToClosure");
  function As(e) {
    return e.length === 0 ? C.types.unaryExpression("void", C.types.numericLiteral(0)) : e.length === 1 ? e[0] : C.types.sequenceExpression(
    e);
  }
  s(As, "maybeSequenceExpression");
  function h_(e) {
    let {
      params: t,
      body: r,
      generator: n,
      async: i
    } = e;
    return C.types.functionExpression(void 0, t, r, n, i);
  }
  s(h_, "createFunctionExpressionFromPrivateMethod");
  function b_(e, t) {
    return C.types.callExpression(e.addHelper("setFunctionName"), [C.types.thisExpression(), t]);
  }
  s(b_, "createSetFunctionNameCall");
  function qb(e, t) {
    return C.types.callExpression(e.addHelper("toPropertyKey"), [t]);
  }
  s(qb, "createToPropertyKeyCall");
  function Mb(e) {
    return C.types.arrowFunctionExpression([C.types.identifier("_")], C.types.binaryExpression("in", C.types.cloneNode(e), C.types.identifier(
    "_")));
  }
  s(Mb, "createPrivateBrandCheckClosure");
  function _0e(e) {
    try {
      return C.types.traverseFast(e, (t) => {
        if (C.types.isPrivateName(t))
          throw null;
      }), !1;
    } catch {
      return !0;
    }
  }
  s(_0e, "usesPrivateField");
  function O0e(e) {
    let {
      node: t
    } = e;
    t.computed = !0, C.types.isIdentifier(t.key) && (t.key = C.types.stringLiteral(t.key.name));
  }
  s(O0e, "convertToComputedKey");
  function Rb(e, t) {
    let r = !1;
    if (t.length > 0) {
      let n = (0, m_.privateNameVisitorFactory)({
        PrivateName(a, o) {
          o.privateNamesMap.has(a.node.id.name) && (r = !0, a.stop());
        }
      }), i = /* @__PURE__ */ new Map();
      for (let a of t)
        i.set(a, null);
      e.traverse(n, {
        privateNamesMap: i
      });
    }
    return r;
  }
  s(Rb, "hasInstancePrivateAccess");
  function N0e(e, t) {
    let r = (0, m_.privateNameVisitorFactory)({
      PrivateName(i, a) {
        if (!a.privateNamesMap.has(i.node.id.name)) return;
        let o = i.parentPath, l = o.parentPath;
        if (l.node.type === "AssignmentExpression" && l.node.left === o.node || l.node.type === "UpdateExpression" || l.node.type === "RestE\
lement" || l.node.type === "ArrayPattern" || l.node.type === "ObjectProperty" && l.node.value === o.node && l.parentPath.type === "ObjectPat\
tern" || l.node.type === "ForOfStatement" && l.node.left === o.node)
          throw i.buildCodeFrameError(`Decorated private methods are read-only, but "#${i.node.id.name}" is updated via this expression.`);
      }
    }), n = /* @__PURE__ */ new Map();
    for (let i of t)
      n.set(i, null);
    e.traverse(r, {
      privateNamesMap: n
    });
  }
  s(N0e, "checkPrivateMethodUpdateError");
  function B0e(e, t, r, n, i, a, o) {
    var l, u;
    let c = e.get("body.body"), f = e.node.decorators, p = !1, h = !1, y = !1, v = u0e(e), d = [], b = e.scope.parent, E = /* @__PURE__ */ s(
    (ue, re, F) => {
      let V = Sr(b, re);
      return F.push(C.types.assignmentExpression("=", V, ue)), C.types.cloneNode(V);
    }, "memoiseExpression"), I, O, k = (l = e.node.id) == null ? void 0 : l.name, j = typeof i == "object" ? i : void 0, R = /* @__PURE__ */ s(
    (ue) => {
      try {
        return C.types.traverseFast(ue, (re) => {
          if (C.types.isThisExpression(re) || C.types.isSuper(re) || C.types.isYieldExpression(re) || C.types.isAwaitExpression(re) || C.types.
          isIdentifier(re, {
            name: "arguments"
          }) || k && C.types.isIdentifier(re, {
            name: k
          }) || C.types.isMetaProperty(re) && re.meta.name !== "import")
            throw null;
        }), !1;
      } catch {
        return !0;
      }
    }, "usesFunctionContextOrYieldAwait"), U = [];
    for (let ue of c) {
      if (!d_(ue))
        continue;
      let re = ue.node;
      if (!re.static && C.types.isPrivateName(re.key) && U.push(re.key.id.name), el(re)) {
        switch (re.type) {
          case "ClassProperty":
            a.ClassProperty(ue, t);
            break;
          case "ClassPrivateProperty":
            a.ClassPrivateProperty(ue, t);
            break;
          case "ClassAccessorProperty":
            if (a.ClassAccessorProperty(ue, t), o === "2023-11")
              break;
          default:
            if (re.static) {
              var Q;
              (Q = O) != null || (O = Sr(b, "initStatic"));
            } else {
              var W;
              (W = I) != null || (I = Sr(b, "initProto"));
            }
            break;
        }
        p = !0, y || (y = re.decorators.some(R));
      } else if (re.type === "ClassAccessorProperty") {
        a.ClassAccessorProperty(ue, t);
        let {
          key: F,
          value: V,
          static: H,
          computed: Z
        } = re, de = v(), ce = a_(de, V, H), Ce = ue.get("key"), [Fe] = ue.replaceWith(ce), Ie, je;
        Z && !Ce.isConstantExpression() ? (Ie = (0, Sf.memoiseComputedKey)(qb(t, F), b, b.generateUid("computedKey")), je = C.types.cloneNode(
        Ie.left)) : (Ie = C.types.cloneNode(F), je = C.types.cloneNode(F)), jb(e, i), o_(e.node.id, Fe, Ie, je, de, Z, H, o);
      }
      "computed" in ue.node && ue.node.computed && (h || (h = !b.isStatic(ue.node.key)));
    }
    if (!f && !p) {
      !e.node.id && typeof i == "string" && (e.node.id = C.types.identifier(i)), j && e.node.body.body.unshift(f_([b_(t, j)]));
      return;
    }
    let q = [], M, K = /* @__PURE__ */ new Set(), pe, ae, X = null;
    function J(ue) {
      let re = !1, F = !1, V = [];
      for (let Z of ue) {
        let {
          expression: de
        } = Z, ce;
        if ((o === "2023-11" || o === "2023-05") && C.types.isMemberExpression(de))
          if (C.types.isSuper(de.object))
            ce = C.types.thisExpression();
          else if (b.isStatic(de.object))
            ce = C.types.cloneNode(de.object);
          else {
            var H;
            (H = X) != null || (X = Sr(b, "obj")), ce = C.types.assignmentExpression("=", C.types.cloneNode(X), de.object), de.object = C.types.
            cloneNode(X);
          }
        V.push(ce), re || (re = !b.isStatic(de)), F || (F = R(Z));
      }
      return {
        hasSideEffects: re,
        usesFnContext: F,
        decoratorsThis: V
      };
    }
    s(J, "handleDecorators");
    let ne = h || y || o !== "2023-11", oe = !1, be = 0, Se = [], De, he = [];
    if (f) {
      pe = Sr(b, "initClass"), oe = e.isClassDeclaration(), {
        id: ae,
        path: e
      } = c0e(e, i), e.node.decorators = null;
      let ue = f.some(_0e), {
        hasSideEffects: re,
        usesFnContext: F,
        decoratorsThis: V
      } = J(f), {
        haveThis: H,
        decs: Z
      } = p_(f, V, o);
      if (be = H ? 1 : 0, Se = Z, (F || re && ne || ue) && (De = E(C.types.arrayExpression(Se), "classDecs", d)), !p)
        for (let de of e.get("body.body")) {
          let {
            node: ce
          } = de;
          if ("computed" in ce && ce.computed)
            if (de.isClassProperty({
              static: !0
            })) {
              if (!de.get("key").isConstantExpression()) {
                let Fe = ce.key, Ie = (0, Sf.memoiseComputedKey)(Fe, b, b.generateUid("computedKey"));
                Ie != null && (ce.key = C.types.cloneNode(Ie.left), he.push(Ie));
              }
            } else he.length > 0 && (Zo(he, de), he = []);
        }
    } else
      jb(e, i), ae = C.types.cloneNode(e.node.id);
    let Ne, mt = !1, Oe = [], ke = [];
    if (p) {
      if (I) {
        let ue = C.types.callExpression(C.types.cloneNode(I), [C.types.thisExpression()]);
        Oe.push(ue);
      }
      for (let ue of c) {
        if (!d_(ue)) {
          ke.length > 0 && ue.isStaticBlock() && (d0e(ke, ue), ke = []);
          continue;
        }
        let {
          node: re
        } = ue, F = re.decorators, V = !!(F != null && F.length), H = "computed" in re && re.computed, Z = "computedKey";
        re.key.type === "PrivateName" ? Z = re.key.id.name : !H && re.key.type === "Identifier" && (Z = re.key.name);
        let de, ce;
        if (V) {
          let {
            hasSideEffects: Je,
            usesFnContext: $e,
            decoratorsThis: ut
          } = J(F), {
            decs: vt,
            haveThis: kt
          } = p_(F, ut, o);
          ce = kt, de = vt.length === 1 ? vt[0] : C.types.arrayExpression(vt), ($e || Je && ne) && (de = E(de, Z + "Decs", he));
        }
        if (H && !ue.get("key").isConstantExpression()) {
          let Je = re.key, $e = (0, Sf.memoiseComputedKey)(V ? qb(t, Je) : Je, b, b.generateUid("computedKey"));
          $e != null && (f && ue.isClassProperty({
            static: !0
          }) ? (re.key = C.types.cloneNode($e.left), he.push($e)) : re.key = $e);
        }
        let {
          key: Ce,
          static: Fe
        } = re, Ie = Ce.type === "PrivateName", je = T0e(ue);
        Ie && !Fe && (V && (mt = !0), (C.types.isClassPrivateProperty(re) || !Ne) && (Ne = Ce)), ue.isClassMethod({
          kind: "constructor"
        }) && (M = ue);
        let Ct;
        if (V) {
          let Je, $e;
          if (H ? $e = f0e(ue.get("key")) : Ce.type === "PrivateName" ? $e = C.types.stringLiteral(Ce.id.name) : Ce.type === "Identifier" ? $e =
          C.types.stringLiteral(Ce.name) : $e = C.types.cloneNode(Ce), je === Ps) {
            let {
              value: ut
            } = ue.node, vt = o === "2023-11" && Fe ? [] : [C.types.thisExpression()];
            ut && vt.push(C.types.cloneNode(ut));
            let kt = v(), an = Sr(b, `init_${Z}`), zn = C.types.callExpression(C.types.cloneNode(an), vt), Sa = a_(kt, zn, Fe), [er] = ue.replaceWith(
            Sa);
            if (Ie) {
              Je = l_(kt, o);
              let mi = Sr(b, `get_${Z}`), Pa = Sr(b, `set_${Z}`);
              A0e(o, er, Ce, mi, Pa, Fe), Ct = [an, mi, Pa];
            } else
              jb(e, i), o_(e.node.id, er, C.types.cloneNode(Ce), C.types.isAssignmentExpression(Ce) ? C.types.cloneNode(Ce.left) : C.types.cloneNode(
              Ce), kt, H, Fe, o), Ct = [an];
          } else if (je === ci) {
            let ut = Sr(b, `init_${Z}`), vt = ue.get("value"), kt = o === "2023-11" && Fe ? [] : [C.types.thisExpression()];
            vt.node && kt.push(vt.node), vt.replaceWith(C.types.callExpression(C.types.cloneNode(ut), kt)), Ct = [ut], Ie && (Je = l_(Ce, o));
          } else if (Ie) {
            let ut = Sr(b, `call_${Z}`);
            if (Ct = [ut], new s_.default({
              constantSuper: r,
              methodPath: ue,
              objectRef: ae,
              superRef: e.node.superClass,
              file: t.file,
              refToPreserve: ae
            }).replace(), Je = [h_(ue.node)], je === g_ || je === Pf)
              C0e(ue, C.types.cloneNode(Ce), C.types.cloneNode(ut), Fe);
            else {
              let kt = ue.node;
              e.node.body.body.unshift(C.types.classPrivateProperty(Ce, C.types.cloneNode(ut), [], kt.static)), K.add(Ce.id.name), ue.remove();
            }
          }
          q.push({
            kind: je,
            decoratorsArray: de,
            decoratorsHaveThis: ce,
            name: $e,
            isStatic: Fe,
            privateMethods: Je,
            locals: Ct
          }), ue.node && (ue.node.decorators = null);
        }
        if (H && he.length > 0 && (f && ue.isClassProperty({
          static: !0
        }) || (Zo(he, je === Ps ? ue.getNextSibling() : ue), he = [])), Oe.length > 0 && !Fe && (je === ci || je === Ps) && (Lb(Oe, ue), Oe =
        []), ke.length > 0 && Fe && (je === ci || je === Ps) && (Lb(ke, ue), ke = []), V && o === "2023-11" && (je === ci || je === Ps)) {
          let Je = Sr(b, `init_extra_${Z}`);
          Ct.push(Je);
          let $e = C.types.callExpression(C.types.cloneNode(Je), Fe ? [] : [C.types.thisExpression()]);
          Fe ? ke.push($e) : Oe.push($e);
        }
      }
    }
    if (he.length > 0) {
      let ue = e.get("body.body"), re;
      for (let F = ue.length - 1; F >= 0; F--) {
        let V = ue[F], H = V.node;
        if (H.computed) {
          if (f && C.types.isClassProperty(H, {
            static: !0
          }))
            continue;
          re = V;
          break;
        }
      }
      re != null && (p0e(he, re), he = []);
    }
    if (Oe.length > 0) {
      let ue = !!e.node.superClass;
      M ? ue ? y0e(Oe, M, I) : h0e(Oe, M) : e.node.body.body.unshift(c_(Oe, ue)), Oe = [];
    }
    ke.length > 0 && (e.node.body.body.push(f_(ke)), ke = []);
    let ft = x0e(q), Nt = S0e(o === "2023-11" ? q : ft, o), Zt = P0e(ft);
    I && Zt.push(I), O && Zt.push(O);
    let Bt = [], Dt = !1, pr = pe && C.types.callExpression(C.types.cloneNode(pe), []), nn = e, vn = e.node, Vr = [];
    if (f) {
      Bt.push(ae, pe);
      let ue = [];
      if (e.get("body.body").forEach((re) => {
        if (re.isStaticBlock()) {
          if (Rb(re, U)) {
            let F = E(D0e(re.node), "staticBlock", Vr);
            ke.push(C.types.callExpression(C.types.memberExpression(F, C.types.identifier("call")), [C.types.thisExpression()]));
          } else
            ke.push(w0e(re.node));
          re.remove();
          return;
        }
        if ((re.isClassProperty() || re.isClassPrivateProperty()) && re.node.static) {
          let F = re.get("value");
          if (Rb(F, U)) {
            let V = E(I0e(F.node), "fieldValue", Vr);
            F.replaceWith(C.types.callExpression(C.types.memberExpression(V, C.types.identifier("call")), [C.types.thisExpression()]));
          }
          ke.length > 0 && (Lb(ke, re), ke = []), re.node.static = !1, ue.push(re.node), re.remove();
        } else if (re.isClassPrivateMethod({
          static: !0
        })) {
          if (Rb(re, U)) {
            new s_.default({
              constantSuper: r,
              methodPath: re,
              objectRef: ae,
              superRef: e.node.superClass,
              file: t.file,
              refToPreserve: ae
            }).replace();
            let V = E(h_(re.node), re.get("key.id").node.name, Vr);
            n ? (re.node.params = [C.types.restElement(C.types.identifier("arg"))], re.node.body = C.types.blockStatement([C.types.returnStatement(
            C.types.callExpression(C.types.memberExpression(V, C.types.identifier("apply")), [C.types.thisExpression(), C.types.identifier("\
arg")]))])) : (re.node.params = re.node.params.map((H, Z) => C.types.isRestElement(H) ? C.types.restElement(C.types.identifier("arg")) : C.types.
            identifier("_" + Z)), re.node.body = C.types.blockStatement([C.types.returnStatement(C.types.callExpression(C.types.memberExpression(
            V, C.types.identifier("apply")), [C.types.thisExpression(), C.types.identifier("arguments")]))]));
          }
          re.node.static = !1, ue.push(re.node), re.remove();
        }
      }), ue.length > 0 || ke.length > 0) {
        let re = C.template.expression.ast`
        class extends ${t.addHelper("identity")} {}
      `;
        re.body.body = [C.types.classProperty(C.types.toExpression(vn), void 0, void 0, void 0, !0, !0), ...ue];
        let F = [], V = C.types.newExpression(re, []);
        ke.length > 0 && F.push(...ke), pr && (Dt = !0, F.push(pr)), F.length > 0 ? (F.unshift(C.types.callExpression(C.types.super(), [C.types.
        cloneNode(ae)])), re.body.body.push(c_(F, !1))) : V.arguments.push(C.types.cloneNode(ae));
        let [H] = e.replaceWith(V);
        nn = H.get("callee").get("body").get("body.0.key");
      }
    }
    !Dt && pr && e.node.body.body.push(C.types.staticBlock([C.types.expressionStatement(pr)]));
    let {
      superClass: sn
    } = vn;
    if (sn && (o === "2023-11" || o === "2023-05")) {
      let ue = e.scope.maybeGenerateMemoised(sn);
      ue && (vn.superClass = C.types.assignmentExpression("=", ue, sn), sn = ue);
    }
    let Yn = C.types.staticBlock([]);
    vn.body.body.unshift(Yn);
    let Tn = Yn.body;
    if (he.length > 0) {
      let ue = nn.get("body.body"), re;
      for (let F of ue)
        if ((F.isClassProperty() || F.isClassMethod()) && F.node.kind !== "constructor") {
          re = F;
          break;
        }
      re != null ? (O0e(re), Zo(he, re)) : (vn.body.body.unshift(C.types.classProperty(C.types.sequenceExpression([...he, C.types.stringLiteral(
      "_")]), void 0, void 0, void 0, !0, !0)), Tn.push(C.types.expressionStatement(C.types.unaryExpression("delete", C.types.memberExpression(
      C.types.thisExpression(), C.types.identifier("_")))))), he = [];
    }
    if (Tn.push(C.types.expressionStatement(k0e(Zt, Bt, Nt, (u = De) != null ? u : C.types.arrayExpression(Se), C.types.numericLiteral(be), mt ?
    Ne : null, j, C.types.cloneNode(sn), t, o))), O && Tn.push(C.types.expressionStatement(C.types.callExpression(C.types.cloneNode(O), [C.types.
    thisExpression()]))), Vr.length > 0 && Tn.push(...Vr.map((ue) => C.types.expressionStatement(ue))), e.insertBefore(d.map((ue) => C.types.
    expressionStatement(ue))), oe)
      if (!b.getBinding(ae.name).constantViolations.length)
        e.insertBefore(C.types.variableDeclaration("let", [C.types.variableDeclarator(C.types.cloneNode(ae))]));
      else {
        let re = b.generateUidIdentifier("t" + ae.name), F = ae;
        e.replaceWithMultiple([C.types.variableDeclaration("let", [C.types.variableDeclarator(C.types.cloneNode(F)), C.types.variableDeclarator(
        re)]), C.types.blockStatement([C.types.variableDeclaration("let", [C.types.variableDeclarator(C.types.cloneNode(ae))]), e.node, C.types.
        expressionStatement(C.types.assignmentExpression("=", C.types.cloneNode(re), C.types.cloneNode(ae)))]), C.types.expressionStatement(
        C.types.assignmentExpression("=", C.types.cloneNode(F), C.types.cloneNode(re)))]);
      }
    return K.size > 0 && N0e(e, K), e.scope.crawl(), e;
  }
  s(B0e, "transformClass");
  function k0e(e, t, r, n, i, a, o, l, u, c) {
    let f, p, h = [o ? b_(u, o) : C.types.thisExpression(), n, r];
    {
      if (c !== "2023-11" && h.splice(1, 2, r, n), c === "2021-12" || c === "2022-03" && !u.availableHelper("applyDecs2203R"))
        return f = C.types.arrayPattern([...e, ...t]), p = C.types.callExpression(u.addHelper(c === "2021-12" ? "applyDecs" : "applyDecs2203"),
        h), C.types.assignmentExpression("=", f, p);
      c === "2022-03" ? p = C.types.callExpression(u.addHelper("applyDecs2203R"), h) : c === "2023-01" ? (a && h.push(Mb(a)), p = C.types.callExpression(
      u.addHelper("applyDecs2301"), h)) : c === "2023-05" && ((a || l || i.value !== 0) && h.push(i), a ? h.push(Mb(a)) : l && h.push(C.types.
      unaryExpression("void", C.types.numericLiteral(0))), l && h.push(l), p = C.types.callExpression(u.addHelper("applyDecs2305"), h));
    }
    return c === "2023-11" && ((a || l || i.value !== 0) && h.push(i), a ? h.push(Mb(a)) : l && h.push(C.types.unaryExpression("void", C.types.
    numericLiteral(0))), l && h.push(l), p = C.types.callExpression(u.addHelper("applyDecs2311"), h)), e.length > 0 ? t.length > 0 ? f = C.types.
    objectPattern([C.types.objectProperty(C.types.identifier("e"), C.types.arrayPattern(e)), C.types.objectProperty(C.types.identifier("c"),
    C.types.arrayPattern(t))]) : (f = C.types.arrayPattern(e), p = C.types.memberExpression(p, C.types.identifier("e"), !1, !1)) : (f = C.types.
    arrayPattern(t), p = C.types.memberExpression(p, C.types.identifier("c"), !1, !1)), C.types.assignmentExpression("=", f, p);
  }
  s(k0e, "createLocalsAssignment");
  function F0e(e) {
    return e.type === "Identifier" ? e.name === "__proto__" : e.value === "__proto__";
  }
  s(F0e, "isProtoKey");
  function el(e) {
    return e.decorators && e.decorators.length > 0;
  }
  s(el, "isDecorated");
  function j0e(e) {
    switch (e.type) {
      case "ClassAccessorProperty":
        return !0;
      case "ClassMethod":
      case "ClassProperty":
      case "ClassPrivateMethod":
      case "ClassPrivateProperty":
        return el(e);
      default:
        return !1;
    }
  }
  s(j0e, "shouldTransformElement");
  function L0e(e) {
    return el(e) || e.body.body.some(j0e);
  }
  s(L0e, "shouldTransformClass");
  function M0e(e, t) {
    function r(n, i, a) {
      switch (i.type) {
        case "StringLiteral":
          return C.types.stringLiteral(i.value);
        case "NumericLiteral":
        case "BigIntLiteral": {
          let o = i.value + "";
          return n.get("key").replaceWith(C.types.stringLiteral(o)), C.types.stringLiteral(o);
        }
        default: {
          let o = n.scope.maybeGenerateMemoised(i);
          return n.get("key").replaceWith(C.types.assignmentExpression("=", o, qb(a, i))), C.types.cloneNode(o);
        }
      }
    }
    return s(r, "handleComputedProperty"), {
      VariableDeclarator(n, i) {
        let a = n.node.id;
        if (a.type === "Identifier") {
          let o = (0, Ss.skipTransparentExprWrappers)(n.get("init"));
          if (e(o)) {
            let l = a.name;
            t(o, i, l);
          }
        }
      },
      AssignmentExpression(n, i) {
        let a = n.node.left;
        if (a.type === "Identifier") {
          let o = (0, Ss.skipTransparentExprWrappers)(n.get("right"));
          if (e(o))
            switch (n.node.operator) {
              case "=":
              case "&&=":
              case "||=":
              case "??=":
                t(o, i, a.name);
            }
        }
      },
      AssignmentPattern(n, i) {
        let a = n.node.left;
        if (a.type === "Identifier") {
          let o = (0, Ss.skipTransparentExprWrappers)(n.get("right"));
          if (e(o)) {
            let l = a.name;
            t(o, i, l);
          }
        }
      },
      ObjectExpression(n, i) {
        for (let a of n.get("properties")) {
          if (!a.isObjectProperty()) continue;
          let {
            node: o
          } = a, l = o.key, u = (0, Ss.skipTransparentExprWrappers)(a.get("value"));
          if (e(u)) {
            if (o.computed) {
              let c = r(a, l, i);
              t(u, i, c);
            } else if (!F0e(l))
              if (l.type === "Identifier")
                t(u, i, l.name);
              else {
                let c = C.types.stringLiteral(l.value + "");
                t(u, i, c);
              }
          }
        }
      },
      ClassPrivateProperty(n, i) {
        let {
          node: a
        } = n, o = (0, Ss.skipTransparentExprWrappers)(n.get("value"));
        if (e(o)) {
          let l = C.types.stringLiteral("#" + a.key.id.name);
          t(o, i, l);
        }
      },
      ClassAccessorProperty(n, i) {
        let {
          node: a
        } = n, o = a.key, l = (0, Ss.skipTransparentExprWrappers)(n.get("value"));
        if (e(l))
          if (a.computed) {
            let u = r(n, o, i);
            t(l, i, u);
          } else if (o.type === "Identifier")
            t(l, i, o.name);
          else if (o.type === "PrivateName") {
            let u = C.types.stringLiteral("#" + o.id.name);
            t(l, i, u);
          } else {
            let u = C.types.stringLiteral(o.value + "");
            t(l, i, u);
          }
      },
      ClassProperty(n, i) {
        let {
          node: a
        } = n, o = a.key, l = (0, Ss.skipTransparentExprWrappers)(n.get("value"));
        if (e(l))
          if (a.computed) {
            let u = r(n, o, i);
            t(l, i, u);
          } else if (o.type === "Identifier")
            t(l, i, o.name);
          else {
            let u = C.types.stringLiteral(o.value + "");
            t(l, i, u);
          }
      }
    };
  }
  s(M0e, "NamedEvaluationVisitoryFactory");
  function R0e(e) {
    return e.isClassExpression({
      id: null
    }) && L0e(e.node);
  }
  s(R0e, "isDecoratedAnonymousClassExpression");
  function Sr(e, t) {
    let r = e.generateUidIdentifier(t);
    return e.push({
      id: r,
      kind: "let"
    }), C.types.cloneNode(r);
  }
  s(Sr, "generateLetUidIdentifier");
  function q0e({
    assertVersion: e,
    assumption: t
  }, {
    loose: r
  }, n, i) {
    var a, o;
    e(n === "2023-11" || n === "2023-05" || n === "2023-01" ? "^7.21.0" : n === "2021-12" ? "^7.16.0" : "^7.19.0");
    let l = /* @__PURE__ */ new WeakSet(), u = (a = t("constantSuper")) != null ? a : r, c = (o = t("ignoreFunctionLength")) != null ? o : r,
    f = M0e(R0e, p);
    function p(h, y, v) {
      var d, b;
      if (l.has(h)) return;
      let {
        node: E
      } = h;
      (d = v) != null || (v = (b = E.id) == null ? void 0 : b.name);
      let I = B0e(h, y, u, c, v, f, n);
      if (I) {
        l.add(I);
        return;
      }
      l.add(h);
    }
    return s(p, "visitClass"), {
      name: "proposal-decorators",
      inherits: i,
      visitor: Object.assign({
        ExportDefaultDeclaration(h, y) {
          let {
            declaration: v
          } = h.node;
          if (v?.type === "ClassDeclaration" && el(v)) {
            let d = !v.id, b = (0, i_.default)(h);
            d && p(b, y, C.types.stringLiteral("default"));
          }
        },
        ExportNamedDeclaration(h) {
          let {
            declaration: y
          } = h.node;
          y?.type === "ClassDeclaration" && el(y) && (0, i_.default)(h);
        },
        Class(h, y) {
          p(h, y, void 0);
        }
      }, f)
    };
  }
  s(q0e, "_default");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js
var Wb = T((tl) => {
  "use strict";
  Object.defineProperty(tl, "__esModule", {
    value: !0
  });
  tl.buildDecoratedClass = Y0e;
  tl.hasDecorators = $0e;
  tl.hasOwnDecorators = $b;
  var lt = bt(), U0e = Ef(), V0e = ub();
  function $b(e) {
    var t;
    return !!((t = e.decorators) != null && t.length);
  }
  s($b, "hasOwnDecorators");
  function $0e(e) {
    return $b(e) || e.body.body.some($b);
  }
  s($0e, "hasDecorators");
  function ha(e, t) {
    return t ? lt.types.objectProperty(lt.types.identifier(e), t) : null;
  }
  s(ha, "prop");
  function W0e(e, t) {
    return lt.types.objectMethod("method", lt.types.identifier(e), [], lt.types.blockStatement(t));
  }
  s(W0e, "method");
  function v_(e) {
    let t;
    return e.decorators && e.decorators.length > 0 && (t = lt.types.arrayExpression(e.decorators.map((r) => r.expression))), e.decorators = void 0,
    t;
  }
  s(v_, "takeDecorators");
  function K0e(e) {
    return e.computed ? e.key : lt.types.isIdentifier(e.key) ? lt.types.stringLiteral(e.key.name) : lt.types.stringLiteral(String(e.key.value));
  }
  s(K0e, "getKey");
  function G0e(e, t, r, n) {
    let i = n.isClassMethod();
    if (n.isPrivate())
      throw n.buildCodeFrameError(`Private ${i ? "methods" : "fields"} in decorated classes are not supported yet.`);
    if (n.node.type === "ClassAccessorProperty")
      throw n.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-1\
2" } instead.');
    if (n.node.type === "StaticBlock")
      throw n.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } i\
nstead.');
    let {
      node: a,
      scope: o
    } = n;
    n.isTSDeclareMethod() || new U0e.default({
      methodPath: n,
      objectRef: t,
      superRef: r,
      file: e,
      refToPreserve: t
    }).replace();
    let l = [ha("kind", lt.types.stringLiteral(lt.types.isClassMethod(a) ? a.kind : "field")), ha("decorators", v_(a)), ha("static", a.static &&
    lt.types.booleanLiteral(!0)), ha("key", K0e(a))].filter(Boolean);
    if (lt.types.isClassMethod(a)) {
      let u = a.computed ? null : a.key, c = lt.types.toExpression(a);
      l.push(ha("value", (0, V0e.default)({
        node: c,
        id: u,
        scope: o
      }) || c));
    } else lt.types.isClassProperty(a) && a.value ? l.push(W0e("value", lt.template.statements.ast`return ${a.value}`)) : l.push(ha("value",
    o.buildUndefinedNode()));
    return n.remove(), lt.types.objectExpression(l);
  }
  s(G0e, "extractElementDescriptor");
  function H0e(e) {
    return e.addHelper("decorate");
  }
  s(H0e, "addDecorateHelper");
  function Y0e(e, t, r, n) {
    let {
      node: i,
      scope: a
    } = t, o = a.generateUidIdentifier("initialize"), l = i.id && t.isDeclaration(), u = t.isInStrictMode(), {
      superClass: c
    } = i;
    i.type = "ClassDeclaration", i.id || (i.id = lt.types.cloneNode(e));
    let f;
    c && (f = a.generateUidIdentifierBasedOnNode(i.superClass, "super"), i.superClass = f);
    let p = v_(i), h = lt.types.arrayExpression(r.filter((b) => !b.node.abstract && b.node.type !== "TSIndexSignature").map((b) => G0e(n, i.
    id, f, b))), y = lt.template.expression.ast`
    ${H0e(n)}(
      ${p || lt.types.nullLiteral()},
      function (${o}, ${c ? lt.types.cloneNode(f) : null}) {
        ${i}
        return { F: ${lt.types.cloneNode(i.id)}, d: ${h} };
      },
      ${c}
    )
  `;
    u || y.arguments[1].body.directives.push(lt.types.directive(lt.types.directiveLiteral("use strict")));
    let v = y, d = "arguments.1.body.body.0";
    return l && (v = lt.template.statement.ast`let ${e} = ${y}`, d = "declarations.0.init." + d), {
      instanceNodes: [lt.template.statement.ast`
        ${lt.types.cloneNode(o)}(this)
      `],
      wrapClass(b) {
        return b.replaceWith(v), b.get(d);
      }
    };
  }
  s(Y0e, "buildDecoratedClass");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/features.js
var P_ = T((fi) => {
  "use strict";
  Object.defineProperty(fi, "__esModule", {
    value: !0
  });
  fi.FEATURES = void 0;
  fi.enableFeature = z0e;
  fi.isLoose = Hb;
  fi.shouldTransform = J0e;
  var T_ = Wb(), $n = fi.FEATURES = Object.freeze({
    fields: 2,
    privateMethods: 4,
    decorators: 8,
    privateIn: 16,
    staticBlocks: 32
  }), x_ = /* @__PURE__ */ new Map([[$n.fields, "@babel/plugin-transform-class-properties"], [$n.privateMethods, "@babel/plugin-transform-pr\
ivate-methods"], [$n.privateIn, "@babel/plugin-transform-private-property-in-object"]]), Kb = "@babel/plugin-class-features/featuresKey", rl = "\
@babel/plugin-class-features/looseKey";
  Cs = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
  var Cs;
  Gb = /* @__PURE__ */ s(function(e, t) {
    return !!(e.get(Cs) & t);
  }, "canIgnoreLoose");
  var Gb;
  function z0e(e, t, r) {
    (!Wn(e, t) || Gb(e, t)) && (e.set(Kb, e.get(Kb) | t), r === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-\
an-error" ? (Af(e, t, !0), e.set(Cs, e.get(Cs) | t)) : r === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-\
error" ? (Af(e, t, !1), e.set(Cs, e.get(Cs) | t)) : Af(e, t, r));
    let n;
    for (let [a, o] of x_) {
      if (!Wn(e, a) || Gb(e, a)) continue;
      let l = Hb(e, a);
      if (n === !l)
        throw new Error(`'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-p\
rivate-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).

` + S_(e));
      n = l;
      var i = o;
    }
    if (n !== void 0)
      for (let [a, o] of x_)
        Wn(e, a) && Hb(e, a) !== n && (Af(e, a, n), console.warn(`Though the "loose" option was set to "${!n}" in your @babel/preset-env con\
fig, it will not be used for ${o} since the "loose" mode option was set to "${n}" for ${i}.
The "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-\
transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
	["${o}", { "loose": ${n} }]
to the "plugins" section of your Babel config.

` + S_(e)));
  }
  s(z0e, "enableFeature");
  function S_(e) {
    let {
      filename: t
    } = e.opts;
    return (!t || t === "unknown") && (t = "[name of the input file]"), `If you already set the same 'loose' mode for these plugins in your \
config, it's possible that they are enabled multiple times with different options.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${t} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.`;
  }
  s(S_, "getBabelShowConfigForHint");
  function Wn(e, t) {
    return !!(e.get(Kb) & t);
  }
  s(Wn, "hasFeature");
  function Hb(e, t) {
    return !!(e.get(rl) & t);
  }
  s(Hb, "isLoose");
  function Af(e, t, r) {
    r ? e.set(rl, e.get(rl) | t) : e.set(rl, e.get(rl) & ~t), e.set(Cs, e.get(Cs) & ~t);
  }
  s(Af, "setLoose");
  function J0e(e, t) {
    let r = null, n = null, i = null, a = null, o = null;
    (0, T_.hasOwnDecorators)(e.node) && (r = e.get("decorators.0"));
    for (let l of e.get("body.body"))
      !r && (0, T_.hasOwnDecorators)(l.node) && (r = l.get("decorators.0")), !n && l.isClassProperty() && (n = l), !i && l.isClassPrivateProperty() &&
      (i = l), !a && l.isClassPrivateMethod != null && l.isClassPrivateMethod() && (a = l), !o && l.isStaticBlock != null && l.isStaticBlock() &&
      (o = l);
    if (r && i)
      throw i.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
    if (r && a)
      throw a.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
    if (r && !Wn(t, $n.decorators))
      throw e.buildCodeFrameError(`Decorators are not enabled.
If you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-\
properties" and enable loose mode, like so:
	["@babel/plugin-proposal-decorators", { "version": "legacy" }]
	["@babel/plugin-transform-class-properties", { "loose": true }]`);
    if (a && !Wn(t, $n.privateMethods))
      throw a.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your confi\
guration.");
    if ((n || i) && !Wn(t, $n.fields) && !Wn(t, $n.privateMethods))
      throw e.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration\
.");
    if (o && !Wn(t, $n.staticBlocks))
      throw e.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your conf\
iguration.");
    return !!(r || a || o || (n || i) && Wn(t, $n.fields));
  }
  s(J0e, "shouldTransform");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/index.js
var A_ = T((di) => {
  "use strict";
  Object.defineProperty(di, "__esModule", {
    value: !0
  });
  Object.defineProperty(di, "FEATURES", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ma.FEATURES;
    }, "get")
  });
  Object.defineProperty(di, "buildCheckInRHS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return nl.buildCheckInRHS;
    }, "get")
  });
  di.createClassFeaturePlugin = rge;
  Object.defineProperty(di, "enableFeature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ma.enableFeature;
    }, "get")
  });
  Object.defineProperty(di, "injectInitialization", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Jb.injectInitialization;
    }, "get")
  });
  var Yb = bt(), X0e = ub(), Q0e = db(), Z0e = E_(), ege = ie("semver"), nl = kb(), zb = Wb(), Jb = Fb(), ma = P_(), tge = Ib(), pi = "@babe\
l/plugin-class-features/version";
  function rge({
    name: e,
    feature: t,
    loose: r,
    manipulateOptions: n,
    api: i,
    inherits: a,
    decoratorVersion: o
  }) {
    var l;
    if (t & ma.FEATURES.decorators && (o === "2023-11" || o === "2023-05" || o === "2023-01" || o === "2022-03" || o === "2021-12"))
      return (0, Z0e.default)(i, {
        loose: r
      }, o, a);
    {
      var u;
      (u = i) != null || (i = {
        assumption: /* @__PURE__ */ s(() => {
        }, "assumption")
      });
    }
    let c = i.assumption("setPublicClassFields"), f = i.assumption("privateFieldsAsSymbols"), p = i.assumption("privateFieldsAsProperties"),
    h = (l = i.assumption("noUninitializedPrivateFieldAccess")) != null ? l : !1, y = i.assumption("constantSuper"), v = i.assumption("noDoc\
umentAll");
    if (p && f)
      throw new Error('Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.');
    let d = p || f;
    if (r === !0) {
      let b = [];
      c !== void 0 && b.push('"setPublicClassFields"'), p !== void 0 && b.push('"privateFieldsAsProperties"'), f !== void 0 && b.push('"priv\
ateFieldsAsSymbols"'), b.length !== 0 && console.warn(`[${e}]: You are using the "loose: true" option and you are explicitly setting a value\
 for the ${b.join(" and ")} assumption${b.length > 1 ? "s" : ""}. The "loose" option can cause incompatibilities with the other class featur\
es plugins, so it's recommended that you replace it with the following top-level option:
	"assumptions": {
		"setPublicClassFields": true,
		"privateFieldsAsSymbols": true
	}`);
    }
    return {
      name: e,
      manipulateOptions: n,
      inherits: a,
      pre(b) {
        if ((0, ma.enableFeature)(b, t, r), typeof b.get(pi) == "number") {
          b.set(pi, "7.24.7");
          return;
        }
        (!b.get(pi) || ege.lt(b.get(pi), "7.24.7")) && b.set(pi, "7.24.7");
      },
      visitor: {
        Class(b, {
          file: E
        }) {
          var I;
          if (E.get(pi) !== "7.24.7" || !(0, ma.shouldTransform)(b, E)) return;
          let O = b.isClassDeclaration();
          O && (0, tge.assertFieldTransformed)(b);
          let k = (0, ma.isLoose)(E, t), j, R = (0, zb.hasDecorators)(b.node), U = [], Q = [], W = [], q = /* @__PURE__ */ new Set(), M = b.
          get("body");
          for (let Oe of M.get("body")) {
            if ((Oe.isClassProperty() || Oe.isClassMethod()) && Oe.node.computed && W.push(Oe), Oe.isPrivate()) {
              let {
                name: ke
              } = Oe.node.key.id, ft = `get ${ke}`, Nt = `set ${ke}`;
              if (Oe.isClassPrivateMethod()) {
                if (Oe.node.kind === "get") {
                  if (q.has(ft) || q.has(ke) && !q.has(Nt))
                    throw Oe.buildCodeFrameError("Duplicate private field");
                  q.add(ft).add(ke);
                } else if (Oe.node.kind === "set") {
                  if (q.has(Nt) || q.has(ke) && !q.has(ft))
                    throw Oe.buildCodeFrameError("Duplicate private field");
                  q.add(Nt).add(ke);
                }
              } else {
                if (q.has(ke) && !q.has(ft) && !q.has(Nt) || q.has(ke) && (q.has(ft) || q.has(Nt)))
                  throw Oe.buildCodeFrameError("Duplicate private field");
                q.add(ke);
              }
            }
            Oe.isClassMethod({
              kind: "constructor"
            }) ? j = Oe : (Q.push(Oe), (Oe.isProperty() || Oe.isPrivate() || Oe.isStaticBlock != null && Oe.isStaticBlock()) && U.push(Oe));
          }
          if (!U.length && !R) return;
          let K = b.node.id, pe;
          (!K || !O) && ((0, X0e.default)(b), pe = b.scope.generateUidIdentifier(K?.name || "Class"));
          let ae = (I = pe) != null ? I : Yb.types.cloneNode(K), X = (0, nl.buildPrivateNamesMap)(ae.name, d ?? k, U, E), J = (0, nl.buildPrivateNamesNodes)(
          X, p ?? k, f ?? !1, E);
          (0, nl.transformPrivateNamesUsage)(ae, b, X, {
            privateFieldsAsProperties: d ?? k,
            noUninitializedPrivateFieldAccess: h,
            noDocumentAll: v,
            innerBinding: K
          }, E);
          let ne, oe, be, Se, De, he, Ne;
          R ? (oe = De = ne = [], {
            instanceNodes: be,
            wrapClass: Ne
          } = (0, zb.buildDecoratedClass)(ae, b, Q, E)) : (ne = (0, Jb.extractComputedKeys)(b, W, E), {
            staticNodes: oe,
            pureStaticNodes: De,
            instanceNodes: be,
            lastInstanceNodeReturnsThis: Se,
            classBindingNode: he,
            wrapClass: Ne
          } = (0, nl.buildFieldsInitNodes)(pe, b.node.superClass, U, X, E, c ?? k, d ?? k, h, y ?? k, K)), be.length > 0 && (0, Jb.injectInitialization)(
          b, j, be, (Oe, ke) => {
            if (!R)
              for (let ft of U)
                Yb.types.isStaticBlock != null && Yb.types.isStaticBlock(ft.node) || ft.node.static || ft.traverse(Oe, ke);
          }, Se);
          let mt = Ne(b);
          mt.insertBefore([...J, ...ne]), oe.length > 0 && mt.insertAfter(oe), De.length > 0 && mt.find((Oe) => Oe.isStatement() || Oe.isDeclaration()).
          insertAfter(De), he != null && O && mt.insertAfter(he);
        },
        ExportDefaultDeclaration(b, {
          file: E
        }) {
          {
            if (E.get(pi) !== "7.24.7") return;
            let I = b.get("declaration");
            I.isClassDeclaration() && (0, zb.hasDecorators)(I.node) && (I.node.id ? (0, Q0e.default)(b) : I.node.type = "ClassExpression");
          }
        }
      }
    };
  }
  s(rge, "createClassFeaturePlugin");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/enum.js
var Qb = T((Cf) => {
  "use strict";
  Object.defineProperty(Cf, "__esModule", {
    value: !0
  });
  Cf.default = age;
  Cf.translateEnumValues = w_;
  var ya = bt(), nge = ie("assert"), sge = wb(), Xb = /* @__PURE__ */ new WeakMap(), ige = ya.template.expression(`
    (function (ID) {
      ASSIGNMENTS;
      return ID;
    })(INIT)
  `);
  function age(e, t) {
    let {
      node: r,
      parentPath: n
    } = e;
    if (r.declare) {
      e.remove();
      return;
    }
    let i = r.id.name, {
      fill: a,
      data: o,
      isPure: l
    } = cge(e, t, r.id);
    switch (n.type) {
      case "BlockStatement":
      case "ExportNamedDeclaration":
      case "Program": {
        let c = t.isProgram(e.parent), f = u(n), p = t.objectExpression([]);
        (f || c) && (p = t.logicalExpression("||", t.cloneNode(a.ID), p));
        let h = ige(Object.assign({}, a, {
          INIT: p
        }));
        l && (0, sge.default)(h), f ? (n.isExportDeclaration() ? n : e).replaceWith(t.expressionStatement(t.assignmentExpression("=", t.cloneNode(
        r.id), h))) : e.scope.registerDeclaration(e.replaceWith(t.variableDeclaration(c ? "var" : "let", [t.variableDeclarator(r.id, h)]))[0]),
        Xb.set(e.scope.getBindingIdentifier(i), o);
        break;
      }
      default:
        throw new Error(`Unexpected enum parent '${e.parent.type}`);
    }
    function u(c) {
      return c.isExportDeclaration() ? u(c.parentPath) : c.getData(i) ? !0 : (c.setData(i, !0), !1);
    }
    s(u, "seen");
  }
  s(age, "transpileEnum");
  var oge = (0, ya.template)(`
  ENUM["NAME"] = VALUE;
`), lge = (0, ya.template)(`
  ENUM[ENUM["NAME"] = VALUE] = "NAME";
`), uge = /* @__PURE__ */ s((e, t) => (e ? oge : lge)(t), "buildEnumMember");
  function cge(e, t, r) {
    let {
      enumValues: n,
      data: i,
      isPure: a
    } = w_(e, t), o = n.map(([l, u]) => uge(t.isStringLiteral(u), {
      ENUM: t.cloneNode(r),
      NAME: l,
      VALUE: u
    }));
    return {
      fill: {
        ID: t.cloneNode(r),
        ASSIGNMENTS: o
      },
      data: i,
      isPure: a
    };
  }
  s(cge, "enumFill");
  function C_(e, t) {
    let {
      seen: r,
      path: n,
      t: i
    } = t, a = e.node.name;
    r.has(a) && !e.scope.hasOwnBinding(a) && (e.replaceWith(i.memberExpression(i.cloneNode(n.node.id), i.cloneNode(e.node))), e.skip());
  }
  s(C_, "ReferencedIdentifier");
  var fge = {
    ReferencedIdentifier: C_
  };
  function w_(e, t) {
    var r;
    let n = e.scope.getBindingIdentifier(e.node.id.name), i = (r = Xb.get(n)) != null ? r : /* @__PURE__ */ new Map(), a = -1, o, l = !0, u = e.
    get("members").map((c) => {
      let f = c.node, p = t.isIdentifier(f.id) ? f.id.name : f.id.value, h = c.get("initializer"), y = f.initializer, v;
      if (y)
        a = D_(h, i), a !== void 0 ? (i.set(p, a), nge(typeof a == "number" || typeof a == "string"), a === 1 / 0 || Number.isNaN(a) ? v = t.
        identifier(String(a)) : a === -1 / 0 ? v = t.unaryExpression("-", t.identifier("Infinity")) : v = t.valueToNode(a)) : (l && (l = h.isPure()),
        h.isReferencedIdentifier() ? C_(h, {
          t,
          seen: i,
          path: e
        }) : h.traverse(fge, {
          t,
          seen: i,
          path: e
        }), v = h.node, i.set(p, void 0));
      else if (typeof a == "number")
        a += 1, v = t.numericLiteral(a), i.set(p, a);
      else {
        if (typeof a == "string")
          throw e.buildCodeFrameError("Enum member must have initializer.");
        {
          let d = t.memberExpression(t.cloneNode(e.node.id), t.stringLiteral(o), !0);
          v = t.binaryExpression("+", t.numericLiteral(1), d), i.set(p, void 0);
        }
      }
      return o = p, [p, v];
    });
    return {
      isPure: l,
      data: i,
      enumValues: u
    };
  }
  s(w_, "translateEnumValues");
  function D_(e, t, r = /* @__PURE__ */ new Set()) {
    return n(e);
    function n(l) {
      let u = l.node;
      switch (u.type) {
        case "MemberExpression":
          return i(l, t, r);
        case "StringLiteral":
          return u.value;
        case "UnaryExpression":
          return a(l);
        case "BinaryExpression":
          return o(l);
        case "NumericLiteral":
          return u.value;
        case "ParenthesizedExpression":
          return n(l.get("expression"));
        case "Identifier":
          return i(l, t, r);
        case "TemplateLiteral": {
          if (u.quasis.length === 1)
            return u.quasis[0].value.cooked;
          let c = l.get("expressions"), f = u.quasis, p = "";
          for (let h = 0; h < f.length; h++)
            if (p += f[h].value.cooked, h + 1 < f.length) {
              let y = i(c[h], t, r);
              if (y === void 0) return;
              p += y;
            }
          return p;
        }
        default:
          return;
      }
    }
    function i(l, u, c) {
      if (l.isMemberExpression()) {
        let f = l.node, p = f.object, h = f.property;
        if (!ya.types.isIdentifier(p) || (f.computed ? !ya.types.isStringLiteral(h) : !ya.types.isIdentifier(h)))
          return;
        let y = l.scope.getBindingIdentifier(p.name), v = Xb.get(y);
        return v ? v.get(h.computed ? h.value : h.name) : void 0;
      } else if (l.isIdentifier()) {
        let f = l.node.name;
        if (["Infinity", "NaN"].includes(f))
          return Number(f);
        let p = u?.get(f);
        return p !== void 0 ? p : c.has(l.node) ? void 0 : (c.add(l.node), p = D_(l.resolve(), u, c), u?.set(f, p), p);
      }
    }
    function a(l) {
      let u = n(l.get("argument"));
      if (u !== void 0)
        switch (l.node.operator) {
          case "+":
            return u;
          case "-":
            return -u;
          case "~":
            return ~u;
          default:
            return;
        }
    }
    function o(l) {
      let u = n(l.get("left"));
      if (u === void 0)
        return;
      let c = n(l.get("right"));
      if (c !== void 0)
        switch (l.node.operator) {
          case "|":
            return u | c;
          case "&":
            return u & c;
          case ">>":
            return u >> c;
          case ">>>":
            return u >>> c;
          case "<<":
            return u << c;
          case "^":
            return u ^ c;
          case "*":
            return u * c;
          case "/":
            return u / c;
          case "+":
            return u + c;
          case "-":
            return u - c;
          case "%":
            return u % c;
          case "**":
            return Math.pow(u, c);
          default:
            return;
        }
    }
  }
  s(D_, "computeConstantValue");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/const-enum.js
var I_ = T((Zb) => {
  "use strict";
  Object.defineProperty(Zb, "__esModule", {
    value: !0
  });
  Zb.default = dge;
  var pge = Qb();
  function dge(e, t) {
    let {
      name: r
    } = e.node.id, n = e.parentPath.isExportNamedDeclaration(), i = n;
    !i && t.isProgram(e.parent) && (i = e.parent.body.some((l) => t.isExportNamedDeclaration(l) && l.exportKind !== "type" && !l.source && l.
    specifiers.some((u) => t.isExportSpecifier(u) && u.exportKind !== "type" && u.local.name === r)));
    let {
      enumValues: a
    } = (0, pge.translateEnumValues)(e, t);
    if (i) {
      let l = t.objectExpression(a.map(([u, c]) => t.objectProperty(t.isValidIdentifier(u) ? t.identifier(u) : t.stringLiteral(u), c)));
      e.scope.hasOwnBinding(r) ? (n ? e.parentPath : e).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("\
Object"), t.identifier("assign")), [e.node.id, l]))) : (e.replaceWith(t.variableDeclaration("var", [t.variableDeclarator(e.node.id, l)])), e.
      scope.registerDeclaration(e));
      return;
    }
    let o = new Map(a);
    e.scope.path.traverse({
      Scope(l) {
        l.scope.hasOwnBinding(r) && l.skip();
      },
      MemberExpression(l) {
        if (!t.isIdentifier(l.node.object, {
          name: r
        })) return;
        let u;
        if (l.node.computed)
          if (t.isStringLiteral(l.node.property))
            u = l.node.property.value;
          else
            return;
        else if (t.isIdentifier(l.node.property))
          u = l.node.property.name;
        else
          return;
        o.has(u) && l.replaceWith(t.cloneNode(o.get(u)));
      }
    }), e.remove();
  }
  s(dge, "transpileConstEnum");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/global-types.js
var e1 = T((ga) => {
  "use strict";
  Object.defineProperty(ga, "__esModule", {
    value: !0
  });
  ga.GLOBAL_TYPES = void 0;
  ga.isGlobalType = hge;
  ga.registerGlobalType = mge;
  var __ = ga.GLOBAL_TYPES = /* @__PURE__ */ new WeakMap();
  function hge({
    scope: e
  }, t) {
    return e.hasBinding(t) ? !1 : __.get(e).has(t) ? !0 : (console.warn(`The exported identifier "${t}" is not declared in Babel's scope tra\
cker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.

This problem is likely caused by another plugin injecting
"${t}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`), !1);
  }
  s(hge, "isGlobalType");
  function mge(e, t) {
    __.get(e).add(t);
  }
  s(mge, "registerGlobalType");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/namespace.js
var N_ = T((s1) => {
  "use strict";
  Object.defineProperty(s1, "__esModule", {
    value: !0
  });
  s1.default = gge;
  var Ze = bt(), yge = e1();
  function gge(e, t) {
    if (e.node.declare || e.node.id.type === "StringLiteral") {
      e.remove();
      return;
    }
    if (!t)
      throw e.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimen\
tally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
    let r = e.node.id.name, n = n1(e, Ze.types.cloneNode(e.node, !0));
    if (n === null) {
      let i = e.findParent((a) => a.isProgram());
      (0, yge.registerGlobalType)(i.scope, r), e.remove();
    } else e.scope.hasOwnBinding(r) ? e.replaceWith(n) : e.scope.registerDeclaration(e.replaceWithMultiple([t1(r), n])[0]);
  }
  s(gge, "transpileNamespace");
  function t1(e) {
    return Ze.types.variableDeclaration("let", [Ze.types.variableDeclarator(Ze.types.identifier(e))]);
  }
  s(t1, "getDeclaration");
  function r1(e, t) {
    return Ze.types.memberExpression(Ze.types.identifier(e), Ze.types.identifier(t));
  }
  s(r1, "getMemberExpression");
  function bge(e, t, r) {
    if (e.kind !== "const")
      throw r.file.buildCodeFrameError(e, "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babelj\
s.io/docs/en/babel-plugin-transform-typescript");
    let {
      declarations: n
    } = e;
    if (n.every((o) => Ze.types.isIdentifier(o.id))) {
      for (let o of n)
        o.init = Ze.types.assignmentExpression("=", r1(t, o.id.name), o.init);
      return [e];
    }
    let i = Ze.types.getBindingIdentifiers(e), a = [];
    for (let o in i)
      a.push(Ze.types.assignmentExpression("=", r1(t, o), Ze.types.cloneNode(i[o])));
    return [e, Ze.types.expressionStatement(Ze.types.sequenceExpression(a))];
  }
  s(bge, "handleVariableDeclaration");
  function O_(e, t) {
    return e.hub.buildError(t, "Ambient modules cannot be nested in other modules or namespaces.", Error);
  }
  s(O_, "buildNestedAmbientModuleError");
  function n1(e, t, r) {
    let n = /* @__PURE__ */ new Set(), i = t.id;
    Ze.types.assertIdentifier(i);
    let a = e.scope.generateUid(i.name), o = Ze.types.isTSModuleBlock(t.body) ? t.body.body : [Ze.types.exportNamedDeclaration(t.body)], l = !0;
    for (let c = 0; c < o.length; c++) {
      let f = o[c];
      switch (f.type) {
        case "TSModuleDeclaration": {
          if (!Ze.types.isIdentifier(f.id))
            throw O_(e, f);
          let p = n1(e, f);
          if (p !== null) {
            l = !1;
            let h = f.id.name;
            n.has(h) ? o[c] = p : (n.add(h), o.splice(c++, 1, t1(h), p));
          }
          continue;
        }
        case "TSEnumDeclaration":
        case "FunctionDeclaration":
        case "ClassDeclaration":
          l = !1, n.add(f.id.name);
          continue;
        case "VariableDeclaration": {
          l = !1;
          for (let p in Ze.types.getBindingIdentifiers(f))
            n.add(p);
          continue;
        }
        default:
          l && (l = Ze.types.isTypeScript(f));
          continue;
        case "ExportNamedDeclaration":
      }
      if (!("declare" in f.declaration && f.declaration.declare))
        switch (f.declaration.type) {
          case "TSEnumDeclaration":
          case "FunctionDeclaration":
          case "ClassDeclaration": {
            l = !1;
            let p = f.declaration.id.name;
            n.add(p), o.splice(c++, 1, f.declaration, Ze.types.expressionStatement(Ze.types.assignmentExpression("=", r1(a, p), Ze.types.identifier(
            p))));
            break;
          }
          case "VariableDeclaration": {
            l = !1;
            let p = bge(f.declaration, a, e.hub);
            o.splice(c, p.length, ...p), c += p.length - 1;
            break;
          }
          case "TSModuleDeclaration": {
            if (!Ze.types.isIdentifier(f.declaration.id))
              throw O_(e, f.declaration);
            let p = n1(e, f.declaration, Ze.types.identifier(a));
            if (p !== null) {
              l = !1;
              let h = f.declaration.id.name;
              n.has(h) ? o[c] = p : (n.add(h), o.splice(c++, 1, t1(h), p));
            } else
              o.splice(c, 1), c--;
          }
        }
    }
    if (l) return null;
    let u = Ze.types.objectExpression([]);
    if (r) {
      let c = Ze.types.memberExpression(r, i);
      u = Ze.template.expression.ast`
      ${Ze.types.cloneNode(c)} ||
        (${Ze.types.cloneNode(c)} = ${u})
    `;
    }
    return Ze.template.statement.ast`
    (function (${Ze.types.identifier(a)}) {
      ${o}
    })(${i} || (${Ze.types.cloneNode(i)} = ${u}));
  `;
  }
  s(n1, "handleNested");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/index.js
var F_ = T((Df) => {
  "use strict";
  Object.defineProperty(Df, "__esModule", {
    value: !0
  });
  Df.default = void 0;
  var Ege = ua(), vge = AI(), Tge = A_(), xge = I_(), Sge = Qb(), Kn = e1(), Pge = N_();
  function Age(e) {
    switch (e.parent.type) {
      case "TSTypeReference":
      case "TSExpressionWithTypeArguments":
      case "TSTypeQuery":
        return !0;
      case "TSQualifiedName":
        return e.parentPath.findParent((t) => t.type !== "TSQualifiedName").type !== "TSImportEqualsDeclaration";
      case "ExportSpecifier":
        return e.parent.exportKind === "type" || e.parentPath.parent.exportKind === "type";
      default:
        return !1;
    }
  }
  s(Age, "isInType");
  var qr = /* @__PURE__ */ new WeakMap(), B_ = /* @__PURE__ */ new WeakSet();
  function wf(e) {
    let t = e.getBindingIdentifiers();
    for (let r of Object.keys(t)) {
      let n = e.scope.getBinding(r);
      n && n.identifier === t[r] && n.scope.removeBinding(r);
    }
    e.opts.noScope = !0, e.remove(), e.opts.noScope = !1;
  }
  s(wf, "safeRemove");
  function k_(e, t, r, n, i = "") {
    if (t.file.get("@babel/plugin-transform-modules-*") !== "commonjs")
      throw e.buildCodeFrameError(`\`${r}\` is only supported when compiling modules to CommonJS.
Please consider using \`${n}\`${i}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`);
  }
  s(k_, "assertCjsTransformEnabled");
  var u_e = Df.default = (0, Ege.declare)((e, t) => {
    let {
      types: r,
      template: n
    } = e;
    e.assertVersion(7);
    let i = /\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/, {
      allowNamespaces: a = !0,
      jsxPragma: o = "React.createElement",
      jsxPragmaFrag: l = "React.Fragment",
      onlyRemoveTypeImports: u = !1,
      optimizeConstEnums: c = !1
    } = t;
    var {
      allowDeclareFields: f = !1
    } = t;
    let p = {
      field(d) {
        let {
          node: b
        } = d;
        if (!f && b.declare)
          throw d.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transfor\
m-typescript or @babel/preset-typescript is enabled.");
        if (b.declare) {
          if (b.value)
            throw d.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
          b.decorators || d.remove();
        } else if (b.definite) {
          if (b.value)
            throw d.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
          !f && !b.decorators && !r.isClassPrivateProperty(b) && d.remove();
        } else (b.abstract || !f && !b.value && !b.decorators && !r.isClassPrivateProperty(b)) && d.remove();
        b.accessibility && (b.accessibility = null), b.abstract && (b.abstract = null), b.readonly && (b.readonly = null), b.optional && (b.
        optional = null), b.typeAnnotation && (b.typeAnnotation = null), b.definite && (b.definite = null), b.declare && (b.declare = null),
        b.override && (b.override = null);
      },
      method({
        node: d
      }) {
        d.accessibility && (d.accessibility = null), d.abstract && (d.abstract = null), d.optional && (d.optional = null), d.override && (d.
        override = null);
      },
      constructor(d, b) {
        d.node.accessibility && (d.node.accessibility = null);
        let E = [], {
          scope: I
        } = d;
        for (let O of d.get("params")) {
          let k = O.node;
          if (k.type === "TSParameterProperty") {
            let j = k.parameter;
            if (B_.has(j)) continue;
            B_.add(j);
            let R;
            if (r.isIdentifier(j))
              R = j;
            else if (r.isAssignmentPattern(j) && r.isIdentifier(j.left))
              R = j.left;
            else
              throw O.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
            E.push(n.statement.ast`
              this.${r.cloneNode(R)} = ${r.cloneNode(R)}
            `), O.replaceWith(O.get("parameter")), I.registerBinding("param", O);
          }
        }
        (0, Tge.injectInitialization)(b, d, E);
      }
    };
    return {
      name: "transform-typescript",
      inherits: vge.default,
      visitor: {
        Pattern: y,
        Identifier: y,
        RestElement: y,
        Program: {
          enter(d, b) {
            let {
              file: E
            } = b, I = null, O = null, k = d.scope;
            if (Kn.GLOBAL_TYPES.has(k) || Kn.GLOBAL_TYPES.set(k, /* @__PURE__ */ new Set()), E.ast.comments)
              for (let U of E.ast.comments) {
                let Q = i.exec(U.value);
                Q && (Q[1] ? O = Q[2] : I = Q[2]);
              }
            let j = I || o;
            j && ([j] = j.split("."));
            let R = O || l;
            R && ([R] = R.split("."));
            for (let U of d.get("body")) {
              if (U.isImportDeclaration()) {
                if (qr.has(b.file.ast.program) || qr.set(b.file.ast.program, !0), U.node.importKind === "type") {
                  for (let M of U.node.specifiers)
                    (0, Kn.registerGlobalType)(k, M.local.name);
                  U.remove();
                  continue;
                }
                let Q = /* @__PURE__ */ new Set(), W = U.node.specifiers.length, q = /* @__PURE__ */ s(() => W > 0 && W === Q.size, "isAllSp\
ecifiersElided");
                for (let M of U.node.specifiers)
                  if (M.type === "ImportSpecifier" && M.importKind === "type") {
                    (0, Kn.registerGlobalType)(k, M.local.name);
                    let K = U.scope.getBinding(M.local.name);
                    K && Q.add(K.path);
                  }
                if (u)
                  qr.set(d.node, !1);
                else {
                  if (U.node.specifiers.length === 0) {
                    qr.set(d.node, !1);
                    continue;
                  }
                  for (let M of U.node.specifiers) {
                    let K = U.scope.getBinding(M.local.name);
                    K && !Q.has(K.path) && (v({
                      binding: K,
                      programPath: d,
                      pragmaImportName: j,
                      pragmaFragImportName: R
                    }) ? Q.add(K.path) : qr.set(d.node, !1));
                  }
                }
                if (q() && !u)
                  U.remove();
                else
                  for (let M of Q)
                    M.remove();
                continue;
              }
              if (U.isExportDeclaration() && (U = U.get("declaration")), U.isVariableDeclaration({
                declare: !0
              }))
                for (let Q of Object.keys(U.getBindingIdentifiers()))
                  (0, Kn.registerGlobalType)(k, Q);
              else (U.isTSTypeAliasDeclaration() || U.isTSDeclareFunction() && U.get("id").isIdentifier() || U.isTSInterfaceDeclaration() ||
              U.isClassDeclaration({
                declare: !0
              }) || U.isTSEnumDeclaration({
                declare: !0
              }) || U.isTSModuleDeclaration({
                declare: !0
              }) && U.get("id").isIdentifier()) && (0, Kn.registerGlobalType)(k, U.node.id.name);
            }
          },
          exit(d) {
            d.node.sourceType === "module" && qr.get(d.node) && d.pushContainer("body", r.exportNamedDeclaration());
          }
        },
        ExportNamedDeclaration(d, b) {
          if (qr.has(b.file.ast.program) || qr.set(b.file.ast.program, !0), d.node.exportKind === "type") {
            d.remove();
            return;
          }
          if (d.node.source && d.node.specifiers.length > 0 && d.node.specifiers.every((E) => E.type === "ExportSpecifier" && E.exportKind ===
          "type")) {
            d.remove();
            return;
          }
          if (!d.node.source && d.node.specifiers.length > 0 && d.node.specifiers.every((E) => r.isExportSpecifier(E) && (0, Kn.isGlobalType)(
          d, E.local.name))) {
            d.remove();
            return;
          }
          if (r.isTSModuleDeclaration(d.node.declaration)) {
            let E = d.node.declaration, {
              id: I
            } = E;
            if (r.isIdentifier(I))
              if (d.scope.hasOwnBinding(I.name))
                d.replaceWith(E);
              else {
                let [O] = d.replaceWithMultiple([r.exportNamedDeclaration(r.variableDeclaration("let", [r.variableDeclarator(r.cloneNode(I))])),
                E]);
                d.scope.registerDeclaration(O);
              }
          }
          qr.set(b.file.ast.program, !1);
        },
        ExportAllDeclaration(d) {
          d.node.exportKind === "type" && d.remove();
        },
        ExportSpecifier(d) {
          (!d.parent.source && (0, Kn.isGlobalType)(d, d.node.local.name) || d.node.exportKind === "type") && d.remove();
        },
        ExportDefaultDeclaration(d, b) {
          if (qr.has(b.file.ast.program) || qr.set(b.file.ast.program, !0), r.isIdentifier(d.node.declaration) && (0, Kn.isGlobalType)(d, d.
          node.declaration.name)) {
            d.remove();
            return;
          }
          qr.set(b.file.ast.program, !1);
        },
        TSDeclareFunction(d) {
          wf(d);
        },
        TSDeclareMethod(d) {
          wf(d);
        },
        VariableDeclaration(d) {
          d.node.declare && wf(d);
        },
        VariableDeclarator({
          node: d
        }) {
          d.definite && (d.definite = null);
        },
        TSIndexSignature(d) {
          d.remove();
        },
        ClassDeclaration(d) {
          let {
            node: b
          } = d;
          b.declare && wf(d);
        },
        Class(d) {
          let {
            node: b
          } = d;
          b.typeParameters && (b.typeParameters = null), b.superTypeParameters && (b.superTypeParameters = null), b.implements && (b.implements =
          null), b.abstract && (b.abstract = null), d.get("body.body").forEach((E) => {
            E.isClassMethod() || E.isClassPrivateMethod() ? E.node.kind === "constructor" ? p.constructor(E, d) : p.method(E) : (E.isClassProperty() ||
            E.isClassPrivateProperty() || E.isClassAccessorProperty()) && p.field(E);
          });
        },
        Function(d) {
          let {
            node: b
          } = d;
          b.typeParameters && (b.typeParameters = null), b.returnType && (b.returnType = null);
          let E = b.params;
          E.length > 0 && r.isIdentifier(E[0], {
            name: "this"
          }) && E.shift();
        },
        TSModuleDeclaration(d) {
          (0, Pge.default)(d, a);
        },
        TSInterfaceDeclaration(d) {
          d.remove();
        },
        TSTypeAliasDeclaration(d) {
          d.remove();
        },
        TSEnumDeclaration(d) {
          c && d.node.const ? (0, xge.default)(d, r) : (0, Sge.default)(d, r);
        },
        TSImportEqualsDeclaration(d, b) {
          let {
            id: E,
            moduleReference: I
          } = d.node, O, k;
          r.isTSExternalModuleReference(I) ? (k_(d, b, `import ${E.name} = require(...);`, `import ${E.name} from '...';`, " alongside Types\
cript's --allowSyntheticDefaultImports option"), O = r.callExpression(r.identifier("require"), [I.expression]), k = "const") : (O = h(I), k =
          "var"), d.replaceWith(r.variableDeclaration(k, [r.variableDeclarator(E, O)])), d.scope.registerDeclaration(d);
        },
        TSExportAssignment(d, b) {
          k_(d, b, "export = <value>;", "export default <value>;"), d.replaceWith(n.statement.ast`module.exports = ${d.node.expression}`);
        },
        TSTypeAssertion(d) {
          d.replaceWith(d.node.expression);
        },
        [`TSAsExpression${r.tsSatisfiesExpression ? "|TSSatisfiesExpression" : ""}`](d) {
          let {
            node: b
          } = d;
          do
            b = b.expression;
          while (r.isTSAsExpression(b) || r.isTSSatisfiesExpression != null && r.isTSSatisfiesExpression(b));
          d.replaceWith(b);
        },
        [e.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](d) {
          d.replaceWith(d.node.expression);
        },
        CallExpression(d) {
          d.node.typeParameters = null;
        },
        OptionalCallExpression(d) {
          d.node.typeParameters = null;
        },
        NewExpression(d) {
          d.node.typeParameters = null;
        },
        JSXOpeningElement(d) {
          d.node.typeParameters = null;
        },
        TaggedTemplateExpression(d) {
          d.node.typeParameters = null;
        }
      }
    };
    function h(d) {
      return r.isTSQualifiedName(d) ? r.memberExpression(h(d.left), d.right) : d;
    }
    function y({
      node: d
    }) {
      d.typeAnnotation && (d.typeAnnotation = null), r.isIdentifier(d) && d.optional && (d.optional = null);
    }
    function v({
      binding: d,
      programPath: b,
      pragmaImportName: E,
      pragmaFragImportName: I
    }) {
      for (let k of d.referencePaths)
        if (!Age(k))
          return !1;
      if (d.identifier.name !== E && d.identifier.name !== I)
        return !0;
      let O = !1;
      return b.traverse({
        "JSXElement|JSXFragment"(k) {
          O = !0, k.stop();
        }
      }), !O;
    }
  });
});

// ../node_modules/@babel/plugin-syntax-jsx/lib/index.js
var j_ = T((If) => {
  "use strict";
  Object.defineProperty(If, "__esModule", {
    value: !0
  });
  If.default = void 0;
  var Cge = ua(), p_e = If.default = (0, Cge.declare)((e) => (e.assertVersion(7), {
    name: "syntax-jsx",
    manipulateOptions(t, r) {
      r.plugins.some((n) => (Array.isArray(n) ? n[0] : n) === "typescript") || r.plugins.push("jsx");
    }
  }));
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js
var R_ = T((i1) => {
  "use strict";
  Object.defineProperty(i1, "__esModule", {
    value: !0
  });
  i1.transformDynamicImport = Ige;
  var L_ = bt(), wge = So(), M_ = /* @__PURE__ */ s((e) => L_.template.expression.ast`require(${e})`, "requireNoInterop"), Dge = /* @__PURE__ */ s(
  (e, t) => L_.types.callExpression(t.addHelper("interopRequireWildcard"), [M_(e)]), "requireInterop");
  function Ige(e, t, r) {
    let n = t ? M_ : Dge;
    e.replaceWith((0, wge.buildDynamicImport)(e.node, !0, !1, (i) => n(i, r)));
  }
  s(Ige, "transformDynamicImport");
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js
var U_ = T((_f) => {
  "use strict";
  Object.defineProperty(_f, "__esModule", {
    value: !0
  });
  _f.lazyImportsHook = void 0;
  var q_ = bt(), _ge = So(), Oge = /* @__PURE__ */ s((e) => ({
    name: "@babel/plugin-transform-modules-commonjs/lazy",
    version: "7.24.7",
    getWrapperPayload(t, r) {
      if ((0, _ge.isSideEffectImport)(r) || r.reexportAll)
        return null;
      if (e === !0)
        return /\./.test(t) ? null : "lazy/function";
      if (Array.isArray(e))
        return e.indexOf(t) === -1 ? null : "lazy/function";
      if (typeof e == "function")
        return e(t) ? "lazy/function" : null;
    },
    buildRequireWrapper(t, r, n, i) {
      if (n === "lazy/function")
        return i ? q_.template.statement.ast`
        function ${t}() {
          const data = ${r};
          ${t} = function(){ return data; };
          return data;
        }
      ` : !1;
    },
    wrapReference(t, r) {
      if (r === "lazy/function") return q_.types.callExpression(t, []);
    }
  }), "lazyImportsHook");
  _f.lazyImportsHook = Oge;
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js
var V_ = T((Of) => {
  "use strict";
  Object.defineProperty(Of, "__esModule", {
    value: !0
  });
  Of.defineCommonJSHook = Nge;
  Of.makeInvokers = Bge;
  var o1 = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";
  function Nge(e, t) {
    let r = e.get(o1);
    r || e.set(o1, r = []), r.push(t);
  }
  s(Nge, "defineCommonJSHook");
  function a1(e, t) {
    if (e)
      for (let r of e) {
        let n = t(r);
        if (n != null) return n;
      }
  }
  s(a1, "findMap");
  function Bge(e) {
    let t = e.get(o1);
    return {
      getWrapperPayload(...r) {
        return a1(t, (n) => n.getWrapperPayload == null ? void 0 : n.getWrapperPayload(...r));
      },
      wrapReference(...r) {
        return a1(t, (n) => n.wrapReference == null ? void 0 : n.wrapReference(...r));
      },
      buildRequireWrapper(...r) {
        return a1(t, (n) => n.buildRequireWrapper == null ? void 0 : n.buildRequireWrapper(...r));
      }
    };
  }
  s(Bge, "makeInvokers");
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js
var $_ = T((sl) => {
  "use strict";
  Object.defineProperty(sl, "__esModule", {
    value: !0
  });
  sl.default = void 0;
  Object.defineProperty(sl, "defineCommonJSHook", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return l1.defineCommonJSHook;
    }, "get")
  });
  var kge = ua(), hi = So(), Fge = Vy(), tn = bt(), jge = R_(), Lge = U_(), l1 = V_(), v_e = sl.default = (0, kge.declare)((e, t) => {
    var r, n, i;
    e.assertVersion(7);
    let {
      strictNamespace: a = !1,
      mjsStrictNamespace: o = a,
      allowTopLevelThis: l,
      strict: u,
      strictMode: c,
      noInterop: f,
      importInterop: p,
      lazy: h = !1,
      allowCommonJSExports: y = !0,
      loose: v = !1
    } = t, d = (r = e.assumption("constantReexports")) != null ? r : v, b = (n = e.assumption("enumerableModuleMeta")) != null ? n : v, E = (i =
    e.assumption("noIncompleteNsImportDetection")) != null ? i : !1;
    if (typeof h != "boolean" && typeof h != "function" && (!Array.isArray(h) || !h.every((k) => typeof k == "string")))
      throw new Error(".lazy must be a boolean, array of strings, or a function");
    if (typeof a != "boolean")
      throw new Error(".strictNamespace must be a boolean, or undefined");
    if (typeof o != "boolean")
      throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
    let I = /* @__PURE__ */ s((k) => tn.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${k}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, "getAssertion"), O = {
      ReferencedIdentifier(k) {
        let j = k.node.name;
        if (j !== "module" && j !== "exports") return;
        let R = k.scope.getBinding(j);
        this.scope.getBinding(j) !== R || k.parentPath.isObjectProperty({
          value: k.node
        }) && k.parentPath.parentPath.isObjectPattern() || k.parentPath.isAssignmentExpression({
          left: k.node
        }) || k.isAssignmentExpression({
          left: k.node
        }) || k.replaceWith(I(j));
      },
      UpdateExpression(k) {
        let j = k.get("argument");
        if (!j.isIdentifier()) return;
        let R = j.node.name;
        if (R !== "module" && R !== "exports") return;
        let U = k.scope.getBinding(R);
        this.scope.getBinding(R) === U && k.replaceWith(tn.types.assignmentExpression(k.node.operator[0] + "=", j.node, I(R)));
      },
      AssignmentExpression(k) {
        let j = k.get("left");
        if (j.isIdentifier()) {
          let R = j.node.name;
          if (R !== "module" && R !== "exports") return;
          let U = k.scope.getBinding(R);
          if (this.scope.getBinding(R) !== U) return;
          let W = k.get("right");
          W.replaceWith(tn.types.sequenceExpression([W.node, I(R)]));
        } else if (j.isPattern()) {
          let R = j.getOuterBindingIdentifiers(), U = Object.keys(R).filter((Q) => Q !== "module" && Q !== "exports" ? !1 : this.scope.getBinding(
          Q) === k.scope.getBinding(Q))[0];
          if (U) {
            let Q = k.get("right");
            Q.replaceWith(tn.types.sequenceExpression([Q.node, I(U)]));
          }
        }
      }
    };
    return {
      name: "transform-modules-commonjs",
      pre() {
        this.file.set("@babel/plugin-transform-modules-*", "commonjs"), h && (0, l1.defineCommonJSHook)(this.file, (0, Lge.lazyImportsHook)(
        h));
      },
      visitor: {
        ["CallExpression" + (e.types.importExpression ? "|ImportExpression" : "")](k) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import") || k.isCallExpression() && !tn.types.isImport(k.node.callee)) return;
          let {
            scope: j
          } = k;
          do
            j.rename("require");
          while (j = j.parent);
          (0, jge.transformDynamicImport)(k, f, this.file);
        },
        Program: {
          exit(k, j) {
            if (!(0, hi.isModule)(k)) return;
            k.scope.rename("exports"), k.scope.rename("module"), k.scope.rename("require"), k.scope.rename("__filename"), k.scope.rename("__\
dirname"), y || ((0, Fge.default)(k, /* @__PURE__ */ new Set(["module", "exports"]), !1), k.traverse(O, {
              scope: k.scope
            }));
            let R = (0, hi.getModuleName)(this.file.opts, t);
            R && (R = tn.types.stringLiteral(R));
            let U = (0, l1.makeInvokers)(this.file), {
              meta: Q,
              headers: W
            } = (0, hi.rewriteModuleStatementsAndPrepareHeader)(k, {
              exportName: "exports",
              constantReexports: d,
              enumerableModuleMeta: b,
              strict: u,
              strictMode: c,
              allowTopLevelThis: l,
              noInterop: f,
              importInterop: p,
              wrapReference: U.wrapReference,
              getWrapperPayload: U.getWrapperPayload,
              esNamespaceOnly: typeof j.filename == "string" && /\.mjs$/.test(j.filename) ? o : a,
              noIncompleteNsImportDetection: E,
              filename: this.file.opts.filename
            });
            for (let [M, K] of Q.source) {
              let pe = tn.types.callExpression(tn.types.identifier("require"), [tn.types.stringLiteral(M)]), ae;
              if ((0, hi.isSideEffectImport)(K)) {
                if (h && K.wrap === "function")
                  throw new Error("Assertion failure");
                ae = tn.types.expressionStatement(pe);
              } else {
                var q;
                let X = (0, hi.wrapInterop)(k, pe, K.interop) || pe;
                if (K.wrap) {
                  let J = U.buildRequireWrapper(K.name, X, K.wrap, K.referenced);
                  if (J === !1) continue;
                  ae = J;
                }
                (q = ae) != null || (ae = tn.template.statement.ast`
                var ${K.name} = ${X};
              `);
              }
              ae.loc = K.loc, W.push(ae), W.push(...(0, hi.buildNamespaceInitStatements)(Q, K, d, U.wrapReference));
            }
            (0, hi.ensureStatementsHoisted)(W), k.unshiftContainer("body", W), k.get("body").forEach((M) => {
              W.indexOf(M.node) !== -1 && M.isVariableDeclaration() && M.scope.registerDeclaration(M);
            });
          }
        }
      }
    };
  });
});

// ../node_modules/@babel/preset-typescript/lib/index.js
var H_ = T((u1) => {
  "use strict";
  Object.defineProperty(u1, "__esModule", { value: !0 });
  var K_ = ua(), Mge = F_();
  j_();
  var Rge = $_(), qge = Fc();
  function G_(e) {
    return e && e.__esModule ? e : { default: e };
  }
  s(G_, "_interopDefault");
  var W_ = /* @__PURE__ */ G_(Mge), Uge = /* @__PURE__ */ G_(Rge), Gn = new qge.OptionValidator("@babel/preset-typescript");
  function Vge(e = {}) {
    let {
      allowNamespaces: t = !0,
      jsxPragma: r,
      onlyRemoveTypeImports: n
    } = e, i = {
      ignoreExtensions: "ignoreExtensions",
      allowNamespaces: "allowNamespaces",
      disallowAmbiguousJSXLike: "disallowAmbiguousJSXLike",
      jsxPragma: "jsxPragma",
      jsxPragmaFrag: "jsxPragmaFrag",
      onlyRemoveTypeImports: "onlyRemoveTypeImports",
      optimizeConstEnums: "optimizeConstEnums",
      rewriteImportExtensions: "rewriteImportExtensions",
      allExtensions: "allExtensions",
      isTSX: "isTSX"
    }, a = Gn.validateStringOption(i.jsxPragmaFrag, e.jsxPragmaFrag, "React.Fragment");
    {
      var o = Gn.validateBooleanOption(i.allExtensions, e.allExtensions, !1), l = Gn.validateBooleanOption(i.isTSX, e.isTSX, !1);
      l && Gn.invariant(o, "isTSX:true requires allExtensions:true");
    }
    let u = Gn.validateBooleanOption(i.ignoreExtensions, e.ignoreExtensions, !1), c = Gn.validateBooleanOption(i.disallowAmbiguousJSXLike, e.
    disallowAmbiguousJSXLike, !1);
    c && Gn.invariant(o, "disallowAmbiguousJSXLike:true requires allExtensions:true");
    let f = Gn.validateBooleanOption(i.optimizeConstEnums, e.optimizeConstEnums, !1), p = Gn.validateBooleanOption(i.rewriteImportExtensions,
    e.rewriteImportExtensions, !1), h = {
      ignoreExtensions: u,
      allowNamespaces: t,
      disallowAmbiguousJSXLike: c,
      jsxPragma: r,
      jsxPragmaFrag: a,
      onlyRemoveTypeImports: n,
      optimizeConstEnums: f,
      rewriteImportExtensions: p
    };
    return h.allExtensions = o, h.isTSX = l, h;
  }
  s(Vge, "normalizeOptions");
  var $ge = K_.declare(function({
    types: e
  }) {
    return {
      name: "preset-typescript/plugin-rewrite-ts-imports",
      visitor: {
        "ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration"({
          node: t
        }) {
          let {
            source: r
          } = t;
          (e.isImportDeclaration(t) ? t.importKind : t.exportKind) === "value" && r && /[\\/]/.test(r.value) && (r.value = r.value.replace(/(\.[mc]?)ts$/,
          "$1js").replace(/\.tsx$/, ".js"));
        }
      }
    };
  }), Wge = K_.declarePreset((e, t) => {
    e.assertVersion(7);
    let {
      allExtensions: r,
      ignoreExtensions: n,
      allowNamespaces: i,
      disallowAmbiguousJSXLike: a,
      isTSX: o,
      jsxPragma: l,
      jsxPragmaFrag: u,
      onlyRemoveTypeImports: c,
      optimizeConstEnums: f,
      rewriteImportExtensions: p
    } = Vge(t), h = /* @__PURE__ */ s((d) => ({
      allowDeclareFields: t.allowDeclareFields,
      allowNamespaces: i,
      disallowAmbiguousJSXLike: d,
      jsxPragma: l,
      jsxPragmaFrag: u,
      onlyRemoveTypeImports: c,
      optimizeConstEnums: f
    }), "pluginOptions"), y = /* @__PURE__ */ s((d, b) => [[W_.default, Object.assign({
      isTSX: d
    }, h(b))]], "getPlugins");
    return {
      plugins: p ? [$ge] : [],
      overrides: r || n ? [{
        plugins: y(o, a)
      }] : [{
        test: /\.ts$/,
        plugins: y(!1, !1)
      }, {
        test: /\.mts$/,
        sourceType: "module",
        plugins: y(!1, !0)
      }, {
        test: /\.cts$/,
        sourceType: "unambiguous",
        plugins: [[Uge.default, {
          allowTopLevelThis: !0
        }], [W_.default, h(!0)]]
      }, {
        test: /\.tsx$/,
        plugins: y(!0, !1)
      }]
    };
  });
  u1.default = Wge;
});

// ../node_modules/@babel/core/lib/config/files/module-types.js
var y1 = T((il) => {
  "use strict";
  Object.defineProperty(il, "__esModule", {
    value: !0
  });
  il.default = zge;
  il.supportsESM = void 0;
  var Y_ = Hi();
  function d1() {
    let e = ie("path");
    return d1 = /* @__PURE__ */ s(function() {
      return e;
    }, "_path"), e;
  }
  s(d1, "_path");
  function J_() {
    let e = ie("url");
    return J_ = /* @__PURE__ */ s(function() {
      return e;
    }, "_url"), e;
  }
  s(J_, "_url");
  function h1() {
    let e = ie("semver");
    return h1 = /* @__PURE__ */ s(function() {
      return e;
    }, "_semver"), e;
  }
  s(h1, "_semver");
  function X_() {
    let e = qs();
    return X_ = /* @__PURE__ */ s(function() {
      return e;
    }, "_debug"), e;
  }
  s(X_, "_debug");
  var Q_ = Fn(), m1 = ri(), Kge = ib();
  function z_(e, t, r, n, i, a, o) {
    try {
      var l = e[a](o), u = l.value;
    } catch (c) {
      r(c);
      return;
    }
    l.done ? t(u) : Promise.resolve(u).then(n, i);
  }
  s(z_, "asyncGeneratorStep");
  function Gge(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(n, i) {
        var a = e.apply(t, r);
        function o(u) {
          z_(a, n, i, o, l, "next", u);
        }
        s(o, "_next");
        function l(u) {
          z_(a, n, i, o, l, "throw", u);
        }
        s(l, "_throw"), o(void 0);
      });
    };
  }
  s(Gge, "_asyncToGenerator");
  var Hge = X_()("babel:config:loading:files:module-types");
  try {
    f1 = xI();
  } catch {
  }
  var f1, A_e = il.supportsESM = h1().satisfies(process.versions.node, "^12.17 || >=13.2"), c1 = /* @__PURE__ */ new Set();
  function p1(e) {
    if (c1.has(e))
      return Hge("Auto-ignoring usage of config %o.", e), {};
    let t;
    try {
      c1.add(e), t = (0, Q_.endHiddenCallStack)(ie)(e);
    } finally {
      c1.delete(e);
    }
    {
      var r;
      return (r = t) != null && r.__esModule ? t.default || (arguments[1] ? t : void 0) : t;
    }
  }
  s(p1, "loadCjsDefault");
  var Yge = (0, Q_.endHiddenCallStack)(function() {
    var e = Gge(function* (r) {
      let n = (0, J_().pathToFileURL)(r).toString();
      {
        if (!f1)
          throw new m1.default(`Internal error: Native ECMAScript modules aren't supported by this platform.
`, r);
        return (yield f1(n)).default;
      }
    });
    function t(r) {
      return e.apply(this, arguments);
    }
    return s(t, "loadMjsDefault"), t;
  }());
  function* zge(e, t) {
    switch (d1().extname(e)) {
      case ".cjs":
        return p1(e, arguments[2]);
      case ".mjs":
        break;
      case ".cts":
        return Jge(e);
      default:
        try {
          return p1(e, arguments[2]);
        } catch (r) {
          if (r.code !== "ERR_REQUIRE_ESM") throw r;
        }
    }
    if (yield* (0, Y_.isAsync)())
      return yield* (0, Y_.waitFor)(Yge(e));
    throw new m1.default(t, e);
  }
  s(zge, "loadCodeDefault");
  function Jge(e) {
    let t = ".cts", r = !!(ie.extensions[".ts"] || ie.extensions[".cts"] || ie.extensions[".mts"]), n;
    if (!r) {
      let i = {
        babelrc: !1,
        configFile: !1,
        sourceType: "unambiguous",
        sourceMaps: "inline",
        sourceFileName: d1().basename(e),
        presets: [[Xge(e), Object.assign({
          onlyRemoveTypeImports: !0,
          optimizeConstEnums: !0
        }, {
          allowDeclareFields: !0
        })]]
      };
      n = /* @__PURE__ */ s(function(a, o) {
        if (n && o.endsWith(t))
          try {
            return a._compile((0, Kge.transformFileSync)(o, Object.assign({}, i, {
              filename: o
            })).code, o);
          } catch (l) {
            if (!r) {
              let u = SI();
              h1().lt(u.version, "7.21.4") && console.error("`.cts` configuration file failed to load, please try to update `@babel/preset-t\
ypescript`.");
            }
            throw l;
          }
        return ie.extensions[".js"](a, o);
      }, "handler"), ie.extensions[t] = n;
    }
    try {
      return p1(e);
    } finally {
      r || (ie.extensions[t] === n && delete ie.extensions[t], n = void 0);
    }
  }
  s(Jge, "loadCtsDefault");
  function Xge(e) {
    try {
      return H_();
    } catch (t) {
      if (t.code !== "MODULE_NOT_FOUND") throw t;
      let r = "You appear to be using a .cts file as Babel configuration, but the `@babel/preset-typescript` package was not found: please i\
nstall it!";
      throw process.versions.pnp && (r += `
If you are using Yarn Plug'n'Play, you may also need to add the following configuration to your .yarnrc.yml file:

packageExtensions:
	"@babel/core@*":
		peerDependencies:
			"@babel/preset-typescript": "*"
`), new m1.default(r, e);
    }
  }
  s(Xge, "getTSPreset");
});

// ../node_modules/@babel/core/lib/config/files/configuration.js
var lO = T((Hn) => {
  "use strict";
  Object.defineProperty(Hn, "__esModule", {
    value: !0
  });
  Hn.ROOT_CONFIG_FILENAMES = void 0;
  Hn.findConfigUpwards = fbe;
  Hn.findRelativeConfig = pbe;
  Hn.findRootConfig = dbe;
  Hn.loadConfig = hbe;
  Hn.resolveShowConfigPath = mbe;
  function eO() {
    let e = qs();
    return eO = /* @__PURE__ */ s(function() {
      return e;
    }, "_debug"), e;
  }
  s(eO, "_debug");
  function g1() {
    let e = ie("fs");
    return g1 = /* @__PURE__ */ s(function() {
      return e;
    }, "_fs"), e;
  }
  s(g1, "_fs");
  function Pr() {
    let e = ie("path");
    return Pr = /* @__PURE__ */ s(function() {
      return e;
    }, "_path"), e;
  }
  s(Pr, "_path");
  function tO() {
    let e = i2();
    return tO = /* @__PURE__ */ s(function() {
      return e;
    }, "_json"), e;
  }
  s(tO, "_json");
  function rO() {
    let e = vr();
    return rO = /* @__PURE__ */ s(function() {
      return e;
    }, "_gensync"), e;
  }
  s(rO, "_gensync");
  var nO = ti(), Qge = A0(), sO = d0(), Zge = y1(), ebe = pg(), rn = ri(), tbe = uc(), rbe = Fn(), b1 = eO()("babel:config:loading:files:con\
figuration"), iO = Hn.ROOT_CONFIG_FILENAMES = ["babel.config.js", "babel.config.cjs", "babel.config.mjs", "babel.config.json", "babel.config\
.cts"], nbe = [".babelrc", ".babelrc.js", ".babelrc.cjs", ".babelrc.mjs", ".babelrc.json", ".babelrc.cts"], sbe = ".babelignore", ibe = (0, nO.
  makeWeakCache)(/* @__PURE__ */ s(function* (t, r) {
    return yield* [], {
      options: (0, rbe.endHiddenCallStack)(t)((0, Qge.makeConfigAPI)(r)),
      cacheNeedsConfiguration: !r.configured()
    };
  }, "runConfig"));
  function* abe(e, t) {
    if (!g1().existsSync(e)) return null;
    let r = yield* (0, Zge.default)(e, "You appear to be using a native ECMAScript module configuration file, which is only supported when r\
unning Babel asynchronously."), n = !1;
    if (typeof r == "function" && ({
      options: r,
      cacheNeedsConfiguration: n
    } = yield* ibe(r, t)), !r || typeof r != "object" || Array.isArray(r))
      throw new rn.default("Configuration should be an exported JavaScript object.", e);
    if (typeof r.then == "function")
      throw r.catch == null || r.catch(() => {
      }), new rn.default("You appear to be using an async configuration, which your current version of Babel does not support. We may add su\
pport for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synch\
ronously return your config.", e);
    return n && ybe(e), obe(r, e);
  }
  s(abe, "readConfigCode");
  var Z_ = /* @__PURE__ */ new WeakMap();
  function obe(e, t) {
    let r = Z_.get(e);
    r || Z_.set(e, r = /* @__PURE__ */ new Map());
    let n = r.get(t);
    return n || (n = {
      filepath: t,
      dirname: Pr().dirname(t),
      options: e
    }, r.set(t, n)), n;
  }
  s(obe, "buildConfigFileObject");
  var lbe = (0, nO.makeWeakCacheSync)((e) => {
    let t = e.options.babel;
    if (typeof t > "u") return null;
    if (typeof t != "object" || Array.isArray(t) || t === null)
      throw new rn.default(".babel property must be an object", e.filepath);
    return {
      filepath: e.filepath,
      dirname: e.dirname,
      options: t
    };
  }), ube = (0, sO.makeStaticFileCache)((e, t) => {
    let r;
    try {
      r = tO().parse(t);
    } catch (n) {
      throw new rn.default(`Error while parsing config - ${n.message}`, e);
    }
    if (!r) throw new rn.default("No config detected", e);
    if (typeof r != "object")
      throw new rn.default(`Config returned typeof ${typeof r}`, e);
    if (Array.isArray(r))
      throw new rn.default("Expected config object but found array", e);
    return delete r.$schema, {
      filepath: e,
      dirname: Pr().dirname(e),
      options: r
    };
  }), cbe = (0, sO.makeStaticFileCache)((e, t) => {
    let r = Pr().dirname(e), n = t.split(`
`).map((i) => i.replace(/#.*$/, "").trim()).filter((i) => !!i);
    for (let i of n)
      if (i[0] === "!")
        throw new rn.default("Negation of file paths is not supported.", e);
    return {
      filepath: e,
      dirname: Pr().dirname(e),
      ignore: n.map((i) => (0, ebe.default)(i, r))
    };
  });
  function fbe(e) {
    let t = e;
    for (; ; ) {
      for (let n of iO)
        if (g1().existsSync(Pr().join(t, n)))
          return t;
      let r = Pr().dirname(t);
      if (t === r) break;
      t = r;
    }
    return null;
  }
  s(fbe, "findConfigUpwards");
  function* pbe(e, t, r) {
    let n = null, i = null, a = Pr().dirname(e.filepath);
    for (let l of e.directories) {
      if (!n) {
        var o;
        n = yield* aO(nbe, l, t, r, ((o = e.pkg) == null ? void 0 : o.dirname) === l ? lbe(e.pkg) : null);
      }
      if (!i) {
        let u = Pr().join(l, sbe);
        i = yield* cbe(u), i && b1("Found ignore %o from %o.", i.filepath, a);
      }
    }
    return {
      config: n,
      ignore: i
    };
  }
  s(pbe, "findRelativeConfig");
  function dbe(e, t, r) {
    return aO(iO, e, t, r);
  }
  s(dbe, "findRootConfig");
  function* aO(e, t, r, n, i = null) {
    let o = (yield* rO().all(e.map((l) => oO(Pr().join(t, l), r, n)))).reduce((l, u) => {
      if (u && l)
        throw new rn.default(`Multiple configuration files found. Please remove one:
 - ${Pr().basename(l.filepath)}
 - ${u.filepath}
from ${t}`);
      return u || l;
    }, i);
    return o && b1("Found configuration %o from %o.", o.filepath, t), o;
  }
  s(aO, "loadOneConfig");
  function* hbe(e, t, r, n) {
    let i = (((o, l) => (o = o.split("."), l = l.split("."), +o[0] > +l[0] || o[0] == l[0] && +o[1] >= +l[1]))(process.versions.node, "8.9") ?
    ie.resolve : (o, {
      paths: [l]
    }, u = ie("module")) => {
      let c = u._findPath(o, u._nodeModulePaths(l).concat(l));
      if (c) return c;
      throw c = new Error(`Cannot resolve module '${o}'`), c.code = "MODULE_NOT_FOUND", c;
    })(e, {
      paths: [t]
    }), a = yield* oO(i, r, n);
    if (!a)
      throw new rn.default("Config file contains no configuration data", i);
    return b1("Loaded config %o from %o.", e, t), a;
  }
  s(hbe, "loadConfig");
  function oO(e, t, r) {
    switch (Pr().extname(e)) {
      case ".js":
      case ".cjs":
      case ".mjs":
      case ".cts":
        return abe(e, {
          envName: t,
          caller: r
        });
      default:
        return ube(e);
    }
  }
  s(oO, "readConfig");
  function* mbe(e) {
    let t = process.env.BABEL_SHOW_CONFIG_FOR;
    if (t != null) {
      let r = Pr().resolve(e, t);
      if (!(yield* tbe.stat(r)).isFile())
        throw new Error(`${r}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);
      return r;
    }
    return null;
  }
  s(mbe, "resolveShowConfigPath");
  function ybe(e) {
    throw new rn.default(`Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`, e);
  }
  s(ybe, "throwConfigError");
});

// ../node_modules/@babel/core/lib/vendor/import-meta-resolve.js
var BO = T((Lf) => {
  "use strict";
  Object.defineProperty(Lf, "__esModule", {
    value: !0
  });
  Lf.moduleResolve = NO;
  Lf.resolve = l1e;
  function bn() {
    let e = ie("assert");
    return bn = /* @__PURE__ */ s(function() {
      return e;
    }, "_assert"), e;
  }
  s(bn, "_assert");
  function ul() {
    let e = gbe(ie("fs"), !0);
    return ul = /* @__PURE__ */ s(function() {
      return e;
    }, "_fs"), e;
  }
  s(ul, "_fs");
  function ws() {
    let e = ie("process");
    return ws = /* @__PURE__ */ s(function() {
      return e;
    }, "_process"), e;
  }
  s(ws, "_process");
  function Te() {
    let e = ie("url");
    return Te = /* @__PURE__ */ s(function() {
      return e;
    }, "_url"), e;
  }
  s(Te, "_url");
  function kf() {
    let e = ie("path");
    return kf = /* @__PURE__ */ s(function() {
      return e;
    }, "_path"), e;
  }
  s(kf, "_path");
  function Ff() {
    let e = ie("module");
    return Ff = /* @__PURE__ */ s(function() {
      return e;
    }, "_module"), e;
  }
  s(Ff, "_module");
  function TO() {
    let e = ie("v8");
    return TO = /* @__PURE__ */ s(function() {
      return e;
    }, "_v"), e;
  }
  s(TO, "_v");
  function ll() {
    let e = ie("util");
    return ll = /* @__PURE__ */ s(function() {
      return e;
    }, "_util"), e;
  }
  s(ll, "_util");
  function xO(e) {
    if (typeof WeakMap != "function") return null;
    var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (xO = /* @__PURE__ */ s(function(n) {
      return n ? r : t;
    }, "_getRequireWildcardCache"))(e);
  }
  s(xO, "_getRequireWildcardCache");
  function gbe(e, t) {
    if (!t && e && e.__esModule) return e;
    if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
    var r = xO(t);
    if (r && r.has(e)) return r.get(e);
    var n = { __proto__: null }, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in e) if (a !== "default" && {}.hasOwnProperty.call(e, a)) {
      var o = i ? Object.getOwnPropertyDescriptor(e, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(n, a, o) : n[a] = e[a];
    }
    return n.default = e, r && r.set(e, n), n;
  }
  s(gbe, "_interopRequireWildcard");
  var bbe = {}.hasOwnProperty, Ebe = /^([A-Z][a-z\d]*)+$/, vbe = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Functio\
n", "Object", "boolean", "bigint", "symbol"]), Gt = {};
  function E1(e, t = "and") {
    return e.length < 3 ? e.join(` ${t} `) : `${e.slice(0, -1).join(", ")}, ${t} ${e[e.length - 1]}`;
  }
  s(E1, "formatList");
  var SO = /* @__PURE__ */ new Map(), Tbe = "__node_internal_", uO;
  Gt.ERR_INVALID_ARG_TYPE = Ur("ERR_INVALID_ARG_TYPE", (e, t, r) => {
    bn()(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let n = "The ";
    if (e.endsWith(" argument"))
      n += `${e} `;
    else {
      let l = e.includes(".") ? "property" : "argument";
      n += `"${e}" ${l} `;
    }
    n += "must be ";
    let i = [], a = [], o = [];
    for (let l of t)
      bn()(typeof l == "string", "All expected entries have to be of type string"), vbe.has(l) ? i.push(l.toLowerCase()) : Ebe.exec(l) === null ?
      (bn()(l !== "object", 'The value "object" should be written as "Object"'), o.push(l)) : a.push(l);
    if (a.length > 0) {
      let l = i.indexOf("object");
      l !== -1 && (i.slice(l, 1), a.push("Object"));
    }
    return i.length > 0 && (n += `${i.length > 1 ? "one of type" : "of type"} ${E1(i, "or")}`, (a.length > 0 || o.length > 0) && (n += " or ")),
    a.length > 0 && (n += `an instance of ${E1(a, "or")}`, o.length > 0 && (n += " or ")), o.length > 0 && (o.length > 1 ? n += `one of ${E1(
    o, "or")}` : (o[0].toLowerCase() !== o[0] && (n += "an "), n += `${o[0]}`)), n += `. Received ${Cbe(r)}`, n;
  }, TypeError);
  Gt.ERR_INVALID_MODULE_SPECIFIER = Ur("ERR_INVALID_MODULE_SPECIFIER", (e, t, r = void 0) => `Invalid module "${e}" ${t}${r ? ` imported fro\
m ${r}` : ""}`, TypeError);
  Gt.ERR_INVALID_PACKAGE_CONFIG = Ur("ERR_INVALID_PACKAGE_CONFIG", (e, t, r) => `Invalid package config ${e}${t ? ` while importing ${t}` : ""}${r ?
  `. ${r}` : ""}`, Error);
  Gt.ERR_INVALID_PACKAGE_TARGET = Ur("ERR_INVALID_PACKAGE_TARGET", (e, t, r, n = !1, i = void 0) => {
    let a = typeof r == "string" && !n && r.length > 0 && !r.startsWith("./");
    return t === "." ? (bn()(n === !1), `Invalid "exports" main target ${JSON.stringify(r)} defined in the package config ${e}package.json${i ?
    ` imported from ${i}` : ""}${a ? '; targets must start with "./"' : ""}`) : `Invalid "${n ? "imports" : "exports"}" target ${JSON.stringify(
    r)} defined for '${t}' in the package config ${e}package.json${i ? ` imported from ${i}` : ""}${a ? '; targets must start with "./"' : ""}`;
  }, Error);
  Gt.ERR_MODULE_NOT_FOUND = Ur("ERR_MODULE_NOT_FOUND", (e, t, r = !1) => `Cannot find ${r ? "module" : "package"} '${e}' imported from ${t}`,
  Error);
  Gt.ERR_NETWORK_IMPORT_DISALLOWED = Ur("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error);
  Gt.ERR_PACKAGE_IMPORT_NOT_DEFINED = Ur("ERR_PACKAGE_IMPORT_NOT_DEFINED", (e, t, r) => `Package import specifier "${e}" is not defined${t ?
  ` in package ${t}package.json` : ""} imported from ${r}`, TypeError);
  Gt.ERR_PACKAGE_PATH_NOT_EXPORTED = Ur("ERR_PACKAGE_PATH_NOT_EXPORTED", (e, t, r = void 0) => t === "." ? `No "exports" main defined in ${e}\
package.json${r ? ` imported from ${r}` : ""}` : `Package subpath '${t}' is not defined by "exports" in ${e}package.json${r ? ` imported fro\
m ${r}` : ""}`, Error);
  Gt.ERR_UNSUPPORTED_DIR_IMPORT = Ur("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported fro\
m %s", Error);
  Gt.ERR_UNSUPPORTED_RESOLVE_REQUEST = Ur("ERR_UNSUPPORTED_RESOLVE_REQUEST", 'Failed to resolve module specifier "%s" from "%s": Invalid rel\
ative URL or base scheme is not hierarchical.', TypeError);
  Gt.ERR_UNKNOWN_FILE_EXTENSION = Ur("ERR_UNKNOWN_FILE_EXTENSION", (e, t) => `Unknown file extension "${e}" for ${t}`, TypeError);
  Gt.ERR_INVALID_ARG_VALUE = Ur("ERR_INVALID_ARG_VALUE", (e, t, r = "is invalid") => {
    let n = (0, ll().inspect)(t);
    return n.length > 128 && (n = `${n.slice(0, 128)}...`), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${n}`;
  }, TypeError);
  function Ur(e, t, r) {
    return SO.set(e, t), xbe(r, e);
  }
  s(Ur, "createError");
  function xbe(e, t) {
    return r;
    function r(...n) {
      let i = Error.stackTraceLimit;
      S1() && (Error.stackTraceLimit = 0);
      let a = new e();
      S1() && (Error.stackTraceLimit = i);
      let o = Abe(t, n, a);
      return Object.defineProperties(a, {
        message: {
          value: o,
          enumerable: !1,
          writable: !0,
          configurable: !0
        },
        toString: {
          value() {
            return `${this.name} [${t}]: ${this.message}`;
          },
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), Pbe(a), a.code = t, a;
    }
  }
  s(xbe, "makeNodeErrorWithCode");
  function S1() {
    try {
      if (TO().startupSnapshot.isBuildingSnapshot())
        return !1;
    } catch {
    }
    let e = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
    return e === void 0 ? Object.isExtensible(Error) : bbe.call(e, "writable") && e.writable !== void 0 ? e.writable : e.set !== void 0;
  }
  s(S1, "isErrorStackTraceLimitWritable");
  function Sbe(e) {
    let t = Tbe + e.name;
    return Object.defineProperty(e, "name", {
      value: t
    }), e;
  }
  s(Sbe, "hideStackFrames");
  var Pbe = Sbe(function(e) {
    let t = S1();
    return t && (uO = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(e), t && (Error.stackTraceLimit =
    uO), e;
  });
  function Abe(e, t, r) {
    let n = SO.get(e);
    if (bn()(n !== void 0, "expected `message` to be found"), typeof n == "function")
      return bn()(n.length <= t.length, `Code: ${e}; The provided arguments length (${t.length}) does not match the required ones (${n.length}\
).`), Reflect.apply(n, r, t);
    let i = /%[dfijoOs]/g, a = 0;
    for (; i.exec(n) !== null; ) a++;
    return bn()(a === t.length, `Code: ${e}; The provided arguments length (${t.length}) does not match the required ones (${a}).`), t.length ===
    0 ? n : (t.unshift(n), Reflect.apply(ll().format, null, t));
  }
  s(Abe, "getMessage");
  function Cbe(e) {
    if (e == null)
      return String(e);
    if (typeof e == "function" && e.name)
      return `function ${e.name}`;
    if (typeof e == "object")
      return e.constructor && e.constructor.name ? `an instance of ${e.constructor.name}` : `${(0, ll().inspect)(e, {
        depth: -1
      })}`;
    let t = (0, ll().inspect)(e, {
      colors: !1
    });
    return t.length > 28 && (t = `${t.slice(0, 25)}...`), `type ${typeof e} (${t})`;
  }
  s(Cbe, "determineSpecificType");
  var al = {}.hasOwnProperty, {
    ERR_INVALID_PACKAGE_CONFIG: wbe
  } = Gt, cO = /* @__PURE__ */ new Map();
  function PO(e, {
    base: t,
    specifier: r
  }) {
    let n = cO.get(e);
    if (n)
      return n;
    let i;
    try {
      i = ul().default.readFileSync(kf().toNamespacedPath(e), "utf8");
    } catch (o) {
      let l = o;
      if (l.code !== "ENOENT")
        throw l;
    }
    let a = {
      exists: !1,
      pjsonPath: e,
      main: void 0,
      name: void 0,
      type: "none",
      exports: void 0,
      imports: void 0
    };
    if (i !== void 0) {
      let o;
      try {
        o = JSON.parse(i);
      } catch (l) {
        let u = l, c = new wbe(e, (t ? `"${r}" from ` : "") + (0, Te().fileURLToPath)(t || r), u.message);
        throw c.cause = u, c;
      }
      a.exists = !0, al.call(o, "name") && typeof o.name == "string" && (a.name = o.name), al.call(o, "main") && typeof o.main == "string" &&
      (a.main = o.main), al.call(o, "exports") && (a.exports = o.exports), al.call(o, "imports") && (a.imports = o.imports), al.call(o, "typ\
e") && (o.type === "commonjs" || o.type === "module") && (a.type = o.type);
    }
    return cO.set(e, a), a;
  }
  s(PO, "read");
  function P1(e) {
    let t = new URL("package.json", e);
    for (; !t.pathname.endsWith("node_modules/package.json"); ) {
      let i = PO((0, Te().fileURLToPath)(t), {
        specifier: e
      });
      if (i.exists)
        return i;
      let a = t;
      if (t = new URL("../package.json", t), t.pathname === a.pathname)
        break;
    }
    return {
      pjsonPath: (0, Te().fileURLToPath)(t),
      exists: !1,
      type: "none"
    };
  }
  s(P1, "getPackageScopeConfig");
  function fO(e) {
    return P1(e).type;
  }
  s(fO, "getPackageType");
  var {
    ERR_UNKNOWN_FILE_EXTENSION: Dbe
  } = Gt, Ibe = {}.hasOwnProperty, _be = {
    __proto__: null,
    ".cjs": "commonjs",
    ".js": "module",
    ".json": "json",
    ".mjs": "module"
  };
  function Obe(e) {
    return e && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(e) ? "module" : e === "application/json" ? "json" : null;
  }
  s(Obe, "mimeToFormat");
  var pO = {
    __proto__: null,
    "data:": Nbe,
    "file:": kbe,
    "http:": dO,
    "https:": dO,
    "node:"() {
      return "builtin";
    }
  };
  function Nbe(e) {
    let {
      1: t
    } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(e.pathname) || [null, null, null];
    return Obe(t);
  }
  s(Nbe, "getDataProtocolModuleFormat");
  function Bbe(e) {
    let t = e.pathname, r = t.length;
    for (; r--; ) {
      let n = t.codePointAt(r);
      if (n === 47)
        return "";
      if (n === 46)
        return t.codePointAt(r - 1) === 47 ? "" : t.slice(r);
    }
    return "";
  }
  s(Bbe, "extname");
  function kbe(e, t, r) {
    let n = Bbe(e);
    if (n === ".js") {
      let o = fO(e);
      return o !== "none" ? o : "commonjs";
    }
    if (n === "") {
      let o = fO(e);
      return o === "none" || o === "commonjs" ? "commonjs" : "module";
    }
    let i = _be[n];
    if (i) return i;
    if (r)
      return;
    let a = (0, Te().fileURLToPath)(e);
    throw new Dbe(n, a);
  }
  s(kbe, "getFileProtocolModuleFormat");
  function dO() {
  }
  s(dO, "getHttpProtocolModuleFormat");
  function AO(e, t) {
    let r = e.protocol;
    return Ibe.call(pO, r) && pO[r](e, t, !0) || null;
  }
  s(AO, "defaultGetFormatWithoutErrors");
  var {
    ERR_INVALID_ARG_VALUE: Fbe
  } = Gt, CO = Object.freeze(["node", "import"]), jbe = new Set(CO);
  function Lbe() {
    return CO;
  }
  s(Lbe, "getDefaultConditions");
  function Mbe() {
    return jbe;
  }
  s(Mbe, "getDefaultConditionsSet");
  function Rbe(e) {
    if (e !== void 0 && e !== Lbe()) {
      if (!Array.isArray(e))
        throw new Fbe("conditions", e, "expected an array");
      return new Set(e);
    }
    return Mbe();
  }
  s(Rbe, "getConditionsSet");
  var Nf = RegExp.prototype[Symbol.replace], {
    ERR_NETWORK_IMPORT_DISALLOWED: v1,
    ERR_INVALID_MODULE_SPECIFIER: jf,
    ERR_INVALID_PACKAGE_CONFIG: wO,
    ERR_INVALID_PACKAGE_TARGET: qbe,
    ERR_MODULE_NOT_FOUND: A1,
    ERR_PACKAGE_IMPORT_NOT_DEFINED: Ube,
    ERR_PACKAGE_PATH_NOT_EXPORTED: Vbe,
    ERR_UNSUPPORTED_DIR_IMPORT: $be,
    ERR_UNSUPPORTED_RESOLVE_REQUEST: hO
  } = Gt, DO = {}.hasOwnProperty, mO = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i,
  yO = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i,
  Wbe = /^\.|%|\\/, Bf = /\*/g, Kbe = /%2f|%5c/i, gO = /* @__PURE__ */ new Set(), Gbe = /[/\\]{2}/;
  function bO(e, t, r, n, i, a, o) {
    if (ws().noDeprecation)
      return;
    let l = (0, Te().fileURLToPath)(n), u = Gbe.exec(o ? e : t) !== null;
    ws().emitWarning(`Use of deprecated ${u ? "double slash" : "leading or trailing slash matching"} resolving "${e}" for module request "${t}\
" ${t === r ? "" : `matched to "${r}" `}in the "${i ? "imports" : "exports"}" field module resolution of the package at ${l}${a ? ` imported\
 from ${(0, Te().fileURLToPath)(a)}` : ""}.`, "DeprecationWarning", "DEP0166");
  }
  s(bO, "emitInvalidSegmentDeprecation");
  function EO(e, t, r, n) {
    if (ws().noDeprecation || AO(e, {
      parentURL: r.href
    }) !== "module") return;
    let a = (0, Te().fileURLToPath)(e.href), o = (0, Te().fileURLToPath)(new (Te()).URL(".", t)), l = (0, Te().fileURLToPath)(r);
    n ? kf().resolve(o, n) !== a && ws().emitWarning(`Package ${o} has a "main" field set to "${n}", excluding the full filename and extensi\
on to the resolved file at "${a.slice(o.length)}", imported from ${l}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151") : ws().emitWarning(`No \
"main" or "exports" field defined in the package.json for ${o} resolving the main entry point "${a.slice(o.length)}", imported from ${l}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
  }
  s(EO, "emitLegacyIndexDeprecation");
  function IO(e) {
    try {
      return (0, ul().statSync)(e);
    } catch {
    }
  }
  s(IO, "tryStatSync");
  function T1(e) {
    let t = (0, ul().statSync)(e, {
      throwIfNoEntry: !1
    }), r = t ? t.isFile() : void 0;
    return r ?? !1;
  }
  s(T1, "fileExists");
  function Hbe(e, t, r) {
    let n;
    if (t.main !== void 0) {
      if (n = new (Te()).URL(t.main, e), T1(n)) return n;
      let o = [`./${t.main}.js`, `./${t.main}.json`, `./${t.main}.node`, `./${t.main}/index.js`, `./${t.main}/index.json`, `./${t.main}/inde\
x.node`], l = -1;
      for (; ++l < o.length && (n = new (Te()).URL(o[l], e), !T1(n)); )
        n = void 0;
      if (n)
        return EO(n, e, r, t.main), n;
    }
    let i = ["./index.js", "./index.json", "./index.node"], a = -1;
    for (; ++a < i.length && (n = new (Te()).URL(i[a], e), !T1(n)); )
      n = void 0;
    if (n)
      return EO(n, e, r, t.main), n;
    throw new A1((0, Te().fileURLToPath)(new (Te()).URL(".", e)), (0, Te().fileURLToPath)(r));
  }
  s(Hbe, "legacyMainResolve");
  function Ybe(e, t, r) {
    if (Kbe.exec(e.pathname) !== null)
      throw new jf(e.pathname, 'must not include encoded "/" or "\\" characters', (0, Te().fileURLToPath)(t));
    let n;
    try {
      n = (0, Te().fileURLToPath)(e);
    } catch (a) {
      let o = a;
      throw Object.defineProperty(o, "input", {
        value: String(e)
      }), Object.defineProperty(o, "module", {
        value: String(t)
      }), o;
    }
    let i = IO(n.endsWith("/") ? n.slice(-1) : n);
    if (i && i.isDirectory()) {
      let a = new $be(n, (0, Te().fileURLToPath)(t));
      throw a.url = String(e), a;
    }
    if (!i || !i.isFile()) {
      let a = new A1(n || e.pathname, t && (0, Te().fileURLToPath)(t), !0);
      throw a.url = String(e), a;
    }
    if (!r) {
      let a = (0, ul().realpathSync)(n), {
        search: o,
        hash: l
      } = e;
      e = (0, Te().pathToFileURL)(a + (n.endsWith(kf().sep) ? "/" : "")), e.search = o, e.hash = l;
    }
    return e;
  }
  s(Ybe, "finalizeResolution");
  function zbe(e, t, r) {
    return new Ube(e, t && (0, Te().fileURLToPath)(new (Te()).URL(".", t)), (0, Te().fileURLToPath)(r));
  }
  s(zbe, "importNotDefined");
  function x1(e, t, r) {
    return new Vbe((0, Te().fileURLToPath)(new (Te()).URL(".", t)), e, r && (0, Te().fileURLToPath)(r));
  }
  s(x1, "exportsNotFound");
  function Jbe(e, t, r, n, i) {
    let a = `request is not a valid match in pattern "${t}" for the "${n ? "imports" : "exports"}" resolution of ${(0, Te().fileURLToPath)(r)}`;
    throw new jf(e, a, i && (0, Te().fileURLToPath)(i));
  }
  s(Jbe, "throwInvalidSubpath");
  function ol(e, t, r, n, i) {
    return t = typeof t == "object" && t !== null ? JSON.stringify(t, null, "") : `${t}`, new qbe((0, Te().fileURLToPath)(new (Te()).URL(".",
    r)), e, t, n, i && (0, Te().fileURLToPath)(i));
  }
  s(ol, "invalidPackageTarget");
  function Xbe(e, t, r, n, i, a, o, l, u) {
    if (t !== "" && !a && e[e.length - 1] !== "/") throw ol(r, e, n, o, i);
    if (!e.startsWith("./")) {
      if (o && !e.startsWith("../") && !e.startsWith("/")) {
        let h = !1;
        try {
          new (Te()).URL(e), h = !0;
        } catch {
        }
        if (!h) {
          let y = a ? Nf.call(Bf, e, () => t) : e + t;
          return OO(y, n, u);
        }
      }
      throw ol(r, e, n, o, i);
    }
    if (mO.exec(e.slice(2)) !== null)
      if (yO.exec(e.slice(2)) === null) {
        if (!l) {
          let h = a ? r.replace("*", () => t) : r + t, y = a ? Nf.call(Bf, e, () => t) : e;
          bO(y, h, r, n, o, i, !0);
        }
      } else
        throw ol(r, e, n, o, i);
    let c = new (Te()).URL(e, n), f = c.pathname, p = new (Te()).URL(".", n).pathname;
    if (!f.startsWith(p)) throw ol(r, e, n, o, i);
    if (t === "") return c;
    if (mO.exec(t) !== null) {
      let h = a ? r.replace("*", () => t) : r + t;
      if (yO.exec(t) === null) {
        if (!l) {
          let y = a ? Nf.call(Bf, e, () => t) : e;
          bO(y, h, r, n, o, i, !1);
        }
      } else
        Jbe(h, r, n, o, i);
    }
    return a ? new (Te()).URL(Nf.call(Bf, c.href, () => t)) : new (Te()).URL(t, c);
  }
  s(Xbe, "resolvePackageTargetString");
  function Qbe(e) {
    let t = Number(e);
    return `${t}` !== e ? !1 : t >= 0 && t < 4294967295;
  }
  s(Qbe, "isArrayIndex");
  function ba(e, t, r, n, i, a, o, l, u) {
    if (typeof t == "string")
      return Xbe(t, r, n, e, i, a, o, l, u);
    if (Array.isArray(t)) {
      let c = t;
      if (c.length === 0) return null;
      let f, p = -1;
      for (; ++p < c.length; ) {
        let h = c[p], y;
        try {
          y = ba(e, h, r, n, i, a, o, l, u);
        } catch (v) {
          let d = v;
          if (f = d, d.code === "ERR_INVALID_PACKAGE_TARGET") continue;
          throw v;
        }
        if (y !== void 0) {
          if (y === null) {
            f = null;
            continue;
          }
          return y;
        }
      }
      if (f == null)
        return null;
      throw f;
    }
    if (typeof t == "object" && t !== null) {
      let c = Object.getOwnPropertyNames(t), f = -1;
      for (; ++f < c.length; ) {
        let p = c[f];
        if (Qbe(p))
          throw new wO((0, Te().fileURLToPath)(e), i, '"exports" cannot contain numeric property keys.');
      }
      for (f = -1; ++f < c.length; ) {
        let p = c[f];
        if (p === "default" || u && u.has(p)) {
          let h = t[p], y = ba(e, h, r, n, i, a, o, l, u);
          if (y === void 0) continue;
          return y;
        }
      }
      return null;
    }
    if (t === null)
      return null;
    throw ol(n, t, e, o, i);
  }
  s(ba, "resolvePackageTarget");
  function Zbe(e, t, r) {
    if (typeof e == "string" || Array.isArray(e)) return !0;
    if (typeof e != "object" || e === null) return !1;
    let n = Object.getOwnPropertyNames(e), i = !1, a = 0, o = -1;
    for (; ++o < n.length; ) {
      let l = n[o], u = l === "" || l[0] !== ".";
      if (a++ === 0)
        i = u;
      else if (i !== u)
        throw new wO((0, Te().fileURLToPath)(t), r, `"exports" cannot contain some keys starting with '.' and some not. The exports object m\
ust either be an object of package subpath keys or an object of main entry condition name keys only.`);
    }
    return i;
  }
  s(Zbe, "isConditionalExportsMainSugar");
  function e1e(e, t, r) {
    if (ws().noDeprecation)
      return;
    let n = (0, Te().fileURLToPath)(t);
    gO.has(n + "|" + e) || (gO.add(n + "|" + e), ws().emitWarning(`Use of deprecated trailing slash pattern mapping "${e}" in the "exports" \
field module resolution of the package at ${n}${r ? ` imported from ${(0, Te().fileURLToPath)(r)}` : ""}. Mapping specifiers ending in "/" i\
s no longer supported.`, "DeprecationWarning", "DEP0155"));
  }
  s(e1e, "emitTrailingSlashPatternDeprecation");
  function vO(e, t, r, n, i) {
    let a = r.exports;
    if (Zbe(a, e, n) && (a = {
      ".": a
    }), DO.call(a, t) && !t.includes("*") && !t.endsWith("/")) {
      let f = a[t], p = ba(e, f, "", t, n, !1, !1, !1, i);
      if (p == null)
        throw x1(t, e, n);
      return p;
    }
    let o = "", l = "", u = Object.getOwnPropertyNames(a), c = -1;
    for (; ++c < u.length; ) {
      let f = u[c], p = f.indexOf("*");
      if (p !== -1 && t.startsWith(f.slice(0, p))) {
        t.endsWith("/") && e1e(t, e, n);
        let h = f.slice(p + 1);
        t.length >= f.length && t.endsWith(h) && _O(o, f) === 1 && f.lastIndexOf("*") === p && (o = f, l = t.slice(p, t.length - h.length));
      }
    }
    if (o) {
      let f = a[o], p = ba(e, f, l, o, n, !0, !1, t.endsWith("/"), i);
      if (p == null)
        throw x1(t, e, n);
      return p;
    }
    throw x1(t, e, n);
  }
  s(vO, "packageExportsResolve");
  function _O(e, t) {
    let r = e.indexOf("*"), n = t.indexOf("*"), i = r === -1 ? e.length : r + 1, a = n === -1 ? t.length : n + 1;
    return i > a ? -1 : a > i || r === -1 ? 1 : n === -1 || e.length > t.length ? -1 : t.length > e.length ? 1 : 0;
  }
  s(_O, "patternKeyCompare");
  function t1e(e, t, r) {
    if (e === "#" || e.startsWith("#/") || e.endsWith("/")) {
      let a = "is not a valid internal imports specifier name";
      throw new jf(e, a, (0, Te().fileURLToPath)(t));
    }
    let n, i = P1(t);
    if (i.exists) {
      n = (0, Te().pathToFileURL)(i.pjsonPath);
      let a = i.imports;
      if (a)
        if (DO.call(a, e) && !e.includes("*")) {
          let o = ba(n, a[e], "", e, t, !1, !0, !1, r);
          if (o != null)
            return o;
        } else {
          let o = "", l = "", u = Object.getOwnPropertyNames(a), c = -1;
          for (; ++c < u.length; ) {
            let f = u[c], p = f.indexOf("*");
            if (p !== -1 && e.startsWith(f.slice(0, -1))) {
              let h = f.slice(p + 1);
              e.length >= f.length && e.endsWith(h) && _O(o, f) === 1 && f.lastIndexOf("*") === p && (o = f, l = e.slice(p, e.length - h.length));
            }
          }
          if (o) {
            let f = a[o], p = ba(n, f, l, o, t, !0, !0, !1, r);
            if (p != null)
              return p;
          }
        }
    }
    throw zbe(e, n, t);
  }
  s(t1e, "packageImportsResolve");
  function r1e(e, t) {
    let r = e.indexOf("/"), n = !0, i = !1;
    e[0] === "@" && (i = !0, r === -1 || e.length === 0 ? n = !1 : r = e.indexOf("/", r + 1));
    let a = r === -1 ? e : e.slice(0, r);
    if (Wbe.exec(a) !== null && (n = !1), !n)
      throw new jf(e, "is not a valid package name", (0, Te().fileURLToPath)(t));
    let o = "." + (r === -1 ? "" : e.slice(r));
    return {
      packageName: a,
      packageSubpath: o,
      isScoped: i
    };
  }
  s(r1e, "parsePackageName");
  function OO(e, t, r) {
    if (Ff().builtinModules.includes(e))
      return new (Te()).URL("node:" + e);
    let {
      packageName: n,
      packageSubpath: i,
      isScoped: a
    } = r1e(e, t), o = P1(t);
    if (o.exists) {
      let f = (0, Te().pathToFileURL)(o.pjsonPath);
      if (o.name === n && o.exports !== void 0 && o.exports !== null)
        return vO(f, i, o, t, r);
    }
    let l = new (Te()).URL("./node_modules/" + n + "/package.json", t), u = (0, Te().fileURLToPath)(l), c;
    do {
      let f = IO(u.slice(0, -13));
      if (!f || !f.isDirectory()) {
        c = u, l = new (Te()).URL((a ? "../../../../node_modules/" : "../../../node_modules/") + n + "/package.json", l), u = (0, Te().fileURLToPath)(
        l);
        continue;
      }
      let p = PO(u, {
        base: t,
        specifier: e
      });
      return p.exports !== void 0 && p.exports !== null ? vO(l, i, p, t, r) : i === "." ? Hbe(l, p, t) : new (Te()).URL(i, l);
    } while (u.length !== c.length);
    throw new A1(n, (0, Te().fileURLToPath)(t), !1);
  }
  s(OO, "packageResolve");
  function n1e(e) {
    return e[0] === "." && (e.length === 1 || e[1] === "/" || e[1] === "." && (e.length === 2 || e[2] === "/"));
  }
  s(n1e, "isRelativeSpecifier");
  function C1(e) {
    return e === "" ? !1 : e[0] === "/" ? !0 : n1e(e);
  }
  s(C1, "shouldBeTreatedAsRelativeOrAbsolutePath");
  function NO(e, t, r, n) {
    let i = t.protocol, o = i === "data:" || i === "http:" || i === "https:", l;
    if (C1(e))
      try {
        l = new (Te()).URL(e, t);
      } catch (u) {
        let c = new hO(e, t);
        throw c.cause = u, c;
      }
    else if (i === "file:" && e[0] === "#")
      l = t1e(e, t, r);
    else
      try {
        l = new (Te()).URL(e);
      } catch (u) {
        if (o && !Ff().builtinModules.includes(e)) {
          let c = new hO(e, t);
          throw c.cause = u, c;
        }
        l = OO(e, t, r);
      }
    return bn()(l !== void 0, "expected to be defined"), l.protocol !== "file:" ? l : Ybe(l, t, n);
  }
  s(NO, "moduleResolve");
  function s1e(e, t, r) {
    if (r) {
      let n = r.protocol;
      if (n === "http:" || n === "https:") {
        if (C1(e)) {
          let i = t?.protocol;
          if (i && i !== "https:" && i !== "http:")
            throw new v1(e, r, "remote imports cannot import from a local location.");
          return {
            url: t?.href || ""
          };
        }
        throw Ff().builtinModules.includes(e) ? new v1(e, r, "remote imports cannot import from a local location.") : new v1(e, r, "only rel\
ative and absolute specifiers are supported.");
      }
    }
  }
  s(s1e, "checkIfDisallowedImport");
  function i1e(e) {
    return !!(e && typeof e == "object" && "href" in e && typeof e.href == "string" && "protocol" in e && typeof e.protocol == "string" && e.
    href && e.protocol);
  }
  s(i1e, "isURL");
  function a1e(e) {
    if (e !== void 0 && typeof e != "string" && !i1e(e))
      throw new Gt.ERR_INVALID_ARG_TYPE("parentURL", ["string", "URL"], e);
  }
  s(a1e, "throwIfInvalidParentURL");
  function o1e(e, t = {}) {
    let {
      parentURL: r
    } = t;
    bn()(r !== void 0, "expected `parentURL` to be defined"), a1e(r);
    let n;
    if (r)
      try {
        n = new (Te()).URL(r);
      } catch {
      }
    let i, a;
    try {
      if (i = C1(e) ? new (Te()).URL(e, n) : new (Te()).URL(e), a = i.protocol, a === "data:")
        return {
          url: i.href,
          format: null
        };
    } catch {
    }
    let o = s1e(e, i, n);
    if (o) return o;
    if (a === void 0 && i && (a = i.protocol), a === "node:")
      return {
        url: e
      };
    if (i && i.protocol === "node:") return {
      url: e
    };
    let l = Rbe(t.conditions), u = NO(e, new (Te()).URL(r), l, !1);
    return {
      url: u.href,
      format: AO(u, {
        parentURL: r
      })
    };
  }
  s(o1e, "defaultResolve");
  function l1e(e, t) {
    if (!t)
      throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
    try {
      return o1e(e, {
        parentURL: t
      }).url;
    } catch (r) {
      let n = r;
      if ((n.code === "ERR_UNSUPPORTED_DIR_IMPORT" || n.code === "ERR_MODULE_NOT_FOUND") && typeof n.url == "string")
        return n.url;
      throw r;
    }
  }
  s(l1e, "resolve");
});

// ../node_modules/@babel/core/lib/config/files/plugins.js
var VO = T((Ds) => {
  "use strict";
  Object.defineProperty(Ds, "__esModule", {
    value: !0
  });
  Ds.loadPlugin = v1e;
  Ds.loadPreset = T1e;
  Ds.resolvePreset = Ds.resolvePlugin = void 0;
  function FO() {
    let e = qs();
    return FO = /* @__PURE__ */ s(function() {
      return e;
    }, "_debug"), e;
  }
  s(FO, "_debug");
  function I1() {
    let e = ie("path");
    return I1 = /* @__PURE__ */ s(function() {
      return e;
    }, "_path"), e;
  }
  s(I1, "_path");
  var _1 = Hi(), jO = y1();
  function D1() {
    let e = ie("url");
    return D1 = /* @__PURE__ */ s(function() {
      return e;
    }, "_url"), e;
  }
  s(D1, "_url");
  var u1e = BO();
  function LO() {
    let e = ie("fs");
    return LO = /* @__PURE__ */ s(function() {
      return e;
    }, "_fs"), e;
  }
  s(LO, "_fs");
  var MO = FO()("babel:config:loading:files:plugins"), c1e = /^module:/, f1e = /^(?!@|module:|[^/]+\/|babel-plugin-)/, p1e = /^(?!@|module:|[^/]+\/|babel-preset-)/,
  d1e = /^(@babel\/)(?!plugin-|[^/]+\/)/, h1e = /^(@babel\/)(?!preset-|[^/]+\/)/, m1e = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/,
  y1e = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/, g1e = /^(@(?!babel$)[^/]+)$/, b1e = Ds.resolvePlugin = qO.bind(null,
  "plugin"), E1e = Ds.resolvePreset = qO.bind(null, "preset");
  function* v1e(e, t) {
    let r = b1e(e, t, yield* (0, _1.isAsync)()), n = yield* UO("plugin", r);
    return MO("Loaded plugin %o from %o.", e, t), {
      filepath: r,
      value: n
    };
  }
  s(v1e, "loadPlugin");
  function* T1e(e, t) {
    let r = E1e(e, t, yield* (0, _1.isAsync)()), n = yield* UO("preset", r);
    return MO("Loaded preset %o from %o.", e, t), {
      filepath: r,
      value: n
    };
  }
  s(T1e, "loadPreset");
  function w1(e, t) {
    if (I1().isAbsolute(t)) return t;
    let r = e === "preset";
    return t.replace(r ? p1e : f1e, `babel-${e}-`).replace(r ? h1e : d1e, `$1${e}-`).replace(r ? y1e : m1e, `$1babel-${e}-`).replace(g1e, `$\
1/babel-${e}`).replace(c1e, "");
  }
  s(w1, "standardizeName");
  function* RO(e, t) {
    let r = w1(e, t), {
      error: n,
      value: i
    } = yield r;
    if (!n) return i;
    if (n.code !== "MODULE_NOT_FOUND") throw n;
    r !== t && !(yield t).error && (n.message += `
- If you want to resolve "${t}", use "module:${t}"`), (yield w1(e, "@babel/" + t)).error || (n.message += `
- Did you mean "@babel/${t}"?`);
    let a = e === "preset" ? "plugin" : "preset";
    if ((yield w1(a, t)).error || (n.message += `
- Did you accidentally pass a ${a} as a ${e}?`), e === "plugin") {
      let o = r.replace("-proposal-", "-transform-");
      o !== r && !(yield o).error && (n.message += `
- Did you mean "${o}"?`);
    }
    throw n.message += `

Make sure that all the Babel plugins and presets you are using
are defined as dependencies or devDependencies in your package.json
file. It's possible that the missing plugin is loaded by a preset
you are using that forgot to add the plugin to its dependencies: you
can workaround this problem by explicitly adding the missing package
to your top-level package.json.
`, n;
  }
  s(RO, "resolveAlternativesHelper");
  function x1e(e, t) {
    try {
      return t ? {
        error: null,
        value: (((r, n) => (r = r.split("."), n = n.split("."), +r[0] > +n[0] || r[0] == n[0] && +r[1] >= +n[1]))(process.versions.node, "8.\
9") ? ie.resolve : (r, {
          paths: [n]
        }, i = ie("module")) => {
          let a = i._findPath(r, i._nodeModulePaths(n).concat(n));
          if (a) return a;
          throw a = new Error(`Cannot resolve module '${r}'`), a.code = "MODULE_NOT_FOUND", a;
        })(e, {
          paths: [t]
        })
      } : {
        error: null,
        value: ie.resolve(e)
      };
    } catch (r) {
      return {
        error: r,
        value: null
      };
    }
  }
  s(x1e, "tryRequireResolve");
  function S1e(e, t) {
    try {
      return {
        error: null,
        value: (0, u1e.resolve)(e, t)
      };
    } catch (r) {
      return {
        error: r,
        value: null
      };
    }
  }
  s(S1e, "tryImportMetaResolve");
  function kO(e, t, r) {
    let n = RO(e, t), i = n.next();
    for (; !i.done; )
      i = n.next(x1e(i.value, r));
    return i.value;
  }
  s(kO, "resolveStandardizedNameForRequire");
  function P1e(e, t, r) {
    let n = (0, D1().pathToFileURL)(I1().join(r, "./babel-virtual-resolve-base.js")).href, i = RO(e, t), a = i.next();
    for (; !a.done; )
      a = i.next(S1e(a.value, n));
    return (0, D1().fileURLToPath)(a.value);
  }
  s(P1e, "resolveStandardizedNameForImport");
  function qO(e, t, r, n) {
    if (!jO.supportsESM || !n)
      return kO(e, t, r);
    try {
      let i = P1e(e, t, r);
      if (!(0, LO().existsSync)(i))
        throw Object.assign(new Error(`Could not resolve "${t}" in file ${r}.`), {
          type: "MODULE_NOT_FOUND"
        });
      return i;
    } catch (i) {
      try {
        return kO(e, t, r);
      } catch (a) {
        throw i.type === "MODULE_NOT_FOUND" ? i : a.type === "MODULE_NOT_FOUND" ? a : i;
      }
    }
  }
  s(qO, "resolveStandardizedName");
  Mf = /* @__PURE__ */ new Set();
  var Mf;
  function* UO(e, t) {
    if (!(yield* (0, _1.isAsync)()) && Mf.has(t))
      throw new Error(`Reentrant ${e} detected trying to load "${t}". This module is not ignored and is trying to load itself while compilin\
g itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);
    try {
      return Mf.add(t), yield* (0, jO.default)(t, `You appear to be using a native ECMAScript module ${e}, which is only supported when runn\
ing Babel asynchronously.`, !0);
    } catch (r) {
      throw r.message = `[BABEL]: ${r.message} (While processing: ${t})`, r;
    } finally {
      Mf.delete(t);
    }
  }
  s(UO, "requireModule");
});

// ../node_modules/@babel/core/lib/config/files/index.js
var Lo = T((Ar) => {
  "use strict";
  Object.defineProperty(Ar, "__esModule", {
    value: !0
  });
  Object.defineProperty(Ar, "ROOT_CONFIG_FILENAMES", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ea.ROOT_CONFIG_FILENAMES;
    }, "get")
  });
  Object.defineProperty(Ar, "findConfigUpwards", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ea.findConfigUpwards;
    }, "get")
  });
  Object.defineProperty(Ar, "findPackageData", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return A1e.findPackageData;
    }, "get")
  });
  Object.defineProperty(Ar, "findRelativeConfig", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ea.findRelativeConfig;
    }, "get")
  });
  Object.defineProperty(Ar, "findRootConfig", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ea.findRootConfig;
    }, "get")
  });
  Object.defineProperty(Ar, "loadConfig", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ea.loadConfig;
    }, "get")
  });
  Object.defineProperty(Ar, "loadPlugin", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Rf.loadPlugin;
    }, "get")
  });
  Object.defineProperty(Ar, "loadPreset", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Rf.loadPreset;
    }, "get")
  });
  Object.defineProperty(Ar, "resolvePlugin", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Rf.resolvePlugin;
    }, "get")
  });
  Object.defineProperty(Ar, "resolvePreset", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Rf.resolvePreset;
    }, "get")
  });
  Object.defineProperty(Ar, "resolveShowConfigPath", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ea.resolveShowConfigPath;
    }, "get")
  });
  var A1e = YC(), Ea = lO(), Rf = VO();
});

// ../node_modules/@babel/core/lib/transform.js
var WO = T((va) => {
  "use strict";
  Object.defineProperty(va, "__esModule", {
    value: !0
  });
  va.transform = void 0;
  va.transformAsync = I1e;
  va.transformSync = D1e;
  function $O() {
    let e = vr();
    return $O = /* @__PURE__ */ s(function() {
      return e;
    }, "_gensync"), e;
  }
  s($O, "_gensync");
  var C1e = la(), w1e = ff(), qf = Fn(), Uf = $O()(/* @__PURE__ */ s(function* (t, r) {
    let n = yield* (0, C1e.default)(r);
    return n === null ? null : yield* (0, w1e.run)(n, t);
  }, "transform")), j_e = va.transform = /* @__PURE__ */ s(function(t, r, n) {
    let i, a;
    if (typeof r == "function" ? (a = r, i = void 0) : (i = r, a = n), a === void 0)
      return (0, qf.beginHiddenCallStack)(Uf.sync)(t, i);
    (0, qf.beginHiddenCallStack)(Uf.errback)(t, i, a);
  }, "transform");
  function D1e(...e) {
    return (0, qf.beginHiddenCallStack)(Uf.sync)(...e);
  }
  s(D1e, "transformSync");
  function I1e(...e) {
    return (0, qf.beginHiddenCallStack)(Uf.async)(...e);
  }
  s(I1e, "transformAsync");
});

// ../node_modules/@babel/core/lib/transform-ast.js
var GO = T((Ta) => {
  "use strict";
  Object.defineProperty(Ta, "__esModule", {
    value: !0
  });
  Ta.transformFromAst = void 0;
  Ta.transformFromAstAsync = B1e;
  Ta.transformFromAstSync = N1e;
  function KO() {
    let e = vr();
    return KO = /* @__PURE__ */ s(function() {
      return e;
    }, "_gensync"), e;
  }
  s(KO, "_gensync");
  var _1e = la(), O1e = ff(), Vf = Fn(), $f = KO()(function* (e, t, r) {
    let n = yield* (0, _1e.default)(r);
    if (n === null) return null;
    if (!e) throw new Error("No AST given");
    return yield* (0, O1e.run)(n, t, e);
  }), R_e = Ta.transformFromAst = /* @__PURE__ */ s(function(t, r, n, i) {
    let a, o;
    if (typeof n == "function" ? (o = n, a = void 0) : (a = n, o = i), o === void 0)
      return (0, Vf.beginHiddenCallStack)($f.sync)(t, r, a);
    (0, Vf.beginHiddenCallStack)($f.errback)(t, r, a, o);
  }, "transformFromAst");
  function N1e(...e) {
    return (0, Vf.beginHiddenCallStack)($f.sync)(...e);
  }
  s(N1e, "transformFromAstSync");
  function B1e(...e) {
    return (0, Vf.beginHiddenCallStack)($f.async)(...e);
  }
  s(B1e, "transformFromAstAsync");
});

// ../node_modules/@babel/core/lib/parse.js
var YO = T((xa) => {
  "use strict";
  Object.defineProperty(xa, "__esModule", {
    value: !0
  });
  xa.parse = void 0;
  xa.parseAsync = M1e;
  xa.parseSync = L1e;
  function HO() {
    let e = vr();
    return HO = /* @__PURE__ */ s(function() {
      return e;
    }, "_gensync"), e;
  }
  s(HO, "_gensync");
  var k1e = la(), F1e = Wg(), j1e = Rg(), Wf = Fn(), Kf = HO()(/* @__PURE__ */ s(function* (t, r) {
    let n = yield* (0, k1e.default)(r);
    return n === null ? null : yield* (0, F1e.default)(n.passes, (0, j1e.default)(n), t);
  }, "parse")), V_e = xa.parse = /* @__PURE__ */ s(function(t, r, n) {
    if (typeof r == "function" && (n = r, r = void 0), n === void 0)
      return (0, Wf.beginHiddenCallStack)(Kf.sync)(t, r);
    (0, Wf.beginHiddenCallStack)(Kf.errback)(t, r, n);
  }, "parse");
  function L1e(...e) {
    return (0, Wf.beginHiddenCallStack)(Kf.sync)(...e);
  }
  s(L1e, "parseSync");
  function M1e(...e) {
    return (0, Wf.beginHiddenCallStack)(Kf.async)(...e);
  }
  s(M1e, "parseAsync");
});

// ../node_modules/@babel/core/lib/index.js
var bt = T((Ve) => {
  "use strict";
  Object.defineProperty(Ve, "__esModule", {
    value: !0
  });
  Ve.DEFAULT_EXTENSIONS = void 0;
  Object.defineProperty(Ve, "File", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return R1e.default;
    }, "get")
  });
  Object.defineProperty(Ve, "buildExternalHelpers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return q1e.default;
    }, "get")
  });
  Object.defineProperty(Ve, "createConfigItem", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return En.createConfigItem;
    }, "get")
  });
  Object.defineProperty(Ve, "createConfigItemAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return En.createConfigItemAsync;
    }, "get")
  });
  Object.defineProperty(Ve, "createConfigItemSync", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return En.createConfigItemSync;
    }, "get")
  });
  Object.defineProperty(Ve, "getEnv", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return U1e.getEnv;
    }, "get")
  });
  Object.defineProperty(Ve, "loadOptions", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return En.loadOptions;
    }, "get")
  });
  Object.defineProperty(Ve, "loadOptionsAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return En.loadOptionsAsync;
    }, "get")
  });
  Object.defineProperty(Ve, "loadOptionsSync", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return En.loadOptionsSync;
    }, "get")
  });
  Object.defineProperty(Ve, "loadPartialConfig", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return En.loadPartialConfig;
    }, "get")
  });
  Object.defineProperty(Ve, "loadPartialConfigAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return En.loadPartialConfigAsync;
    }, "get")
  });
  Object.defineProperty(Ve, "loadPartialConfigSync", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return En.loadPartialConfigSync;
    }, "get")
  });
  Object.defineProperty(Ve, "parse", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return k1.parse;
    }, "get")
  });
  Object.defineProperty(Ve, "parseAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return k1.parseAsync;
    }, "get")
  });
  Object.defineProperty(Ve, "parseSync", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return k1.parseSync;
    }, "get")
  });
  Object.defineProperty(Ve, "resolvePlugin", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return zO.resolvePlugin;
    }, "get")
  });
  Object.defineProperty(Ve, "resolvePreset", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return zO.resolvePreset;
    }, "get")
  });
  Object.defineProperty(Ve, "template", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ZO().default;
    }, "get")
  });
  Object.defineProperty(Ve, "tokTypes", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return XO().tokTypes;
    }, "get")
  });
  Object.defineProperty(Ve, "transform", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return O1.transform;
    }, "get")
  });
  Object.defineProperty(Ve, "transformAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return O1.transformAsync;
    }, "get")
  });
  Object.defineProperty(Ve, "transformFile", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return N1.transformFile;
    }, "get")
  });
  Object.defineProperty(Ve, "transformFileAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return N1.transformFileAsync;
    }, "get")
  });
  Object.defineProperty(Ve, "transformFileSync", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return N1.transformFileSync;
    }, "get")
  });
  Object.defineProperty(Ve, "transformFromAst", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return B1.transformFromAst;
    }, "get")
  });
  Object.defineProperty(Ve, "transformFromAstAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return B1.transformFromAstAsync;
    }, "get")
  });
  Object.defineProperty(Ve, "transformFromAstSync", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return B1.transformFromAstSync;
    }, "get")
  });
  Object.defineProperty(Ve, "transformSync", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return O1.transformSync;
    }, "get")
  });
  Object.defineProperty(Ve, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return QO().default;
    }, "get")
  });
  Ve.version = Ve.types = void 0;
  var R1e = Qy(), q1e = TC(), zO = Lo(), U1e = wg();
  function JO() {
    let e = Pe();
    return JO = /* @__PURE__ */ s(function() {
      return e;
    }, "_types"), e;
  }
  s(JO, "_types");
  Object.defineProperty(Ve, "types", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return JO();
    }, "get")
  });
  function XO() {
    let e = Ls();
    return XO = /* @__PURE__ */ s(function() {
      return e;
    }, "_parser"), e;
  }
  s(XO, "_parser");
  function QO() {
    let e = _r();
    return QO = /* @__PURE__ */ s(function() {
      return e;
    }, "_traverse"), e;
  }
  s(QO, "_traverse");
  function ZO() {
    let e = Ni();
    return ZO = /* @__PURE__ */ s(function() {
      return e;
    }, "_template"), e;
  }
  s(ZO, "_template");
  var En = la(), O1 = WO(), N1 = ib(), B1 = GO(), k1 = YO(), K_e = bt(), G_e = Ve.version = "7.25.2", H_e = Ve.DEFAULT_EXTENSIONS = Object.freeze(
  [".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
  Ve.OptionManager = class {
    static {
      s(this, "OptionManager");
    }
    init(t) {
      return (0, En.loadOptionsSync)(t);
    }
  }, Ve.Plugin = /* @__PURE__ */ s(function(t) {
    throw new Error(`The (${t}) Babel 5 plugin is being run with an unsupported Babel version.`);
  }, "Plugin");
});

// src/babel/index.ts
var $1e = Jn(bt(), 1), rOe = Jn(bt(), 1), tN = Jn(bt(), 1), F1 = Jn(fo(), 1), nOe = Jn(Ls(), 1), j1 = Jn(_r(), 1), sOe = Jn(Pe(), 1);
import * as iOe from "recast";

// src/babel/babelParse.ts
var Gf = Jn(Ls(), 1);
import * as Hf from "recast";
function V1e(e, t) {
  let i = /^\s*\/\/\s*@flow/.test(e) ? ["flow"] : ["typescript"], a = {
    ...t,
    plugins: [...t.plugins ?? [], ...i]
  };
  return Gf.parse(e, a);
}
s(V1e, "parseWithFlowOrTypescript");
var eN = {
  sourceType: "module",
  // FIXME: we should get this from the project config somehow?
  plugins: ["jsx", "decorators-legacy", "classProperties"],
  tokens: !0
}, X_e = /* @__PURE__ */ s((e) => Hf.parse(e, {
  parser: {
    parse(t) {
      return V1e(t, eN);
    }
  }
}), "babelParse"), Q_e = /* @__PURE__ */ s((e) => Hf.print(e, {
  quote: "single",
  trailingComma: !0,
  tabWidth: 2,
  wrapColumn: 80,
  arrowParensAlways: !0
}).code, "babelPrint"), Z_e = /* @__PURE__ */ s((e) => Gf.parseExpression(e, eN), "babelParseExpression");

// src/babel/index.ts
var aOe = j1.default.default || j1.default, oOe = F1.default.default || F1.default, lOe = tN.File;
var export_transformSync = $1e.transformSync;
export {
  lOe as BabelFileClass,
  X_e as babelParse,
  Z_e as babelParseExpression,
  Q_e as babelPrint,
  rOe as core,
  oOe as generate,
  nOe as parser,
  eN as parserOptions,
  iOe as recast,
  export_transformSync as transformSync,
  aOe as traverse,
  sOe as types
};
