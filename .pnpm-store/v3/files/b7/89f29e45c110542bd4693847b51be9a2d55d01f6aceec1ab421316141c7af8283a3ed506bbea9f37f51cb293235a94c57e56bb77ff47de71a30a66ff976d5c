/**
 * @license
 * Copyright Tyler Technologies, Inc. 
 * License: Apache-2.0
 */
import { BUTTON_TOGGLE_CONSTANTS } from '../button-toggle/button-toggle-constants';
import { BUTTON_TOGGLE_GROUP_CONSTANTS } from './button-toggle-group-constants';
export class ButtonToggleGroupCore {
    constructor(_adapter) {
        this._adapter = _adapter;
        this._values = [];
        this._outlined = true;
        this._multiple = false;
        this._mandatory = false;
        this._vertical = false;
        this._stretch = false;
        this._dense = false;
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        this._theme = 'tertiary';
        this._selectListener = evt => this._onSelect(evt);
        this._slotListener = () => this._synchronize();
    }
    initialize() {
        this._adapter.setFormValue();
        this._adapter.setFormValidity();
        this._adapter.addListener(BUTTON_TOGGLE_CONSTANTS.events.SELECT, this._selectListener);
        this._adapter.addSlotChangeListener(this._slotListener);
    }
    destroy() {
        this._adapter.removeListener(BUTTON_TOGGLE_CONSTANTS.events.SELECT, this._selectListener);
        this._adapter.removeSlotChangeListener(this._slotListener);
    }
    _synchronize() {
        if (this._disabled) {
            this._adapter.setDisabled(this._disabled);
        }
        if (this._readonly) {
            this._adapter.setReadonly(this._readonly);
        }
        if (this._multiple) {
            const selectedValues = new Set(this._adapter.getSelectedValues().concat(this._values));
            this.value = Array.from(selectedValues);
        }
        else {
            const selectedValues = this._adapter.getSelectedValues().concat(this._values);
            this.value = selectedValues.length ? selectedValues[selectedValues.length - 1] : null;
        }
    }
    _onSelect(evt) {
        // When in mandatory mode we need to ensure at least one element is selected. If the user tries to deselect the last
        // element, we prevent the select event from toggling.
        if (this._mandatory) {
            const values = this._adapter.getSelectedValues();
            if (!values.length) {
                evt.preventDefault();
                return;
            }
        }
        // Compute the new state to provide in the change event
        let value;
        if (evt.detail.selected) {
            value = this._multiple ? [...this._values, evt.detail.value] : [evt.detail.value];
        }
        else {
            value = this._multiple ? this._values.filter(v => v !== evt.detail.value) : [];
        }
        const detail = this._multiple ? value : value.length ? value[0] : null;
        const changeEvt = new CustomEvent(BUTTON_TOGGLE_GROUP_CONSTANTS.events.CHANGE, {
            detail,
            bubbles: true,
            cancelable: true
        });
        this._adapter.dispatchHostEvent(changeEvt);
        if (changeEvt.defaultPrevented) {
            evt.preventDefault();
            return;
        }
        this._values = value;
        this._adapter.applyValues(this._values);
        this._adapter.setFormValue();
        this._adapter.setFormValidity();
    }
    _applyValue(value) {
        let values = Array.isArray(value) ? value : value != null ? [value] : [];
        this._values = values;
        if (!this._multiple && values.length > 1) {
            values = [values[0]];
        }
        this._adapter.applyValues(values);
        this._adapter.setFormValue();
        this._adapter.setFormValidity();
    }
    get value() {
        // Combine the selected toggle values with our current state to ensure we always return the latest value
        // even if our state doesn't match a selected toggle.
        const values = Array.from(new Set(this._adapter.getSelectedValues().concat(this._values)));
        // eslint-disable-next-line prettier/prettier
        return this._multiple ? Array.from(values) : (values[0] ?? null);
    }
    set value(value) {
        this._applyValue(value);
    }
    get multiple() {
        return this._multiple;
    }
    set multiple(value) {
        value = !!value;
        if (this._multiple !== value) {
            this._multiple = value;
            this._applyValue(this._values);
            this._adapter.toggleHostAttribute(BUTTON_TOGGLE_GROUP_CONSTANTS.attributes.MULTIPLE, this._multiple);
        }
    }
    get mandatory() {
        return this._mandatory;
    }
    set mandatory(value) {
        value = !!value;
        if (this._mandatory !== value) {
            this._mandatory = value;
            this._adapter.toggleHostAttribute(BUTTON_TOGGLE_GROUP_CONSTANTS.attributes.MANDATORY, this._mandatory);
        }
    }
    get vertical() {
        return this._vertical;
    }
    set vertical(value) {
        value = !!value;
        if (this._vertical !== value) {
            this._vertical = value;
            this._adapter.toggleHostAttribute(BUTTON_TOGGLE_GROUP_CONSTANTS.attributes.VERTICAL, this._vertical);
        }
    }
    get stretch() {
        return this._stretch;
    }
    set stretch(value) {
        value = !!value;
        if (this._stretch !== value) {
            this._stretch = value;
            this._adapter.toggleHostAttribute(BUTTON_TOGGLE_GROUP_CONSTANTS.attributes.STRETCH, this._stretch);
        }
    }
    get dense() {
        return this._dense;
    }
    set dense(value) {
        value = !!value;
        if (this._dense !== value) {
            this._dense = value;
            this._adapter.toggleHostAttribute(BUTTON_TOGGLE_GROUP_CONSTANTS.attributes.DENSE, this._dense);
        }
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        value = !!value;
        if (this._disabled !== value) {
            this._disabled = value;
            this._adapter.setDisabled(this._disabled);
            this._adapter.toggleHostAttribute(BUTTON_TOGGLE_GROUP_CONSTANTS.attributes.DISABLED, this._disabled);
        }
    }
    get readonly() {
        return this._readonly;
    }
    set readonly(value) {
        value = !!value;
        if (this._readonly !== value) {
            this._readonly = value;
            this._adapter.setReadonly(this._readonly);
            this._adapter.toggleHostAttribute(BUTTON_TOGGLE_GROUP_CONSTANTS.attributes.READONLY, this._readonly);
        }
    }
    get required() {
        return this._required;
    }
    set required(value) {
        value = !!value;
        if (this._required !== value) {
            this._required = value;
            this._adapter.toggleHostAttribute(BUTTON_TOGGLE_GROUP_CONSTANTS.attributes.REQUIRED, this._required);
        }
    }
    get outlined() {
        return this._outlined;
    }
    set outlined(value) {
        value = !!value;
        if (this._outlined !== value) {
            this._outlined = value;
            this._adapter.toggleHostAttribute(BUTTON_TOGGLE_GROUP_CONSTANTS.attributes.NO_OUTLINE, !this._outlined);
        }
    }
    get theme() {
        return this._theme;
    }
    set theme(value) {
        if (this._theme !== value) {
            this._theme = value;
            this._adapter.toggleHostAttribute(BUTTON_TOGGLE_GROUP_CONSTANTS.attributes.THEME, this._theme !== 'tertiary', this._theme);
        }
    }
}
