/**
 * @license
 * Copyright Tyler Technologies, Inc. 
 * License: Apache-2.0
 */
import { TimeSegmentParser } from './time-segment-parser';
export const SEGMENT_CURSOR_POSITION = {
    'hours-start': 0,
    'hours-end': 2,
    'minutes-start': 3,
    'minutes-end': 5,
    'seconds-start': 6,
    'seconds-end': 8,
    'meridiem-start': 9,
    'meridiem-end': 11
};
export class IntermediateTimeParser {
    constructor(_char, _mask) {
        this._char = _char;
        this._mask = _mask;
        this._segmentParser = new TimeSegmentParser(this._mask.value);
    }
    get value() {
        return this.isAllSelected ? '' : this._normalizeTimeString(this._mask.value);
    }
    get numChar() {
        return Number(this._char);
    }
    get asPaddedChar() {
        return String(this.numChar).padStart(2, '0');
    }
    _normalizeTimeString(str) {
        // Remove all whitespace and placeholder chars
        let value = str.replace(/\s+|_/g, '');
        // If the time value only contains separator chars (:) then we can assume it's empty (applicable when the mask format is visible)
        if (/^:+$/.test(value)) {
            value = '';
        }
        return value;
    }
    get isAllSelected() {
        // eslint-disable-next-line @typescript-eslint/dot-notation
        const { start, end } = this._mask['_selection'];
        return start === 0 && end > 0 && end === this._mask.value.length;
    }
    /** Determines if this is the first non-zero hours character being entered. */
    get isFirstHoursChar() {
        return this._mask.cursorPos === 1 && this.numChar > 0;
    }
    /** Determines if this is the first minutes char being entered */
    get isFirstMinutesChar() {
        return [3, 4].includes(this._mask.cursorPos) && this._segmentParser.minutes.length !== 2;
    }
    get isFirstSecondsChar() {
        return [6, 7].includes(this._mask.cursorPos) && this._segmentParser.seconds.length !== 2;
    }
    get isFinalHoursChar() {
        return this._mask.cursorPos === 3 && this._segmentParser.hours.length === 2;
    }
    get isFinalMinutesChar() {
        return this._mask.cursorPos === 6 && this._segmentParser.minutes.length === 2;
    }
    get isFinalSecondsChar() {
        return this._mask.cursorPos === 9 && this._segmentParser.seconds.length === 2;
    }
    get isInitialHoursEntry() {
        return this._segmentParser.hours.length === 0;
    }
    get hasOnlyHoursSegment() {
        return !!this._segmentParser.hours && !this._segmentParser.minutes && !this._segmentParser.seconds;
    }
    get hoursSegmentNum() {
        return Number(this._segmentParser.hours);
    }
    get minutesSegmentNum() {
        return Number(this._segmentParser.minutes);
    }
    get secondsSegmentNum() {
        return Number(this._segmentParser.seconds);
    }
    get canOverwriteHoursChar() {
        return this._mask.cursorPos === 3 && !!this._segmentParser.hours.length && this.hoursSegmentNum < 3;
    }
    get canOverwriteMinutesChar() {
        return [5, 6].includes(this._mask.cursorPos) && !!this._segmentParser.minutes.length && this.minutesSegmentNum < 60;
    }
    get canOverwriteSecondsChar() {
        return [8, 9].includes(this._mask.cursorPos) && !!this._segmentParser.seconds.length && this.secondsSegmentNum < 60;
    }
    reset() {
        this._segmentParser.applyValue('');
    }
    patchSegmentValue(type, value, { overwrite = false } = {}) {
        if (overwrite) {
            this.reset();
        }
        this._segmentParser.patchSegmentValue(type, value);
        return this._segmentParser.toString();
    }
    applyValue(value, cursorPos) {
        this._mask.unmaskedValue = value;
        if (cursorPos !== undefined) {
            window.requestAnimationFrame(() => this._mask.updateCursor(SEGMENT_CURSOR_POSITION[cursorPos]));
        }
    }
}
