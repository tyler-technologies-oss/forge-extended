/**
 * @license
 * Copyright Tyler Technologies, Inc. 
 * License: Apache-2.0
 */
import { ICON_CONSTANTS } from './icon-constants';
import { IconRegistry } from './icon-registry';
import { createSanitizedSvg, fetchIconContent, getCachedIcon, sanitizeExternalType, awaitIconDefinition, removeIconListener } from './icon-utils';
export class IconCore {
    constructor(_adapter) {
        this._adapter = _adapter;
        this._lazy = false;
        this._external = false;
        this._externalType = 'standard';
        this._lazyListener = this._loadIcon.bind(this);
    }
    initialize() {
        this._applyIcon();
    }
    destroy() {
        this._adapter.destroyVisibilityObserver();
        this._clearIconQueue();
        this._tryRemoveListener();
    }
    _safeApplyIcon() {
        if (!this._adapter.isConnected) {
            return;
        }
        this._clearIconQueue();
        this._queueIconUpdate();
    }
    _tryRemoveListener() {
        if (this._registrationListener && this._name) {
            removeIconListener(this._name, this._registrationListener);
        }
    }
    _applyIcon() {
        if (this._lazy && this._adapter.canLazyLoad()) {
            this._adapter.observeVisibility(this._lazyListener);
        }
        else {
            this._loadIcon();
        }
    }
    _clearIconQueue() {
        if (this._applyTimer) {
            clearTimeout(this._applyTimer);
            this._applyTimer = undefined;
        }
    }
    _queueIconUpdate() {
        this._applyTimer = window.setTimeout(() => {
            this._applyTimer = undefined;
            this._applyIcon();
        });
    }
    async _loadIcon() {
        try {
            if (this._src) {
                // We were provided direct icon source content so just set that
                const node = createSanitizedSvg(this._src, this._viewbox);
                this._setIconContent(node);
            }
            else if (this._name) {
                // Let's attempt to get our icon from the registry
                const descriptor = this._tryGetIcon(this._name);
                // Short circuit here if we already have the node from a previous usage
                if (descriptor?.node) {
                    this._setIconContent(descriptor.node);
                    return;
                }
                let svgEl = null;
                if (!descriptor) {
                    if (!this._external) {
                        // We attach a listener to the registry to let us know when the icon is registered
                        this._registrationListener = () => this._applyIcon();
                        awaitIconDefinition(this._name, this._registrationListener);
                        // For now, we render nothing...
                        this._adapter.setContent(null);
                        return;
                    }
                    // We don't have a registry icon, so let's try the network to fetch it
                    if (!this._externalType) {
                        this._externalType = 'standard';
                    }
                    const url = this._getExternalUrl(this._name, this._externalType);
                    if (url) {
                        const content = await fetchIconContent(url, this._name);
                        if (content) {
                            svgEl = createSanitizedSvg(content, this._viewbox);
                        }
                    }
                }
                else if (descriptor.raw) {
                    svgEl = createSanitizedSvg(descriptor.raw, this._viewbox);
                }
                if (svgEl) {
                    if (!descriptor?.node) {
                        // Store the node for future use to improve performance
                        IconRegistry.setNode(this._name, svgEl);
                    }
                    this._setIconContent(svgEl);
                }
            }
            else {
                this._adapter.setContent(null);
            }
        }
        catch (e) {
            this._adapter.setContent(null);
            throw e;
        }
    }
    _setIconContent(svgElement) {
        const clone = svgElement ? svgElement.cloneNode(true) : null;
        if (clone) {
            this._adapter.setContent(clone);
        }
    }
    _tryGetIcon(key) {
        return getCachedIcon(key);
    }
    _getExternalUrl(name, type) {
        if (typeof this._externalUrlBuilder === 'function') {
            return this._externalUrlBuilder(name, type);
        }
        const setName = sanitizeExternalType(this._externalType);
        return `${ICON_CONSTANTS.strings.DEFAULT_NETWORK_BASE_URL}${setName ? `/${setName}` : ''}/${name}.svg`;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        if (this._name !== value) {
            // We need to remove our listener for the previous name if we have any
            if (!!this._registrationListener) {
                this._tryRemoveListener();
            }
            this._name = (value || '').replace(/\s+/, '');
            this._safeApplyIcon();
            this._adapter.toggleHostAttribute(ICON_CONSTANTS.attributes.NAME, !!this._name, this._name);
        }
    }
    get src() {
        return this._src;
    }
    set src(value) {
        if (this._src !== value) {
            this._src = value;
            if (this._adapter.isConnected) {
                this._applyIcon();
            }
            this._adapter.toggleHostAttribute(ICON_CONSTANTS.attributes.SRC, !!this._src, this._src);
        }
    }
    get lazy() {
        return this._lazy;
    }
    set lazy(value) {
        if (this._lazy !== value) {
            this._lazy = value;
            this._safeApplyIcon();
            this._adapter.toggleHostAttribute(ICON_CONSTANTS.attributes.LAZY, this._lazy);
        }
    }
    get external() {
        return this._external;
    }
    set external(value) {
        if (this._external !== value) {
            this._external = value;
            this._safeApplyIcon();
            this._adapter.toggleHostAttribute(ICON_CONSTANTS.attributes.EXTERNAL, this._external);
        }
    }
    get externalType() {
        return this._externalType;
    }
    set externalType(value) {
        if (this._externalType !== value) {
            this._externalType = value;
            this._safeApplyIcon();
            this._adapter.setHostAttribute(ICON_CONSTANTS.attributes.EXTERNAL_TYPE, `${this._externalType}`);
        }
    }
    get externalUrlBuilder() {
        return this._externalUrlBuilder;
    }
    set externalUrlBuilder(cb) {
        if (this._externalUrlBuilder !== cb) {
            this._externalUrlBuilder = cb;
            this._safeApplyIcon();
        }
    }
    get viewbox() {
        return this._viewbox;
    }
    set viewbox(value) {
        if (this._viewbox !== value) {
            this._viewbox = value;
            this._adapter.setViewBox(this._viewbox);
            this._adapter.setHostAttribute(ICON_CONSTANTS.attributes.VIEWBOX, `${this.viewbox}`);
        }
    }
    get theme() {
        return this._theme;
    }
    set theme(value) {
        if (this._theme !== value) {
            this._theme = value;
            this._adapter.setHostAttribute(ICON_CONSTANTS.attributes.THEME, this._theme);
        }
    }
    layout() {
        if (this._adapter.isConnected) {
            this._applyIcon();
        }
    }
}
