// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
import { booleanAttribute, Component, ChangeDetectionStrategy, Input } from '@angular/core';
import { defineTabComponent } from '@tylertech/forge';
import * as i0 from "@angular/core";
/**  */
export class TabComponent {
    /** The disabled state of the tab. Should not be set if using the disabled property on `forge-tab-bar`. */
    set disabled(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.disabled = value;
        });
    }
    get disabled() {
        return this.nativeElement.disabled;
    }
    /** The selected state of the tab. */
    set selected(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.selected = value;
        });
    }
    get selected() {
        return this.nativeElement.selected;
    }
    /** Controls whether the tab is vertical or horizontal. */
    set vertical(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.vertical = value;
        });
    }
    get vertical() {
        return this.nativeElement.vertical;
    }
    /** Controls whether the tab is taller to allow for slotted leading/trailing elements. */
    set stacked(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.stacked = value;
        });
    }
    get stacked() {
        return this.nativeElement.stacked;
    }
    /** Controls whether the tab is styled as secondary tab navigation. */
    set secondary(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.secondary = value;
        });
    }
    get secondary() {
        return this.nativeElement.secondary;
    }
    /** Controls whether the tab indicator is rendered on the opposite side of the tab. */
    set inverted(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.inverted = value;
        });
    }
    get inverted() {
        return this.nativeElement.inverted;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-tab element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineTabComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: TabComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: TabComponent, selector: "forge-tab", inputs: { disabled: ["disabled", "disabled", booleanAttribute], selected: ["selected", "selected", booleanAttribute], vertical: ["vertical", "vertical", booleanAttribute], stacked: ["stacked", "stacked", booleanAttribute], secondary: ["secondary", "secondary", booleanAttribute], inverted: ["inverted", "inverted", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: TabComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-tab',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], selected: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], vertical: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], stacked: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], secondary: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], inverted: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFiLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2ZvcmdlLWFuZ3VsYXIvc3JjL2xpYi90YWIvdGFiLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSx3SEFBd0g7QUFDeEgsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFNBQVMsRUFBYyx1QkFBdUIsRUFBNkIsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ25JLE9BQU8sRUFBNkMsa0JBQWtCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQzs7QUFFakcsT0FBTztBQU1QLE1BQU0sT0FBTyxZQUFZO0lBS3hCLDBHQUEwRztJQUMxRyxJQUNXLFFBQVEsQ0FBQyxLQUE0QztRQUMvRCxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRTtZQUNoQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFDckMsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBQ0QsSUFBVyxRQUFRO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUM7SUFDcEMsQ0FBQztJQUVELHFDQUFxQztJQUNyQyxJQUNXLFFBQVEsQ0FBQyxLQUE0QztRQUMvRCxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRTtZQUNoQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFDckMsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBQ0QsSUFBVyxRQUFRO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUM7SUFDcEMsQ0FBQztJQUVELDBEQUEwRDtJQUMxRCxJQUNXLFFBQVEsQ0FBQyxLQUE0QztRQUMvRCxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRTtZQUNoQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFDckMsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBQ0QsSUFBVyxRQUFRO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUM7SUFDcEMsQ0FBQztJQUVELHlGQUF5RjtJQUN6RixJQUNXLE9BQU8sQ0FBQyxLQUEyQztRQUM3RCxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRTtZQUNoQyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFDcEMsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBQ0QsSUFBVyxPQUFPO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUM7SUFDbkMsQ0FBQztJQUVELHNFQUFzRTtJQUN0RSxJQUNXLFNBQVMsQ0FBQyxLQUE2QztRQUNqRSxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRTtZQUNoQyxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7UUFDdEMsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBQ0QsSUFBVyxTQUFTO1FBQ25CLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUM7SUFDckMsQ0FBQztJQUVELHNGQUFzRjtJQUN0RixJQUNXLFFBQVEsQ0FBQyxLQUE0QztRQUMvRCxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRTtZQUNoQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFDckMsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBQ0QsSUFBVyxRQUFRO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUM7SUFDcEMsQ0FBQztJQUVELFlBQ0MsaUJBQW9DLEVBQzFCLFVBQWlELEVBQ2pELElBQVk7UUFEWixlQUFVLEdBQVYsVUFBVSxDQUF1QztRQUNqRCxTQUFJLEdBQUosSUFBSSxDQUFRO1FBeEV2Qiw2QkFBNkI7UUFDYixrQkFBYSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDO1FBeUU3RCxrQkFBa0IsRUFBRSxDQUFDO1FBQ3JCLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQzVCLENBQUM7OEdBOUVXLFlBQVk7a0dBQVosWUFBWSxzRUFNSixnQkFBZ0Isc0NBV2hCLGdCQUFnQixzQ0FXaEIsZ0JBQWdCLG1DQVdoQixnQkFBZ0IseUNBV2hCLGdCQUFnQixzQ0FXaEIsZ0JBQWdCLDZCQS9EekIsMkJBQTJCOzsyRkFFMUIsWUFBWTtrQkFMeEIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsV0FBVztvQkFDckIsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07b0JBQy9DLFFBQVEsRUFBRSwyQkFBMkI7aUJBQ3RDO29JQVFXLFFBQVE7c0JBRGxCLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBWTNCLFFBQVE7c0JBRGxCLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBWTNCLFFBQVE7c0JBRGxCLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBWTNCLE9BQU87c0JBRGpCLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBWTNCLFNBQVM7c0JBRG5CLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBWTNCLFFBQVE7c0JBRGxCLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGNvZGUgd2FzIGdlbmVyYXRlZCBieSB0aGUgYW5ndWxhci1jdXN0b20tZWxlbWVudHMtc2NoZW1hdGljLiAgQW55IGNoYW5nZXMgd2lsbCBiZSBvdmVyd3JpdHRlbiBuZXh0IHRpbWUgaXQgcnVucy5cbmltcG9ydCB7IGJvb2xlYW5BdHRyaWJ1dGUsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBOZ1pvbmUsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUYWJDb21wb25lbnQgYXMgVGFiQ29tcG9uZW50Q3VzdG9tRWxlbWVudCwgZGVmaW5lVGFiQ29tcG9uZW50IH0gZnJvbSAnQHR5bGVydGVjaC9mb3JnZSc7XG5cbi8qKiAgKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2ZvcmdlLXRhYicsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIFRhYkNvbXBvbmVudCB7XG5cblx0LyoqIFRoZSBmb3JnZS10YWIgZWxlbWVudC4gKi9cblx0cHVibGljIHJlYWRvbmx5IG5hdGl2ZUVsZW1lbnQgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcblxuXHQvKiogVGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSB0YWIuIFNob3VsZCBub3QgYmUgc2V0IGlmIHVzaW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eSBvbiBgZm9yZ2UtdGFiLWJhcmAuICovXG5cdEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuXHRwdWJsaWMgc2V0IGRpc2FibGVkKHZhbHVlOiBUYWJDb21wb25lbnRDdXN0b21FbGVtZW50WydkaXNhYmxlZCddKSB7XG5cdFx0dGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcblx0XHRcdHRoaXMubmF0aXZlRWxlbWVudC5kaXNhYmxlZCA9IHZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cdHB1YmxpYyBnZXQgZGlzYWJsZWQoKTogVGFiQ29tcG9uZW50Q3VzdG9tRWxlbWVudFsnZGlzYWJsZWQnXSB7XG5cdFx0cmV0dXJuIHRoaXMubmF0aXZlRWxlbWVudC5kaXNhYmxlZDtcblx0fVxuXG5cdC8qKiBUaGUgc2VsZWN0ZWQgc3RhdGUgb2YgdGhlIHRhYi4gKi9cblx0QElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG5cdHB1YmxpYyBzZXQgc2VsZWN0ZWQodmFsdWU6IFRhYkNvbXBvbmVudEN1c3RvbUVsZW1lbnRbJ3NlbGVjdGVkJ10pIHtcblx0XHR0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuXHRcdFx0dGhpcy5uYXRpdmVFbGVtZW50LnNlbGVjdGVkID0gdmFsdWU7XG5cdFx0fSk7XG5cdH1cblx0cHVibGljIGdldCBzZWxlY3RlZCgpOiBUYWJDb21wb25lbnRDdXN0b21FbGVtZW50WydzZWxlY3RlZCddIHtcblx0XHRyZXR1cm4gdGhpcy5uYXRpdmVFbGVtZW50LnNlbGVjdGVkO1xuXHR9XG5cblx0LyoqIENvbnRyb2xzIHdoZXRoZXIgdGhlIHRhYiBpcyB2ZXJ0aWNhbCBvciBob3Jpem9udGFsLiAqL1xuXHRASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcblx0cHVibGljIHNldCB2ZXJ0aWNhbCh2YWx1ZTogVGFiQ29tcG9uZW50Q3VzdG9tRWxlbWVudFsndmVydGljYWwnXSkge1xuXHRcdHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG5cdFx0XHR0aGlzLm5hdGl2ZUVsZW1lbnQudmVydGljYWwgPSB2YWx1ZTtcblx0XHR9KTtcblx0fVxuXHRwdWJsaWMgZ2V0IHZlcnRpY2FsKCk6IFRhYkNvbXBvbmVudEN1c3RvbUVsZW1lbnRbJ3ZlcnRpY2FsJ10ge1xuXHRcdHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnQudmVydGljYWw7XG5cdH1cblxuXHQvKiogQ29udHJvbHMgd2hldGhlciB0aGUgdGFiIGlzIHRhbGxlciB0byBhbGxvdyBmb3Igc2xvdHRlZCBsZWFkaW5nL3RyYWlsaW5nIGVsZW1lbnRzLiAqL1xuXHRASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcblx0cHVibGljIHNldCBzdGFja2VkKHZhbHVlOiBUYWJDb21wb25lbnRDdXN0b21FbGVtZW50WydzdGFja2VkJ10pIHtcblx0XHR0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuXHRcdFx0dGhpcy5uYXRpdmVFbGVtZW50LnN0YWNrZWQgPSB2YWx1ZTtcblx0XHR9KTtcblx0fVxuXHRwdWJsaWMgZ2V0IHN0YWNrZWQoKTogVGFiQ29tcG9uZW50Q3VzdG9tRWxlbWVudFsnc3RhY2tlZCddIHtcblx0XHRyZXR1cm4gdGhpcy5uYXRpdmVFbGVtZW50LnN0YWNrZWQ7XG5cdH1cblxuXHQvKiogQ29udHJvbHMgd2hldGhlciB0aGUgdGFiIGlzIHN0eWxlZCBhcyBzZWNvbmRhcnkgdGFiIG5hdmlnYXRpb24uICovXG5cdEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuXHRwdWJsaWMgc2V0IHNlY29uZGFyeSh2YWx1ZTogVGFiQ29tcG9uZW50Q3VzdG9tRWxlbWVudFsnc2Vjb25kYXJ5J10pIHtcblx0XHR0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuXHRcdFx0dGhpcy5uYXRpdmVFbGVtZW50LnNlY29uZGFyeSA9IHZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cdHB1YmxpYyBnZXQgc2Vjb25kYXJ5KCk6IFRhYkNvbXBvbmVudEN1c3RvbUVsZW1lbnRbJ3NlY29uZGFyeSddIHtcblx0XHRyZXR1cm4gdGhpcy5uYXRpdmVFbGVtZW50LnNlY29uZGFyeTtcblx0fVxuXG5cdC8qKiBDb250cm9scyB3aGV0aGVyIHRoZSB0YWIgaW5kaWNhdG9yIGlzIHJlbmRlcmVkIG9uIHRoZSBvcHBvc2l0ZSBzaWRlIG9mIHRoZSB0YWIuICovXG5cdEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuXHRwdWJsaWMgc2V0IGludmVydGVkKHZhbHVlOiBUYWJDb21wb25lbnRDdXN0b21FbGVtZW50WydpbnZlcnRlZCddKSB7XG5cdFx0dGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcblx0XHRcdHRoaXMubmF0aXZlRWxlbWVudC5pbnZlcnRlZCA9IHZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cdHB1YmxpYyBnZXQgaW52ZXJ0ZWQoKTogVGFiQ29tcG9uZW50Q3VzdG9tRWxlbWVudFsnaW52ZXJ0ZWQnXSB7XG5cdFx0cmV0dXJuIHRoaXMubmF0aXZlRWxlbWVudC5pbnZlcnRlZDtcblx0fVxuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcblx0XHRwcm90ZWN0ZWQgZWxlbWVudFJlZjogRWxlbWVudFJlZjxUYWJDb21wb25lbnRDdXN0b21FbGVtZW50Pixcblx0XHRwcm90ZWN0ZWQgem9uZTogTmdab25lXG5cdCkge1xuXHRcdGRlZmluZVRhYkNvbXBvbmVudCgpO1xuXHRcdGNoYW5nZURldGVjdG9yUmVmLmRldGFjaCgpO1xuXHR9XG59XG4iXX0=