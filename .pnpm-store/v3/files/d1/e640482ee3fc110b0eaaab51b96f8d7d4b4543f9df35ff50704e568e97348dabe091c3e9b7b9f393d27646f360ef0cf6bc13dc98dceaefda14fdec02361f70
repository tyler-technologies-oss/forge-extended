/**
 * @license
 * Copyright Tyler Technologies, Inc. 
 * License: Apache-2.0
 */
import { __decorate } from "tslib";
import { customElement, coerceNumber, coreProperty, coerceBoolean, attachShadowTemplate } from '@tylertech/forge-core';
import { TooltipAdapter } from './tooltip-adapter';
import { TooltipCore } from './tooltip-core';
import { TOOLTIP_CONSTANTS } from './tooltip-constants';
import { BaseComponent } from '../core/base/base-component';
import { OverlayComponent } from '../overlay/overlay';
import { coerceStringToArray } from '../core/utils/utils';
import { WithDefaultAria } from '../core/mixins/internals/with-default-aria';
import { WithElementInternals } from '../core/mixins/internals/with-element-internals';
import { tryDismiss } from '../core/utils/dismissible-stack';
const template = '<template><div class=\"forge-tooltip\" part=\"surface\"><slot></slot><div class=\"arrow\" part=\"arrow\"></div></div></template>';
const styles = '@keyframes slidein{from{opacity:0;transform:translateX(var(--_tooltip-slidein-x)) translateY(var(--_tooltip-slidein-y))}to{opacity:1;transform:translateX(0) translateY(0)}}:host{display:contents;pointer-events:none}:host([hidden]){display:none}.forge-tooltip{--_tooltip-background:var(--forge-tooltip-background, var(--forge-theme-surface-inverse, #333333));--_tooltip-color:var(--forge-tooltip-color, var(--forge-theme-on-surface-inverse, #ffffff));--_tooltip-shape:var(--forge-tooltip-shape, calc(var(--forge-shape-medium, 4px) * var(--forge-shape-factor, 1)));--_tooltip-padding:var(--forge-tooltip-padding, var(--forge-spacing-xsmall, 8px));--_tooltip-padding-block:var(--forge-tooltip-padding-block, var(--_tooltip-padding));--_tooltip-padding-inline:var(--forge-tooltip-padding-inline, var(--_tooltip-padding));--_tooltip-width:var(--forge-tooltip-width, max-content);--_tooltip-max-width:var(--forge-tooltip-max-width, 320px);--_tooltip-elevation:var(--forge-tooltip-elevation, var(--forge-theme-surface-bright-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12)));--_tooltip-content-align:var(--forge-tooltip-content-align, center);--_tooltip-border-width:var(--forge-tooltip-border-width, 0);--_tooltip-border-style:var(--forge-tooltip-border-style, solid);--_tooltip-border-color:var(--forge-tooltip-border-color, var(--forge-theme-outline, #e0e0e0));--_tooltip-animation-timing:var(--forge-tooltip-animation-timing, var(--forge-animation-easing-decelerate, cubic-bezier(0, 0, 0, 1)));--_tooltip-animation-duration:var(--forge-tooltip-animation-duration, var(--forge-animation-duration-short3, 150ms));--_tooltip-animation-offset:var(--forge-tooltip-animation-offset, 24px);--_tooltip-arrow-size:var(--forge-tooltip-arrow-size, 8px);--_tooltip-arrow-height:var(--forge-tooltip-arrow-height, var(--_tooltip-arrow-size));--_tooltip-arrow-width:var(--forge-tooltip-arrow-width, var(--_tooltip-arrow-size));--_tooltip-arrow-shape:var(--forge-tooltip-arrow-shape, calc(var(--forge-shape-small, 2px) * var(--forge-shape-factor, 1)));--_tooltip-arrow-rotation:var(--forge-tooltip-arrow-rotation, 0deg);--_tooltip-arrow-top-rotation:var(--forge-tooltip-arrow-top-rotation, 315deg);--_tooltip-arrow-right-rotation:var(--forge-tooltip-arrow-right-rotation, 45deg);--_tooltip-arrow-bottom-rotation:var(--forge-tooltip-arrow-bottom-rotation, 135deg);--_tooltip-arrow-left-rotation:var(--forge-tooltip-arrow-left-rotation, 225deg)}.forge-tooltip{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--forge-typography-body1-font-family, var(--forge-typography-font-family, \"Roboto\", sans-serif));font-size:var(--forge-typography-body1-font-size, calc(var(--forge-typography-font-size, 1rem) * var(--forge-typography-body-font-size-scale, .875)));font-weight:var(--forge-typography-body1-font-weight,400);line-height:var(--forge-typography-body1-line-height, calc(var(--forge-typography-font-size, 1rem) * var(--forge-typography-body-line-height-scale, 1.125)));letter-spacing:var(--forge-typography-body1-letter-spacing, .0357142857em);text-transform:var(--forge-typography-body1-text-transform,inherit);text-decoration:var(--forge-typography-body1-text-decoration,inherit);position:relative;background:var(--_tooltip-background);color:var(--_tooltip-color);border-radius:var(--_tooltip-shape);border-width:var(--_tooltip-border-width);border-style:var(--_tooltip-border-style);border-color:var(--_tooltip-border-color);padding-block:var(--_tooltip-padding-block);padding-inline:var(--_tooltip-padding-inline);box-shadow:var(--_tooltip-elevation);width:var(--_tooltip-width);max-width:var(--_tooltip-max-width);pointer-events:none;text-align:var(--_tooltip-content-align);line-height:normal;white-space:normal;animation-duration:var(--_tooltip-animation-duration);animation-timing-function:var(--_tooltip-animation-timing);animation-name:slidein;animation-fill-mode:forwards}:host(:not([open])) .forge-tooltip{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:fixed;width:1px;outline:0;-webkit-appearance:none;-moz-appearance:none}.arrow{position:absolute;contain:strict;background-color:inherit;height:var(--_tooltip-arrow-height);width:var(--_tooltip-arrow-width);box-shadow:inherit;border:inherit;border-end-start-radius:var(--_tooltip-arrow-shape);rotate:var(--_tooltip-arrow-rotation);clip-path:var(--_tooltip-arrow-clip-path);--_tooltip-arrow-translate-x:0;--_tooltip-arrow-translate-y:0;--_tooltip-arrow-clip-path:polygon(0 0, 0 100%, 100% 100%)}.forge-tooltip{--_tooltip-slidein-x:0;--_tooltip-slidein-y:0}forge-overlay[open][position-placement^=top] .forge-tooltip{--_tooltip-slidein-y:var(--forge-tooltip-slidein-y, var(--_tooltip-animation-offset))}forge-overlay[open][position-placement^=top] .arrow{--_tooltip-arrow-rotation:var(--_tooltip-arrow-top-rotation);margin-block-end:var(--_tooltip-border-width)}forge-overlay[open][position-placement^=right] .forge-tooltip{--_tooltip-slidein-x:var(--forge-tooltip-slidein-x, calc(var(--_tooltip-animation-offset) * -1))}forge-overlay[open][position-placement^=right] .arrow{--_tooltip-arrow-rotation:var(--_tooltip-arrow-right-rotation);margin-inline-start:var(--_tooltip-border-width)}forge-overlay[open][position-placement^=bottom] .forge-tooltip{--_tooltip-slidein-y:var(--forge-tooltip-slidein-y, calc(var(--_tooltip-animation-offset) * -1))}forge-overlay[open][position-placement^=bottom] .arrow{--_tooltip-arrow-rotation:var(--_tooltip-arrow-bottom-rotation);margin-block-start:var(--_tooltip-border-width)}forge-overlay[open][position-placement^=left] .forge-tooltip{--_tooltip-slidein-x:var(--forge-tooltip-slidein-x, var(--_tooltip-animation-offset))}forge-overlay[open][position-placement^=left] .arrow{--_tooltip-arrow-rotation:var(--_tooltip-arrow-left-rotation);margin-inline-end:var(--_tooltip-border-width)}';
/**
 * @tag forge-tooltip
 *
 * @summary Tooltips display information related to an element when the user hovers over an element.
 *
 * @dependency forge-overlay
 *
 * @property {boolean} [open=false] - Whether or not the tooltip is open.
 * @property {TooltipType} [type="presentation"] - The type of tooltip. Valid values are `presentation` (default), `label`, and `description`.
 * @property {string} anchor - The id of the element that the tooltip is anchored to.
 * @property {TooltipPlacement} [placement="right"] - The placement of the tooltip relative to the anchor element.
 * @property {number} [delay=500] - The delay in milliseconds before the tooltip is shown.
 * @property {number} [offset=4] - The offset in pixels between the tooltip and the anchor element.
 * @property {OverlayFlipState} [flip="auto"] - How the tooltip should place itself if there is not enough space at the desired placement.
 * @property {string | null} boundary - The id of the element that the tooltip should be constrained to.
 * @property {HTMLElement | null} boundaryElement - The element that the tooltip should be constrained to.
 * @property {PositionPlacement[] | null} fallbackPlacements - The fallback placements of the tooltip relative to the anchor element.
 * @property {TooltipTriggerType | TooltipTriggerType[]} [triggerType="hover"] - The trigger type(s) that will open the tooltip. Valid values are `hover` (default), `longpress`, and `focus`.
 *
 * @globalconfig type
 * @globalconfig delay
 * @globalconfig placement
 * @globalconfig offset
 * @globalconfig flip
 * @globalconfig boundaryElement
 * @globalconfig fallbackPlacements
 * @globalconfig triggerType
 *
 * @attribute {boolean} [open=false] - Whether or not the tooltip is open.
 * @attribute {TooltipType} [type="presentation"] - The type of tooltip. Valid values are `presentation` (default), `label`, and `description`.
 * @attribute {string} anchor - The id of the element that the tooltip is anchored to.
 * @attribute {TooltipPlacement} [placement="right"] - The placement of the tooltip relative to the anchor element.
 * @attribute {number} [delay=500] - The delay in milliseconds before the tooltip is shown.
 * @attribute {number} [offset=4] - The offset in pixels between the tooltip and the anchor element.
 * @attribute {OverlayFlipState} [flip="auto"] - How the tooltip should place itself if there is not enough space at the desired placement.
 * @attribute {string | null} boundary - The id of the element that the tooltip should be constrained to.
 * @attribute {PositionPlacement[]} fallback-placements - The fallback placements of the tooltip relative to the anchor element.
 * @attribute {TooltipTriggerType | TooltipTriggerType[]} [trigger-type="hover"] - The trigger type(s) that will open the tooltip. Valid values are `hover` (default), `longpress`, and `focus`.
 *
 * @cssproperty --forge-tooltip-background - The background color of the tooltip surface.
 * @cssproperty --forge-tooltip-color - The text color of the tooltip surface.
 * @cssproperty --forge-tooltip-shape - The shape of the tooltip surface.
 * @cssproperty --forge-tooltip-padding - The padding of the tooltip surface.
 * @cssproperty --forge-tooltip-padding-block - The block padding of the tooltip surface.
 * @cssproperty --forge-tooltip-padding-inline - The inline padding of the tooltip surface.
 * @cssproperty --forge-tooltip-max-width - The maximum width of the tooltip surface.
 * @cssproperty --forge-tooltip-elevation - The elevation of the tooltip surface.
 * @cssproperty --forge-tooltip-border-width - The border width of the tooltip surface.
 * @cssproperty --forge-tooltip-border-style - The border style of the tooltip surface.
 * @cssproperty --forge-tooltip-border-color - The border color of the tooltip surface.
 * @cssproperty --forge-tooltip-animation-timing - The animation timing function of the tooltip surface.
 * @cssproperty --forge-tooltip-animation-duration - The animation duration of the tooltip surface.
 * @cssproperty --forge-tooltip-animation-offset - The animation offset of the tooltip surface.
 * @cssproperty --forge-tooltip-arrow-size - The size of the tooltip arrow.
 * @cssproperty --forge-tooltip-arrow-height - The height of the tooltip arrow.
 * @cssproperty --forge-tooltip-arrow-width - The width of the tooltip arrow.
 * @cssproperty --forge-tooltip-arrow-shape - The shape of the tooltip arrow.
 * @cssproperty --forge-tooltip-arrow-clip-path - The clip path of the tooltip arrow.
 * @cssproperty --forge-tooltip-arrow-rotation - The rotation of the tooltip arrow.
 * @cssproperty --forge-tooltip-arrow-top-rotation - The rotation of the tooltip arrow when the tooltip is placed on top.
 * @cssproperty --forge-tooltip-arrow-right-rotation - The rotation of the tooltip arrow when the tooltip is placed on the right.
 * @cssproperty --forge-tooltip-arrow-bottom-rotation - The rotation of the tooltip arrow when the tooltip is placed on the bottom.
 * @cssproperty --forge-tooltip-arrow-left-rotation - The rotation of the tooltip arrow when the tooltip is placed on the left.
 *
 * @slot - The content to display in the tooltip.
 *
 * @csspart surface - The tooltip surface.
 * @csspart arrow - The tooltip arrow.
 * @csspart overlay - The overlay surface.
 */
let TooltipComponent = class TooltipComponent extends WithDefaultAria(WithElementInternals(BaseComponent)) {
    static get observedAttributes() {
        return Object.values(TOOLTIP_CONSTANTS.observedAttributes);
    }
    constructor() {
        super();
        attachShadowTemplate(this, template, styles);
        this._core = new TooltipCore(new TooltipAdapter(this));
    }
    [tryDismiss](state) {
        return true;
    }
    connectedCallback() {
        this._core.initialize();
    }
    disconnectedCallback() {
        this._core.destroy();
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case TOOLTIP_CONSTANTS.observedAttributes.ID:
                this._core.syncTooltipAria();
                break;
            case TOOLTIP_CONSTANTS.observedAttributes.OPEN:
                this.open = coerceBoolean(newValue);
                break;
            case TOOLTIP_CONSTANTS.observedAttributes.TYPE:
                this.type = newValue?.trim() ? newValue : TOOLTIP_CONSTANTS.defaults.TYPE;
                break;
            case TOOLTIP_CONSTANTS.observedAttributes.TARGET:
            case TOOLTIP_CONSTANTS.observedAttributes.ANCHOR:
                this.anchor = newValue;
                break;
            case TOOLTIP_CONSTANTS.observedAttributes.DELAY:
                this.delay = coerceNumber(newValue);
                break;
            case TOOLTIP_CONSTANTS.observedAttributes.POSITION:
            case TOOLTIP_CONSTANTS.observedAttributes.PLACEMENT:
                this.placement = newValue;
                break;
            case TOOLTIP_CONSTANTS.observedAttributes.OFFSET:
                this.offset = coerceNumber(newValue);
                break;
            case TOOLTIP_CONSTANTS.observedAttributes.FLIP:
                this.flip = newValue;
                break;
            case TOOLTIP_CONSTANTS.observedAttributes.BOUNDARY:
                this.boundary = newValue;
                break;
            case TOOLTIP_CONSTANTS.observedAttributes.FALLBACK_PLACEMENTS:
                this.fallbackPlacements = newValue?.trim() ? coerceStringToArray(newValue) : null;
                break;
            case TOOLTIP_CONSTANTS.observedAttributes.TRIGGER_TYPE:
                this.triggerType = newValue?.trim() ? coerceStringToArray(newValue) : TOOLTIP_CONSTANTS.defaults.TRIGGER_TYPES;
                break;
        }
    }
};
__decorate([
    coreProperty()
], TooltipComponent.prototype, "open", void 0);
__decorate([
    coreProperty()
], TooltipComponent.prototype, "type", void 0);
__decorate([
    coreProperty()
], TooltipComponent.prototype, "anchor", void 0);
__decorate([
    coreProperty()
], TooltipComponent.prototype, "anchorElement", void 0);
__decorate([
    coreProperty({ name: 'anchor' })
], TooltipComponent.prototype, "target", void 0);
__decorate([
    coreProperty()
], TooltipComponent.prototype, "placement", void 0);
__decorate([
    coreProperty({ name: 'placement' })
], TooltipComponent.prototype, "position", void 0);
__decorate([
    coreProperty()
], TooltipComponent.prototype, "delay", void 0);
__decorate([
    coreProperty()
], TooltipComponent.prototype, "offset", void 0);
__decorate([
    coreProperty()
], TooltipComponent.prototype, "flip", void 0);
__decorate([
    coreProperty()
], TooltipComponent.prototype, "boundary", void 0);
__decorate([
    coreProperty()
], TooltipComponent.prototype, "boundaryElement", void 0);
__decorate([
    coreProperty()
], TooltipComponent.prototype, "fallbackPlacements", void 0);
__decorate([
    coreProperty()
], TooltipComponent.prototype, "triggerType", void 0);
TooltipComponent = __decorate([
    customElement({
        name: TOOLTIP_CONSTANTS.elementName,
        dependencies: [OverlayComponent]
    })
], TooltipComponent);
export { TooltipComponent };
