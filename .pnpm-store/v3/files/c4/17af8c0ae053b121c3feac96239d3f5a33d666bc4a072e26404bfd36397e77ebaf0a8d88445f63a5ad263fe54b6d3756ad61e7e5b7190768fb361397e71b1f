import { ElementRef, ChangeDetectorRef, NgZone } from '@angular/core';
import { MenuComponent as MenuComponentCustomElement } from '@tylertech/forge';
import * as i0 from "@angular/core";
/**  */
export declare class MenuComponent {
    protected elementRef: ElementRef<MenuComponentCustomElement>;
    protected zone: NgZone;
    /** The forge-menu element. */
    readonly nativeElement: MenuComponentCustomElement;
    /** Gets/sets the open state. */
    set open(value: MenuComponentCustomElement['open']);
    get open(): MenuComponentCustomElement['open'];
    /** Gets/sets the array of options to display in the menu. */
    set options(value: MenuComponentCustomElement['options']);
    get options(): MenuComponentCustomElement['options'];
    /** Gets/sets the selected option to the index. Does not support cascading menus. */
    set selectedIndex(value: MenuComponentCustomElement['selectedIndex']);
    get selectedIndex(): MenuComponentCustomElement['selectedIndex'];
    /** Gets/sets the value of the option to select. */
    set selectedValue(value: MenuComponentCustomElement['selectedValue']);
    get selectedValue(): MenuComponentCustomElement['selectedValue'];
    /** Gets/sets the menu placement (default is bottom-left). */
    set placement(value: MenuComponentCustomElement['placement']);
    get placement(): MenuComponentCustomElement['placement'];
    /** Gets/sets the fallback menu placement for overriding the default of any side. */
    set fallbackPlacements(value: MenuComponentCustomElement['fallbackPlacements']);
    get fallbackPlacements(): MenuComponentCustomElement['fallbackPlacements'];
    /** Gets/sets dense state of the list options used in the menu popup. */
    set dense(value: MenuComponentCustomElement['dense']);
    get dense(): MenuComponentCustomElement['dense'];
    /** Gets/sets the class name to use for option icons. */
    set iconClass(value: MenuComponentCustomElement['iconClass']);
    get iconClass(): MenuComponentCustomElement['iconClass'];
    /** Gets/sets whether selection of menu items is persisted. */
    set persistSelection(value: MenuComponentCustomElement['persistSelection']);
    get persistSelection(): MenuComponentCustomElement['persistSelection'];
    /** Gets/sets the mode that this menu is using. */
    set mode(value: MenuComponentCustomElement['mode']);
    get mode(): MenuComponentCustomElement['mode'];
    /** Sets the position adjustment on the internal popup element. */
    set popupOffset(value: MenuComponentCustomElement['popupOffset']);
    get popupOffset(): MenuComponentCustomElement['popupOffset'];
    /** Sets the callback that will be executed for each option in the dropdown for producing custom option templates. */
    set optionBuilder(value: MenuComponentCustomElement['optionBuilder']);
    get optionBuilder(): MenuComponentCustomElement['optionBuilder'];
    /** Gets the currently active popup element when the dropdown is open. */
    get popupElement(): MenuComponentCustomElement['popupElement'];
    /** Gets/sets the list of classes to apply to the popup element. */
    set popupClasses(value: MenuComponentCustomElement['popupClasses']);
    get popupClasses(): MenuComponentCustomElement['popupClasses'];
    /** Gets/sets the callback function for generating header content within the popup. */
    set popupHeaderBuilder(value: MenuComponentCustomElement['popupHeaderBuilder']);
    get popupHeaderBuilder(): MenuComponentCustomElement['popupHeaderBuilder'];
    /** Gets/sets the callback function for generating header content within the popup. */
    set popupFooterBuilder(value: MenuComponentCustomElement['popupFooterBuilder']);
    get popupFooterBuilder(): MenuComponentCustomElement['popupFooterBuilder'];
    /** Gets/sets whether the popup width is synchronized with the popup target width. */
    set syncPopupWidth(value: MenuComponentCustomElement['syncPopupWidth']);
    get syncPopupWidth(): MenuComponentCustomElement['syncPopupWidth'];
    /** Gets/sets the maximum number of options to display in the dropdown. */
    set optionLimit(value: MenuComponentCustomElement['optionLimit']);
    get optionLimit(): MenuComponentCustomElement['optionLimit'];
    /** Controls the observation of scroll events on the dropdown. */
    set observeScroll(value: MenuComponentCustomElement['observeScroll']);
    get observeScroll(): MenuComponentCustomElement['observeScroll'];
    /** The number of pixels from the bottom to trigger the scroll bottom event. Only applicable if `observeScroll` is true. */
    set observeScrollThreshold(value: MenuComponentCustomElement['observeScrollThreshold']);
    get observeScrollThreshold(): MenuComponentCustomElement['observeScrollThreshold'];
    /** Gets/sets whether the popup width will be constrained to a max width of the viewport width (default: `100vw`). */
    set constrainPopupWidth(value: MenuComponentCustomElement['constrainPopupWidth']);
    get constrainPopupWidth(): MenuComponentCustomElement['constrainPopupWidth'];
    /**
     * Gets/sets whether the options will wrap their text or not.
     * This only applies if `constrainPopupWidth` is `true`, if there is an explicit width set via CSS.
     */
    set wrapOptionText(value: MenuComponentCustomElement['wrapOptionText']);
    get wrapOptionText(): MenuComponentCustomElement['wrapOptionText'];
    /** Force propagates the key event from another element to this component. */
    propagateKeyEvent(...args: Parameters<MenuComponentCustomElement['propagateKeyEvent']>): ReturnType<MenuComponentCustomElement['propagateKeyEvent']>;
    /** Activates the first option in the menu when open. */
    activateFirstOption(...args: Parameters<MenuComponentCustomElement['activateFirstOption']>): ReturnType<MenuComponentCustomElement['activateFirstOption']>;
    constructor(changeDetectorRef: ChangeDetectorRef, elementRef: ElementRef<MenuComponentCustomElement>, zone: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<MenuComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<MenuComponent, "forge-menu", never, { "open": { "alias": "open"; "required": false; }; "options": { "alias": "options"; "required": false; }; "selectedIndex": { "alias": "selectedIndex"; "required": false; }; "selectedValue": { "alias": "selectedValue"; "required": false; }; "placement": { "alias": "placement"; "required": false; }; "fallbackPlacements": { "alias": "fallbackPlacements"; "required": false; }; "dense": { "alias": "dense"; "required": false; }; "iconClass": { "alias": "iconClass"; "required": false; }; "persistSelection": { "alias": "persistSelection"; "required": false; }; "mode": { "alias": "mode"; "required": false; }; "popupOffset": { "alias": "popupOffset"; "required": false; }; "optionBuilder": { "alias": "optionBuilder"; "required": false; }; "popupClasses": { "alias": "popupClasses"; "required": false; }; "popupHeaderBuilder": { "alias": "popupHeaderBuilder"; "required": false; }; "popupFooterBuilder": { "alias": "popupFooterBuilder"; "required": false; }; "syncPopupWidth": { "alias": "syncPopupWidth"; "required": false; }; "optionLimit": { "alias": "optionLimit"; "required": false; }; "observeScroll": { "alias": "observeScroll"; "required": false; }; "observeScrollThreshold": { "alias": "observeScrollThreshold"; "required": false; }; "constrainPopupWidth": { "alias": "constrainPopupWidth"; "required": false; }; "wrapOptionText": { "alias": "wrapOptionText"; "required": false; }; }, {}, never, ["*"], false, never>;
    static ngAcceptInputType_open: unknown;
    static ngAcceptInputType_selectedIndex: unknown;
    static ngAcceptInputType_dense: unknown;
    static ngAcceptInputType_persistSelection: unknown;
    static ngAcceptInputType_syncPopupWidth: unknown;
    static ngAcceptInputType_optionLimit: unknown;
    static ngAcceptInputType_observeScroll: unknown;
    static ngAcceptInputType_observeScrollThreshold: unknown;
    static ngAcceptInputType_constrainPopupWidth: unknown;
    static ngAcceptInputType_wrapOptionText: unknown;
}
