/**
 * @license
 * Copyright Tyler Technologies, Inc. 
 * License: Apache-2.0
 */
import { __decorate } from "tslib";
import { coerceBoolean, coerceNumber, customElement, coreProperty } from '@tylertech/forge-core';
import { tylIconArrowDownward } from '@tylertech/tyler-icons/standard';
import { ExpansionPanelComponent } from '../expansion-panel';
import { CheckboxComponent } from '../checkbox';
import { TableAdapter } from './table-adapter';
import { TABLE_CONSTANTS } from './table-constants';
import { TableCore } from './table-core';
import { IconRegistry, IconComponent } from '../icon';
import { BaseComponent } from '../core/base/base-component';
import { CellAlign } from './types';
import { TooltipComponent } from '../tooltip';
/**
 * @tag forge-table
 *
 * @dependency forge-expansion-panel
 * @dependency forge-icon
 * @dependency forge-checkbox
 * @dependency forge-tooltip
 *
 * @event {CustomEvent<ITableRowClickEventData>} forge-table-row-click - Dispatched when a row is clicked. Only applies when `allow-row-click` is specified.
 * @event {CustomEvent<ITableSelectEventData>} forge-table-select - Dispatched when a row is selected. Only applies when `select` is specified.
 * @event {CustomEvent<ITableSelectDoubleEventData>} forge-table-select-double - Dispatched when a row is double-clicked. Only applies when `select` is specified.
 * @event {CustomEvent<ITableSelectAllEventData>} forge-table-select-all - Dispatched when the select all checkbox is toggled. Only applies when `select` and `multiselect` is specified.
 * @event {CustomEvent<ITableSortEventData | ITableSortMultipleEventData>} forge-table-sort - Dispatched when a column is sorted.
 * @event {CustomEvent<ITableFilterEventData>} forge-table-filter - Dispatched when a column is filtered. Only applies when `filter` is specified.
 * @event {CustomEvent<void>} forge-table-initialized - Dispatched when the table is initialized in the DOM for the first time.
 * @event {CustomEvent<ITableColumnResizeEventData>} forge-table-column-resize - Dispatched when a column is resized.
 *
 * @cssclass forge-data-table - The base table class.
 */
let TableComponent = class TableComponent extends BaseComponent {
    static get observedAttributes() {
        return [
            TABLE_CONSTANTS.attributes.SELECT,
            TABLE_CONSTANTS.attributes.MULTISELECT,
            TABLE_CONSTANTS.attributes.SELECT_KEY,
            TABLE_CONSTANTS.attributes.DENSE,
            TABLE_CONSTANTS.attributes.ROOMY,
            TABLE_CONSTANTS.attributes.FILTER,
            TABLE_CONSTANTS.attributes.FIXED_HEADERS,
            TABLE_CONSTANTS.attributes.LAYOUT_TYPE,
            TABLE_CONSTANTS.attributes.WRAP_CONTENT,
            TABLE_CONSTANTS.attributes.RESIZABLE,
            TABLE_CONSTANTS.attributes.MIN_RESIZE_WIDTH,
            TABLE_CONSTANTS.attributes.ALLOW_ROW_CLICK,
            TABLE_CONSTANTS.attributes.MULTI_COLUMN_SORT,
            TABLE_CONSTANTS.attributes.SELECT_CHECKBOX_ALIGNMENT,
            TABLE_CONSTANTS.attributes.TOOLTIP_SELECT,
            TABLE_CONSTANTS.attributes.TOOLTIP_SELECT_ALL
        ];
    }
    constructor() {
        super();
        IconRegistry.define(tylIconArrowDownward);
        this._core = new TableCore(new TableAdapter(this));
    }
    initializedCallback() {
        this._core.initialize();
    }
    connectedCallback() {
        this._core.initialize();
    }
    disconnectedCallback() {
        this._core.destroy();
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case TABLE_CONSTANTS.attributes.SELECT:
                this.select = coerceBoolean(newValue);
                break;
            case TABLE_CONSTANTS.attributes.MULTISELECT:
                this.multiselect = coerceBoolean(newValue);
                break;
            case TABLE_CONSTANTS.attributes.SELECT_KEY:
                this.selectKey = newValue;
                break;
            case TABLE_CONSTANTS.attributes.DENSE:
                this.dense = coerceBoolean(newValue);
                break;
            case TABLE_CONSTANTS.attributes.ROOMY:
                this.roomy = coerceBoolean(newValue);
                break;
            case TABLE_CONSTANTS.attributes.FILTER:
                this.filter = coerceBoolean(newValue);
                break;
            case TABLE_CONSTANTS.attributes.FIXED_HEADERS:
                this.fixedHeaders = coerceBoolean(newValue);
                break;
            case TABLE_CONSTANTS.attributes.LAYOUT_TYPE:
                this.layoutType = newValue;
                break;
            case TABLE_CONSTANTS.attributes.WRAP_CONTENT:
                this.wrapContent = coerceBoolean(newValue);
                break;
            case TABLE_CONSTANTS.attributes.RESIZABLE:
                this.resizable = coerceBoolean(newValue);
                break;
            case TABLE_CONSTANTS.attributes.MIN_RESIZE_WIDTH:
                this.minResizeWidth = coerceNumber(newValue);
                break;
            case TABLE_CONSTANTS.attributes.ALLOW_ROW_CLICK:
                this.allowRowClick = coerceBoolean(newValue);
                break;
            case TABLE_CONSTANTS.attributes.MULTI_COLUMN_SORT:
                this.multiColumnSort = coerceBoolean(newValue);
                break;
            case TABLE_CONSTANTS.attributes.SELECT_CHECKBOX_ALIGNMENT:
                this.selectCheckboxAlignment = (this.getAttribute(TABLE_CONSTANTS.attributes.SELECT_CHECKBOX_ALIGNMENT) || CellAlign.Center);
                break;
            case TABLE_CONSTANTS.attributes.TOOLTIP_SELECT:
                this.tooltipSelect = newValue;
                break;
            case TABLE_CONSTANTS.attributes.TOOLTIP_SELECT_ALL:
                this.tooltipSelectAll = newValue;
                break;
        }
    }
    /**
     * Hides a column from the table.
     * @param columnIndex The index of the column to hide.
     */
    hideColumn(columnIndex) {
        this._core.hideColumn(columnIndex);
    }
    /**
     * Shows a hidden column in th table.
     * @param columnIndex The index of the column to show.
     */
    showColumn(columnIndex) {
        this._core.showColumn(columnIndex);
    }
    /**
     * Determines if a column at the given index is hidden or not.
     * @param {number} columnIndex The index of the column.
     * @returns {boolean} `true` if the column is hidden, `false` otherwise.
     */
    isColumnHidden(columnIndex) {
        return this._core.isColumnHidden(columnIndex);
    }
    /** Returns the selected row instances. */
    getSelectedRows() {
        return this._core.getSelectedRows();
    }
    /**
     * Selects a row in the table. Only applicable if `select` is true.
     * @param data The row data behind the row that should be selected.
     */
    selectRow(data) {
        this._core.selectRows([data], false);
    }
    /**
     * Selects one or more rows in the table. Only applicable if `select` is true.
     * @param data The row data begind the rows that should be selected.
     * @param [preserveExisting=false] Should existing row selections be preserved or cleared.
     */
    selectRows(data, preserveExisting = false) {
        this._core.selectRows(data, !preserveExisting);
    }
    /**
     * Deselects a single row in the table.
     * @param data The data behind the row that should be deselected.
     */
    deselectRow(data) {
        this._core.deselectRows([data]);
    }
    /**
     * Deselects one or more rows in the table.
     * @param data The data behind the rows that should be deselected.
     */
    deselectRows(data) {
        this._core.deselectRows(data);
    }
    /**
     * Clears all selected table rows.
     */
    clearSelections() {
        this._core.clearSelections();
    }
    /**
     * Forces the table to re-render based on its current configuration.
     */
    render() {
        this._core.render();
    }
    /**
     * Expands a collapsed row.
     * @param rowIndex The index of the row to expand.
     */
    expandRow(rowIndex, template) {
        return this._core.expandRow(rowIndex, template);
    }
    /**
     * Collapses an expanded row.
     * @param rowIndex The index of the row to expand.
     */
    collapseRow(rowIndex) {
        return this._core.collapseRow(rowIndex);
    }
    /**
     * Checks if a row is expanded or not.
     * @param rowIndex The row index to check.
     */
    isRowExpanded(rowIndex) {
        return this._core.isRowExpanded(rowIndex);
    }
    /**
     * Selects a rows by an index or array of indexes.
     * @param indexes The row index/indexes to select.
     */
    selectRowsByIndex(indexes, preserveExisting) {
        if (typeof indexes === 'number') {
            this._core.selectRowsByIndex([indexes], preserveExisting);
        }
        else if (Array.isArray(indexes)) {
            this._core.selectRowsByIndex(indexes, preserveExisting);
        }
    }
    /**
     * Deselects a rows by an index or array of indexes.
     * @param indexes The row index/indexes to deselect
     */
    deselectRowsByIndex(indexes) {
        if (typeof indexes === 'number') {
            this._core.deselectRowsByIndex([indexes]);
        }
        else if (Array.isArray(indexes)) {
            this._core.deselectRowsByIndex(indexes);
        }
    }
    /**
     * Checks if a row is selected or not.
     * @param rowData The row object data to check.
     */
    isRowSelected(rowData) {
        return this._core.isRowSelected(rowData);
    }
};
__decorate([
    coreProperty()
], TableComponent.prototype, "data", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "columnConfigurations", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "select", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "multiselect", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "selectKey", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "tooltipSelect", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "tooltipSelectAll", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "dense", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "roomy", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "filter", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "fixedHeaders", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "layoutType", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "wrapContent", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "resizable", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "minResizeWidth", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "allowRowClick", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "multiColumnSort", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "rowCreated", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "cellCreated", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "selectAllTemplate", void 0);
__decorate([
    coreProperty()
], TableComponent.prototype, "selectCheckboxAlignment", void 0);
TableComponent = __decorate([
    customElement({
        name: TABLE_CONSTANTS.elementName,
        dependencies: [ExpansionPanelComponent, IconComponent, CheckboxComponent, TooltipComponent]
    })
], TableComponent);
export { TableComponent };
