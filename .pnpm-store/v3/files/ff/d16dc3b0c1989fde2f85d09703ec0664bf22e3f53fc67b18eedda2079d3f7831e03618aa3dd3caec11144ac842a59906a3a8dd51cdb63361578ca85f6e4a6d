import { ALL_MEDIA_FEATURES } from './types';
/** Returns the names of all queries that match. Used for range media features. */
export function getMatchingValues(namedQueries) {
    const values = [];
    for (const namedQuery of namedQueries) {
        const queryList = window.matchMedia(namedQuery.query);
        if (queryList.matches) {
            values.push(namedQuery.name);
        }
    }
    return values;
}
/** Returns the name of one query that matches. Used for discrete media features. */
export function getMatchingValue(namedQueries) {
    for (const namedQuery of namedQueries) {
        const queryList = window.matchMedia(namedQuery.query);
        if (queryList.matches) {
            return namedQuery.name;
        }
    }
    // We can assume that at least one query will match, this fallback is mostly to satisfy TypeScript
    console.warn(`No media query returned a match, falling back to ${namedQueries[0].name}.`);
    return namedQueries[0].name;
}
/** Returns whether a query matches. */
export function getBooleanValue(query) {
    return window.matchMedia(query.query).matches;
}
/** Returns a CSS media query string from a range. */
export function getRangeQuery(feature, range) {
    if (range.equals !== undefined) {
        return `(${feature}: ${range.equals})`;
    }
    const rules = [];
    if (range.min !== undefined) {
        rules.push(`(min-${feature}: ${range.min})`);
    }
    if (range.max !== undefined) {
        rules.push(`(max-${feature}: ${range.max})`);
    }
    return rules.join(' and ');
}
/** Whether a string is the name of a media feature. */
export function isMediaFeature(value) {
    return ALL_MEDIA_FEATURES.includes(value);
}
/** Return `undefined` if the name is a reserved media feature. */
export function validateName(name) {
    if (!name) {
        return undefined;
    }
    if (isMediaFeature(name)) {
        console.error(`${name} is a disallowed media observer name.`);
        return undefined;
    }
    return name;
}
