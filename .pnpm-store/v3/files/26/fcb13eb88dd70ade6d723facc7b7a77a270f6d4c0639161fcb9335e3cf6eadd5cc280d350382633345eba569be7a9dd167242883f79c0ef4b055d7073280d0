"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toJsDocBlock = exports.moduleExists = exports.toBaseName = exports.getOutDir = exports.isCustomElement = exports.getDeclaration = void 0;
const schematics_1 = require("@angular-devkit/schematics");
/**
 * Returns a declaration matching the provided selector.
 * @param modules The array of modules from the manifest.
 * @param selector A selector to use to locate a declaration within any of the modules.
 * @returns The matching declaration if found, or undefined.
 */
function getDeclaration(modules, selector) {
    var _a;
    const module = modules.find(module => { var _a; return (_a = module.declarations) === null || _a === void 0 ? void 0 : _a.some(selector); });
    return (_a = module === null || module === void 0 ? void 0 : module.declarations) === null || _a === void 0 ? void 0 : _a.find(selector);
}
exports.getDeclaration = getDeclaration;
/**
 * Determine if a declared export of a module represents a custom element, accounting for inheritance.
 * @param declaration A declared export from the manifest.
 * @param modules The array of modules from the manifest.
 * @returns True if the declaration represents a custom element, false otherwise.
 */
function isCustomElement(declaration, modules) {
    if (!declaration)
        return false;
    if ('customElement' in declaration && declaration.customElement)
        return true;
    if ('superclass' in declaration && declaration.superclass) {
        return isCustomElement(getDeclaration(modules, d => { var _a; return d.name === ((_a = declaration.superclass) === null || _a === void 0 ? void 0 : _a.name); }), modules);
    }
    return false;
}
exports.isCustomElement = isCustomElement;
/**
 * Processes schematic configuration to return the appropriate directory to output a generated custom element proxy.
 * @param cliOptions The schematic options
 * @param tagName The tag name of the custom element.
 * @param options.relative Whether to generate the path relative to the base configured outDir.
 * @returns The output directory to use for the custom element proxy.
 */
function getOutDir(cliOptions, tagName, options) {
    var _a;
    return `${(options === null || options === void 0 ? void 0 : options.relative) ? '' : ((_a = cliOptions.outDir) !== null && _a !== void 0 ? _a : '.')}/${cliOptions.outDirExcludePrefix
        ? tagName.replace(new RegExp(`^${cliOptions.outDirExcludePrefix}`), '')
        : tagName}`;
}
exports.getOutDir = getOutDir;
/**
 * Strips off the 'Component' suffix from a class name.
 * @param className A component class name.
 * @returns The component name without the 'Component' suffix.
 */
function toBaseName(className) {
    return className.replace(/Component$/, '');
}
exports.toBaseName = toBaseName;
/**
 * Checks if a non-generated module exists in the target directory.
 * @param tree The filesystem tree context the schematic is being run in.
 * @param targetDir The directory to look in.
 * @returns True if a `.module.ts` file exists in the target directory without the header comment, false otherwise
 */
function moduleExists(tree, targetDir) {
    return tree.getDir('/' + targetDir).subfiles.some((p) => {
        var _a;
        const exists = p.endsWith('.module.ts');
        const isGenerated = (_a = readText(tree, `/${targetDir}/${p}`)) === null || _a === void 0 ? void 0 : _a.includes('// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.');
        return exists && !isGenerated;
    });
}
exports.moduleExists = moduleExists;
// Can use tree.readText in Angular 15
function readText(tree, path) {
    const data = tree.read(path);
    if (data === null) {
        throw new schematics_1.FileDoesNotExistException(path);
    }
    const decoder = new TextDecoder('utf-8', { fatal: true });
    try {
        // With the `fatal` option enabled, invalid data will throw a TypeError
        return decoder.decode(data);
    }
    catch (e) {
        if (e instanceof TypeError) {
            throw new Error(`Failed to decode "${path}" as UTF-8 text.`);
        }
        throw e;
    }
}
/**
 * Converts a description string into a JSDoc block comment.
 * @param description The description string, which can be multi-line.
 * @param indentLevel Optional level of indentation, defaults to zero.
 * @return The description formatted as a JSDoc block comment.
 */
function toJsDocBlock(description, indentLevel = 0) {
    const indent = '\t'.repeat(indentLevel);
    if (!description.includes('\n')) {
        return `${indent}/** ${description} */`;
    }
    const body = description.split('\n').map(line => `${indent} * ${line}`).join('\n');
    return `${indent}/**\n${body}\n${indent} */`;
}
exports.toJsDocBlock = toJsDocBlock;
//# sourceMappingURL=utils.js.map