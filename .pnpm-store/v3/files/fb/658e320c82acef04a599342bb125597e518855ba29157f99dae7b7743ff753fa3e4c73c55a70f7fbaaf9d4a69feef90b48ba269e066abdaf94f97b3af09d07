import { ElementRef, ChangeDetectorRef, NgZone } from '@angular/core';
import { TooltipComponent as TooltipComponentCustomElement } from '@tylertech/forge';
import * as i0 from "@angular/core";
/**  */
export declare class TooltipComponent {
    protected elementRef: ElementRef<TooltipComponentCustomElement>;
    protected zone: NgZone;
    /** The forge-tooltip element. */
    readonly nativeElement: TooltipComponentCustomElement;
    /** Whether or not the tooltip is open. */
    set open(value: TooltipComponentCustomElement['open']);
    get open(): TooltipComponentCustomElement['open'];
    /** The type of tooltip. Valid values are `presentation` (default), `label`, and `description`. */
    set type(value: TooltipComponentCustomElement['type']);
    get type(): TooltipComponentCustomElement['type'];
    /** The id of the element that the tooltip is anchored to. */
    set anchor(value: TooltipComponentCustomElement['anchor']);
    get anchor(): TooltipComponentCustomElement['anchor'];
    set anchorElement(value: TooltipComponentCustomElement['anchorElement']);
    get anchorElement(): TooltipComponentCustomElement['anchorElement'];
    set target(value: TooltipComponentCustomElement['target']);
    get target(): TooltipComponentCustomElement['target'];
    /** The placement of the tooltip relative to the anchor element. */
    set placement(value: TooltipComponentCustomElement['placement']);
    get placement(): TooltipComponentCustomElement['placement'];
    set position(value: TooltipComponentCustomElement['position']);
    get position(): TooltipComponentCustomElement['position'];
    /** The delay in milliseconds before the tooltip is shown. */
    set delay(value: TooltipComponentCustomElement['delay']);
    get delay(): TooltipComponentCustomElement['delay'];
    /** The offset in pixels between the tooltip and the anchor element. */
    set offset(value: TooltipComponentCustomElement['offset']);
    get offset(): TooltipComponentCustomElement['offset'];
    /** How the tooltip should place itself if there is not enough space at the desired placement. */
    set flip(value: TooltipComponentCustomElement['flip']);
    get flip(): TooltipComponentCustomElement['flip'];
    /** The id of the element that the tooltip should be constrained to. */
    set boundary(value: TooltipComponentCustomElement['boundary']);
    get boundary(): TooltipComponentCustomElement['boundary'];
    /** The element that the tooltip should be constrained to. */
    set boundaryElement(value: TooltipComponentCustomElement['boundaryElement']);
    get boundaryElement(): TooltipComponentCustomElement['boundaryElement'];
    /** The fallback placements of the tooltip relative to the anchor element. */
    set fallbackPlacements(value: TooltipComponentCustomElement['fallbackPlacements']);
    get fallbackPlacements(): TooltipComponentCustomElement['fallbackPlacements'];
    /** The trigger type(s) that will open the tooltip. Valid values are `hover` (default), `longpress`, and `focus`. */
    set triggerType(value: TooltipComponentCustomElement['triggerType']);
    get triggerType(): TooltipComponentCustomElement['triggerType'];
    constructor(changeDetectorRef: ChangeDetectorRef, elementRef: ElementRef<TooltipComponentCustomElement>, zone: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<TooltipComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TooltipComponent, "forge-tooltip", never, { "open": { "alias": "open"; "required": false; }; "type": { "alias": "type"; "required": false; }; "anchor": { "alias": "anchor"; "required": false; }; "anchorElement": { "alias": "anchorElement"; "required": false; }; "target": { "alias": "target"; "required": false; }; "placement": { "alias": "placement"; "required": false; }; "position": { "alias": "position"; "required": false; }; "delay": { "alias": "delay"; "required": false; }; "offset": { "alias": "offset"; "required": false; }; "flip": { "alias": "flip"; "required": false; }; "boundary": { "alias": "boundary"; "required": false; }; "boundaryElement": { "alias": "boundaryElement"; "required": false; }; "fallbackPlacements": { "alias": "fallbackPlacements"; "required": false; }; "triggerType": { "alias": "triggerType"; "required": false; }; }, {}, never, ["*"], false, never>;
    static ngAcceptInputType_open: unknown;
    static ngAcceptInputType_delay: unknown;
    static ngAcceptInputType_offset: unknown;
}
