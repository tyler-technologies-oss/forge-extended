"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.customElements = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const fs_1 = require("fs");
const utils_1 = require("./utils");
function customElements(inputOptions) {
    return (tree, context) => {
        var _a;
        // If config file is passed, read file and convert to same options as CLI.
        const options = 'config' in inputOptions && inputOptions.config
            ? JSON.parse((0, fs_1.readFileSync)(inputOptions.config, { encoding: 'utf-8' }))
            : inputOptions;
        const manifest = JSON.parse((0, fs_1.readFileSync)(options.manifest, { encoding: 'utf-8' }));
        let customElementsWithTags = manifest.modules.reduce((acc, module) => {
            var _a, _b;
            acc.push(...((_b = (_a = module.declarations) === null || _a === void 0 ? void 0 : _a.filter(
            // Potentially should (also?) check for CustomElementDefinition export which requires `name` property.
            (dec) => (0, utils_1.isCustomElement)(dec, manifest.modules) && 'tagName' in dec)) !== null && _b !== void 0 ? _b : []));
            return acc;
        }, []);
        context.logger.info(`Found ${customElementsWithTags.length} custom element(s) with tag name specified in ${manifest.modules.length} module(s).`);
        const excludedTagNames = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.split(',').map(e => e.trim()).filter(e => e !== '');
        if ((excludedTagNames === null || excludedTagNames === void 0 ? void 0 : excludedTagNames.length) > 0) {
            customElementsWithTags = customElementsWithTags.filter(ce => !excludedTagNames.includes(ce.tagName));
            context.logger.info(`Excluding ${excludedTagNames.length} elements, ${customElementsWithTags.length} remain.`);
        }
        context.logger.debug(`Elements to generate components for: ${customElementsWithTags.map(x => x.tagName).toString()}`);
        const sources = customElementsWithTags.map(element => {
            var _a, _b, _c, _d, _e, _f;
            return (0, schematics_1.apply)((0, schematics_1.url)('./files/component'), [
                (0, schematics_1.template)(Object.assign(Object.assign(Object.assign(Object.assign({}, element), { baseName: (0, utils_1.toBaseName)(element.name), importPath: options.importPath, useDefineFunction: options.useDefineFunction, methods: (_b = (_a = element.members) === null || _a === void 0 ? void 0 : _a.filter(x => x.kind === 'method' && x.privacy === 'public')) !== null && _b !== void 0 ? _b : [], properties: (_d = (_c = element.members) === null || _c === void 0 ? void 0 : _c.filter(x => x.kind === 'field' && x.privacy === 'public')) !== null && _d !== void 0 ? _d : [], attributes: (_e = element.attributes) !== null && _e !== void 0 ? _e : [], events: (_f = element.events) !== null && _f !== void 0 ? _f : [] }), schematics_1.strings), { toJsDocBlock: utils_1.toJsDocBlock })),
                (0, schematics_1.move)((0, utils_1.getOutDir)(options, element.tagName))
            ]);
        });
        const elementMap = customElementsWithTags.reduce((agg, element) => {
            const hasExistingModule = (0, utils_1.moduleExists)(tree, (0, utils_1.getOutDir)(options, element.tagName));
            const baseName = (0, utils_1.toBaseName)(element.name);
            const moduleName = `${options.modulePrefix}${baseName}${hasExistingModule ? 'Proxy' : ''}Module`;
            const relativePath = `..${(0, utils_1.getOutDir)(options, element.tagName, { relative: true })}/${schematics_1.strings.dasherize(baseName)}${hasExistingModule ? '-proxy' : ''}.module`;
            agg[element.tagName] = { hasExistingModule, moduleName, relativePath };
            return agg;
        }, {});
        context.logger.info(`Generating modules for ${customElementsWithTags.length} components.`);
        const moduleSources = customElementsWithTags.map(element => {
            var _a, _b, _c;
            return (0, schematics_1.apply)((0, schematics_1.url)('./files/module '), [
                (0, schematics_1.template)(Object.assign(Object.assign(Object.assign({}, element), schematics_1.strings), { baseName: (0, utils_1.toBaseName)(element.name), moduleName: elementMap[element.tagName].moduleName, dependencies: (_c = (_b = (_a = options.componentDependencies) === null || _a === void 0 ? void 0 : _a[element.tagName]) === null || _b === void 0 ? void 0 : _b.map(tag => elementMap[tag])) !== null && _c !== void 0 ? _c : [], importPath: options.importPath, useDefineFunction: options.useDefineFunction })),
                (tree) => {
                    const moduleInfo = elementMap[element.tagName];
                    if (moduleInfo.hasExistingModule) {
                        const fileName = schematics_1.strings.dasherize((0, utils_1.toBaseName)(element.name));
                        context.logger.debug(`Generating: ${fileName}-proxy.module.ts because a non-generated ${fileName}.module.ts already exists.`);
                        tree.rename(`${fileName}.module.ts`, `${fileName}-proxy.module.ts`);
                    }
                    return tree;
                },
                (0, schematics_1.move)((0, utils_1.getOutDir)(options, element.tagName)),
            ]);
        });
        // TODO (3.0): Update existing non-generated modules to ensure proxy module in declarations and exports.
        // TODO: Either generate index.ts and export component/module, or update existing
        return (0, schematics_1.chain)([
            (0, schematics_1.chain)(sources.map(source => (0, schematics_1.mergeWith)(source, schematics_1.MergeStrategy.Overwrite))),
            (0, schematics_1.chain)(moduleSources.map(source => (0, schematics_1.mergeWith)(source, schematics_1.MergeStrategy.Overwrite))),
        ]);
    };
}
exports.customElements = customElements;
//# sourceMappingURL=index.js.map