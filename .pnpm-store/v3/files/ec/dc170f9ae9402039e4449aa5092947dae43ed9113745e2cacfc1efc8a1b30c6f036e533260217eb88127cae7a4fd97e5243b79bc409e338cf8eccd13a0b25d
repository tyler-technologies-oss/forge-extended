// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
import { booleanAttribute, Component, ChangeDetectionStrategy, Input } from '@angular/core';
import { defineColorPickerComponent } from '@tylertech/forge';
import * as i0 from "@angular/core";
/**  */
export class ColorPickerComponent {
    /** Gets/sets the value using hex format only. */
    set value(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.value = value;
        });
    }
    get value() {
        return this.nativeElement.value;
    }
    /** Gets/sets the value using rgba format. */
    set rgba(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.rgba = value;
        });
    }
    get rgba() {
        return this.nativeElement.rgba;
    }
    /** Gets/sets the value using hsva format. */
    set hsva(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.hsva = value;
        });
    }
    get hsva() {
        return this.nativeElement.hsva;
    }
    /** Gets/sets the opacity value, if `allowOpacity` is true. */
    set opacity(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.opacity = value;
        });
    }
    get opacity() {
        return this.nativeElement.opacity;
    }
    /** Gets/sets whether opacity is displayed and allowed be to changed. */
    set allowOpacity(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.allowOpacity = value;
        });
    }
    get allowOpacity() {
        return this.nativeElement.allowOpacity;
    }
    /** Gets/sets whether change event has a debounce applied to avoid successive updates. */
    set debounceChangeEvent(value) {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.debounceChangeEvent = value;
        });
    }
    get debounceChangeEvent() {
        return this.nativeElement.debounceChangeEvent;
    }
    constructor(changeDetectorRef, elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        /** The forge-color-picker element. */
        this.nativeElement = this.elementRef.nativeElement;
        defineColorPickerComponent();
        changeDetectorRef.detach();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ColorPickerComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.7", type: ColorPickerComponent, selector: "forge-color-picker", inputs: { value: "value", rgba: "rgba", hsva: "hsva", opacity: "opacity", allowOpacity: ["allowOpacity", "allowOpacity", booleanAttribute], debounceChangeEvent: ["debounceChangeEvent", "debounceChangeEvent", booleanAttribute] }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.7", ngImport: i0, type: ColorPickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'forge-color-picker',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>'
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { value: [{
                type: Input
            }], rgba: [{
                type: Input
            }], hsva: [{
                type: Input
            }], opacity: [{
                type: Input
            }], allowOpacity: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], debounceChangeEvent: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sb3ItcGlja2VyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2ZvcmdlLWFuZ3VsYXIvc3JjL2xpYi9jb2xvci1waWNrZXIvY29sb3ItcGlja2VyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSx3SEFBd0g7QUFDeEgsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFNBQVMsRUFBYyx1QkFBdUIsRUFBNkIsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ25JLE9BQU8sRUFBNkQsMEJBQTBCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQzs7QUFFekgsT0FBTztBQU1QLE1BQU0sT0FBTyxvQkFBb0I7SUFLaEMsaURBQWlEO0lBQ2pELElBQ1csS0FBSyxDQUFDLEtBQWlEO1FBQ2pFLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxFQUFFO1lBQ2hDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNsQyxDQUFDLENBQUMsQ0FBQztJQUNKLENBQUM7SUFDRCxJQUFXLEtBQUs7UUFDZixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDO0lBQ2pDLENBQUM7SUFFRCw2Q0FBNkM7SUFDN0MsSUFDVyxJQUFJLENBQUMsS0FBZ0Q7UUFDL0QsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUU7WUFDaEMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDO1FBQ2pDLENBQUMsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUNELElBQVcsSUFBSTtRQUNkLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUM7SUFDaEMsQ0FBQztJQUVELDZDQUE2QztJQUM3QyxJQUNXLElBQUksQ0FBQyxLQUFnRDtRQUMvRCxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRTtZQUNoQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDakMsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBQ0QsSUFBVyxJQUFJO1FBQ2QsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQztJQUNoQyxDQUFDO0lBRUQsOERBQThEO0lBQzlELElBQ1csT0FBTyxDQUFDLEtBQW1EO1FBQ3JFLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxFQUFFO1lBQ2hDLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztRQUNwQyxDQUFDLENBQUMsQ0FBQztJQUNKLENBQUM7SUFDRCxJQUFXLE9BQU87UUFDakIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQztJQUNuQyxDQUFDO0lBRUQsd0VBQXdFO0lBQ3hFLElBQ1csWUFBWSxDQUFDLEtBQXdEO1FBQy9FLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxFQUFFO1lBQ2hDLElBQUksQ0FBQyxhQUFhLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztRQUN6QyxDQUFDLENBQUMsQ0FBQztJQUNKLENBQUM7SUFDRCxJQUFXLFlBQVk7UUFDdEIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQztJQUN4QyxDQUFDO0lBRUQseUZBQXlGO0lBQ3pGLElBQ1csbUJBQW1CLENBQUMsS0FBK0Q7UUFDN0YsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUU7WUFDaEMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsR0FBRyxLQUFLLENBQUM7UUFDaEQsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBQ0QsSUFBVyxtQkFBbUI7UUFDN0IsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLG1CQUFtQixDQUFDO0lBQy9DLENBQUM7SUFFRCxZQUNDLGlCQUFvQyxFQUMxQixVQUF5RCxFQUN6RCxJQUFZO1FBRFosZUFBVSxHQUFWLFVBQVUsQ0FBK0M7UUFDekQsU0FBSSxHQUFKLElBQUksQ0FBUTtRQXhFdkIsc0NBQXNDO1FBQ3RCLGtCQUFhLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7UUF5RTdELDBCQUEwQixFQUFFLENBQUM7UUFDN0IsaUJBQWlCLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDNUIsQ0FBQzs4R0E5RVcsb0JBQW9CO2tHQUFwQixvQkFBb0IsMkpBa0RaLGdCQUFnQix1RUFXaEIsZ0JBQWdCLDZCQS9EekIsMkJBQTJCOzsyRkFFMUIsb0JBQW9CO2tCQUxoQyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxvQkFBb0I7b0JBQzlCLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO29CQUMvQyxRQUFRLEVBQUUsMkJBQTJCO2lCQUN0QztvSUFRVyxLQUFLO3NCQURmLEtBQUs7Z0JBWUssSUFBSTtzQkFEZCxLQUFLO2dCQVlLLElBQUk7c0JBRGQsS0FBSztnQkFZSyxPQUFPO3NCQURqQixLQUFLO2dCQVlLLFlBQVk7c0JBRHRCLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBWTNCLG1CQUFtQjtzQkFEN0IsS0FBSzt1QkFBQyxFQUFFLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRSIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgY29kZSB3YXMgZ2VuZXJhdGVkIGJ5IHRoZSBhbmd1bGFyLWN1c3RvbS1lbGVtZW50cy1zY2hlbWF0aWMuICBBbnkgY2hhbmdlcyB3aWxsIGJlIG92ZXJ3cml0dGVuIG5leHQgdGltZSBpdCBydW5zLlxuaW1wb3J0IHsgYm9vbGVhbkF0dHJpYnV0ZSwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIE5nWm9uZSwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbG9yUGlja2VyQ29tcG9uZW50IGFzIENvbG9yUGlja2VyQ29tcG9uZW50Q3VzdG9tRWxlbWVudCwgZGVmaW5lQ29sb3JQaWNrZXJDb21wb25lbnQgfSBmcm9tICdAdHlsZXJ0ZWNoL2ZvcmdlJztcblxuLyoqICAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZm9yZ2UtY29sb3ItcGlja2VyJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgQ29sb3JQaWNrZXJDb21wb25lbnQge1xuXG5cdC8qKiBUaGUgZm9yZ2UtY29sb3ItcGlja2VyIGVsZW1lbnQuICovXG5cdHB1YmxpYyByZWFkb25seSBuYXRpdmVFbGVtZW50ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG5cblx0LyoqIEdldHMvc2V0cyB0aGUgdmFsdWUgdXNpbmcgaGV4IGZvcm1hdCBvbmx5LiAqL1xuXHRASW5wdXQoKVxuXHRwdWJsaWMgc2V0IHZhbHVlKHZhbHVlOiBDb2xvclBpY2tlckNvbXBvbmVudEN1c3RvbUVsZW1lbnRbJ3ZhbHVlJ10pIHtcblx0XHR0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuXHRcdFx0dGhpcy5uYXRpdmVFbGVtZW50LnZhbHVlID0gdmFsdWU7XG5cdFx0fSk7XG5cdH1cblx0cHVibGljIGdldCB2YWx1ZSgpOiBDb2xvclBpY2tlckNvbXBvbmVudEN1c3RvbUVsZW1lbnRbJ3ZhbHVlJ10ge1xuXHRcdHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnQudmFsdWU7XG5cdH1cblxuXHQvKiogR2V0cy9zZXRzIHRoZSB2YWx1ZSB1c2luZyByZ2JhIGZvcm1hdC4gKi9cblx0QElucHV0KClcblx0cHVibGljIHNldCByZ2JhKHZhbHVlOiBDb2xvclBpY2tlckNvbXBvbmVudEN1c3RvbUVsZW1lbnRbJ3JnYmEnXSkge1xuXHRcdHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG5cdFx0XHR0aGlzLm5hdGl2ZUVsZW1lbnQucmdiYSA9IHZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cdHB1YmxpYyBnZXQgcmdiYSgpOiBDb2xvclBpY2tlckNvbXBvbmVudEN1c3RvbUVsZW1lbnRbJ3JnYmEnXSB7XG5cdFx0cmV0dXJuIHRoaXMubmF0aXZlRWxlbWVudC5yZ2JhO1xuXHR9XG5cblx0LyoqIEdldHMvc2V0cyB0aGUgdmFsdWUgdXNpbmcgaHN2YSBmb3JtYXQuICovXG5cdEBJbnB1dCgpXG5cdHB1YmxpYyBzZXQgaHN2YSh2YWx1ZTogQ29sb3JQaWNrZXJDb21wb25lbnRDdXN0b21FbGVtZW50Wydoc3ZhJ10pIHtcblx0XHR0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuXHRcdFx0dGhpcy5uYXRpdmVFbGVtZW50LmhzdmEgPSB2YWx1ZTtcblx0XHR9KTtcblx0fVxuXHRwdWJsaWMgZ2V0IGhzdmEoKTogQ29sb3JQaWNrZXJDb21wb25lbnRDdXN0b21FbGVtZW50Wydoc3ZhJ10ge1xuXHRcdHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnQuaHN2YTtcblx0fVxuXG5cdC8qKiBHZXRzL3NldHMgdGhlIG9wYWNpdHkgdmFsdWUsIGlmIGBhbGxvd09wYWNpdHlgIGlzIHRydWUuICovXG5cdEBJbnB1dCgpXG5cdHB1YmxpYyBzZXQgb3BhY2l0eSh2YWx1ZTogQ29sb3JQaWNrZXJDb21wb25lbnRDdXN0b21FbGVtZW50WydvcGFjaXR5J10pIHtcblx0XHR0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuXHRcdFx0dGhpcy5uYXRpdmVFbGVtZW50Lm9wYWNpdHkgPSB2YWx1ZTtcblx0XHR9KTtcblx0fVxuXHRwdWJsaWMgZ2V0IG9wYWNpdHkoKTogQ29sb3JQaWNrZXJDb21wb25lbnRDdXN0b21FbGVtZW50WydvcGFjaXR5J10ge1xuXHRcdHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnQub3BhY2l0eTtcblx0fVxuXG5cdC8qKiBHZXRzL3NldHMgd2hldGhlciBvcGFjaXR5IGlzIGRpc3BsYXllZCBhbmQgYWxsb3dlZCBiZSB0byBjaGFuZ2VkLiAqL1xuXHRASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcblx0cHVibGljIHNldCBhbGxvd09wYWNpdHkodmFsdWU6IENvbG9yUGlja2VyQ29tcG9uZW50Q3VzdG9tRWxlbWVudFsnYWxsb3dPcGFjaXR5J10pIHtcblx0XHR0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuXHRcdFx0dGhpcy5uYXRpdmVFbGVtZW50LmFsbG93T3BhY2l0eSA9IHZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cdHB1YmxpYyBnZXQgYWxsb3dPcGFjaXR5KCk6IENvbG9yUGlja2VyQ29tcG9uZW50Q3VzdG9tRWxlbWVudFsnYWxsb3dPcGFjaXR5J10ge1xuXHRcdHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnQuYWxsb3dPcGFjaXR5O1xuXHR9XG5cblx0LyoqIEdldHMvc2V0cyB3aGV0aGVyIGNoYW5nZSBldmVudCBoYXMgYSBkZWJvdW5jZSBhcHBsaWVkIHRvIGF2b2lkIHN1Y2Nlc3NpdmUgdXBkYXRlcy4gKi9cblx0QElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG5cdHB1YmxpYyBzZXQgZGVib3VuY2VDaGFuZ2VFdmVudCh2YWx1ZTogQ29sb3JQaWNrZXJDb21wb25lbnRDdXN0b21FbGVtZW50WydkZWJvdW5jZUNoYW5nZUV2ZW50J10pIHtcblx0XHR0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuXHRcdFx0dGhpcy5uYXRpdmVFbGVtZW50LmRlYm91bmNlQ2hhbmdlRXZlbnQgPSB2YWx1ZTtcblx0XHR9KTtcblx0fVxuXHRwdWJsaWMgZ2V0IGRlYm91bmNlQ2hhbmdlRXZlbnQoKTogQ29sb3JQaWNrZXJDb21wb25lbnRDdXN0b21FbGVtZW50WydkZWJvdW5jZUNoYW5nZUV2ZW50J10ge1xuXHRcdHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnQuZGVib3VuY2VDaGFuZ2VFdmVudDtcblx0fVxuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcblx0XHRwcm90ZWN0ZWQgZWxlbWVudFJlZjogRWxlbWVudFJlZjxDb2xvclBpY2tlckNvbXBvbmVudEN1c3RvbUVsZW1lbnQ+LFxuXHRcdHByb3RlY3RlZCB6b25lOiBOZ1pvbmVcblx0KSB7XG5cdFx0ZGVmaW5lQ29sb3JQaWNrZXJDb21wb25lbnQoKTtcblx0XHRjaGFuZ2VEZXRlY3RvclJlZi5kZXRhY2goKTtcblx0fVxufVxuIl19