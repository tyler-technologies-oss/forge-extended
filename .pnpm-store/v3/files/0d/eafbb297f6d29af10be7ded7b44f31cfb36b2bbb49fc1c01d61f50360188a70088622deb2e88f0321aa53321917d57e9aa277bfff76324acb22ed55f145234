/**
 * @license
 * Copyright Tyler Technologies, Inc. 
 * License: Apache-2.0
 */
import { task } from '../core/utils/utils';
import { LABEL_CONSTANTS } from './label-constants';
export class LabelCore {
    constructor(_adapter) {
        this._adapter = _adapter;
        this._dynamic = false;
        this._nonInteractive = false;
        this._legend = false;
        this._isConnected = false;
        this._clickListener = (evt) => this._handleClick(evt);
        this._slotChangeListener = () => this._handleSlotChange();
        this._mutationCallback = () => this._handleMutation();
    }
    initialize() {
        if (this._legend) {
            this._initializeAsLegend();
        }
        else {
            this._initializeAsLabel();
        }
    }
    destroy() {
        this._disconnect();
        this._adapter.destroy();
    }
    update() {
        this._adapter.updateTargetLabel();
    }
    updateTarget(target) {
        this._adapter.setTargetElement(target);
        if (this._adapter.hasTargetElement()) {
            this._connect();
            return true;
        }
        return false;
    }
    /**
     * Emit an event to give ancestor elements a chance to connect
     */
    async _initializeAsLegend() {
        // Give ancestor elements a chance to connect to the DOM
        // TODO: see if this works in Angular
        await task();
        this._adapter.dispatchHostEvent(new CustomEvent(LABEL_CONSTANTS.events.CONNECTED, { bubbles: true }));
    }
    /**
     * Search for child or id-targetted elements to connect to
     */
    async _initializeAsLabel() {
        this._adapter.addSlotChangeListener(this._slotChangeListener);
        this._adapter.trySetTarget(this._for ?? null);
        if (this._adapter.hasTargetElement()) {
            this._connect();
        }
    }
    _handleClick(evt) {
        // Prevent duplicate clicks from a nested target element or if the event originates
        // from within the target element
        const targetEl = this._clickTarget ?? this._adapter.getTargetElement();
        if (evt.target === targetEl || targetEl?.contains(evt.target)) {
            return;
        }
        this._adapter.clickTarget();
    }
    _handleSlotChange() {
        if (!this._for && !this._forElement) {
            this._adapter.trySetTarget(null);
            this._tryConnect();
        }
    }
    _handleMutation() {
        this._adapter.updateTargetLabel();
    }
    _connect() {
        if (!this._nonInteractive) {
            this._adapter.addHostListener('click', this._clickListener);
        }
        this._adapter.updateTargetLabel();
        if (this._dynamic) {
            this._adapter.addMutationObserver(this._mutationCallback);
        }
        this._isConnected = true;
    }
    _disconnect() {
        this._adapter.removeHostListener('click', this._clickListener);
        this._adapter.removeMutationObserver();
        this._isConnected = false;
    }
    _tryConnect() {
        if (!this._adapter.hasTargetElement()) {
            this._disconnect();
        }
        else if (!this._isConnected) {
            this._connect();
        }
    }
    get for() {
        return this._for;
    }
    set for(value) {
        if (this._for !== value) {
            this._for = value;
            this._adapter.toggleHostAttribute(LABEL_CONSTANTS.attributes.FOR, !!this.for, this.for ?? undefined);
            this._adapter.trySetTarget(this._for ?? null);
            this._tryConnect();
        }
    }
    get forElement() {
        return this._forElement;
    }
    set forElement(value) {
        if (this._forElement !== value) {
            this._forElement = value;
            this._adapter.setTargetElement(this._forElement ?? null);
            this._tryConnect();
        }
    }
    get clickTarget() {
        return this._clickTarget;
    }
    set clickTarget(value) {
        if (this._clickTarget !== value) {
            this._clickTarget = value;
        }
    }
    get dynamic() {
        return this._dynamic;
    }
    set dynamic(value) {
        if (this._dynamic !== value) {
            this._dynamic = value;
            this._adapter.toggleHostAttribute(LABEL_CONSTANTS.attributes.DYNAMIC, this._dynamic);
            if (!this._dynamic) {
                this._adapter.removeMutationObserver();
            }
            else if (this._adapter.hasTargetElement()) {
                this._adapter.addMutationObserver(this._mutationCallback);
            }
        }
    }
    get nonInteractive() {
        return this._nonInteractive;
    }
    set nonInteractive(value) {
        if (this._nonInteractive !== value) {
            this._nonInteractive = value;
            this._adapter.toggleHostAttribute(LABEL_CONSTANTS.attributes.NON_INTERACTIVE, this._nonInteractive);
            // The click listener is only added if the label is connected
            if (!this._isConnected) {
                return;
            }
            if (this._nonInteractive) {
                this._adapter.removeHostListener('click', this._clickListener);
            }
            else {
                this._adapter.addHostListener('click', this._clickListener);
            }
        }
    }
    get legend() {
        return this._legend;
    }
    set legend(value) {
        if (this._legend !== value) {
            this._legend = value;
            this._adapter.toggleHostAttribute(LABEL_CONSTANTS.attributes.LEGEND, this._legend);
            if (this._legend) {
                this._adapter.removeSlotChangeListener(this._slotChangeListener);
                this._adapter.dispatchHostEvent(new CustomEvent(LABEL_CONSTANTS.events.CONNECTED, { bubbles: true }));
                return;
            }
            this._adapter.addSlotChangeListener(this._slotChangeListener);
            this._adapter.trySetTarget(this._for ?? null);
            if (this._adapter.hasTargetElement()) {
                this._connect();
            }
        }
    }
}
