/**
 * @license
 * Copyright Tyler Technologies, Inc. 
 * License: Apache-2.0
 */
import { BaseComponent, IBaseComponent } from '../../core/base/base-component';
import { IOverlayComponent } from '../overlay';
import { IOverlayAwareCore } from './overlay-aware-core';
import { IOverlayOffset, OverlayFlipState, OverlayHideState, OverlayPlacement, OverlayPositionStrategy } from '../overlay-constants';
import { PositionPlacement, VirtualElement } from '../../core/utils/position-utils';
import { IBaseOverlay } from './base-overlay';
export interface IOverlayAware extends IBaseComponent, IBaseOverlay {
    readonly overlay: IOverlayComponent;
}
/**
 * @property {HTMLElement | VirtualElement | null} anchorElement - The anchor element to position the overlay relative to.
 * @property {string | null} anchor - The IDREF of the anchor element to position the overlay relative to.
 * @property {boolean} [noAnchor=false] - Whether the overlay should not be anchored to an element. This allows for custom positioning.
 * @property {boolean} [open=false] - Whether the overlay is open.
 * @property {boolean} [inline=false] - Whether the overlay is inline (not in the top-layer).
 * @property {OverlayPlacement} [placement="bottom"] - The placement of the overlay.
 * @property {OverlayPositionStrategy} [positionStrategy="fixed"] - The position strategy of the overlay.
 * @property {IOverlayOffset} [offset={}] - The offset of the overlay.
 * @property {boolean} [shift=false] - Whether the overlay should shift to fit within the viewport.
 * @property {OverlayHideState} [hide="anchor-hidden"] - The hide state of the overlay.
 * @property {boolean} [persistent=false] - Whether the overlay should persist when the anchor is removed.
 * @property {OverlayFlipState} [flip="auto"] - Whether the overlay should flip placements to another side fit within the viewport.
 * @property {string | null} boundary - An IDREF to boundary element to constrain the overlay within.
 * @property {HTMLElement | null} boundaryElement - The boundary element instance to constrain the overlay within.
 * @property {PositionPlacement[] | null} fallbackPlacements - The fallback placements of the overlay.
 * @property {IOverlayComponent} overlay - A readonly reference to the internal `<forge-overlay>` element instance.
 *
 * @attribute {string | null} anchor - The IDREF of the anchor element to position the overlay relative to.
 * @attribute {boolean} [no-anchor=false] - Whether the overlay should not be anchored to an element. This allows for custom positioning.
 * @attribute {boolean} [open=false] - Whether the overlay is open.
 * @attribute {boolean} [inline=false] - Whether the overlay is inline.
 * @attribute {OverlayPlacement} [placement="bottom"] - The placement of the overlay.
 * @attribute {OverlayPositionStrategy} [position-strategy="fixed"] - The position strategy of the overlay.
 * @attribute {IOverlayOffset} offset - The offset of the overlay.
 * @attribute {boolean} [shift=false] - Whether the overlay should shift to fit within the viewport.
 * @attribute {OverlayHideState} [hide="anchor-hidden"] - The hide state of the overlay.
 * @attribute {boolean} [persistent=false] - Whether the overlay should persist when the anchor is removed.
 * @attribute {OverlayFlipState} [flip="auto"] - Whether the overlay should flip placements to another side fit within the viewport.
 * @attribute {string | null} boundary - An IDREF to boundary element to constrain the overlay within.
 */
export declare abstract class OverlayAware<T extends IOverlayAwareCore> extends BaseComponent implements IOverlayAware {
    protected _core: T;
    constructor();
    /**
     * Forces the overlay to reposition itself.
     */
    position(): void;
    attributeChangedCallback(name: string, _oldValue: string, newValue: string): void;
    get overlay(): IOverlayComponent;
    anchorElement: HTMLElement | VirtualElement | null;
    anchor: string | null;
    noAnchor: boolean;
    open: boolean;
    inline: boolean;
    placement: OverlayPlacement;
    positionStrategy: OverlayPositionStrategy;
    offset: IOverlayOffset;
    shift: boolean;
    hide: OverlayHideState;
    persistent: boolean;
    flip: OverlayFlipState;
    boundary: string | null;
    boundaryElement: HTMLElement | null;
    fallbackPlacements: PositionPlacement[] | null;
}
